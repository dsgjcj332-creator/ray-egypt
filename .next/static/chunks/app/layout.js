/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/layout"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5CUsers%5CDream%5Cray-egypt-8%5Capp%5Cglobals.css&modules=C%3A%5CUsers%5CDream%5Cray-egypt-8%5Ccomponents%5Ccommon%5CGeminiAssistant.tsx&modules=C%3A%5CUsers%5CDream%5Cray-egypt-8%5Ccomponents%5Ccommon%5CThemeContext.tsx&modules=C%3A%5CUsers%5CDream%5Cray-egypt-8%5Ccomponents%5Ccommon%5CToastContext.tsx&modules=C%3A%5CUsers%5CDream%5Cray-egypt-8%5Ccontext%5CAuthContext.tsx&modules=C%3A%5CUsers%5CDream%5Cray-egypt-8%5Ccontext%5CLanguageContext.tsx&modules=C%3A%5CUsers%5CDream%5Cray-egypt-8%5Cnode_modules%5Cnext%5Cfont%5Cgoogle%5Ctarget.css%3F%7B%22path%22%3A%22app%5C%5Clayout.tsx%22%2C%22import%22%3A%22Cairo%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22arabic%22%2C%22latin%22%5D%2C%22variable%22%3A%22--font-cairo%22%7D%5D%2C%22variableName%22%3A%22cairo%22%7D&modules=C%3A%5CUsers%5CDream%5Cray-egypt-8%5Cnode_modules%5Cnext%5Cfont%5Cgoogle%5Ctarget.css%3F%7B%22path%22%3A%22app%5C%5Clayout.tsx%22%2C%22import%22%3A%22Dancing_Script%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22latin%22%5D%2C%22variable%22%3A%22--font-dancing%22%7D%5D%2C%22variableName%22%3A%22dancing%22%7D&server=false!":
/*!*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5CUsers%5CDream%5Cray-egypt-8%5Capp%5Cglobals.css&modules=C%3A%5CUsers%5CDream%5Cray-egypt-8%5Ccomponents%5Ccommon%5CGeminiAssistant.tsx&modules=C%3A%5CUsers%5CDream%5Cray-egypt-8%5Ccomponents%5Ccommon%5CThemeContext.tsx&modules=C%3A%5CUsers%5CDream%5Cray-egypt-8%5Ccomponents%5Ccommon%5CToastContext.tsx&modules=C%3A%5CUsers%5CDream%5Cray-egypt-8%5Ccontext%5CAuthContext.tsx&modules=C%3A%5CUsers%5CDream%5Cray-egypt-8%5Ccontext%5CLanguageContext.tsx&modules=C%3A%5CUsers%5CDream%5Cray-egypt-8%5Cnode_modules%5Cnext%5Cfont%5Cgoogle%5Ctarget.css%3F%7B%22path%22%3A%22app%5C%5Clayout.tsx%22%2C%22import%22%3A%22Cairo%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22arabic%22%2C%22latin%22%5D%2C%22variable%22%3A%22--font-cairo%22%7D%5D%2C%22variableName%22%3A%22cairo%22%7D&modules=C%3A%5CUsers%5CDream%5Cray-egypt-8%5Cnode_modules%5Cnext%5Cfont%5Cgoogle%5Ctarget.css%3F%7B%22path%22%3A%22app%5C%5Clayout.tsx%22%2C%22import%22%3A%22Dancing_Script%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22latin%22%5D%2C%22variable%22%3A%22--font-dancing%22%7D%5D%2C%22variableName%22%3A%22dancing%22%7D&server=false! ***!
  \*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/globals.css */ \"(app-pages-browser)/./app/globals.css\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./components/common/GeminiAssistant.tsx */ \"(app-pages-browser)/./components/common/GeminiAssistant.tsx\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./components/common/ThemeContext.tsx */ \"(app-pages-browser)/./components/common/ThemeContext.tsx\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./components/common/ToastContext.tsx */ \"(app-pages-browser)/./components/common/ToastContext.tsx\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./context/AuthContext.tsx */ \"(app-pages-browser)/./context/AuthContext.tsx\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./context/LanguageContext.tsx */ \"(app-pages-browser)/./context/LanguageContext.tsx\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/font/google/target.css?{\"path\":\"app\\\\layout.tsx\",\"import\":\"Cairo\",\"arguments\":[{\"subsets\":[\"arabic\",\"latin\"],\"variable\":\"--font-cairo\"}],\"variableName\":\"cairo\"} */ \"(app-pages-browser)/./node_modules/next/font/google/target.css?{\\\"path\\\":\\\"app\\\\\\\\layout.tsx\\\",\\\"import\\\":\\\"Cairo\\\",\\\"arguments\\\":[{\\\"subsets\\\":[\\\"arabic\\\",\\\"latin\\\"],\\\"variable\\\":\\\"--font-cairo\\\"}],\\\"variableName\\\":\\\"cairo\\\"}\", 23));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/font/google/target.css?{\"path\":\"app\\\\layout.tsx\",\"import\":\"Dancing_Script\",\"arguments\":[{\"subsets\":[\"latin\"],\"variable\":\"--font-dancing\"}],\"variableName\":\"dancing\"} */ \"(app-pages-browser)/./node_modules/next/font/google/target.css?{\\\"path\\\":\\\"app\\\\\\\\layout.tsx\\\",\\\"import\\\":\\\"Dancing_Script\\\",\\\"arguments\\\":[{\\\"subsets\\\":[\\\"latin\\\"],\\\"variable\\\":\\\"--font-dancing\\\"}],\\\"variableName\\\":\\\"dancing\\\"}\", 23))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz1DJTNBJTVDVXNlcnMlNUNEcmVhbSU1Q3JheS1lZ3lwdC04JTVDYXBwJTVDZ2xvYmFscy5jc3MmbW9kdWxlcz1DJTNBJTVDVXNlcnMlNUNEcmVhbSU1Q3JheS1lZ3lwdC04JTVDY29tcG9uZW50cyU1Q2NvbW1vbiU1Q0dlbWluaUFzc2lzdGFudC50c3gmbW9kdWxlcz1DJTNBJTVDVXNlcnMlNUNEcmVhbSU1Q3JheS1lZ3lwdC04JTVDY29tcG9uZW50cyU1Q2NvbW1vbiU1Q1RoZW1lQ29udGV4dC50c3gmbW9kdWxlcz1DJTNBJTVDVXNlcnMlNUNEcmVhbSU1Q3JheS1lZ3lwdC04JTVDY29tcG9uZW50cyU1Q2NvbW1vbiU1Q1RvYXN0Q29udGV4dC50c3gmbW9kdWxlcz1DJTNBJTVDVXNlcnMlNUNEcmVhbSU1Q3JheS1lZ3lwdC04JTVDY29udGV4dCU1Q0F1dGhDb250ZXh0LnRzeCZtb2R1bGVzPUMlM0ElNUNVc2VycyU1Q0RyZWFtJTVDcmF5LWVneXB0LTglNUNjb250ZXh0JTVDTGFuZ3VhZ2VDb250ZXh0LnRzeCZtb2R1bGVzPUMlM0ElNUNVc2VycyU1Q0RyZWFtJTVDcmF5LWVneXB0LTglNUNub2RlX21vZHVsZXMlNUNuZXh0JTVDZm9udCU1Q2dvb2dsZSU1Q3RhcmdldC5jc3MlM0YlN0IlMjJwYXRoJTIyJTNBJTIyYXBwJTVDJTVDbGF5b3V0LnRzeCUyMiUyQyUyMmltcG9ydCUyMiUzQSUyMkNhaXJvJTIyJTJDJTIyYXJndW1lbnRzJTIyJTNBJTVCJTdCJTIyc3Vic2V0cyUyMiUzQSU1QiUyMmFyYWJpYyUyMiUyQyUyMmxhdGluJTIyJTVEJTJDJTIydmFyaWFibGUlMjIlM0ElMjItLWZvbnQtY2Fpcm8lMjIlN0QlNUQlMkMlMjJ2YXJpYWJsZU5hbWUlMjIlM0ElMjJjYWlybyUyMiU3RCZtb2R1bGVzPUMlM0ElNUNVc2VycyU1Q0RyZWFtJTVDcmF5LWVneXB0LTglNUNub2RlX21vZHVsZXMlNUNuZXh0JTVDZm9udCU1Q2dvb2dsZSU1Q3RhcmdldC5jc3MlM0YlN0IlMjJwYXRoJTIyJTNBJTIyYXBwJTVDJTVDbGF5b3V0LnRzeCUyMiUyQyUyMmltcG9ydCUyMiUzQSUyMkRhbmNpbmdfU2NyaXB0JTIyJTJDJTIyYXJndW1lbnRzJTIyJTNBJTVCJTdCJTIyc3Vic2V0cyUyMiUzQSU1QiUyMmxhdGluJTIyJTVEJTJDJTIydmFyaWFibGUlMjIlM0ElMjItLWZvbnQtZGFuY2luZyUyMiU3RCU1RCUyQyUyMnZhcmlhYmxlTmFtZSUyMiUzQSUyMmRhbmNpbmclMjIlN0Qmc2VydmVyPWZhbHNlISIsIm1hcHBpbmdzIjoiQUFBQSw0SkFBb0Y7QUFDcEYsd01BQTJHO0FBQzNHLGtNQUF3RztBQUN4RyxrTUFBd0c7QUFDeEcsNEtBQTRGO0FBQzVGLG9MQUFnRztBQUNoRyxrZ0JBQW9SO0FBQ3BSIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/ZjgyZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIkM6XFxcXFVzZXJzXFxcXERyZWFtXFxcXHJheS1lZ3lwdC04XFxcXGFwcFxcXFxnbG9iYWxzLmNzc1wiKTtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiQzpcXFxcVXNlcnNcXFxcRHJlYW1cXFxccmF5LWVneXB0LThcXFxcY29tcG9uZW50c1xcXFxjb21tb25cXFxcR2VtaW5pQXNzaXN0YW50LnRzeFwiKTtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiQzpcXFxcVXNlcnNcXFxcRHJlYW1cXFxccmF5LWVneXB0LThcXFxcY29tcG9uZW50c1xcXFxjb21tb25cXFxcVGhlbWVDb250ZXh0LnRzeFwiKTtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiQzpcXFxcVXNlcnNcXFxcRHJlYW1cXFxccmF5LWVneXB0LThcXFxcY29tcG9uZW50c1xcXFxjb21tb25cXFxcVG9hc3RDb250ZXh0LnRzeFwiKTtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiQzpcXFxcVXNlcnNcXFxcRHJlYW1cXFxccmF5LWVneXB0LThcXFxcY29udGV4dFxcXFxBdXRoQ29udGV4dC50c3hcIik7XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIkM6XFxcXFVzZXJzXFxcXERyZWFtXFxcXHJheS1lZ3lwdC04XFxcXGNvbnRleHRcXFxcTGFuZ3VhZ2VDb250ZXh0LnRzeFwiKTtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiQzpcXFxcVXNlcnNcXFxcRHJlYW1cXFxccmF5LWVneXB0LThcXFxcbm9kZV9tb2R1bGVzXFxcXG5leHRcXFxcZm9udFxcXFxnb29nbGVcXFxcdGFyZ2V0LmNzcz97XFxcInBhdGhcXFwiOlxcXCJhcHBcXFxcXFxcXGxheW91dC50c3hcXFwiLFxcXCJpbXBvcnRcXFwiOlxcXCJDYWlyb1xcXCIsXFxcImFyZ3VtZW50c1xcXCI6W3tcXFwic3Vic2V0c1xcXCI6W1xcXCJhcmFiaWNcXFwiLFxcXCJsYXRpblxcXCJdLFxcXCJ2YXJpYWJsZVxcXCI6XFxcIi0tZm9udC1jYWlyb1xcXCJ9XSxcXFwidmFyaWFibGVOYW1lXFxcIjpcXFwiY2Fpcm9cXFwifVwiKTtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiQzpcXFxcVXNlcnNcXFxcRHJlYW1cXFxccmF5LWVneXB0LThcXFxcbm9kZV9tb2R1bGVzXFxcXG5leHRcXFxcZm9udFxcXFxnb29nbGVcXFxcdGFyZ2V0LmNzcz97XFxcInBhdGhcXFwiOlxcXCJhcHBcXFxcXFxcXGxheW91dC50c3hcXFwiLFxcXCJpbXBvcnRcXFwiOlxcXCJEYW5jaW5nX1NjcmlwdFxcXCIsXFxcImFyZ3VtZW50c1xcXCI6W3tcXFwic3Vic2V0c1xcXCI6W1xcXCJsYXRpblxcXCJdLFxcXCJ2YXJpYWJsZVxcXCI6XFxcIi0tZm9udC1kYW5jaW5nXFxcIn1dLFxcXCJ2YXJpYWJsZU5hbWVcXFwiOlxcXCJkYW5jaW5nXFxcIn1cIikiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5CUsers%5CDream%5Cray-egypt-8%5Capp%5Cglobals.css&modules=C%3A%5CUsers%5CDream%5Cray-egypt-8%5Ccomponents%5Ccommon%5CGeminiAssistant.tsx&modules=C%3A%5CUsers%5CDream%5Cray-egypt-8%5Ccomponents%5Ccommon%5CThemeContext.tsx&modules=C%3A%5CUsers%5CDream%5Cray-egypt-8%5Ccomponents%5Ccommon%5CToastContext.tsx&modules=C%3A%5CUsers%5CDream%5Cray-egypt-8%5Ccontext%5CAuthContext.tsx&modules=C%3A%5CUsers%5CDream%5Cray-egypt-8%5Ccontext%5CLanguageContext.tsx&modules=C%3A%5CUsers%5CDream%5Cray-egypt-8%5Cnode_modules%5Cnext%5Cfont%5Cgoogle%5Ctarget.css%3F%7B%22path%22%3A%22app%5C%5Clayout.tsx%22%2C%22import%22%3A%22Cairo%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22arabic%22%2C%22latin%22%5D%2C%22variable%22%3A%22--font-cairo%22%7D%5D%2C%22variableName%22%3A%22cairo%22%7D&modules=C%3A%5CUsers%5CDream%5Cray-egypt-8%5Cnode_modules%5Cnext%5Cfont%5Cgoogle%5Ctarget.css%3F%7B%22path%22%3A%22app%5C%5Clayout.tsx%22%2C%22import%22%3A%22Dancing_Script%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22latin%22%5D%2C%22variable%22%3A%22--font-dancing%22%7D%5D%2C%22variableName%22%3A%22dancing%22%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/Icon.js":
/*!****************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/Icon.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Icon; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _defaultAttributes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./defaultAttributes.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/defaultAttributes.js\");\n/* harmony import */ var _shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shared/src/utils.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/shared/src/utils.js\");\n/**\n * @license lucide-react v0.554.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \n\n\nconst Icon = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(_c = (param, ref)=>{\n    let { color = \"currentColor\", size = 24, strokeWidth = 2, absoluteStrokeWidth, className = \"\", children, iconNode, ...rest } = param;\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"svg\", {\n        ref,\n        ..._defaultAttributes_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n        width: size,\n        height: size,\n        stroke: color,\n        strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,\n        className: (0,_shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.mergeClasses)(\"lucide\", className),\n        ...!children && !(0,_shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.hasA11yProp)(rest) && {\n            \"aria-hidden\": \"true\"\n        },\n        ...rest\n    }, [\n        ...iconNode.map((param)=>{\n            let [tag, attrs] = param;\n            return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(tag, attrs);\n        }),\n        ...Array.isArray(children) ? children : [\n            children\n        ]\n    ]);\n});\n_c1 = Icon;\n //# sourceMappingURL=Icon.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"Icon$forwardRef\");\n$RefreshReg$(_c1, \"Icon\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vSWNvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7OztDQUtDLEdBRWlEO0FBQ0s7QUFDVztBQUVsRSxNQUFNSyxxQkFBT0wsaURBQVVBLE1BQ3JCLFFBU0dNO1FBVEYsRUFDQ0MsUUFBUSxjQUFjLEVBQ3RCQyxPQUFPLEVBQUUsRUFDVEMsY0FBYyxDQUFDLEVBQ2ZDLG1CQUFtQixFQUNuQkMsWUFBWSxFQUFFLEVBQ2RDLFFBQVEsRUFDUkMsUUFBUSxFQUNSLEdBQUdDLE1BQ0o7eUJBQVViLG9EQUFhQSxDQUN0QixPQUNBO1FBQ0VLO1FBQ0EsR0FBR0osNkRBQWlCO1FBQ3BCYSxPQUFPUDtRQUNQUSxRQUFRUjtRQUNSUyxRQUFRVjtRQUNSRSxhQUFhQyxzQkFBc0JRLE9BQU9ULGVBQWUsS0FBS1MsT0FBT1YsUUFBUUM7UUFDN0VFLFdBQVdSLGtFQUFZQSxDQUFDLFVBQVVRO1FBQ2xDLEdBQUcsQ0FBQ0MsWUFBWSxDQUFDUixpRUFBV0EsQ0FBQ1UsU0FBUztZQUFFLGVBQWU7UUFBTyxDQUFDO1FBQy9ELEdBQUdBLElBQUk7SUFDVCxHQUNBO1dBQ0tELFNBQVNNLEdBQUcsQ0FBQztnQkFBQyxDQUFDQyxLQUFLQyxNQUFNO2lDQUFLcEIsb0RBQWFBLENBQUNtQixLQUFLQzs7V0FDbERDLE1BQU1DLE9BQU8sQ0FBQ1gsWUFBWUEsV0FBVztZQUFDQTtTQUFTO0tBQ25EOzs7QUFJc0IsQ0FDM0IsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vSWNvbi5qcz85MjMxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjU1NC4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgeyBmb3J3YXJkUmVmLCBjcmVhdGVFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGRlZmF1bHRBdHRyaWJ1dGVzIGZyb20gJy4vZGVmYXVsdEF0dHJpYnV0ZXMuanMnO1xuaW1wb3J0IHsgbWVyZ2VDbGFzc2VzLCBoYXNBMTF5UHJvcCB9IGZyb20gJy4vc2hhcmVkL3NyYy91dGlscy5qcyc7XG5cbmNvbnN0IEljb24gPSBmb3J3YXJkUmVmKFxuICAoe1xuICAgIGNvbG9yID0gXCJjdXJyZW50Q29sb3JcIixcbiAgICBzaXplID0gMjQsXG4gICAgc3Ryb2tlV2lkdGggPSAyLFxuICAgIGFic29sdXRlU3Ryb2tlV2lkdGgsXG4gICAgY2xhc3NOYW1lID0gXCJcIixcbiAgICBjaGlsZHJlbixcbiAgICBpY29uTm9kZSxcbiAgICAuLi5yZXN0XG4gIH0sIHJlZikgPT4gY3JlYXRlRWxlbWVudChcbiAgICBcInN2Z1wiLFxuICAgIHtcbiAgICAgIHJlZixcbiAgICAgIC4uLmRlZmF1bHRBdHRyaWJ1dGVzLFxuICAgICAgd2lkdGg6IHNpemUsXG4gICAgICBoZWlnaHQ6IHNpemUsXG4gICAgICBzdHJva2U6IGNvbG9yLFxuICAgICAgc3Ryb2tlV2lkdGg6IGFic29sdXRlU3Ryb2tlV2lkdGggPyBOdW1iZXIoc3Ryb2tlV2lkdGgpICogMjQgLyBOdW1iZXIoc2l6ZSkgOiBzdHJva2VXaWR0aCxcbiAgICAgIGNsYXNzTmFtZTogbWVyZ2VDbGFzc2VzKFwibHVjaWRlXCIsIGNsYXNzTmFtZSksXG4gICAgICAuLi4hY2hpbGRyZW4gJiYgIWhhc0ExMXlQcm9wKHJlc3QpICYmIHsgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIiB9LFxuICAgICAgLi4ucmVzdFxuICAgIH0sXG4gICAgW1xuICAgICAgLi4uaWNvbk5vZGUubWFwKChbdGFnLCBhdHRyc10pID0+IGNyZWF0ZUVsZW1lbnQodGFnLCBhdHRycykpLFxuICAgICAgLi4uQXJyYXkuaXNBcnJheShjaGlsZHJlbikgPyBjaGlsZHJlbiA6IFtjaGlsZHJlbl1cbiAgICBdXG4gIClcbik7XG5cbmV4cG9ydCB7IEljb24gYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SWNvbi5qcy5tYXBcbiJdLCJuYW1lcyI6WyJmb3J3YXJkUmVmIiwiY3JlYXRlRWxlbWVudCIsImRlZmF1bHRBdHRyaWJ1dGVzIiwibWVyZ2VDbGFzc2VzIiwiaGFzQTExeVByb3AiLCJJY29uIiwicmVmIiwiY29sb3IiLCJzaXplIiwic3Ryb2tlV2lkdGgiLCJhYnNvbHV0ZVN0cm9rZVdpZHRoIiwiY2xhc3NOYW1lIiwiY2hpbGRyZW4iLCJpY29uTm9kZSIsInJlc3QiLCJ3aWR0aCIsImhlaWdodCIsInN0cm9rZSIsIk51bWJlciIsIm1hcCIsInRhZyIsImF0dHJzIiwiQXJyYXkiLCJpc0FycmF5IiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/Icon.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js":
/*!****************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/createLucideIcon.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ createLucideIcon; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shared/src/utils.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/shared/src/utils.js\");\n/* harmony import */ var _Icon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Icon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/Icon.js\");\n/**\n * @license lucide-react v0.554.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \n\n\nconst createLucideIcon = (iconName, iconNode)=>{\n    const Component = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((param, ref)=>{\n        let { className, ...props } = param;\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(_Icon_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n            ref,\n            iconNode,\n            className: (0,_shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.mergeClasses)(\"lucide-\".concat((0,_shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.toKebabCase)((0,_shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.toPascalCase)(iconName))), \"lucide-\".concat(iconName), className),\n            ...props\n        });\n    });\n    Component.displayName = (0,_shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.toPascalCase)(iconName);\n    return Component;\n};\n //# sourceMappingURL=createLucideIcon.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vY3JlYXRlTHVjaWRlSWNvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7OztDQUtDLEdBRWlEO0FBQzhCO0FBQ25EO0FBRTdCLE1BQU1NLG1CQUFtQixDQUFDQyxVQUFVQztJQUNsQyxNQUFNQywwQkFBWVQsaURBQVVBLENBQzFCLFFBQTBCVTtZQUF6QixFQUFFQyxTQUFTLEVBQUUsR0FBR0MsT0FBTzs2QkFBVVgsb0RBQWFBLENBQUNJLGdEQUFJQSxFQUFFO1lBQ3BESztZQUNBRjtZQUNBRyxXQUFXVCxrRUFBWUEsQ0FDckIsVUFBOEMsT0FBcENDLGlFQUFXQSxDQUFDQyxrRUFBWUEsQ0FBQ0csYUFDbkMsVUFBbUIsT0FBVEEsV0FDVkk7WUFFRixHQUFHQyxLQUFLO1FBQ1Y7O0lBRUZILFVBQVVJLFdBQVcsR0FBR1Qsa0VBQVlBLENBQUNHO0lBQ3JDLE9BQU9FO0FBQ1Q7QUFFdUMsQ0FDdkMsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vY3JlYXRlTHVjaWRlSWNvbi5qcz80MGM0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjU1NC4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgeyBmb3J3YXJkUmVmLCBjcmVhdGVFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgbWVyZ2VDbGFzc2VzLCB0b0tlYmFiQ2FzZSwgdG9QYXNjYWxDYXNlIH0gZnJvbSAnLi9zaGFyZWQvc3JjL3V0aWxzLmpzJztcbmltcG9ydCBJY29uIGZyb20gJy4vSWNvbi5qcyc7XG5cbmNvbnN0IGNyZWF0ZUx1Y2lkZUljb24gPSAoaWNvbk5hbWUsIGljb25Ob2RlKSA9PiB7XG4gIGNvbnN0IENvbXBvbmVudCA9IGZvcndhcmRSZWYoXG4gICAgKHsgY2xhc3NOYW1lLCAuLi5wcm9wcyB9LCByZWYpID0+IGNyZWF0ZUVsZW1lbnQoSWNvbiwge1xuICAgICAgcmVmLFxuICAgICAgaWNvbk5vZGUsXG4gICAgICBjbGFzc05hbWU6IG1lcmdlQ2xhc3NlcyhcbiAgICAgICAgYGx1Y2lkZS0ke3RvS2ViYWJDYXNlKHRvUGFzY2FsQ2FzZShpY29uTmFtZSkpfWAsXG4gICAgICAgIGBsdWNpZGUtJHtpY29uTmFtZX1gLFxuICAgICAgICBjbGFzc05hbWVcbiAgICAgICksXG4gICAgICAuLi5wcm9wc1xuICAgIH0pXG4gICk7XG4gIENvbXBvbmVudC5kaXNwbGF5TmFtZSA9IHRvUGFzY2FsQ2FzZShpY29uTmFtZSk7XG4gIHJldHVybiBDb21wb25lbnQ7XG59O1xuXG5leHBvcnQgeyBjcmVhdGVMdWNpZGVJY29uIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZUx1Y2lkZUljb24uanMubWFwXG4iXSwibmFtZXMiOlsiZm9yd2FyZFJlZiIsImNyZWF0ZUVsZW1lbnQiLCJtZXJnZUNsYXNzZXMiLCJ0b0tlYmFiQ2FzZSIsInRvUGFzY2FsQ2FzZSIsIkljb24iLCJjcmVhdGVMdWNpZGVJY29uIiwiaWNvbk5hbWUiLCJpY29uTm9kZSIsIkNvbXBvbmVudCIsInJlZiIsImNsYXNzTmFtZSIsInByb3BzIiwiZGlzcGxheU5hbWUiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/defaultAttributes.js":
/*!*****************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/defaultAttributes.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ defaultAttributes; }\n/* harmony export */ });\n/**\n * @license lucide-react v0.554.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ var defaultAttributes = {\n    xmlns: \"http://www.w3.org/2000/svg\",\n    width: 24,\n    height: 24,\n    viewBox: \"0 0 24 24\",\n    fill: \"none\",\n    stroke: \"currentColor\",\n    strokeWidth: 2,\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\"\n};\n //# sourceMappingURL=defaultAttributes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vZGVmYXVsdEF0dHJpYnV0ZXMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7OztDQUtDLEdBRUQsSUFBSUEsb0JBQW9CO0lBQ3RCQyxPQUFPO0lBQ1BDLE9BQU87SUFDUEMsUUFBUTtJQUNSQyxTQUFTO0lBQ1RDLE1BQU07SUFDTkMsUUFBUTtJQUNSQyxhQUFhO0lBQ2JDLGVBQWU7SUFDZkMsZ0JBQWdCO0FBQ2xCO0FBRXdDLENBQ3hDLDZDQUE2QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2RlZmF1bHRBdHRyaWJ1dGVzLmpzPzFkN2YiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtcmVhY3QgdjAuNTU0LjAgLSBJU0NcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBJU0MgbGljZW5zZS5cbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBkZWZhdWx0QXR0cmlidXRlcyA9IHtcbiAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgd2lkdGg6IDI0LFxuICBoZWlnaHQ6IDI0LFxuICB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLFxuICBmaWxsOiBcIm5vbmVcIixcbiAgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLFxuICBzdHJva2VXaWR0aDogMixcbiAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiXG59O1xuXG5leHBvcnQgeyBkZWZhdWx0QXR0cmlidXRlcyBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0QXR0cmlidXRlcy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJkZWZhdWx0QXR0cmlidXRlcyIsInhtbG5zIiwid2lkdGgiLCJoZWlnaHQiLCJ2aWV3Qm94IiwiZmlsbCIsInN0cm9rZSIsInN0cm9rZVdpZHRoIiwic3Ryb2tlTGluZWNhcCIsInN0cm9rZUxpbmVqb2luIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/defaultAttributes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/circle-alert.js":
/*!******************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/circle-alert.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __iconNode: function() { return /* binding */ __iconNode; },\n/* harmony export */   \"default\": function() { return /* binding */ CircleAlert; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.554.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst __iconNode = [\n    [\n        \"circle\",\n        {\n            cx: \"12\",\n            cy: \"12\",\n            r: \"10\",\n            key: \"1mglay\"\n        }\n    ],\n    [\n        \"line\",\n        {\n            x1: \"12\",\n            x2: \"12\",\n            y1: \"8\",\n            y2: \"12\",\n            key: \"1pkeuh\"\n        }\n    ],\n    [\n        \"line\",\n        {\n            x1: \"12\",\n            x2: \"12.01\",\n            y1: \"16\",\n            y2: \"16\",\n            key: \"4dfq90\"\n        }\n    ]\n];\nconst CircleAlert = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"circle-alert\", __iconNode);\n //# sourceMappingURL=circle-alert.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvY2lyY2xlLWFsZXJ0LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7OztDQUtDLEdBRXFEO0FBRXRELE1BQU1DLGFBQWE7SUFDakI7UUFBQztRQUFVO1lBQUVDLElBQUk7WUFBTUMsSUFBSTtZQUFNQyxHQUFHO1lBQU1DLEtBQUs7UUFBUztLQUFFO0lBQzFEO1FBQUM7UUFBUTtZQUFFQyxJQUFJO1lBQU1DLElBQUk7WUFBTUMsSUFBSTtZQUFLQyxJQUFJO1lBQU1KLEtBQUs7UUFBUztLQUFFO0lBQ2xFO1FBQUM7UUFBUTtZQUFFQyxJQUFJO1lBQU1DLElBQUk7WUFBU0MsSUFBSTtZQUFNQyxJQUFJO1lBQU1KLEtBQUs7UUFBUztLQUFFO0NBQ3ZFO0FBQ0QsTUFBTUssY0FBY1YsZ0VBQWdCQSxDQUFDLGdCQUFnQkM7QUFFUCxDQUM5Qyx3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2x1Y2lkZS1yZWFjdC9kaXN0L2VzbS9pY29ucy9jaXJjbGUtYWxlcnQuanM/OGM4YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1yZWFjdCB2MC41NTQuMCAtIElTQ1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIElTQyBsaWNlbnNlLlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IGNyZWF0ZUx1Y2lkZUljb24gZnJvbSAnLi4vY3JlYXRlTHVjaWRlSWNvbi5qcyc7XG5cbmNvbnN0IF9faWNvbk5vZGUgPSBbXG4gIFtcImNpcmNsZVwiLCB7IGN4OiBcIjEyXCIsIGN5OiBcIjEyXCIsIHI6IFwiMTBcIiwga2V5OiBcIjFtZ2xheVwiIH1dLFxuICBbXCJsaW5lXCIsIHsgeDE6IFwiMTJcIiwgeDI6IFwiMTJcIiwgeTE6IFwiOFwiLCB5MjogXCIxMlwiLCBrZXk6IFwiMXBrZXVoXCIgfV0sXG4gIFtcImxpbmVcIiwgeyB4MTogXCIxMlwiLCB4MjogXCIxMi4wMVwiLCB5MTogXCIxNlwiLCB5MjogXCIxNlwiLCBrZXk6IFwiNGRmcTkwXCIgfV1cbl07XG5jb25zdCBDaXJjbGVBbGVydCA9IGNyZWF0ZUx1Y2lkZUljb24oXCJjaXJjbGUtYWxlcnRcIiwgX19pY29uTm9kZSk7XG5cbmV4cG9ydCB7IF9faWNvbk5vZGUsIENpcmNsZUFsZXJ0IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNpcmNsZS1hbGVydC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJjcmVhdGVMdWNpZGVJY29uIiwiX19pY29uTm9kZSIsImN4IiwiY3kiLCJyIiwia2V5IiwieDEiLCJ4MiIsInkxIiwieTIiLCJDaXJjbGVBbGVydCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/circle-alert.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/circle-check-big.js":
/*!**********************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/circle-check-big.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __iconNode: function() { return /* binding */ __iconNode; },\n/* harmony export */   \"default\": function() { return /* binding */ CircleCheckBig; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.554.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst __iconNode = [\n    [\n        \"path\",\n        {\n            d: \"M21.801 10A10 10 0 1 1 17 3.335\",\n            key: \"yps3ct\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"m9 11 3 3L22 4\",\n            key: \"1pflzl\"\n        }\n    ]\n];\nconst CircleCheckBig = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"circle-check-big\", __iconNode);\n //# sourceMappingURL=circle-check-big.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvY2lyY2xlLWNoZWNrLWJpZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUVxRDtBQUV0RCxNQUFNQyxhQUFhO0lBQ2pCO1FBQUM7UUFBUTtZQUFFQyxHQUFHO1lBQW1DQyxLQUFLO1FBQVM7S0FBRTtJQUNqRTtRQUFDO1FBQVE7WUFBRUQsR0FBRztZQUFrQkMsS0FBSztRQUFTO0tBQUU7Q0FDakQ7QUFDRCxNQUFNQyxpQkFBaUJKLGdFQUFnQkEsQ0FBQyxvQkFBb0JDO0FBRVgsQ0FDakQsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvY2lyY2xlLWNoZWNrLWJpZy5qcz8zZDFiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjU1NC4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgY3JlYXRlTHVjaWRlSWNvbiBmcm9tICcuLi9jcmVhdGVMdWNpZGVJY29uLmpzJztcblxuY29uc3QgX19pY29uTm9kZSA9IFtcbiAgW1wicGF0aFwiLCB7IGQ6IFwiTTIxLjgwMSAxMEExMCAxMCAwIDEgMSAxNyAzLjMzNVwiLCBrZXk6IFwieXBzM2N0XCIgfV0sXG4gIFtcInBhdGhcIiwgeyBkOiBcIm05IDExIDMgM0wyMiA0XCIsIGtleTogXCIxcGZsemxcIiB9XVxuXTtcbmNvbnN0IENpcmNsZUNoZWNrQmlnID0gY3JlYXRlTHVjaWRlSWNvbihcImNpcmNsZS1jaGVjay1iaWdcIiwgX19pY29uTm9kZSk7XG5cbmV4cG9ydCB7IF9faWNvbk5vZGUsIENpcmNsZUNoZWNrQmlnIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNpcmNsZS1jaGVjay1iaWcuanMubWFwXG4iXSwibmFtZXMiOlsiY3JlYXRlTHVjaWRlSWNvbiIsIl9faWNvbk5vZGUiLCJkIiwia2V5IiwiQ2lyY2xlQ2hlY2tCaWciLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/circle-check-big.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/info.js":
/*!**********************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/info.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __iconNode: function() { return /* binding */ __iconNode; },\n/* harmony export */   \"default\": function() { return /* binding */ Info; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.554.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst __iconNode = [\n    [\n        \"circle\",\n        {\n            cx: \"12\",\n            cy: \"12\",\n            r: \"10\",\n            key: \"1mglay\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M12 16v-4\",\n            key: \"1dtifu\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M12 8h.01\",\n            key: \"e9boi3\"\n        }\n    ]\n];\nconst Info = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"info\", __iconNode);\n //# sourceMappingURL=info.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvaW5mby5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUVxRDtBQUV0RCxNQUFNQyxhQUFhO0lBQ2pCO1FBQUM7UUFBVTtZQUFFQyxJQUFJO1lBQU1DLElBQUk7WUFBTUMsR0FBRztZQUFNQyxLQUFLO1FBQVM7S0FBRTtJQUMxRDtRQUFDO1FBQVE7WUFBRUMsR0FBRztZQUFhRCxLQUFLO1FBQVM7S0FBRTtJQUMzQztRQUFDO1FBQVE7WUFBRUMsR0FBRztZQUFhRCxLQUFLO1FBQVM7S0FBRTtDQUM1QztBQUNELE1BQU1FLE9BQU9QLGdFQUFnQkEsQ0FBQyxRQUFRQztBQUVDLENBQ3ZDLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2ljb25zL2luZm8uanM/YWM4MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1yZWFjdCB2MC41NTQuMCAtIElTQ1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIElTQyBsaWNlbnNlLlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IGNyZWF0ZUx1Y2lkZUljb24gZnJvbSAnLi4vY3JlYXRlTHVjaWRlSWNvbi5qcyc7XG5cbmNvbnN0IF9faWNvbk5vZGUgPSBbXG4gIFtcImNpcmNsZVwiLCB7IGN4OiBcIjEyXCIsIGN5OiBcIjEyXCIsIHI6IFwiMTBcIiwga2V5OiBcIjFtZ2xheVwiIH1dLFxuICBbXCJwYXRoXCIsIHsgZDogXCJNMTIgMTZ2LTRcIiwga2V5OiBcIjFkdGlmdVwiIH1dLFxuICBbXCJwYXRoXCIsIHsgZDogXCJNMTIgOGguMDFcIiwga2V5OiBcImU5Ym9pM1wiIH1dXG5dO1xuY29uc3QgSW5mbyA9IGNyZWF0ZUx1Y2lkZUljb24oXCJpbmZvXCIsIF9faWNvbk5vZGUpO1xuXG5leHBvcnQgeyBfX2ljb25Ob2RlLCBJbmZvIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZm8uanMubWFwXG4iXSwibmFtZXMiOlsiY3JlYXRlTHVjaWRlSWNvbiIsIl9faWNvbk5vZGUiLCJjeCIsImN5IiwiciIsImtleSIsImQiLCJJbmZvIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/info.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/loader-circle.js":
/*!*******************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/loader-circle.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __iconNode: function() { return /* binding */ __iconNode; },\n/* harmony export */   \"default\": function() { return /* binding */ LoaderCircle; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.554.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst __iconNode = [\n    [\n        \"path\",\n        {\n            d: \"M21 12a9 9 0 1 1-6.219-8.56\",\n            key: \"13zald\"\n        }\n    ]\n];\nconst LoaderCircle = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"loader-circle\", __iconNode);\n //# sourceMappingURL=loader-circle.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvbG9hZGVyLWNpcmNsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUVxRDtBQUV0RCxNQUFNQyxhQUFhO0lBQUM7UUFBQztRQUFRO1lBQUVDLEdBQUc7WUFBK0JDLEtBQUs7UUFBUztLQUFFO0NBQUM7QUFDbEYsTUFBTUMsZUFBZUosZ0VBQWdCQSxDQUFDLGlCQUFpQkM7QUFFUixDQUMvQyx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2x1Y2lkZS1yZWFjdC9kaXN0L2VzbS9pY29ucy9sb2FkZXItY2lyY2xlLmpzPzQwM2QiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtcmVhY3QgdjAuNTU0LjAgLSBJU0NcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBJU0MgbGljZW5zZS5cbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24uanMnO1xuXG5jb25zdCBfX2ljb25Ob2RlID0gW1tcInBhdGhcIiwgeyBkOiBcIk0yMSAxMmE5IDkgMCAxIDEtNi4yMTktOC41NlwiLCBrZXk6IFwiMTN6YWxkXCIgfV1dO1xuY29uc3QgTG9hZGVyQ2lyY2xlID0gY3JlYXRlTHVjaWRlSWNvbihcImxvYWRlci1jaXJjbGVcIiwgX19pY29uTm9kZSk7XG5cbmV4cG9ydCB7IF9faWNvbk5vZGUsIExvYWRlckNpcmNsZSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkZXItY2lyY2xlLmpzLm1hcFxuIl0sIm5hbWVzIjpbImNyZWF0ZUx1Y2lkZUljb24iLCJfX2ljb25Ob2RlIiwiZCIsImtleSIsIkxvYWRlckNpcmNsZSIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/loader-circle.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/mic-off.js":
/*!*************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/mic-off.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __iconNode: function() { return /* binding */ __iconNode; },\n/* harmony export */   \"default\": function() { return /* binding */ MicOff; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.554.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst __iconNode = [\n    [\n        \"path\",\n        {\n            d: \"M12 19v3\",\n            key: \"npa21l\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M15 9.34V5a3 3 0 0 0-5.68-1.33\",\n            key: \"1gzdoj\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M16.95 16.95A7 7 0 0 1 5 12v-2\",\n            key: \"cqa7eg\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M18.89 13.23A7 7 0 0 0 19 12v-2\",\n            key: \"16hl24\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"m2 2 20 20\",\n            key: \"1ooewy\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M9 9v3a3 3 0 0 0 5.12 2.12\",\n            key: \"r2i35w\"\n        }\n    ]\n];\nconst MicOff = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"mic-off\", __iconNode);\n //# sourceMappingURL=mic-off.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvbWljLW9mZi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUVxRDtBQUV0RCxNQUFNQyxhQUFhO0lBQ2pCO1FBQUM7UUFBUTtZQUFFQyxHQUFHO1lBQVlDLEtBQUs7UUFBUztLQUFFO0lBQzFDO1FBQUM7UUFBUTtZQUFFRCxHQUFHO1lBQWtDQyxLQUFLO1FBQVM7S0FBRTtJQUNoRTtRQUFDO1FBQVE7WUFBRUQsR0FBRztZQUFrQ0MsS0FBSztRQUFTO0tBQUU7SUFDaEU7UUFBQztRQUFRO1lBQUVELEdBQUc7WUFBbUNDLEtBQUs7UUFBUztLQUFFO0lBQ2pFO1FBQUM7UUFBUTtZQUFFRCxHQUFHO1lBQWNDLEtBQUs7UUFBUztLQUFFO0lBQzVDO1FBQUM7UUFBUTtZQUFFRCxHQUFHO1lBQThCQyxLQUFLO1FBQVM7S0FBRTtDQUM3RDtBQUNELE1BQU1DLFNBQVNKLGdFQUFnQkEsQ0FBQyxXQUFXQztBQUVGLENBQ3pDLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2ljb25zL21pYy1vZmYuanM/YjBjMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1yZWFjdCB2MC41NTQuMCAtIElTQ1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIElTQyBsaWNlbnNlLlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IGNyZWF0ZUx1Y2lkZUljb24gZnJvbSAnLi4vY3JlYXRlTHVjaWRlSWNvbi5qcyc7XG5cbmNvbnN0IF9faWNvbk5vZGUgPSBbXG4gIFtcInBhdGhcIiwgeyBkOiBcIk0xMiAxOXYzXCIsIGtleTogXCJucGEyMWxcIiB9XSxcbiAgW1wicGF0aFwiLCB7IGQ6IFwiTTE1IDkuMzRWNWEzIDMgMCAwIDAtNS42OC0xLjMzXCIsIGtleTogXCIxZ3pkb2pcIiB9XSxcbiAgW1wicGF0aFwiLCB7IGQ6IFwiTTE2Ljk1IDE2Ljk1QTcgNyAwIDAgMSA1IDEydi0yXCIsIGtleTogXCJjcWE3ZWdcIiB9XSxcbiAgW1wicGF0aFwiLCB7IGQ6IFwiTTE4Ljg5IDEzLjIzQTcgNyAwIDAgMCAxOSAxMnYtMlwiLCBrZXk6IFwiMTZobDI0XCIgfV0sXG4gIFtcInBhdGhcIiwgeyBkOiBcIm0yIDIgMjAgMjBcIiwga2V5OiBcIjFvb2V3eVwiIH1dLFxuICBbXCJwYXRoXCIsIHsgZDogXCJNOSA5djNhMyAzIDAgMCAwIDUuMTIgMi4xMlwiLCBrZXk6IFwicjJpMzV3XCIgfV1cbl07XG5jb25zdCBNaWNPZmYgPSBjcmVhdGVMdWNpZGVJY29uKFwibWljLW9mZlwiLCBfX2ljb25Ob2RlKTtcblxuZXhwb3J0IHsgX19pY29uTm9kZSwgTWljT2ZmIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1pYy1vZmYuanMubWFwXG4iXSwibmFtZXMiOlsiY3JlYXRlTHVjaWRlSWNvbiIsIl9faWNvbk5vZGUiLCJkIiwia2V5IiwiTWljT2ZmIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/mic-off.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/mic.js":
/*!*********************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/mic.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __iconNode: function() { return /* binding */ __iconNode; },\n/* harmony export */   \"default\": function() { return /* binding */ Mic; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.554.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst __iconNode = [\n    [\n        \"path\",\n        {\n            d: \"M12 19v3\",\n            key: \"npa21l\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M19 10v2a7 7 0 0 1-14 0v-2\",\n            key: \"1vc78b\"\n        }\n    ],\n    [\n        \"rect\",\n        {\n            x: \"9\",\n            y: \"2\",\n            width: \"6\",\n            height: \"13\",\n            rx: \"3\",\n            key: \"s6n7sd\"\n        }\n    ]\n];\nconst Mic = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"mic\", __iconNode);\n //# sourceMappingURL=mic.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvbWljLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7OztDQUtDLEdBRXFEO0FBRXRELE1BQU1DLGFBQWE7SUFDakI7UUFBQztRQUFRO1lBQUVDLEdBQUc7WUFBWUMsS0FBSztRQUFTO0tBQUU7SUFDMUM7UUFBQztRQUFRO1lBQUVELEdBQUc7WUFBOEJDLEtBQUs7UUFBUztLQUFFO0lBQzVEO1FBQUM7UUFBUTtZQUFFQyxHQUFHO1lBQUtDLEdBQUc7WUFBS0MsT0FBTztZQUFLQyxRQUFRO1lBQU1DLElBQUk7WUFBS0wsS0FBSztRQUFTO0tBQUU7Q0FDL0U7QUFDRCxNQUFNTSxNQUFNVCxnRUFBZ0JBLENBQUMsT0FBT0M7QUFFRSxDQUN0QywrQkFBK0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2x1Y2lkZS1yZWFjdC9kaXN0L2VzbS9pY29ucy9taWMuanM/NzRiNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1yZWFjdCB2MC41NTQuMCAtIElTQ1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIElTQyBsaWNlbnNlLlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IGNyZWF0ZUx1Y2lkZUljb24gZnJvbSAnLi4vY3JlYXRlTHVjaWRlSWNvbi5qcyc7XG5cbmNvbnN0IF9faWNvbk5vZGUgPSBbXG4gIFtcInBhdGhcIiwgeyBkOiBcIk0xMiAxOXYzXCIsIGtleTogXCJucGEyMWxcIiB9XSxcbiAgW1wicGF0aFwiLCB7IGQ6IFwiTTE5IDEwdjJhNyA3IDAgMCAxLTE0IDB2LTJcIiwga2V5OiBcIjF2Yzc4YlwiIH1dLFxuICBbXCJyZWN0XCIsIHsgeDogXCI5XCIsIHk6IFwiMlwiLCB3aWR0aDogXCI2XCIsIGhlaWdodDogXCIxM1wiLCByeDogXCIzXCIsIGtleTogXCJzNm43c2RcIiB9XVxuXTtcbmNvbnN0IE1pYyA9IGNyZWF0ZUx1Y2lkZUljb24oXCJtaWNcIiwgX19pY29uTm9kZSk7XG5cbmV4cG9ydCB7IF9faWNvbk5vZGUsIE1pYyBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1taWMuanMubWFwXG4iXSwibmFtZXMiOlsiY3JlYXRlTHVjaWRlSWNvbiIsIl9faWNvbk5vZGUiLCJkIiwia2V5IiwieCIsInkiLCJ3aWR0aCIsImhlaWdodCIsInJ4IiwiTWljIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/mic.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/send.js":
/*!**********************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/send.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __iconNode: function() { return /* binding */ __iconNode; },\n/* harmony export */   \"default\": function() { return /* binding */ Send; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.554.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst __iconNode = [\n    [\n        \"path\",\n        {\n            d: \"M14.536 21.686a.5.5 0 0 0 .937-.024l6.5-19a.496.496 0 0 0-.635-.635l-19 6.5a.5.5 0 0 0-.024.937l7.93 3.18a2 2 0 0 1 1.112 1.11z\",\n            key: \"1ffxy3\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"m21.854 2.147-10.94 10.939\",\n            key: \"12cjpa\"\n        }\n    ]\n];\nconst Send = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"send\", __iconNode);\n //# sourceMappingURL=send.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvc2VuZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUVxRDtBQUV0RCxNQUFNQyxhQUFhO0lBQ2pCO1FBQ0U7UUFDQTtZQUNFQyxHQUFHO1lBQ0hDLEtBQUs7UUFDUDtLQUNEO0lBQ0Q7UUFBQztRQUFRO1lBQUVELEdBQUc7WUFBOEJDLEtBQUs7UUFBUztLQUFFO0NBQzdEO0FBQ0QsTUFBTUMsT0FBT0osZ0VBQWdCQSxDQUFDLFFBQVFDO0FBRUMsQ0FDdkMsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvc2VuZC5qcz9hNjRlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjU1NC4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgY3JlYXRlTHVjaWRlSWNvbiBmcm9tICcuLi9jcmVhdGVMdWNpZGVJY29uLmpzJztcblxuY29uc3QgX19pY29uTm9kZSA9IFtcbiAgW1xuICAgIFwicGF0aFwiLFxuICAgIHtcbiAgICAgIGQ6IFwiTTE0LjUzNiAyMS42ODZhLjUuNSAwIDAgMCAuOTM3LS4wMjRsNi41LTE5YS40OTYuNDk2IDAgMCAwLS42MzUtLjYzNWwtMTkgNi41YS41LjUgMCAwIDAtLjAyNC45MzdsNy45MyAzLjE4YTIgMiAwIDAgMSAxLjExMiAxLjExelwiLFxuICAgICAga2V5OiBcIjFmZnh5M1wiXG4gICAgfVxuICBdLFxuICBbXCJwYXRoXCIsIHsgZDogXCJtMjEuODU0IDIuMTQ3LTEwLjk0IDEwLjkzOVwiLCBrZXk6IFwiMTJjanBhXCIgfV1cbl07XG5jb25zdCBTZW5kID0gY3JlYXRlTHVjaWRlSWNvbihcInNlbmRcIiwgX19pY29uTm9kZSk7XG5cbmV4cG9ydCB7IF9faWNvbk5vZGUsIFNlbmQgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VuZC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJjcmVhdGVMdWNpZGVJY29uIiwiX19pY29uTm9kZSIsImQiLCJrZXkiLCJTZW5kIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/send.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/sparkles.js":
/*!**************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/sparkles.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __iconNode: function() { return /* binding */ __iconNode; },\n/* harmony export */   \"default\": function() { return /* binding */ Sparkles; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.554.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst __iconNode = [\n    [\n        \"path\",\n        {\n            d: \"M11.017 2.814a1 1 0 0 1 1.966 0l1.051 5.558a2 2 0 0 0 1.594 1.594l5.558 1.051a1 1 0 0 1 0 1.966l-5.558 1.051a2 2 0 0 0-1.594 1.594l-1.051 5.558a1 1 0 0 1-1.966 0l-1.051-5.558a2 2 0 0 0-1.594-1.594l-5.558-1.051a1 1 0 0 1 0-1.966l5.558-1.051a2 2 0 0 0 1.594-1.594z\",\n            key: \"1s2grr\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M20 2v4\",\n            key: \"1rf3ol\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M22 4h-4\",\n            key: \"gwowj6\"\n        }\n    ],\n    [\n        \"circle\",\n        {\n            cx: \"4\",\n            cy: \"20\",\n            r: \"2\",\n            key: \"6kqj1y\"\n        }\n    ]\n];\nconst Sparkles = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"sparkles\", __iconNode);\n //# sourceMappingURL=sparkles.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvc3BhcmtsZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7Ozs7O0NBS0MsR0FFcUQ7QUFFdEQsTUFBTUMsYUFBYTtJQUNqQjtRQUNFO1FBQ0E7WUFDRUMsR0FBRztZQUNIQyxLQUFLO1FBQ1A7S0FDRDtJQUNEO1FBQUM7UUFBUTtZQUFFRCxHQUFHO1lBQVdDLEtBQUs7UUFBUztLQUFFO0lBQ3pDO1FBQUM7UUFBUTtZQUFFRCxHQUFHO1lBQVlDLEtBQUs7UUFBUztLQUFFO0lBQzFDO1FBQUM7UUFBVTtZQUFFQyxJQUFJO1lBQUtDLElBQUk7WUFBTUMsR0FBRztZQUFLSCxLQUFLO1FBQVM7S0FBRTtDQUN6RDtBQUNELE1BQU1JLFdBQVdQLGdFQUFnQkEsQ0FBQyxZQUFZQztBQUVILENBQzNDLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2ljb25zL3NwYXJrbGVzLmpzPzlmNTMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtcmVhY3QgdjAuNTU0LjAgLSBJU0NcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBJU0MgbGljZW5zZS5cbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24uanMnO1xuXG5jb25zdCBfX2ljb25Ob2RlID0gW1xuICBbXG4gICAgXCJwYXRoXCIsXG4gICAge1xuICAgICAgZDogXCJNMTEuMDE3IDIuODE0YTEgMSAwIDAgMSAxLjk2NiAwbDEuMDUxIDUuNTU4YTIgMiAwIDAgMCAxLjU5NCAxLjU5NGw1LjU1OCAxLjA1MWExIDEgMCAwIDEgMCAxLjk2NmwtNS41NTggMS4wNTFhMiAyIDAgMCAwLTEuNTk0IDEuNTk0bC0xLjA1MSA1LjU1OGExIDEgMCAwIDEtMS45NjYgMGwtMS4wNTEtNS41NThhMiAyIDAgMCAwLTEuNTk0LTEuNTk0bC01LjU1OC0xLjA1MWExIDEgMCAwIDEgMC0xLjk2Nmw1LjU1OC0xLjA1MWEyIDIgMCAwIDAgMS41OTQtMS41OTR6XCIsXG4gICAgICBrZXk6IFwiMXMyZ3JyXCJcbiAgICB9XG4gIF0sXG4gIFtcInBhdGhcIiwgeyBkOiBcIk0yMCAydjRcIiwga2V5OiBcIjFyZjNvbFwiIH1dLFxuICBbXCJwYXRoXCIsIHsgZDogXCJNMjIgNGgtNFwiLCBrZXk6IFwiZ3dvd2o2XCIgfV0sXG4gIFtcImNpcmNsZVwiLCB7IGN4OiBcIjRcIiwgY3k6IFwiMjBcIiwgcjogXCIyXCIsIGtleTogXCI2a3FqMXlcIiB9XVxuXTtcbmNvbnN0IFNwYXJrbGVzID0gY3JlYXRlTHVjaWRlSWNvbihcInNwYXJrbGVzXCIsIF9faWNvbk5vZGUpO1xuXG5leHBvcnQgeyBfX2ljb25Ob2RlLCBTcGFya2xlcyBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zcGFya2xlcy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJjcmVhdGVMdWNpZGVJY29uIiwiX19pY29uTm9kZSIsImQiLCJrZXkiLCJjeCIsImN5IiwiciIsIlNwYXJrbGVzIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/sparkles.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/x.js":
/*!*******************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/x.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __iconNode: function() { return /* binding */ __iconNode; },\n/* harmony export */   \"default\": function() { return /* binding */ X; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.554.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst __iconNode = [\n    [\n        \"path\",\n        {\n            d: \"M18 6 6 18\",\n            key: \"1bl5f8\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"m6 6 12 12\",\n            key: \"d8bk6v\"\n        }\n    ]\n];\nconst X = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"x\", __iconNode);\n //# sourceMappingURL=x.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMveC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUVxRDtBQUV0RCxNQUFNQyxhQUFhO0lBQ2pCO1FBQUM7UUFBUTtZQUFFQyxHQUFHO1lBQWNDLEtBQUs7UUFBUztLQUFFO0lBQzVDO1FBQUM7UUFBUTtZQUFFRCxHQUFHO1lBQWNDLEtBQUs7UUFBUztLQUFFO0NBQzdDO0FBQ0QsTUFBTUMsSUFBSUosZ0VBQWdCQSxDQUFDLEtBQUtDO0FBRUksQ0FDcEMsNkJBQTZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMveC5qcz9kZjg4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjU1NC4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgY3JlYXRlTHVjaWRlSWNvbiBmcm9tICcuLi9jcmVhdGVMdWNpZGVJY29uLmpzJztcblxuY29uc3QgX19pY29uTm9kZSA9IFtcbiAgW1wicGF0aFwiLCB7IGQ6IFwiTTE4IDYgNiAxOFwiLCBrZXk6IFwiMWJsNWY4XCIgfV0sXG4gIFtcInBhdGhcIiwgeyBkOiBcIm02IDYgMTIgMTJcIiwga2V5OiBcImQ4Yms2dlwiIH1dXG5dO1xuY29uc3QgWCA9IGNyZWF0ZUx1Y2lkZUljb24oXCJ4XCIsIF9faWNvbk5vZGUpO1xuXG5leHBvcnQgeyBfX2ljb25Ob2RlLCBYIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXguanMubWFwXG4iXSwibmFtZXMiOlsiY3JlYXRlTHVjaWRlSWNvbiIsIl9faWNvbk5vZGUiLCJkIiwia2V5IiwiWCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/x.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/shared/src/utils.js":
/*!****************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/shared/src/utils.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hasA11yProp: function() { return /* binding */ hasA11yProp; },\n/* harmony export */   mergeClasses: function() { return /* binding */ mergeClasses; },\n/* harmony export */   toCamelCase: function() { return /* binding */ toCamelCase; },\n/* harmony export */   toKebabCase: function() { return /* binding */ toKebabCase; },\n/* harmony export */   toPascalCase: function() { return /* binding */ toPascalCase; }\n/* harmony export */ });\n/**\n * @license lucide-react v0.554.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ const toKebabCase = (string)=>string.replace(/([a-z0-9])([A-Z])/g, \"$1-$2\").toLowerCase();\nconst toCamelCase = (string)=>string.replace(/^([A-Z])|[\\s-_]+(\\w)/g, (match, p1, p2)=>p2 ? p2.toUpperCase() : p1.toLowerCase());\nconst toPascalCase = (string)=>{\n    const camelCase = toCamelCase(string);\n    return camelCase.charAt(0).toUpperCase() + camelCase.slice(1);\n};\nconst mergeClasses = function() {\n    for(var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++){\n        classes[_key] = arguments[_key];\n    }\n    return classes.filter((className, index, array)=>{\n        return Boolean(className) && className.trim() !== \"\" && array.indexOf(className) === index;\n    }).join(\" \").trim();\n};\nconst hasA11yProp = (props)=>{\n    for(const prop in props){\n        if (prop.startsWith(\"aria-\") || prop === \"role\" || prop === \"title\") {\n            return true;\n        }\n    }\n};\n //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vc2hhcmVkL3NyYy91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7OztDQUtDLEdBRUQsTUFBTUEsY0FBYyxDQUFDQyxTQUFXQSxPQUFPQyxPQUFPLENBQUMsc0JBQXNCLFNBQVNDLFdBQVc7QUFDekYsTUFBTUMsY0FBYyxDQUFDSCxTQUFXQSxPQUFPQyxPQUFPLENBQzVDLHlCQUNBLENBQUNHLE9BQU9DLElBQUlDLEtBQU9BLEtBQUtBLEdBQUdDLFdBQVcsS0FBS0YsR0FBR0gsV0FBVztBQUUzRCxNQUFNTSxlQUFlLENBQUNSO0lBQ3BCLE1BQU1TLFlBQVlOLFlBQVlIO0lBQzlCLE9BQU9TLFVBQVVDLE1BQU0sQ0FBQyxHQUFHSCxXQUFXLEtBQUtFLFVBQVVFLEtBQUssQ0FBQztBQUM3RDtBQUNBLE1BQU1DLGVBQWU7cUNBQUlDO1FBQUFBOztXQUFZQSxRQUFRQyxNQUFNLENBQUMsQ0FBQ0MsV0FBV0MsT0FBT0M7UUFDckUsT0FBT0MsUUFBUUgsY0FBY0EsVUFBVUksSUFBSSxPQUFPLE1BQU1GLE1BQU1HLE9BQU8sQ0FBQ0wsZUFBZUM7SUFDdkYsR0FBR0ssSUFBSSxDQUFDLEtBQUtGLElBQUk7O0FBQ2pCLE1BQU1HLGNBQWMsQ0FBQ0M7SUFDbkIsSUFBSyxNQUFNQyxRQUFRRCxNQUFPO1FBQ3hCLElBQUlDLEtBQUtDLFVBQVUsQ0FBQyxZQUFZRCxTQUFTLFVBQVVBLFNBQVMsU0FBUztZQUNuRSxPQUFPO1FBQ1Q7SUFDRjtBQUNGO0FBRTZFLENBQzdFLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL3NoYXJlZC9zcmMvdXRpbHMuanM/MGE5MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1yZWFjdCB2MC41NTQuMCAtIElTQ1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIElTQyBsaWNlbnNlLlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuY29uc3QgdG9LZWJhYkNhc2UgPSAoc3RyaW5nKSA9PiBzdHJpbmcucmVwbGFjZSgvKFthLXowLTldKShbQS1aXSkvZywgXCIkMS0kMlwiKS50b0xvd2VyQ2FzZSgpO1xuY29uc3QgdG9DYW1lbENhc2UgPSAoc3RyaW5nKSA9PiBzdHJpbmcucmVwbGFjZShcbiAgL14oW0EtWl0pfFtcXHMtX10rKFxcdykvZyxcbiAgKG1hdGNoLCBwMSwgcDIpID0+IHAyID8gcDIudG9VcHBlckNhc2UoKSA6IHAxLnRvTG93ZXJDYXNlKClcbik7XG5jb25zdCB0b1Bhc2NhbENhc2UgPSAoc3RyaW5nKSA9PiB7XG4gIGNvbnN0IGNhbWVsQ2FzZSA9IHRvQ2FtZWxDYXNlKHN0cmluZyk7XG4gIHJldHVybiBjYW1lbENhc2UuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBjYW1lbENhc2Uuc2xpY2UoMSk7XG59O1xuY29uc3QgbWVyZ2VDbGFzc2VzID0gKC4uLmNsYXNzZXMpID0+IGNsYXNzZXMuZmlsdGVyKChjbGFzc05hbWUsIGluZGV4LCBhcnJheSkgPT4ge1xuICByZXR1cm4gQm9vbGVhbihjbGFzc05hbWUpICYmIGNsYXNzTmFtZS50cmltKCkgIT09IFwiXCIgJiYgYXJyYXkuaW5kZXhPZihjbGFzc05hbWUpID09PSBpbmRleDtcbn0pLmpvaW4oXCIgXCIpLnRyaW0oKTtcbmNvbnN0IGhhc0ExMXlQcm9wID0gKHByb3BzKSA9PiB7XG4gIGZvciAoY29uc3QgcHJvcCBpbiBwcm9wcykge1xuICAgIGlmIChwcm9wLnN0YXJ0c1dpdGgoXCJhcmlhLVwiKSB8fCBwcm9wID09PSBcInJvbGVcIiB8fCBwcm9wID09PSBcInRpdGxlXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IHsgaGFzQTExeVByb3AsIG1lcmdlQ2xhc3NlcywgdG9DYW1lbENhc2UsIHRvS2ViYWJDYXNlLCB0b1Bhc2NhbENhc2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcFxuIl0sIm5hbWVzIjpbInRvS2ViYWJDYXNlIiwic3RyaW5nIiwicmVwbGFjZSIsInRvTG93ZXJDYXNlIiwidG9DYW1lbENhc2UiLCJtYXRjaCIsInAxIiwicDIiLCJ0b1VwcGVyQ2FzZSIsInRvUGFzY2FsQ2FzZSIsImNhbWVsQ2FzZSIsImNoYXJBdCIsInNsaWNlIiwibWVyZ2VDbGFzc2VzIiwiY2xhc3NlcyIsImZpbHRlciIsImNsYXNzTmFtZSIsImluZGV4IiwiYXJyYXkiLCJCb29sZWFuIiwidHJpbSIsImluZGV4T2YiLCJqb2luIiwiaGFzQTExeVByb3AiLCJwcm9wcyIsInByb3AiLCJzdGFydHNXaXRoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/shared/src/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js ***!
  \*********************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("var __dirname = \"/\";\n\n(()=>{\n    \"use strict\";\n    var e = {\n        686: (e, r, t)=>{\n            var n = t(808);\n            var i = Object.create(null);\n            var a = typeof document === \"undefined\";\n            var o = Array.prototype.forEach;\n            function debounce(e, r) {\n                var t = 0;\n                return function() {\n                    var n = this;\n                    var i = arguments;\n                    var a = function functionCall() {\n                        return e.apply(n, i);\n                    };\n                    clearTimeout(t);\n                    t = setTimeout(a, r);\n                };\n            }\n            function noop() {}\n            function getCurrentScriptUrl(e) {\n                var r = i[e];\n                if (!r) {\n                    if (document.currentScript) {\n                        r = document.currentScript.src;\n                    } else {\n                        var t = document.getElementsByTagName(\"script\");\n                        var a = t[t.length - 1];\n                        if (a) {\n                            r = a.src;\n                        }\n                    }\n                    i[e] = r;\n                }\n                return function(e) {\n                    if (!r) {\n                        return null;\n                    }\n                    var t = r.split(/([^\\\\/]+)\\.js$/);\n                    var i = t && t[1];\n                    if (!i) {\n                        return [\n                            r.replace(\".js\", \".css\")\n                        ];\n                    }\n                    if (!e) {\n                        return [\n                            r.replace(\".js\", \".css\")\n                        ];\n                    }\n                    return e.split(\",\").map(function(e) {\n                        var t = new RegExp(\"\".concat(i, \"\\\\.js$\"), \"g\");\n                        return n(r.replace(t, \"\".concat(e.replace(/{fileName}/g, i), \".css\")));\n                    });\n                };\n            }\n            function updateCss(e, r) {\n                if (!r) {\n                    if (!e.href) {\n                        return;\n                    }\n                    r = e.href.split(\"?\")[0];\n                }\n                if (!isUrlRequest(r)) {\n                    return;\n                }\n                if (e.isLoaded === false) {\n                    return;\n                }\n                if (!r || !(r.indexOf(\".css\") > -1)) {\n                    return;\n                }\n                e.visited = true;\n                var t = e.cloneNode();\n                t.isLoaded = false;\n                t.addEventListener(\"load\", function() {\n                    if (t.isLoaded) {\n                        return;\n                    }\n                    t.isLoaded = true;\n                    e.parentNode.removeChild(e);\n                });\n                t.addEventListener(\"error\", function() {\n                    if (t.isLoaded) {\n                        return;\n                    }\n                    t.isLoaded = true;\n                    e.parentNode.removeChild(e);\n                });\n                t.href = \"\".concat(r, \"?\").concat(Date.now());\n                if (e.nextSibling) {\n                    e.parentNode.insertBefore(t, e.nextSibling);\n                } else {\n                    e.parentNode.appendChild(t);\n                }\n            }\n            function getReloadUrl(e, r) {\n                var t;\n                e = n(e, {\n                    stripWWW: false\n                });\n                r.some(function(n) {\n                    if (e.indexOf(r) > -1) {\n                        t = n;\n                    }\n                });\n                return t;\n            }\n            function reloadStyle(e) {\n                if (!e) {\n                    return false;\n                }\n                var r = document.querySelectorAll(\"link\");\n                var t = false;\n                o.call(r, function(r) {\n                    if (!r.href) {\n                        return;\n                    }\n                    var n = getReloadUrl(r.href, e);\n                    if (!isUrlRequest(n)) {\n                        return;\n                    }\n                    if (r.visited === true) {\n                        return;\n                    }\n                    if (n) {\n                        updateCss(r, n);\n                        t = true;\n                    }\n                });\n                return t;\n            }\n            function reloadAll() {\n                var e = document.querySelectorAll(\"link\");\n                o.call(e, function(e) {\n                    if (e.visited === true) {\n                        return;\n                    }\n                    updateCss(e);\n                });\n            }\n            function isUrlRequest(e) {\n                if (!/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.test(e)) {\n                    return false;\n                }\n                return true;\n            }\n            e.exports = function(e, r) {\n                if (a) {\n                    console.log(\"no window.document found, will not HMR CSS\");\n                    return noop;\n                }\n                var t = getCurrentScriptUrl(e);\n                function update() {\n                    var e = t(r.filename);\n                    var n = reloadStyle(e);\n                    if (r.locals) {\n                        console.log(\"[HMR] Detected local css modules. Reload all css\");\n                        reloadAll();\n                        return;\n                    }\n                    if (n) {\n                        console.log(\"[HMR] css reload %s\", e.join(\" \"));\n                    } else {\n                        console.log(\"[HMR] Reload all css\");\n                        reloadAll();\n                    }\n                }\n                return debounce(update, 50);\n            };\n        },\n        808: (e)=>{\n            function normalizeUrl(e) {\n                return e.reduce(function(e, r) {\n                    switch(r){\n                        case \"..\":\n                            e.pop();\n                            break;\n                        case \".\":\n                            break;\n                        default:\n                            e.push(r);\n                    }\n                    return e;\n                }, []).join(\"/\");\n            }\n            e.exports = function(e) {\n                e = e.trim();\n                if (/^data:/i.test(e)) {\n                    return e;\n                }\n                var r = e.indexOf(\"//\") !== -1 ? e.split(\"//\")[0] + \"//\" : \"\";\n                var t = e.replace(new RegExp(r, \"i\"), \"\").split(\"/\");\n                var n = t[0].toLowerCase().replace(/\\.$/, \"\");\n                t[0] = \"\";\n                var i = normalizeUrl(t);\n                return r + n + i;\n            };\n        }\n    };\n    var r = {};\n    function __nccwpck_require__(t) {\n        var n = r[t];\n        if (n !== undefined) {\n            return n.exports;\n        }\n        var i = r[t] = {\n            exports: {}\n        };\n        var a = true;\n        try {\n            e[t](i, i.exports, __nccwpck_require__);\n            a = false;\n        } finally{\n            if (a) delete r[t];\n        }\n        return i.exports;\n    }\n    if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n    var t = __nccwpck_require__(686);\n    module.exports = t;\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzIiwibWFwcGluZ3MiOiI7O0FBQUM7SUFBSztJQUFhLElBQUlBLElBQUU7UUFBQyxLQUFJLENBQUNBLEdBQUVDLEdBQUVDO1lBQUssSUFBSUMsSUFBRUQsRUFBRTtZQUFLLElBQUlFLElBQUVDLE9BQU9DLE1BQU0sQ0FBQztZQUFNLElBQUlDLElBQUUsT0FBT0MsYUFBVztZQUFZLElBQUlDLElBQUVDLE1BQU1DLFNBQVMsQ0FBQ0MsT0FBTztZQUFDLFNBQVNDLFNBQVNiLENBQUMsRUFBQ0MsQ0FBQztnQkFBRSxJQUFJQyxJQUFFO2dCQUFFLE9BQU87b0JBQVcsSUFBSUMsSUFBRSxJQUFJO29CQUFDLElBQUlDLElBQUVVO29CQUFVLElBQUlQLElBQUUsU0FBU1E7d0JBQWUsT0FBT2YsRUFBRWdCLEtBQUssQ0FBQ2IsR0FBRUM7b0JBQUU7b0JBQUVhLGFBQWFmO29CQUFHQSxJQUFFZ0IsV0FBV1gsR0FBRU47Z0JBQUU7WUFBQztZQUFDLFNBQVNrQixRQUFPO1lBQUMsU0FBU0Msb0JBQW9CcEIsQ0FBQztnQkFBRSxJQUFJQyxJQUFFRyxDQUFDLENBQUNKLEVBQUU7Z0JBQUMsSUFBRyxDQUFDQyxHQUFFO29CQUFDLElBQUdPLFNBQVNhLGFBQWEsRUFBQzt3QkFBQ3BCLElBQUVPLFNBQVNhLGFBQWEsQ0FBQ0MsR0FBRztvQkFBQSxPQUFLO3dCQUFDLElBQUlwQixJQUFFTSxTQUFTZSxvQkFBb0IsQ0FBQzt3QkFBVSxJQUFJaEIsSUFBRUwsQ0FBQyxDQUFDQSxFQUFFc0IsTUFBTSxHQUFDLEVBQUU7d0JBQUMsSUFBR2pCLEdBQUU7NEJBQUNOLElBQUVNLEVBQUVlLEdBQUc7d0JBQUE7b0JBQUM7b0JBQUNsQixDQUFDLENBQUNKLEVBQUUsR0FBQ0M7Z0JBQUM7Z0JBQUMsT0FBTyxTQUFT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Q0FBQ0MsRUFBRSxHQUFDO1lBQUNtRCxTQUFRLENBQUM7UUFBQztRQUFFLElBQUk5QyxJQUFFO1FBQUssSUFBRztZQUFDUCxDQUFDLENBQUNFLEVBQUUsQ0FBQ0UsR0FBRUEsRUFBRWlELE9BQU8sRUFBQ2E7WUFBcUIzRCxJQUFFO1FBQUssU0FBUTtZQUFDLElBQUdBLEdBQUUsT0FBT04sQ0FBQyxDQUFDQyxFQUFFO1FBQUE7UUFBQyxPQUFPRSxFQUFFaUQsT0FBTztJQUFBO0lBQUMsSUFBRyxPQUFPYSx3QkFBc0IsYUFBWUEsb0JBQW9CRSxFQUFFLEdBQUNDLFNBQVNBLEdBQUM7SUFBSSxJQUFJbkUsSUFBRWdFLG9CQUFvQjtJQUFLSSxPQUFPakIsT0FBTyxHQUFDbkQ7QUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qcz81ZDQ5Il0sInNvdXJjZXNDb250ZW50IjpbIigoKT0+e1widXNlIHN0cmljdFwiO3ZhciBlPXs2ODY6KGUscix0KT0+e3ZhciBuPXQoODA4KTt2YXIgaT1PYmplY3QuY3JlYXRlKG51bGwpO3ZhciBhPXR5cGVvZiBkb2N1bWVudD09PVwidW5kZWZpbmVkXCI7dmFyIG89QXJyYXkucHJvdG90eXBlLmZvckVhY2g7ZnVuY3Rpb24gZGVib3VuY2UoZSxyKXt2YXIgdD0wO3JldHVybiBmdW5jdGlvbigpe3ZhciBuPXRoaXM7dmFyIGk9YXJndW1lbnRzO3ZhciBhPWZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbCgpe3JldHVybiBlLmFwcGx5KG4saSl9O2NsZWFyVGltZW91dCh0KTt0PXNldFRpbWVvdXQoYSxyKX19ZnVuY3Rpb24gbm9vcCgpe31mdW5jdGlvbiBnZXRDdXJyZW50U2NyaXB0VXJsKGUpe3ZhciByPWlbZV07aWYoIXIpe2lmKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpe3I9ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmN9ZWxzZXt2YXIgdD1kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTt2YXIgYT10W3QubGVuZ3RoLTFdO2lmKGEpe3I9YS5zcmN9fWlbZV09cn1yZXR1cm4gZnVuY3Rpb24oZSl7aWYoIXIpe3JldHVybiBudWxsfXZhciB0PXIuc3BsaXQoLyhbXlxcXFwvXSspXFwuanMkLyk7dmFyIGk9dCYmdFsxXTtpZighaSl7cmV0dXJuW3IucmVwbGFjZShcIi5qc1wiLFwiLmNzc1wiKV19aWYoIWUpe3JldHVybltyLnJlcGxhY2UoXCIuanNcIixcIi5jc3NcIildfXJldHVybiBlLnNwbGl0KFwiLFwiKS5tYXAoKGZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBSZWdFeHAoXCJcIi5jb25jYXQoaSxcIlxcXFwuanMkXCIpLFwiZ1wiKTtyZXR1cm4gbihyLnJlcGxhY2UodCxcIlwiLmNvbmNhdChlLnJlcGxhY2UoL3tmaWxlTmFtZX0vZyxpKSxcIi5jc3NcIikpKX0pKX19ZnVuY3Rpb24gdXBkYXRlQ3NzKGUscil7aWYoIXIpe2lmKCFlLmhyZWYpe3JldHVybn1yPWUuaHJlZi5zcGxpdChcIj9cIilbMF19aWYoIWlzVXJsUmVxdWVzdChyKSl7cmV0dXJufWlmKGUuaXNMb2FkZWQ9PT1mYWxzZSl7cmV0dXJufWlmKCFyfHwhKHIuaW5kZXhPZihcIi5jc3NcIik+LTEpKXtyZXR1cm59ZS52aXNpdGVkPXRydWU7dmFyIHQ9ZS5jbG9uZU5vZGUoKTt0LmlzTG9hZGVkPWZhbHNlO3QuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwoZnVuY3Rpb24oKXtpZih0LmlzTG9hZGVkKXtyZXR1cm59dC5pc0xvYWRlZD10cnVlO2UucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKX0pKTt0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLChmdW5jdGlvbigpe2lmKHQuaXNMb2FkZWQpe3JldHVybn10LmlzTG9hZGVkPXRydWU7ZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpfSkpO3QuaHJlZj1cIlwiLmNvbmNhdChyLFwiP1wiKS5jb25jYXQoRGF0ZS5ub3coKSk7aWYoZS5uZXh0U2libGluZyl7ZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0LGUubmV4dFNpYmxpbmcpfWVsc2V7ZS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHQpfX1mdW5jdGlvbiBnZXRSZWxvYWRVcmwoZSxyKXt2YXIgdDtlPW4oZSx7c3RyaXBXV1c6ZmFsc2V9KTtyLnNvbWUoKGZ1bmN0aW9uKG4pe2lmKGUuaW5kZXhPZihyKT4tMSl7dD1ufX0pKTtyZXR1cm4gdH1mdW5jdGlvbiByZWxvYWRTdHlsZShlKXtpZighZSl7cmV0dXJuIGZhbHNlfXZhciByPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaW5rXCIpO3ZhciB0PWZhbHNlO28uY2FsbChyLChmdW5jdGlvbihyKXtpZighci5ocmVmKXtyZXR1cm59dmFyIG49Z2V0UmVsb2FkVXJsKHIuaHJlZixlKTtpZighaXNVcmxSZXF1ZXN0KG4pKXtyZXR1cm59aWYoci52aXNpdGVkPT09dHJ1ZSl7cmV0dXJufWlmKG4pe3VwZGF0ZUNzcyhyLG4pO3Q9dHJ1ZX19KSk7cmV0dXJuIHR9ZnVuY3Rpb24gcmVsb2FkQWxsKCl7dmFyIGU9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImxpbmtcIik7by5jYWxsKGUsKGZ1bmN0aW9uKGUpe2lmKGUudmlzaXRlZD09PXRydWUpe3JldHVybn11cGRhdGVDc3MoZSl9KSl9ZnVuY3Rpb24gaXNVcmxSZXF1ZXN0KGUpe2lmKCEvXlthLXpBLVpdW2EtekEtWlxcZCtcXC0uXSo6Ly50ZXN0KGUpKXtyZXR1cm4gZmFsc2V9cmV0dXJuIHRydWV9ZS5leHBvcnRzPWZ1bmN0aW9uKGUscil7aWYoYSl7Y29uc29sZS5sb2coXCJubyB3aW5kb3cuZG9jdW1lbnQgZm91bmQsIHdpbGwgbm90IEhNUiBDU1NcIik7cmV0dXJuIG5vb3B9dmFyIHQ9Z2V0Q3VycmVudFNjcmlwdFVybChlKTtmdW5jdGlvbiB1cGRhdGUoKXt2YXIgZT10KHIuZmlsZW5hbWUpO3ZhciBuPXJlbG9hZFN0eWxlKGUpO2lmKHIubG9jYWxzKXtjb25zb2xlLmxvZyhcIltITVJdIERldGVjdGVkIGxvY2FsIGNzcyBtb2R1bGVzLiBSZWxvYWQgYWxsIGNzc1wiKTtyZWxvYWRBbGwoKTtyZXR1cm59aWYobil7Y29uc29sZS5sb2coXCJbSE1SXSBjc3MgcmVsb2FkICVzXCIsZS5qb2luKFwiIFwiKSl9ZWxzZXtjb25zb2xlLmxvZyhcIltITVJdIFJlbG9hZCBhbGwgY3NzXCIpO3JlbG9hZEFsbCgpfX1yZXR1cm4gZGVib3VuY2UodXBkYXRlLDUwKX19LDgwODplPT57ZnVuY3Rpb24gbm9ybWFsaXplVXJsKGUpe3JldHVybiBlLnJlZHVjZSgoZnVuY3Rpb24oZSxyKXtzd2l0Y2gocil7Y2FzZVwiLi5cIjplLnBvcCgpO2JyZWFrO2Nhc2VcIi5cIjpicmVhaztkZWZhdWx0OmUucHVzaChyKX1yZXR1cm4gZX0pLFtdKS5qb2luKFwiL1wiKX1lLmV4cG9ydHM9ZnVuY3Rpb24oZSl7ZT1lLnRyaW0oKTtpZigvXmRhdGE6L2kudGVzdChlKSl7cmV0dXJuIGV9dmFyIHI9ZS5pbmRleE9mKFwiLy9cIikhPT0tMT9lLnNwbGl0KFwiLy9cIilbMF0rXCIvL1wiOlwiXCI7dmFyIHQ9ZS5yZXBsYWNlKG5ldyBSZWdFeHAocixcImlcIiksXCJcIikuc3BsaXQoXCIvXCIpO3ZhciBuPXRbMF0udG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXC4kLyxcIlwiKTt0WzBdPVwiXCI7dmFyIGk9bm9ybWFsaXplVXJsKHQpO3JldHVybiByK24raX19fTt2YXIgcj17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHQpe3ZhciBuPXJbdF07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT1yW3RdPXtleHBvcnRzOnt9fTt2YXIgYT10cnVlO3RyeXtlW3RdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO2E9ZmFsc2V9ZmluYWxseXtpZihhKWRlbGV0ZSByW3RdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciB0PV9fbmNjd3Bja19yZXF1aXJlX18oNjg2KTttb2R1bGUuZXhwb3J0cz10fSkoKTsiXSwibmFtZXMiOlsiZSIsInIiLCJ0IiwibiIsImkiLCJPYmplY3QiLCJjcmVhdGUiLCJhIiwiZG9jdW1lbnQiLCJvIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJmb3JFYWNoIiwiZGVib3VuY2UiLCJhcmd1bWVudHMiLCJmdW5jdGlvbkNhbGwiLCJhcHBseSIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJub29wIiwiZ2V0Q3VycmVudFNjcmlwdFVybCIsImN1cnJlbnRTY3JpcHQiLCJzcmMiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImxlbmd0aCIsInNwbGl0IiwicmVwbGFjZSIsIm1hcCIsIlJlZ0V4cCIsImNvbmNhdCIsInVwZGF0ZUNzcyIsImhyZWYiLCJpc1VybFJlcXVlc3QiLCJpc0xvYWRlZCIsImluZGV4T2YiLCJ2aXNpdGVkIiwiY2xvbmVOb2RlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsIkRhdGUiLCJub3ciLCJuZXh0U2libGluZyIsImluc2VydEJlZm9yZSIsImFwcGVuZENoaWxkIiwiZ2V0UmVsb2FkVXJsIiwic3RyaXBXV1ciLCJzb21lIiwicmVsb2FkU3R5bGUiLCJxdWVyeVNlbGVjdG9yQWxsIiwiY2FsbCIsInJlbG9hZEFsbCIsInRlc3QiLCJleHBvcnRzIiwiY29uc29sZSIsImxvZyIsInVwZGF0ZSIsImZpbGVuYW1lIiwibG9jYWxzIiwiam9pbiIsIm5vcm1hbGl6ZVVybCIsInJlZHVjZSIsInBvcCIsInB1c2giLCJ0cmltIiwidG9Mb3dlckNhc2UiLCJfX25jY3dwY2tfcmVxdWlyZV9fIiwidW5kZWZpbmVkIiwiYWIiLCJfX2Rpcm5hbWUiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var REACT_CACHE_TYPE = Symbol.for(\"react.cache\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === \"function\") {\n                return maybeIterator;\n            }\n            return null;\n        }\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        function error(format) {\n            {\n                {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        // -----------------------------------------------------------------------------\n        var enableScopeAPI = false; // Experimental Create Event Handle API.\n        var enableCacheElement = false;\n        var enableTransitionTracing = false; // No known bugs, but needs performance testing\n        var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n        // stuff. Intended to enable React core members to more easily debug scheduling\n        // issues in DEV builds.\n        var enableDebugTracing = false;\n        var REACT_CLIENT_REFERENCE$2 = Symbol.for(\"react.client.reference\");\n        function isValidElementType(type) {\n            if (typeof type === \"string\" || typeof type === \"function\") {\n                return true;\n            } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n                return true;\n            }\n            if (typeof type === \"object\" && type !== null) {\n                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n                // types supported by any Flight configuration anywhere since\n                // we don't know which Flight build this will end up being used\n                // with.\n                type.$$typeof === REACT_CLIENT_REFERENCE$2 || type.getModuleId !== undefined) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || \"\";\n            return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName(type) {\n            return type.displayName || \"Context\";\n        }\n        var REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\"); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            if (typeof type === \"function\") {\n                if (type.$$typeof === REACT_CLIENT_REFERENCE$1) {\n                    // TODO: Create a convention for naming client references with debug info.\n                    return null;\n                }\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === \"string\") {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return \"Fragment\";\n                case REACT_PORTAL_TYPE:\n                    return \"Portal\";\n                case REACT_PROFILER_TYPE:\n                    return \"Profiler\";\n                case REACT_STRICT_MODE_TYPE:\n                    return \"StrictMode\";\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n                case REACT_CACHE_TYPE:\n                    {\n                        return \"Cache\";\n                    }\n            }\n            if (typeof type === \"object\") {\n                {\n                    if (typeof type.tag === \"number\") {\n                        error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n                    }\n                }\n                switch(type.$$typeof){\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        return getContextName(context) + \".Consumer\";\n                    case REACT_PROVIDER_TYPE:\n                        var provider = type;\n                        return getContextName(provider._context) + \".Provider\";\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName(type, type.render, \"ForwardRef\");\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || \"Memo\";\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                }\n            }\n            return null;\n        }\n        var assign = Object.assign;\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n                }\n            }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || \"\";\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return \"\\n\" + prefix + name;\n            }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap();\n        }\n        /**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */ function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return \"\";\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher;\n            {\n                previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactCurrentDispatcher.current = null;\n                disableLogs();\n            }\n            /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */ var RunInRootFrame = {\n                DetermineComponentFrameRoot: function() {\n                    var control;\n                    try {\n                        // This should throw.\n                        if (construct) {\n                            // Something should be setting the props in the constructor.\n                            var Fake = function() {\n                                throw Error();\n                            }; // $FlowFixMe[prop-missing]\n                            Object.defineProperty(Fake.prototype, \"props\", {\n                                set: function() {\n                                    // We use a throwing setter instead of frozen or non-writable props\n                                    // because that won't throw in a non-strict mode function.\n                                    throw Error();\n                                }\n                            });\n                            if (typeof Reflect === \"object\" && Reflect.construct) {\n                                // We construct a different control for this case to include any extra\n                                // frames added by the construct call.\n                                try {\n                                    Reflect.construct(Fake, []);\n                                } catch (x) {\n                                    control = x;\n                                }\n                                Reflect.construct(fn, [], Fake);\n                            } else {\n                                try {\n                                    Fake.call();\n                                } catch (x) {\n                                    control = x;\n                                } // $FlowFixMe[prop-missing] found when upgrading Flow\n                                fn.call(Fake.prototype);\n                            }\n                        } else {\n                            try {\n                                throw Error();\n                            } catch (x) {\n                                control = x;\n                            } // TODO(luna): This will currently only throw if the function component\n                            // tries to access React/ReactDOM/props. We should probably make this throw\n                            // in simple components too\n                            var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n                            // component, which we don't yet support. Attach a noop catch handler to\n                            // silence the error.\n                            // TODO: Implement component stacks for async client components?\n                            if (maybePromise && typeof maybePromise.catch === \"function\") {\n                                maybePromise.catch(function() {});\n                            }\n                        }\n                    } catch (sample) {\n                        // This is inlined manually because closure doesn't do it for us.\n                        if (sample && control && typeof sample.stack === \"string\") {\n                            return [\n                                sample.stack,\n                                control.stack\n                            ];\n                        }\n                    }\n                    return [\n                        null,\n                        null\n                    ];\n                }\n            }; // $FlowFixMe[prop-missing]\n            RunInRootFrame.DetermineComponentFrameRoot.displayName = \"DetermineComponentFrameRoot\";\n            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, \"name\"); // Before ES6, the `name` property was not configurable.\n            if (namePropDescriptor && namePropDescriptor.configurable) {\n                // V8 utilizes a function's `name` property when generating a stack trace.\n                Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // is set to `false`.\n                // $FlowFixMe[cannot-write]\n                \"name\", {\n                    value: \"DetermineComponentFrameRoot\"\n                });\n            }\n            try {\n                var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n                if (sampleStack && controlStack) {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sampleStack.split(\"\\n\");\n                    var controlLines = controlStack.split(\"\\n\");\n                    var s = 0;\n                    var c = 0;\n                    while(s < sampleLines.length && !sampleLines[s].includes(\"DetermineComponentFrameRoot\")){\n                        s++;\n                    }\n                    while(c < controlLines.length && !controlLines[c].includes(\"DetermineComponentFrameRoot\")){\n                        c++;\n                    } // We couldn't find our intentionally injected common root frame, attempt\n                    // to find another common root frame by search from the bottom of the\n                    // control stack...\n                    if (s === sampleLines.length || c === controlLines.length) {\n                        s = sampleLines.length - 1;\n                        c = controlLines.length - 1;\n                        while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                            // We expect at least one stack frame to be shared.\n                            // Typically this will be the root most one. However, stack frames may be\n                            // cut off due to maximum stack limits. In this case, one maybe cut off\n                            // earlier than the other. We assume that the sample is longer or the same\n                            // and there for cut off earlier. So we should find the root most frame in\n                            // the sample somewhere in the control.\n                            c--;\n                        }\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \"); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                                            _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                                        }\n                                        if (true) {\n                                            if (typeof fn === \"function\") {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        } // Return the line we found.\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactCurrentDispatcher.current = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : \"\";\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n            {\n                if (typeof fn === \"function\") {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        function shouldConstruct(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n            if (type == null) {\n                return \"\";\n            }\n            if (typeof type === \"function\") {\n                {\n                    return describeNativeComponentFrame(type, shouldConstruct(type));\n                }\n            }\n            if (typeof type === \"string\") {\n                return describeBuiltInComponentFrame(type);\n            }\n            switch(type){\n                case REACT_SUSPENSE_TYPE:\n                    return describeBuiltInComponentFrame(\"Suspense\");\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return describeBuiltInComponentFrame(\"SuspenseList\");\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        return describeFunctionComponentFrame(type.render);\n                    case REACT_MEMO_TYPE:\n                        // Memo may contain any component type so we recursively resolve it.\n                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                // Lazy may contain any component type so we recursively resolve it.\n                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                            } catch (x) {}\n                        }\n                }\n            }\n            return \"\";\n        }\n        // $FlowFixMe[method-unbinding]\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement$1(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n                }\n            }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n            {\n                // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n                var has = Function.call.bind(hasOwnProperty);\n                for(var typeSpecName in typeSpecs){\n                    if (has(typeSpecs, typeSpecName)) {\n                        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n                        // fail the render phase where it didn't fail before. So we log it.\n                        // After these have been cleaned up, we'll let them throw.\n                        try {\n                            // This is intentionally an invariant that gets caught. It's the same\n                            // behavior as without this statement except with a better message.\n                            if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                // eslint-disable-next-line react-internal/prod-error-codes\n                                var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                err.name = \"Invariant Violation\";\n                                throw err;\n                            }\n                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                        } catch (ex) {\n                            error$1 = ex;\n                        }\n                        if (error$1 && !(error$1 instanceof Error)) {\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                            // Only monitor this failure once because there tends to be a lot of the\n                            // same error.\n                            loggedTypeFailures[error$1.message] = true;\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"Failed %s type: %s\", location, error$1.message);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                    }\n                }\n            }\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        /*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\"; // $FlowFixMe[incompatible-return]\n                return type;\n            }\n        } // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return \"\" + value;\n        }\n        function checkKeyStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided key is an unsupported type %s.\" + \" This value must be coerced to a string before using it here.\", typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n        var RESERVED_PROPS = {\n            key: true,\n            ref: true,\n            __self: true,\n            __source: true\n        };\n        var specialPropKeyWarningShown;\n        var specialPropRefWarningShown;\n        var didWarnAboutStringRefs;\n        {\n            didWarnAboutStringRefs = {};\n        }\n        function hasValidRef(config) {\n            {\n                if (hasOwnProperty.call(config, \"ref\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.ref !== undefined;\n        }\n        function hasValidKey(config) {\n            {\n                if (hasOwnProperty.call(config, \"key\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.key !== undefined;\n        }\n        function warnIfStringRefCannotBeAutoConverted(config, self) {\n            {\n                if (typeof config.ref === \"string\" && ReactCurrentOwner$1.current && self && ReactCurrentOwner$1.current.stateNode !== self) {\n                    var componentName = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n                    if (!didWarnAboutStringRefs[componentName]) {\n                        error('Component \"%s\" contains the string ref \"%s\". ' + \"Support for string refs will be removed in a future major release. \" + \"This case cannot be automatically converted to an arrow function. \" + \"We ask you to manually fix this case by using useRef() or createRef() instead. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-string-ref\", getComponentNameFromType(ReactCurrentOwner$1.current.type), config.ref);\n                        didWarnAboutStringRefs[componentName] = true;\n                    }\n                }\n            }\n        }\n        function defineKeyPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingKey = function() {\n                    if (!specialPropKeyWarningShown) {\n                        specialPropKeyWarningShown = true;\n                        error(\"%s: `key` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingKey.isReactWarning = true;\n                Object.defineProperty(props, \"key\", {\n                    get: warnAboutAccessingKey,\n                    configurable: true\n                });\n            }\n        }\n        function defineRefPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingRef = function() {\n                    if (!specialPropRefWarningShown) {\n                        specialPropRefWarningShown = true;\n                        error(\"%s: `ref` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingRef.isReactWarning = true;\n                Object.defineProperty(props, \"ref\", {\n                    get: warnAboutAccessingRef,\n                    configurable: true\n                });\n            }\n        }\n        /**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */ function ReactElement(type, key, ref, self, source, owner, props) {\n            var element = {\n                // This tag allows us to uniquely identify this as a React Element\n                $$typeof: REACT_ELEMENT_TYPE,\n                // Built-in properties that belong on the element\n                type: type,\n                key: key,\n                ref: ref,\n                props: props,\n                // Record the component responsible for creating this element.\n                _owner: owner\n            };\n            {\n                // The validation flag is currently mutative. We put it on\n                // an external backing store so that we can freeze the whole object.\n                // This can be replaced with a WeakMap once they are implemented in\n                // commonly used development environments.\n                element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n                // the validation flag non-enumerable (where possible, which should\n                // include every environment we run tests in), so the test framework\n                // ignores it.\n                Object.defineProperty(element._store, \"validated\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: true,\n                    value: false\n                }); // self and source are DEV only properties.\n                Object.defineProperty(element, \"_self\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: self\n                }); // Two elements created in two different places should be considered\n                // equal for testing purposes and therefore we hide it from enumeration.\n                Object.defineProperty(element, \"_source\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: source\n                });\n                if (Object.freeze) {\n                    Object.freeze(element.props);\n                    Object.freeze(element);\n                }\n            }\n            return element;\n        }\n        /**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */ function jsxDEV$1(type, config, maybeKey, source, self) {\n            {\n                var propName; // Reserved names are extracted\n                var props = {};\n                var key = null;\n                var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n                // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n                // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n                // but as an intermediary step, we will use jsxDEV for everything except\n                // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n                // key is explicitly declared to be undefined or not.\n                if (maybeKey !== undefined) {\n                    {\n                        checkKeyStringCoercion(maybeKey);\n                    }\n                    key = \"\" + maybeKey;\n                }\n                if (hasValidKey(config)) {\n                    {\n                        checkKeyStringCoercion(config.key);\n                    }\n                    key = \"\" + config.key;\n                }\n                if (hasValidRef(config)) {\n                    ref = config.ref;\n                    warnIfStringRefCannotBeAutoConverted(config, self);\n                } // Remaining properties are added to a new props object\n                for(propName in config){\n                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                        props[propName] = config[propName];\n                    }\n                } // Resolve default props\n                if (type && type.defaultProps) {\n                    var defaultProps = type.defaultProps;\n                    for(propName in defaultProps){\n                        if (props[propName] === undefined) {\n                            props[propName] = defaultProps[propName];\n                        }\n                    }\n                }\n                if (key || ref) {\n                    var displayName = typeof type === \"function\" ? type.displayName || type.name || \"Unknown\" : type;\n                    if (key) {\n                        defineKeyPropWarningGetter(props, displayName);\n                    }\n                    if (ref) {\n                        defineRefPropWarningGetter(props, displayName);\n                    }\n                }\n                return ReactElement(type, key, ref, self, source, ReactCurrentOwner$1.current, props);\n            }\n        }\n        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\n        function setCurrentlyValidatingElement(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame.setExtraStackFrame(null);\n                }\n            }\n        }\n        var propTypesMisspellWarningShown;\n        {\n            propTypesMisspellWarningShown = false;\n        }\n        /**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */ function isValidElement(object) {\n            {\n                return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n            }\n        }\n        function getDeclarationErrorAddendum() {\n            {\n                if (ReactCurrentOwner.current) {\n                    var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n                    if (name) {\n                        return \"\\n\\nCheck the render method of `\" + name + \"`.\";\n                    }\n                }\n                return \"\";\n            }\n        }\n        function getSourceInfoErrorAddendum(source) {\n            {\n                if (source !== undefined) {\n                    var fileName = source.fileName.replace(/^.*[\\\\\\/]/, \"\");\n                    var lineNumber = source.lineNumber;\n                    return \"\\n\\nCheck your code at \" + fileName + \":\" + lineNumber + \".\";\n                }\n                return \"\";\n            }\n        }\n        /**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */ var ownerHasKeyUseWarning = {};\n        function getCurrentComponentErrorInfo(parentType) {\n            {\n                var info = getDeclarationErrorAddendum();\n                if (!info) {\n                    var parentName = getComponentNameFromType(parentType);\n                    if (parentName) {\n                        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n                    }\n                }\n                return info;\n            }\n        }\n        /**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */ function validateExplicitKey(element, parentType) {\n            {\n                if (!element._store || element._store.validated || element.key != null) {\n                    return;\n                }\n                element._store.validated = true;\n                var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n                if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n                    return;\n                }\n                ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n                // property, it may be the creator of the child that's responsible for\n                // assigning it a key.\n                var childOwner = \"\";\n                if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n                    // Give the component that originally created this child.\n                    childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n                }\n                setCurrentlyValidatingElement(element);\n                error('Each child in a list should have a unique \"key\" prop.' + \"%s%s See https://reactjs.org/link/warning-keys for more information.\", currentComponentErrorInfo, childOwner);\n                setCurrentlyValidatingElement(null);\n            }\n        }\n        /**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */ function validateChildKeys(node, parentType) {\n            {\n                if (typeof node !== \"object\" || !node) {\n                    return;\n                }\n                if (node.$$typeof === REACT_CLIENT_REFERENCE) ;\n                else if (isArray(node)) {\n                    for(var i = 0; i < node.length; i++){\n                        var child = node[i];\n                        if (isValidElement(child)) {\n                            validateExplicitKey(child, parentType);\n                        }\n                    }\n                } else if (isValidElement(node)) {\n                    // This element was passed in a valid location.\n                    if (node._store) {\n                        node._store.validated = true;\n                    }\n                } else {\n                    var iteratorFn = getIteratorFn(node);\n                    if (typeof iteratorFn === \"function\") {\n                        // Entry iterators used to provide implicit keys,\n                        // but now we print a separate warning for them later.\n                        if (iteratorFn !== node.entries) {\n                            var iterator = iteratorFn.call(node);\n                            var step;\n                            while(!(step = iterator.next()).done){\n                                if (isValidElement(step.value)) {\n                                    validateExplicitKey(step.value, parentType);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */ function validatePropTypes(element) {\n            {\n                var type = element.type;\n                if (type === null || type === undefined || typeof type === \"string\") {\n                    return;\n                }\n                if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n                    return;\n                }\n                var propTypes;\n                if (typeof type === \"function\") {\n                    propTypes = type.propTypes;\n                } else if (typeof type === \"object\" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n                // Inner props are checked in the reconciler.\n                type.$$typeof === REACT_MEMO_TYPE)) {\n                    propTypes = type.propTypes;\n                } else {\n                    return;\n                }\n                if (propTypes) {\n                    // Intentionally inside to avoid triggering lazy initializers:\n                    var name = getComponentNameFromType(type);\n                    checkPropTypes(propTypes, element.props, \"prop\", name, element);\n                } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n                    propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n                    var _name = getComponentNameFromType(type);\n                    error(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", _name || \"Unknown\");\n                }\n                if (typeof type.getDefaultProps === \"function\" && !type.getDefaultProps.isReactClassApproved) {\n                    error(\"getDefaultProps is only used on classic React.createClass \" + \"definitions. Use a static property named `defaultProps` instead.\");\n                }\n            }\n        }\n        /**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */ function validateFragmentProps(fragment) {\n            {\n                var keys = Object.keys(fragment.props);\n                for(var i = 0; i < keys.length; i++){\n                    var key = keys[i];\n                    if (key !== \"children\" && key !== \"key\") {\n                        setCurrentlyValidatingElement(fragment);\n                        error(\"Invalid prop `%s` supplied to `React.Fragment`. \" + \"React.Fragment can only have `key` and `children` props.\", key);\n                        setCurrentlyValidatingElement(null);\n                        break;\n                    }\n                }\n                if (fragment.ref !== null) {\n                    setCurrentlyValidatingElement(fragment);\n                    error(\"Invalid attribute `ref` supplied to `React.Fragment`.\");\n                    setCurrentlyValidatingElement(null);\n                }\n            }\n        }\n        var didWarnAboutKeySpread = {};\n        function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n            {\n                var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n                // succeed and there will likely be errors in render.\n                if (!validType) {\n                    var info = \"\";\n                    if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                        info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and named imports.\";\n                    }\n                    var sourceInfo = getSourceInfoErrorAddendum(source);\n                    if (sourceInfo) {\n                        info += sourceInfo;\n                    } else {\n                        info += getDeclarationErrorAddendum();\n                    }\n                    var typeString;\n                    if (type === null) {\n                        typeString = \"null\";\n                    } else if (isArray(type)) {\n                        typeString = \"array\";\n                    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n                        typeString = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\";\n                        info = \" Did you accidentally export a JSX literal instead of a component?\";\n                    } else {\n                        typeString = typeof type;\n                    }\n                    error(\"React.jsx: type is invalid -- expected a string (for \" + \"built-in components) or a class/function (for composite \" + \"components) but got: %s.%s\", typeString, info);\n                }\n                var element = jsxDEV$1(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n                // TODO: Drop this when these are no longer allowed as the type argument.\n                if (element == null) {\n                    return element;\n                } // Skip key warning if the type isn't valid since our key validation logic\n                // doesn't expect a non-string/function type and can throw confusing errors.\n                // We don't want exception behavior to differ between dev and prod.\n                // (Rendering will throw with a helpful message and as soon as the type is\n                // fixed, the key warnings will appear.)\n                if (validType) {\n                    var children = props.children;\n                    if (children !== undefined) {\n                        if (isStaticChildren) {\n                            if (isArray(children)) {\n                                for(var i = 0; i < children.length; i++){\n                                    validateChildKeys(children[i], type);\n                                }\n                                if (Object.freeze) {\n                                    Object.freeze(children);\n                                }\n                            } else {\n                                error(\"React.jsx: Static children should always be an array. \" + \"You are likely explicitly calling React.jsxs or React.jsxDEV. \" + \"Use the Babel transform instead.\");\n                            }\n                        } else {\n                            validateChildKeys(children, type);\n                        }\n                    }\n                }\n                if (hasOwnProperty.call(props, \"key\")) {\n                    var componentName = getComponentNameFromType(type);\n                    var keys = Object.keys(props).filter(function(k) {\n                        return k !== \"key\";\n                    });\n                    var beforeExample = keys.length > 0 ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\" : \"{key: someKey}\";\n                    if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n                        var afterExample = keys.length > 0 ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\";\n                        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + \"  let props = %s;\\n\" + \"  <%s {...props} />\\n\" + \"React keys must be passed directly to JSX without using spread:\\n\" + \"  let props = %s;\\n\" + \"  <%s key={someKey} {...props} />\", beforeExample, componentName, afterExample, componentName);\n                        didWarnAboutKeySpread[componentName + beforeExample] = true;\n                    }\n                }\n                if (type === REACT_FRAGMENT_TYPE) {\n                    validateFragmentProps(element);\n                } else {\n                    validatePropTypes(element);\n                }\n                return element;\n            }\n        } // These two functions exist to still get child warnings in dev\n        var jsxDEV = jsxWithValidation;\n        exports.Fragment = REACT_FRAGMENT_TYPE;\n        exports.jsxDEV = jsxDEV;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVEO0FBRUEsSUFBSUEsSUFBcUMsRUFBRTtJQUN4QztRQUNIO1FBRUEsSUFBSUMsUUFBUUMsbUJBQU9BLENBQUMsc0dBQTBCO1FBRTlDLFlBQVk7UUFDWix3Q0FBd0M7UUFDeEMsa0ZBQWtGO1FBQ2xGLHNEQUFzRDtRQUN0RCxJQUFJQyxxQkFBcUJDLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJQyxvQkFBb0JGLE9BQU9DLEdBQUcsQ0FBQztRQUNuQyxJQUFJRSxzQkFBc0JILE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJRyx5QkFBeUJKLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJSSxzQkFBc0JMLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJSyxzQkFBc0JOLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJTSxxQkFBcUJQLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJTyx5QkFBeUJSLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJUSxzQkFBc0JULE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJUywyQkFBMkJWLE9BQU9DLEdBQUcsQ0FBQztRQUMxQyxJQUFJVSxrQkFBa0JYLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJVyxrQkFBa0JaLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJWSx1QkFBdUJiLE9BQU9DLEdBQUcsQ0FBQztRQUN0QyxJQUFJYSxtQkFBbUJkLE9BQU9DLEdBQUcsQ0FBQztRQUNsQyxJQUFJYyx3QkFBd0JmLE9BQU9nQixRQUFRO1FBQzNDLElBQUlDLHVCQUF1QjtRQUMzQixTQUFTQyxjQUFjQyxhQUFhO1lBQ2xDLElBQUlBLGtCQUFrQixRQUFRLE9BQU9BLGtCQUFrQixVQUFVO2dCQUMv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LE9BQU8sUUFBUTtvQkFDckMsSUFBSXVFLGdCQUFnQnZHLHlCQUF5QmI7b0JBQzdDLElBQUlzTSxPQUFPM0ssT0FBTzJLLElBQUksQ0FBQ3pKLE9BQU9pSyxNQUFNLENBQUMsU0FBVUMsQ0FBQzt3QkFDOUMsT0FBT0EsTUFBTTtvQkFDZjtvQkFDQSxJQUFJQyxnQkFBZ0JWLEtBQUtqTyxNQUFNLEdBQUcsSUFBSSxvQkFBb0JpTyxLQUFLVyxJQUFJLENBQUMsYUFBYSxXQUFXO29CQUU1RixJQUFJLENBQUNWLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxFQUFFO3dCQUN6RCxJQUFJRSxlQUFlWixLQUFLak8sTUFBTSxHQUFHLElBQUksTUFBTWlPLEtBQUtXLElBQUksQ0FBQyxhQUFhLFdBQVc7d0JBRTdFaFAsTUFBTSx1RUFBdUUsd0JBQXdCLDBCQUEwQixzRUFBc0Usd0JBQXdCLHFDQUFxQytPLGVBQWU1RixlQUFlOEYsY0FBYzlGO3dCQUU5U21GLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxHQUFHO29CQUN6RDtnQkFDRjtnQkFFQSxJQUFJaE4sU0FBU25ELHFCQUFxQjtvQkFDaEN1UCxzQkFBc0J6RjtnQkFDeEIsT0FBTztvQkFDTG1GLGtCQUFrQm5GO2dCQUNwQjtnQkFFQSxPQUFPQTtZQUNUO1FBQ0YsRUFBRSwrREFBK0Q7UUFFakUsSUFBSXdHLFNBQVNYO1FBRWJZLGdCQUFnQixHQUFHdlE7UUFDbkJ1USxjQUFjLEdBQUdEO0lBQ2Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanM/ZmU2MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3RcIik7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG52YXIgUkVBQ1RfQ0FDSEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNhY2hlJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG52YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7XG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgLy8gd2l0aC5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSkge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG4vKipcbiAqIExldmVyYWdlcyBuYXRpdmUgYnJvd3Nlci9WTSBzdGFjayBmcmFtZXMgdG8gZ2V0IHByb3BlciBkZXRhaWxzIChlLmcuXG4gKiBmaWxlbmFtZSwgbGluZSArIGNvbCBudW1iZXIpIGZvciBhIHNpbmdsZSBjb21wb25lbnQgaW4gYSBjb21wb25lbnQgc3RhY2suIFdlXG4gKiBkbyB0aGlzIGJ5OlxuICogICAoMSkgdGhyb3dpbmcgYW5kIGNhdGNoaW5nIGFuIGVycm9yIGluIHRoZSBmdW5jdGlvbiAtIHRoaXMgd2lsbCBiZSBvdXJcbiAqICAgICAgIGNvbnRyb2wgZXJyb3IuXG4gKiAgICgyKSBjYWxsaW5nIHRoZSBjb21wb25lbnQgd2hpY2ggd2lsbCBldmVudHVhbGx5IHRocm93IGFuIGVycm9yIHRoYXQgd2UnbGxcbiAqICAgICAgIGNhdGNoIC0gdGhpcyB3aWxsIGJlIG91ciBzYW1wbGUgZXJyb3IuXG4gKiAgICgzKSBkaWZmaW5nIHRoZSBjb250cm9sIGFuZCBzYW1wbGUgZXJyb3Igc3RhY2tzIHRvIGZpbmQgdGhlIHN0YWNrIGZyYW1lXG4gKiAgICAgICB3aGljaCByZXByZXNlbnRzIG91ciBjb21wb25lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kaW5nIGEgY29tbW9uIHN0YWNrIGZyYW1lIGJldHdlZW4gc2FtcGxlIGFuZCBjb250cm9sIGVycm9ycyBjYW4gYmVcbiAgICogdHJpY2t5IGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMgYW5kIGxldmVscyBvZiBzdGFjayB0cmFjZSB0cnVuY2F0aW9uIGZyb21cbiAgICogZGlmZmVyZW50IEpTIFZNcy4gU28gaW5zdGVhZCB3ZSdsbCBhdHRlbXB0IHRvIGNvbnRyb2wgd2hhdCB0aGF0IGNvbW1vblxuICAgKiBmcmFtZSBzaG91bGQgYmUgdGhyb3VnaCB0aGlzIG9iamVjdCBtZXRob2Q6XG4gICAqIEhhdmluZyBib3RoIHRoZSBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGJlIGluIHRoZSBmdW5jdGlvbiB1bmRlciB0aGVcbiAgICogYERlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWVSb290YCBwcm9wZXJ0eSwgKyBzZXR0aW5nIHRoZSBgbmFtZWAgYW5kXG4gICAqIGBkaXNwbGF5TmFtZWAgcHJvcGVydGllcyBvZiB0aGUgZnVuY3Rpb24gZW5zdXJlcyB0aGF0IGEgc3RhY2tcbiAgICogZnJhbWUgZXhpc3RzIHRoYXQgaGFzIHRoZSBtZXRob2QgbmFtZSBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIGluXG4gICAqIGl0IGZvciBib3RoIGNvbnRyb2wgYW5kIHNhbXBsZSBzdGFja3MuXG4gICAqL1xuXG5cbiAgdmFyIFJ1bkluUm9vdEZyYW1lID0ge1xuICAgIERldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbnRyb2w7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgIH0gLy8gVE9ETyhsdW5hKTogVGhpcyB3aWxsIGN1cnJlbnRseSBvbmx5IHRocm93IGlmIHRoZSBmdW5jdGlvbiBjb21wb25lbnRcbiAgICAgICAgICAvLyB0cmllcyB0byBhY2Nlc3MgUmVhY3QvUmVhY3RET00vcHJvcHMuIFdlIHNob3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgdGhyb3dcbiAgICAgICAgICAvLyBpbiBzaW1wbGUgY29tcG9uZW50cyB0b29cblxuXG4gICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IGZuKCk7IC8vIElmIHRoZSBmdW5jdGlvbiBjb21wb25lbnQgcmV0dXJucyBhIHByb21pc2UsIGl0J3MgbGlrZWx5IGFuIGFzeW5jXG4gICAgICAgICAgLy8gY29tcG9uZW50LCB3aGljaCB3ZSBkb24ndCB5ZXQgc3VwcG9ydC4gQXR0YWNoIGEgbm9vcCBjYXRjaCBoYW5kbGVyIHRvXG4gICAgICAgICAgLy8gc2lsZW5jZSB0aGUgZXJyb3IuXG4gICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGNvbXBvbmVudCBzdGFja3MgZm9yIGFzeW5jIGNsaWVudCBjb21wb25lbnRzP1xuXG4gICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSAmJiB0eXBlb2YgbWF5YmVQcm9taXNlLmNhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiBbc2FtcGxlLnN0YWNrLCBjb250cm9sLnN0YWNrXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgIH1cbiAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cbiAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID0gJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCc7XG4gIHZhciBuYW1lUHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgJ25hbWUnKTsgLy8gQmVmb3JlIEVTNiwgdGhlIGBuYW1lYCBwcm9wZXJ0eSB3YXMgbm90IGNvbmZpZ3VyYWJsZS5cblxuICBpZiAobmFtZVByb3BEZXNjcmlwdG9yICYmIG5hbWVQcm9wRGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICAvLyBWOCB1dGlsaXplcyBhIGZ1bmN0aW9uJ3MgYG5hbWVgIHByb3BlcnR5IHdoZW4gZ2VuZXJhdGluZyBhIHN0YWNrIHRyYWNlLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsIC8vIENvbmZpZ3VyYWJsZSBwcm9wZXJ0aWVzIGNhbiBiZSB1cGRhdGVkIGV2ZW4gaWYgaXRzIHdyaXRhYmxlIGRlc2NyaXB0b3JcbiAgICAvLyBpcyBzZXQgdG8gYGZhbHNlYC5cbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cbiAgICAnbmFtZScsIHtcbiAgICAgIHZhbHVlOiAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290J1xuICAgIH0pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgX1J1bkluUm9vdEZyYW1lJERldGVyID0gUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290KCksXG4gICAgICAgIHNhbXBsZVN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzBdLFxuICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG5cbiAgICBpZiAoc2FtcGxlU3RhY2sgJiYgY29udHJvbFN0YWNrKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbFN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gMDtcbiAgICAgIHZhciBjID0gMDtcblxuICAgICAgd2hpbGUgKHMgPCBzYW1wbGVMaW5lcy5sZW5ndGggJiYgIXNhbXBsZUxpbmVzW3NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBzKys7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChjIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJiAhY29udHJvbExpbmVzW2NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBjKys7XG4gICAgICB9IC8vIFdlIGNvdWxkbid0IGZpbmQgb3VyIGludGVudGlvbmFsbHkgaW5qZWN0ZWQgY29tbW9uIHJvb3QgZnJhbWUsIGF0dGVtcHRcbiAgICAgIC8vIHRvIGZpbmQgYW5vdGhlciBjb21tb24gcm9vdCBmcmFtZSBieSBzZWFyY2ggZnJvbSB0aGUgYm90dG9tIG9mIHRoZVxuICAgICAgLy8gY29udHJvbCBzdGFjay4uLlxuXG5cbiAgICAgIGlmIChzID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHwgYyA9PT0gY29udHJvbExpbmVzLmxlbmd0aCkge1xuICAgICAgICBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgICAgYy0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JzsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbn0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblxuXG5mdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3NcbiAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcbiAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cbiAgLy9cbiAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4gIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXG4gIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbiAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXG4gIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG4gIC8vXG4gIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcbiAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuICAvL1xuICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxuICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcbiAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxuICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG4gIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbiAgLy9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUocGFyZW50VHlwZSk7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCAhbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSA7IGVsc2UgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYkMSh0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrICE9PSAna2V5JztcbiAgICAgIH0pO1xuICAgICAgdmFyIGJlZm9yZUV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAne2tleTogc29tZUtleSwgJyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne2tleTogc29tZUtleX0nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0pIHtcbiAgICAgICAgdmFyIGFmdGVyRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7JyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne30nO1xuXG4gICAgICAgIGVycm9yKCdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyB7Li4ucHJvcHN9IC8+XFxuJyArICdSZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLCBiZWZvcmVFeGFtcGxlLCBjb21wb25lbnROYW1lLCBhZnRlckV4YW1wbGUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuXG52YXIganN4REVWID0ganN4V2l0aFZhbGlkYXRpb24gO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJSZWFjdCIsInJlcXVpcmUiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIlJFQUNUX09GRlNDUkVFTl9UWVBFIiwiUkVBQ1RfQ0FDSEVfVFlQRSIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsIml0ZXJhdG9yIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIm1heWJlSXRlcmF0b3IiLCJSZWFjdFNoYXJlZEludGVybmFscyIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwiZXJyb3IiLCJmb3JtYXQiLCJfbGVuMiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkyIiwicHJpbnRXYXJuaW5nIiwibGV2ZWwiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lIiwic3RhY2siLCJnZXRTdGFja0FkZGVuZHVtIiwiY29uY2F0IiwiYXJnc1dpdGhGb3JtYXQiLCJtYXAiLCJpdGVtIiwiU3RyaW5nIiwidW5zaGlmdCIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiYXBwbHkiLCJjYWxsIiwiY29uc29sZSIsImVuYWJsZVNjb3BlQVBJIiwiZW5hYmxlQ2FjaGVFbGVtZW50IiwiZW5hYmxlVHJhbnNpdGlvblRyYWNpbmciLCJlbmFibGVMZWdhY3lIaWRkZW4iLCJlbmFibGVEZWJ1Z1RyYWNpbmciLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJ0eXBlIiwiJCR0eXBlb2YiLCJnZXRNb2R1bGVJZCIsInVuZGVmaW5lZCIsImdldFdyYXBwZWROYW1lIiwib3V0ZXJUeXBlIiwiaW5uZXJUeXBlIiwid3JhcHBlck5hbWUiLCJkaXNwbGF5TmFtZSIsImZ1bmN0aW9uTmFtZSIsIm5hbWUiLCJnZXRDb250ZXh0TmFtZSIsIlJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSIsImdldENvbXBvbmVudE5hbWVGcm9tVHlwZSIsInRhZyIsImNvbnRleHQiLCJwcm92aWRlciIsIl9jb250ZXh0IiwicmVuZGVyIiwib3V0ZXJOYW1lIiwibGF6eUNvbXBvbmVudCIsInBheWxvYWQiLCJfcGF5bG9hZCIsImluaXQiLCJfaW5pdCIsIngiLCJhc3NpZ24iLCJPYmplY3QiLCJkaXNhYmxlZERlcHRoIiwicHJldkxvZyIsInByZXZJbmZvIiwicHJldldhcm4iLCJwcmV2RXJyb3IiLCJwcmV2R3JvdXAiLCJwcmV2R3JvdXBDb2xsYXBzZWQiLCJwcmV2R3JvdXBFbmQiLCJkaXNhYmxlZExvZyIsIl9fcmVhY3REaXNhYmxlZExvZyIsImRpc2FibGVMb2dzIiwibG9nIiwiaW5mbyIsIndhcm4iLCJncm91cCIsImdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBFbmQiLCJwcm9wcyIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ2YWx1ZSIsIndyaXRhYmxlIiwiZGVmaW5lUHJvcGVydGllcyIsInJlZW5hYmxlTG9ncyIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIiLCJwcmVmaXgiLCJkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSIsInNvdXJjZSIsIm93bmVyRm4iLCJFcnJvciIsIm1hdGNoIiwidHJpbSIsInJlZW50cnkiLCJjb21wb25lbnRGcmFtZUNhY2hlIiwiUG9zc2libHlXZWFrTWFwIiwiV2Vha01hcCIsIk1hcCIsImRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUiLCJmbiIsImNvbnN0cnVjdCIsImZyYW1lIiwiZ2V0IiwicHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSIsInByZXBhcmVTdGFja1RyYWNlIiwicHJldmlvdXNEaXNwYXRjaGVyIiwiY3VycmVudCIsIlJ1bkluUm9vdEZyYW1lIiwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290IiwiY29udHJvbCIsIkZha2UiLCJkZWZpbmVQcm9wZXJ0eSIsInNldCIsIlJlZmxlY3QiLCJtYXliZVByb21pc2UiLCJjYXRjaCIsInNhbXBsZSIsIm5hbWVQcm9wRGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9SdW5JblJvb3RGcmFtZSREZXRlciIsInNhbXBsZVN0YWNrIiwiY29udHJvbFN0YWNrIiwic2FtcGxlTGluZXMiLCJzcGxpdCIsImNvbnRyb2xMaW5lcyIsInMiLCJjIiwiaW5jbHVkZXMiLCJfZnJhbWUiLCJyZXBsYWNlIiwic3ludGhldGljRnJhbWUiLCJkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUiLCJzaG91bGRDb25zdHJ1Y3QiLCJDb21wb25lbnQiLCJpc1JlYWN0Q29tcG9uZW50IiwiZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWIiwiaGFzT3duUHJvcGVydHkiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEiLCJzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxIiwiZWxlbWVudCIsIm93bmVyIiwiX293bmVyIiwiX3NvdXJjZSIsInNldEV4dHJhU3RhY2tGcmFtZSIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwidmFsdWVzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiaGFzIiwiYmluZCIsInR5cGVTcGVjTmFtZSIsImVycm9yJDEiLCJlcnIiLCJleCIsIm1lc3NhZ2UiLCJpc0FycmF5SW1wbCIsImlzQXJyYXkiLCJhIiwidHlwZU5hbWUiLCJoYXNUb1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwiY29uc3RydWN0b3IiLCJ3aWxsQ29lcmNpb25UaHJvdyIsInRlc3RTdHJpbmdDb2VyY2lvbiIsImUiLCJjaGVja0tleVN0cmluZ0NvZXJjaW9uIiwiUmVhY3RDdXJyZW50T3duZXIkMSIsIlJlYWN0Q3VycmVudE93bmVyIiwiUkVTRVJWRURfUFJPUFMiLCJrZXkiLCJyZWYiLCJfX3NlbGYiLCJfX3NvdXJjZSIsInNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIiwic3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24iLCJkaWRXYXJuQWJvdXRTdHJpbmdSZWZzIiwiaGFzVmFsaWRSZWYiLCJjb25maWciLCJnZXR0ZXIiLCJpc1JlYWN0V2FybmluZyIsImhhc1ZhbGlkS2V5Iiwid2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkIiwic2VsZiIsInN0YXRlTm9kZSIsImRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nS2V5IiwiZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdSZWYiLCJSZWFjdEVsZW1lbnQiLCJfc3RvcmUiLCJmcmVlemUiLCJqc3hERVYkMSIsIm1heWJlS2V5IiwicHJvcE5hbWUiLCJkZWZhdWx0UHJvcHMiLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biIsImlzVmFsaWRFbGVtZW50Iiwib2JqZWN0IiwiZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtIiwiZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0iLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwicGFyZW50VHlwZSIsInBhcmVudE5hbWUiLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwidmFsaWRhdGVkIiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNoaWxkT3duZXIiLCJ2YWxpZGF0ZUNoaWxkS2V5cyIsIm5vZGUiLCJpIiwiY2hpbGQiLCJpdGVyYXRvckZuIiwiZW50cmllcyIsInN0ZXAiLCJuZXh0IiwiZG9uZSIsInZhbGlkYXRlUHJvcFR5cGVzIiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwiX25hbWUiLCJnZXREZWZhdWx0UHJvcHMiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsInZhbGlkYXRlRnJhZ21lbnRQcm9wcyIsImZyYWdtZW50Iiwia2V5cyIsImRpZFdhcm5BYm91dEtleVNwcmVhZCIsImpzeFdpdGhWYWxpZGF0aW9uIiwiaXNTdGF0aWNDaGlsZHJlbiIsInZhbGlkVHlwZSIsInNvdXJjZUluZm8iLCJ0eXBlU3RyaW5nIiwiY2hpbGRyZW4iLCJmaWx0ZXIiLCJrIiwiYmVmb3JlRXhhbXBsZSIsImpvaW4iLCJhZnRlckV4YW1wbGUiLCJqc3hERVYiLCJleHBvcnRzIiwiRnJhZ21lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsS0FBeUIsRUFBYyxFQUUxQyxNQUFNO0lBQ0xDLDhMQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcz9jYTIwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/globals.css":
/*!*************************!*\
  !*** ./app/globals.css ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"7917142b9f23\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9nbG9iYWxzLmNzcyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2dsb2JhbHMuY3NzP2YyYTEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCI3OTE3MTQyYjlmMjNcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/common/GeminiAssistant.tsx":
/*!***********************************************!*\
  !*** ./components/common/GeminiAssistant.tsx ***!
  \***********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _barrel_optimize_names_Loader2_Mic_MicOff_Send_Sparkles_X_lucide_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! __barrel_optimize__?names=Loader2,Mic,MicOff,Send,Sparkles,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/sparkles.js\");\n/* harmony import */ var _barrel_optimize_names_Loader2_Mic_MicOff_Send_Sparkles_X_lucide_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! __barrel_optimize__?names=Loader2,Mic,MicOff,Send,Sparkles,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/x.js\");\n/* harmony import */ var _barrel_optimize_names_Loader2_Mic_MicOff_Send_Sparkles_X_lucide_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! __barrel_optimize__?names=Loader2,Mic,MicOff,Send,Sparkles,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/loader-circle.js\");\n/* harmony import */ var _barrel_optimize_names_Loader2_Mic_MicOff_Send_Sparkles_X_lucide_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! __barrel_optimize__?names=Loader2,Mic,MicOff,Send,Sparkles,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/send.js\");\n/* harmony import */ var _barrel_optimize_names_Loader2_Mic_MicOff_Send_Sparkles_X_lucide_react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! __barrel_optimize__?names=Loader2,Mic,MicOff,Send,Sparkles,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/mic-off.js\");\n/* harmony import */ var _barrel_optimize_names_Loader2_Mic_MicOff_Send_Sparkles_X_lucide_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! __barrel_optimize__?names=Loader2,Mic,MicOff,Send,Sparkles,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/mic.js\");\n/* harmony import */ var _services_geminiService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../services/geminiService */ \"(app-pages-browser)/./services/geminiService.ts\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nconst GeminiAssistant = (param)=>{\n    let { context } = param;\n    _s();\n    const [isOpen, setIsOpen] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([\n        {\n            id: \"1\",\n            text: context === \"merchant\" ? \"   !      \" : \"  !     \",\n            sender: \"bot\"\n        }\n    ]);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isListening, setIsListening] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const messagesEndRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const recognitionRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [hasSpeechSupport, setHasSpeechSupport] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const scrollToBottom = ()=>{\n        var _messagesEndRef_current;\n        (_messagesEndRef_current = messagesEndRef.current) === null || _messagesEndRef_current === void 0 ? void 0 : _messagesEndRef_current.scrollIntoView({\n            behavior: \"smooth\"\n        });\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        scrollToBottom();\n    }, [\n        messages,\n        isOpen\n    ]);\n    // Initialize Speech Recognition\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (\"webkitSpeechRecognition\" in window || \"SpeechRecognition\" in window) {\n            const SpeechRecognition = window.webkitSpeechRecognition || window.SpeechRecognition;\n            recognitionRef.current = new SpeechRecognition();\n            recognitionRef.current.continuous = false;\n            recognitionRef.current.lang = \"ar-EG\"; // Set to Arabic Egypt\n            recognitionRef.current.interimResults = false;\n            recognitionRef.current.onresult = (event)=>{\n                const transcript = event.results[0][0].transcript;\n                setInput(transcript);\n                setIsListening(false);\n            };\n            recognitionRef.current.onerror = (event)=>{\n                console.error(\"Speech recognition error\", event.error);\n                setIsListening(false);\n            };\n            recognitionRef.current.onend = ()=>{\n                setIsListening(false);\n            };\n            setHasSpeechSupport(true);\n        }\n    }, []);\n    const toggleListening = ()=>{\n        if (!hasSpeechSupport) return;\n        if (isListening) {\n            var _recognitionRef_current;\n            (_recognitionRef_current = recognitionRef.current) === null || _recognitionRef_current === void 0 ? void 0 : _recognitionRef_current.stop();\n        } else {\n            try {\n                var _recognitionRef_current1;\n                (_recognitionRef_current1 = recognitionRef.current) === null || _recognitionRef_current1 === void 0 ? void 0 : _recognitionRef_current1.start();\n                setIsListening(true);\n            } catch (error) {\n                console.error(\"Microphone start failed\", error);\n                setIsListening(false);\n            }\n        }\n    };\n    const handleSend = async ()=>{\n        if (!input.trim()) return;\n        const userMsg = {\n            id: Date.now().toString(),\n            text: input,\n            sender: \"user\"\n        };\n        setMessages((prev)=>[\n                ...prev,\n                userMsg\n            ]);\n        setInput(\"\");\n        setIsLoading(true);\n        try {\n            const responseText = await (0,_services_geminiService__WEBPACK_IMPORTED_MODULE_2__.getGeminiResponse)(input, context);\n            const botMsg = {\n                id: (Date.now() + 1).toString(),\n                text: responseText,\n                sender: \"bot\"\n            };\n            setMessages((prev)=>[\n                    ...prev,\n                    botMsg\n                ]);\n        } catch (error) {\n            console.error(error);\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"fixed bottom-6 left-6 z-50 flex flex-col items-end\",\n        children: [\n            isOpen && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"mb-4 w-80 sm:w-96 bg-white rounded-2xl shadow-2xl border border-gray-200 overflow-hidden flex flex-col transition-all duration-300 animate-in slide-in-from-bottom-10\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"bg-gradient-to-r from-ray-blue to-blue-900 p-4 flex justify-between items-center text-white\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"flex items-center gap-2\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Loader2_Mic_MicOff_Send_Sparkles_X_lucide_react__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                                        className: \"w-5 h-5 text-ray-gold\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\Dream\\\\ray-egypt-8\\\\components\\\\common\\\\GeminiAssistant.tsx\",\n                                        lineNumber: 107,\n                                        columnNumber: 15\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                        className: \"font-bold text-lg\",\n                                        children: \"  \"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\Dream\\\\ray-egypt-8\\\\components\\\\common\\\\GeminiAssistant.tsx\",\n                                        lineNumber: 108,\n                                        columnNumber: 15\n                                    }, undefined)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\Dream\\\\ray-egypt-8\\\\components\\\\common\\\\GeminiAssistant.tsx\",\n                                lineNumber: 106,\n                                columnNumber: 13\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: ()=>setIsOpen(false),\n                                className: \"hover:bg-white/20 p-1 rounded-full transition\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Loader2_Mic_MicOff_Send_Sparkles_X_lucide_react__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                                    className: \"w-5 h-5\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\Dream\\\\ray-egypt-8\\\\components\\\\common\\\\GeminiAssistant.tsx\",\n                                    lineNumber: 111,\n                                    columnNumber: 15\n                                }, undefined)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Dream\\\\ray-egypt-8\\\\components\\\\common\\\\GeminiAssistant.tsx\",\n                                lineNumber: 110,\n                                columnNumber: 13\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\Dream\\\\ray-egypt-8\\\\components\\\\common\\\\GeminiAssistant.tsx\",\n                        lineNumber: 105,\n                        columnNumber: 11\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"h-80 overflow-y-auto p-4 bg-gray-50 flex flex-col gap-3\",\n                        children: [\n                            messages.map((msg)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"p-3 rounded-2xl max-w-[85%] text-sm leading-relaxed \".concat(msg.sender === \"user\" ? \"bg-ray-blue text-white self-start rounded-br-none\" : \"bg-white text-gray-800 border border-gray-200 self-end rounded-bl-none shadow-sm\"),\n                                    children: msg.text\n                                }, msg.id, false, {\n                                    fileName: \"C:\\\\Users\\\\Dream\\\\ray-egypt-8\\\\components\\\\common\\\\GeminiAssistant.tsx\",\n                                    lineNumber: 118,\n                                    columnNumber: 15\n                                }, undefined)),\n                            isLoading && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"self-end bg-white border border-gray-200 p-3 rounded-2xl rounded-bl-none shadow-sm\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Loader2_Mic_MicOff_Send_Sparkles_X_lucide_react__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                                    className: \"w-5 h-5 animate-spin text-ray-blue\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\Dream\\\\ray-egypt-8\\\\components\\\\common\\\\GeminiAssistant.tsx\",\n                                    lineNumber: 131,\n                                    columnNumber: 17\n                                }, undefined)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Dream\\\\ray-egypt-8\\\\components\\\\common\\\\GeminiAssistant.tsx\",\n                                lineNumber: 130,\n                                columnNumber: 15\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                ref: messagesEndRef\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Dream\\\\ray-egypt-8\\\\components\\\\common\\\\GeminiAssistant.tsx\",\n                                lineNumber: 134,\n                                columnNumber: 13\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\Dream\\\\ray-egypt-8\\\\components\\\\common\\\\GeminiAssistant.tsx\",\n                        lineNumber: 116,\n                        columnNumber: 11\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"p-3 bg-white border-t border-gray-100 flex gap-2 items-center\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: handleSend,\n                                disabled: !input.trim() || isLoading,\n                                className: \"p-2 bg-ray-gold text-ray-blue rounded-full hover:bg-yellow-400 transition disabled:opacity-50\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Loader2_Mic_MicOff_Send_Sparkles_X_lucide_react__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n                                    className: \"w-5 h-5 rtl:rotate-180\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\Dream\\\\ray-egypt-8\\\\components\\\\common\\\\GeminiAssistant.tsx\",\n                                    lineNumber: 144,\n                                    columnNumber: 15\n                                }, undefined)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Dream\\\\ray-egypt-8\\\\components\\\\common\\\\GeminiAssistant.tsx\",\n                                lineNumber: 139,\n                                columnNumber: 13\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"flex-1 relative\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                        type: \"text\",\n                                        value: input,\n                                        onChange: (e)=>setInput(e.target.value),\n                                        onKeyDown: (e)=>e.key === \"Enter\" && handleSend(),\n                                        placeholder: isListening ? \" ...\" : \"  ...\",\n                                        className: \"w-full bg-gray-100 rounded-full px-4 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-ray-blue/50 transition-all \".concat(isListening ? \"ring-2 ring-red-400 bg-red-50 placeholder-red-400\" : \"\")\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\Dream\\\\ray-egypt-8\\\\components\\\\common\\\\GeminiAssistant.tsx\",\n                                        lineNumber: 148,\n                                        columnNumber: 17\n                                    }, undefined),\n                                    hasSpeechSupport && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        onClick: toggleListening,\n                                        className: \"absolute left-2 top-1/2 -translate-y-1/2 p-1 rounded-full transition \".concat(isListening ? \"text-red-500 animate-pulse\" : \"text-gray-400 hover:text-ray-blue\"),\n                                        children: isListening ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Loader2_Mic_MicOff_Send_Sparkles_X_lucide_react__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n                                            className: \"w-4 h-4\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\Dream\\\\ray-egypt-8\\\\components\\\\common\\\\GeminiAssistant.tsx\",\n                                            lineNumber: 162,\n                                            columnNumber: 40\n                                        }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Loader2_Mic_MicOff_Send_Sparkles_X_lucide_react__WEBPACK_IMPORTED_MODULE_8__[\"default\"], {\n                                            className: \"w-4 h-4\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\Dream\\\\ray-egypt-8\\\\components\\\\common\\\\GeminiAssistant.tsx\",\n                                            lineNumber: 162,\n                                            columnNumber: 73\n                                        }, undefined)\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\Dream\\\\ray-egypt-8\\\\components\\\\common\\\\GeminiAssistant.tsx\",\n                                        lineNumber: 158,\n                                        columnNumber: 21\n                                    }, undefined)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\Dream\\\\ray-egypt-8\\\\components\\\\common\\\\GeminiAssistant.tsx\",\n                                lineNumber: 147,\n                                columnNumber: 13\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\Dream\\\\ray-egypt-8\\\\components\\\\common\\\\GeminiAssistant.tsx\",\n                        lineNumber: 138,\n                        columnNumber: 11\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\Dream\\\\ray-egypt-8\\\\components\\\\common\\\\GeminiAssistant.tsx\",\n                lineNumber: 103,\n                columnNumber: 9\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                onClick: ()=>setIsOpen(!isOpen),\n                className: \"\".concat(isOpen ? \"scale-0\" : \"scale-100\", \" transition-transform duration-200 bg-gradient-to-r from-ray-blue to-blue-900 text-white p-4 rounded-full shadow-lg hover:shadow-xl hover:-translate-y-1 flex items-center justify-center group\"),\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Loader2_Mic_MicOff_Send_Sparkles_X_lucide_react__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                        className: \"w-7 h-7 text-ray-gold animate-pulse\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Dream\\\\ray-egypt-8\\\\components\\\\common\\\\GeminiAssistant.tsx\",\n                        lineNumber: 174,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"sr-only\",\n                        children: \"Chat with AI\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Dream\\\\ray-egypt-8\\\\components\\\\common\\\\GeminiAssistant.tsx\",\n                        lineNumber: 175,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\Dream\\\\ray-egypt-8\\\\components\\\\common\\\\GeminiAssistant.tsx\",\n                lineNumber: 170,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\Dream\\\\ray-egypt-8\\\\components\\\\common\\\\GeminiAssistant.tsx\",\n        lineNumber: 101,\n        columnNumber: 5\n    }, undefined);\n};\n_s(GeminiAssistant, \"H4vauZyjMFM8ldCyfU46CbRbCdQ=\");\n_c = GeminiAssistant;\n/* harmony default export */ __webpack_exports__[\"default\"] = (GeminiAssistant);\nvar _c;\n$RefreshReg$(_c, \"GeminiAssistant\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvY29tbW9uL0dlbWluaUFzc2lzdGFudC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUcyRDtBQUMyQjtBQUNyQjtBQVlqRSxNQUFNVyxrQkFBbUM7UUFBQyxFQUFFQyxPQUFPLEVBQUU7O0lBQ25ELE1BQU0sQ0FBQ0MsUUFBUUMsVUFBVSxHQUFHYiwrQ0FBUUEsQ0FBQztJQUNyQyxNQUFNLENBQUNjLE9BQU9DLFNBQVMsR0FBR2YsK0NBQVFBLENBQUM7SUFDbkMsTUFBTSxDQUFDZ0IsVUFBVUMsWUFBWSxHQUFHakIsK0NBQVFBLENBQVk7UUFDbEQ7WUFBRWtCLElBQUk7WUFBS0MsTUFBTVIsWUFBWSxhQUFhLDJEQUEyRDtZQUFnRFMsUUFBUTtRQUFNO0tBQ3BLO0lBQ0QsTUFBTSxDQUFDQyxXQUFXQyxhQUFhLEdBQUd0QiwrQ0FBUUEsQ0FBQztJQUMzQyxNQUFNLENBQUN1QixhQUFhQyxlQUFlLEdBQUd4QiwrQ0FBUUEsQ0FBQztJQUMvQyxNQUFNeUIsaUJBQWlCeEIsNkNBQU1BLENBQWlCO0lBQzlDLE1BQU15QixpQkFBaUJ6Qiw2Q0FBTUEsQ0FBTTtJQUNuQyxNQUFNLENBQUMwQixrQkFBa0JDLG9CQUFvQixHQUFHNUIsK0NBQVFBLENBQUM7SUFFekQsTUFBTTZCLGlCQUFpQjtZQUNyQko7U0FBQUEsMEJBQUFBLGVBQWVLLE9BQU8sY0FBdEJMLDhDQUFBQSx3QkFBd0JNLGNBQWMsQ0FBQztZQUFFQyxVQUFVO1FBQVM7SUFDOUQ7SUFFQTlCLGdEQUFTQSxDQUFDO1FBQ1IyQjtJQUNGLEdBQUc7UUFBQ2I7UUFBVUo7S0FBTztJQUVyQixnQ0FBZ0M7SUFDaENWLGdEQUFTQSxDQUFDO1FBQ1IsSUFBSSw2QkFBNkIrQixVQUFVLHVCQUF1QkEsUUFBUTtZQUN0RSxNQUFNQyxvQkFBb0IsT0FBZ0JDLHVCQUF1QixJQUFJLE9BQWdCRCxpQkFBaUI7WUFDdEdSLGVBQWVJLE9BQU8sR0FBRyxJQUFJSTtZ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Ozs7a0NBSVosOERBQUNrQzt3QkFBSUMsV0FBVTs7MENBQ2IsOERBQUNFO2dDQUNDQyxTQUFTYjtnQ0FDVGlCLFVBQVUsQ0FBQ3JELE1BQU1xQyxJQUFJLE1BQU05QjtnQ0FDM0J1QyxXQUFVOzBDQUVWLDRFQUFDeEQsOEdBQUlBO29DQUFDd0QsV0FBVTs7Ozs7Ozs7Ozs7MENBR2xCLDhEQUFDRDtnQ0FBSUMsV0FBVTs7a0RBQ1gsOERBQUM5Qzt3Q0FDRHNELE1BQUs7d0NBQ0xDLE9BQU92RDt3Q0FDUHdELFVBQVUsQ0FBQ0MsSUFBTXhELFNBQVN3RCxFQUFFQyxNQUFNLENBQUNILEtBQUs7d0NBQ3hDSSxXQUFXLENBQUNGLElBQU1BLEVBQUVHLEdBQUcsS0FBSyxXQUFXeEI7d0NBQ3ZDeUIsYUFBYXBELGNBQWMscUJBQXFCO3dDQUNoRHFDLFdBQVcsMkhBQWtNLE9BQXZFckMsY0FBYyxzREFBc0Q7Ozs7OztvQ0FHek1JLGtDQUNHLDhEQUFDbUM7d0NBQ0dDLFNBQVNoQjt3Q0FDVGEsV0FBVyx3RUFBeUosT0FBakZyQyxjQUFjLCtCQUErQjtrREFFL0hBLDRCQUFjLDhEQUFDZiw4R0FBTUE7NENBQUNvRCxXQUFVOzs7OztzRUFBZSw4REFBQ3JELDhHQUFHQTs0Q0FBQ3FELFdBQVU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQVFqRiw4REFBQ0U7Z0JBQ0NDLFNBQVMsSUFBTWxELFVBQVUsQ0FBQ0Q7Z0JBQzFCZ0QsV0FBVyxHQUFvQyxPQUFqQ2hELFNBQVMsWUFBWSxhQUFZOztrQ0FFL0MsOERBQUNQLDhHQUFRQTt3QkFBQ3VELFdBQVU7Ozs7OztrQ0FDcEIsOERBQUNnQjt3QkFBS2hCLFdBQVU7a0NBQVU7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUlsQztHQWpLTWxEO0tBQUFBO0FBbUtOLCtEQUFlQSxlQUFlQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvY29tbW9uL0dlbWluaUFzc2lzdGFudC50c3g/MDU1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcclxuXCJ1c2UgY2xpZW50XCI7XHJcblxyXG5pbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZVJlZiwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBNZXNzYWdlQ2lyY2xlLCBYLCBTZW5kLCBTcGFya2xlcywgTG9hZGVyMiwgTWljLCBNaWNPZmYgfSBmcm9tICdsdWNpZGUtcmVhY3QnO1xyXG5pbXBvcnQgeyBnZXRHZW1pbmlSZXNwb25zZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2dlbWluaVNlcnZpY2UnO1xyXG5cclxuaW50ZXJmYWNlIE1lc3NhZ2Uge1xyXG4gIGlkOiBzdHJpbmc7XHJcbiAgdGV4dDogc3RyaW5nO1xyXG4gIHNlbmRlcjogJ3VzZXInIHwgJ2JvdCc7XHJcbn1cclxuXHJcbmludGVyZmFjZSBQcm9wcyB7XHJcbiAgY29udGV4dDogJ21lcmNoYW50JyB8ICdjdXN0b21lcic7XHJcbn1cclxuXHJcbmNvbnN0IEdlbWluaUFzc2lzdGFudDogUmVhY3QuRkM8UHJvcHM+ID0gKHsgY29udGV4dCB9KSA9PiB7XHJcbiAgY29uc3QgW2lzT3Blbiwgc2V0SXNPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICBjb25zdCBbaW5wdXQsIHNldElucHV0XSA9IHVzZVN0YXRlKCcnKTtcclxuICBjb25zdCBbbWVzc2FnZXMsIHNldE1lc3NhZ2VzXSA9IHVzZVN0YXRlPE1lc3NhZ2VbXT4oW1xyXG4gICAgeyBpZDogJzEnLCB0ZXh0OiBjb250ZXh0ID09PSAnbWVyY2hhbnQnID8gJ9ij2YfZhNin2Ysg2KjZitmDINmK2Kcg2LHZitizISDZhdit2KrYp9isINmF2LPYp9i52K/YqSDZgdmKINil2K/Yp9ix2Kkg2YXYrdmE2YMg2KfZhNmG2YfYp9ix2K/YqdifJyA6ICfZhdmG2YjYsSDZitinINi62KfZhNmKISDYqNiq2K/ZiNixINi52YTZiSDYrdin2KzYqSDZhdi52YrZhtipINin2YTZhtmH2KfYsdiv2KnYnycsIHNlbmRlcjogJ2JvdCcgfVxyXG4gIF0pO1xyXG4gIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgY29uc3QgW2lzTGlzdGVuaW5nLCBzZXRJc0xpc3RlbmluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgY29uc3QgbWVzc2FnZXNFbmRSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xyXG4gIGNvbnN0IHJlY29nbml0aW9uUmVmID0gdXNlUmVmPGFueT4obnVsbCk7XHJcbiAgY29uc3QgW2hhc1NwZWVjaFN1cHBvcnQsIHNldEhhc1NwZWVjaFN1cHBvcnRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICBjb25zdCBzY3JvbGxUb0JvdHRvbSA9ICgpID0+IHtcclxuICAgIG1lc3NhZ2VzRW5kUmVmLmN1cnJlbnQ/LnNjcm9sbEludG9WaWV3KHsgYmVoYXZpb3I6IFwic21vb3RoXCIgfSk7XHJcbiAgfTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIHNjcm9sbFRvQm90dG9tKCk7XHJcbiAgfSwgW21lc3NhZ2VzLCBpc09wZW5dKTtcclxuXHJcbiAgLy8gSW5pdGlhbGl6ZSBTcGVlY2ggUmVjb2duaXRpb25cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKCd3ZWJraXRTcGVlY2hSZWNvZ25pdGlvbicgaW4gd2luZG93IHx8ICdTcGVlY2hSZWNvZ25pdGlvbicgaW4gd2luZG93KSB7XHJcbiAgICAgICAgY29uc3QgU3BlZWNoUmVjb2duaXRpb24gPSAod2luZG93IGFzIGFueSkud2Via2l0U3BlZWNoUmVjb2duaXRpb24gfHwgKHdpbmRvdyBhcyBhbnkpLlNwZWVjaFJlY29nbml0aW9uO1xyXG4gICAgICAgIHJlY29nbml0aW9uUmVmLmN1cnJlbnQgPSBuZXcgU3BlZWNoUmVjb2duaXRpb24oKTtcclxuICAgICAgICByZWNvZ25pdGlvblJlZi5jdXJyZW50LmNvbnRpbnVvdXMgPSBmYWxzZTtcclxuICAgICAgICByZWNvZ25pdGlvblJlZi5jdXJyZW50LmxhbmcgPSAnYXItRUcnOyAvLyBTZXQgdG8gQXJhYmljIEVneXB0XHJcbiAgICAgICAgcmVjb2duaXRpb25SZWYuY3VycmVudC5pbnRlcmltUmVzdWx0cyA9IGZhbHNlO1xyXG5cclxuICAgICAgICByZWNvZ25pdGlvblJlZi5jdXJyZW50Lm9ucmVzdWx0ID0gKGV2ZW50OiBhbnkpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgdHJhbnNjcmlwdCA9IGV2ZW50LnJlc3VsdHNbMF1bMF0udHJhbnNjcmlwdDtcclxuICAgICAgICAgICAgc2V0SW5wdXQodHJhbnNjcmlwdCk7XHJcbiAgICAgICAgICAgIHNldElzTGlzdGVuaW5nKGZhbHNlKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZWNvZ25pdGlvblJlZi5jdXJyZW50Lm9uZXJyb3IgPSAoZXZlbnQ6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdTcGVlY2ggcmVjb2duaXRpb24gZXJyb3InLCBldmVudC5lcnJvcik7XHJcbiAgICAgICAgICAgIHNldElzTGlzdGVuaW5nKGZhbHNlKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZWNvZ25pdGlvblJlZi5jdXJyZW50Lm9uZW5kID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBzZXRJc0xpc3RlbmluZyhmYWxzZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBzZXRIYXNTcGVlY2hTdXBwb3J0KHRydWUpO1xyXG4gICAgfVxyXG4gIH0sIFtdKTtcclxuXHJcbiAgY29uc3QgdG9nZ2xlTGlzdGVuaW5nID0gKCkgPT4ge1xyXG4gICAgaWYgKCFoYXNTcGVlY2hTdXBwb3J0KSByZXR1cm47XHJcbiAgICBcclxuICAgIGlmIChpc0xpc3RlbmluZykge1xyXG4gICAgICAgIHJlY29nbml0aW9uUmVmLmN1cnJlbnQ/LnN0b3AoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmVjb2duaXRpb25SZWYuY3VycmVudD8uc3RhcnQoKTtcclxuICAgICAgICAgICAgc2V0SXNMaXN0ZW5pbmcodHJ1ZSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIk1pY3JvcGhvbmUgc3RhcnQgZmFpbGVkXCIsIGVycm9yKTtcclxuICAgICAgICAgICAgc2V0SXNMaXN0ZW5pbmcoZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCBoYW5kbGVTZW5kID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgaWYgKCFpbnB1dC50cmltKCkpIHJldHVybjtcclxuXHJcbiAgICBjb25zdCB1c2VyTXNnOiBNZXNzYWdlID0geyBpZDogRGF0ZS5ub3coKS50b1N0cmluZygpLCB0ZXh0OiBpbnB1dCwgc2VuZGVyOiAndXNlcicgfTtcclxuICAgIHNldE1lc3NhZ2VzKHByZXYgPT4gWy4uLnByZXYsIHVzZXJNc2ddKTtcclxuICAgIHNldElucHV0KCcnKTtcclxuICAgIHNldElzTG9hZGluZyh0cnVlKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZVRleHQgPSBhd2FpdCBnZXRHZW1pbmlSZXNwb25zZShpbnB1dCwgY29udGV4dCk7XHJcbiAgICAgIGNvbnN0IGJvdE1zZzogTWVzc2FnZSA9IHsgaWQ6IChEYXRlLm5vdygpICsgMSkudG9TdHJpbmcoKSwgdGV4dDogcmVzcG9uc2VUZXh0LCBzZW5kZXI6ICdib3QnIH07XHJcbiAgICAgIHNldE1lc3NhZ2VzKHByZXYgPT4gWy4uLnByZXYsIGJvdE1zZ10pO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImZpeGVkIGJvdHRvbS02IGxlZnQtNiB6LTUwIGZsZXggZmxleC1jb2wgaXRlbXMtZW5kXCI+XHJcbiAgICAgIHtpc09wZW4gJiYgKFxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibWItNCB3LTgwIHNtOnctOTYgYmctd2hpdGUgcm91bmRlZC0yeGwgc2hhZG93LTJ4bCBib3JkZXIgYm9yZGVyLWdyYXktMjAwIG92ZXJmbG93LWhpZGRlbiBmbGV4IGZsZXgtY29sIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTMwMCBhbmltYXRlLWluIHNsaWRlLWluLWZyb20tYm90dG9tLTEwXCI+XHJcbiAgICAgICAgICB7LyogSGVhZGVyICovfVxyXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJiZy1ncmFkaWVudC10by1yIGZyb20tcmF5LWJsdWUgdG8tYmx1ZS05MDAgcC00IGZsZXgganVzdGlmeS1iZXR3ZWVuIGl0ZW1zLWNlbnRlciB0ZXh0LXdoaXRlXCI+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTJcIj5cclxuICAgICAgICAgICAgICA8U3BhcmtsZXMgY2xhc3NOYW1lPVwidy01IGgtNSB0ZXh0LXJheS1nb2xkXCIgLz5cclxuICAgICAgICAgICAgICA8aDMgY2xhc3NOYW1lPVwiZm9udC1ib2xkIHRleHQtbGdcIj7Zhdiz2KfYudivINix2KfZiiDYp9mE2LDZg9mKPC9oMz5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxidXR0b24gb25DbGljaz17KCkgPT4gc2V0SXNPcGVuKGZhbHNlKX0gY2xhc3NOYW1lPVwiaG92ZXI6Ymctd2hpdGUvMjAgcC0xIHJvdW5kZWQtZnVsbCB0cmFuc2l0aW9uXCI+XHJcbiAgICAgICAgICAgICAgPFggY2xhc3NOYW1lPVwidy01IGgtNVwiIC8+XHJcbiAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgey8qIE1lc3NhZ2VzICovfVxyXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJoLTgwIG92ZXJmbG93LXktYXV0byBwLTQgYmctZ3JheS01MCBmbGV4IGZsZXgtY29sIGdhcC0zXCI+XHJcbiAgICAgICAgICAgIHttZXNzYWdlcy5tYXAoKG1zZykgPT4gKFxyXG4gICAgICAgICAgICAgIDxkaXZcclxuICAgICAgICAgICAgICAgIGtleT17bXNnLmlkfVxyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgcC0zIHJvdW5kZWQtMnhsIG1heC13LVs4NSVdIHRleHQtc20gbGVhZGluZy1yZWxheGVkICR7XHJcbiAgICAgICAgICAgICAgICAgIG1zZy5zZW5kZXIgPT09ICd1c2VyJ1xyXG4gICAgICAgICAgICAgICAgICAgID8gJ2JnLXJheS1ibHVlIHRleHQtd2hpdGUgc2VsZi1zdGFydCByb3VuZGVkLWJyLW5vbmUnXHJcbiAgICAgICAgICAgICAgICAgICAgOiAnYmctd2hpdGUgdGV4dC1ncmF5LTgwMCBib3JkZXIgYm9yZGVyLWdyYXktMjAwIHNlbGYtZW5kIHJvdW5kZWQtYmwtbm9uZSBzaGFkb3ctc20nXHJcbiAgICAgICAgICAgICAgICB9YH1cclxuICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICB7bXNnLnRleHR9XHJcbiAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICkpfVxyXG4gICAgICAgICAgICB7aXNMb2FkaW5nICYmIChcclxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNlbGYtZW5kIGJnLXdoaXRlIGJvcmRlciBib3JkZXItZ3JheS0yMDAgcC0zIHJvdW5kZWQtMnhsIHJvdW5kZWQtYmwtbm9uZSBzaGFkb3ctc21cIj5cclxuICAgICAgICAgICAgICAgIDxMb2FkZXIyIGNsYXNzTmFtZT1cInctNSBoLTUgYW5pbWF0ZS1zcGluIHRleHQtcmF5LWJsdWVcIiAvPlxyXG4gICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICApfVxyXG4gICAgICAgICAgICA8ZGl2IHJlZj17bWVzc2FnZXNFbmRSZWZ9IC8+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICB7LyogSW5wdXQgKi99XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInAtMyBiZy13aGl0ZSBib3JkZXItdCBib3JkZXItZ3JheS0xMDAgZmxleCBnYXAtMiBpdGVtcy1jZW50ZXJcIj5cclxuICAgICAgICAgICAgPGJ1dHRvbiBcclxuICAgICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVTZW5kfSBcclxuICAgICAgICAgICAgICBkaXNhYmxlZD17IWlucHV0LnRyaW0oKSB8fCBpc0xvYWRpbmd9XHJcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwicC0yIGJnLXJheS1nb2xkIHRleHQtcmF5LWJsdWUgcm91bmRlZC1mdWxsIGhvdmVyOmJnLXllbGxvdy00MDAgdHJhbnNpdGlvbiBkaXNhYmxlZDpvcGFjaXR5LTUwXCJcclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgIDxTZW5kIGNsYXNzTmFtZT1cInctNSBoLTUgcnRsOnJvdGF0ZS0xODBcIiAvPlxyXG4gICAgICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleC0xIHJlbGF0aXZlXCI+XHJcbiAgICAgICAgICAgICAgICA8aW5wdXRcclxuICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcclxuICAgICAgICAgICAgICAgIHZhbHVlPXtpbnB1dH1cclxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4gc2V0SW5wdXQoZS50YXJnZXQudmFsdWUpfVxyXG4gICAgICAgICAgICAgICAgb25LZXlEb3duPXsoZSkgPT4gZS5rZXkgPT09ICdFbnRlcicgJiYgaGFuZGxlU2VuZCgpfVxyXG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9e2lzTGlzdGVuaW5nID8gXCLYrNin2LHZiiDYp9mE2KfYs9iq2YXYp9i5Li4uXCIgOiBcItin2YPYqtioINix2LPYp9mE2KrZgyDZh9mG2KcuLi5cIn1cclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YHctZnVsbCBiZy1ncmF5LTEwMCByb3VuZGVkLWZ1bGwgcHgtNCBweS0yIHRleHQtc20gZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMiBmb2N1czpyaW5nLXJheS1ibHVlLzUwIHRyYW5zaXRpb24tYWxsICR7aXNMaXN0ZW5pbmcgPyAncmluZy0yIHJpbmctcmVkLTQwMCBiZy1yZWQtNTAgcGxhY2Vob2xkZXItcmVkLTQwMCcgOiAnJ31gfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIHsvKiBNaWMgQnV0dG9uIGluc2lkZSBpbnB1dCAqL31cclxuICAgICAgICAgICAgICAgIHtoYXNTcGVlY2hTdXBwb3J0ICYmIChcclxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXt0b2dnbGVMaXN0ZW5pbmd9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YGFic29sdXRlIGxlZnQtMiB0b3AtMS8yIC10cmFuc2xhdGUteS0xLzIgcC0xIHJvdW5kZWQtZnVsbCB0cmFuc2l0aW9uICR7aXNMaXN0ZW5pbmcgPyAndGV4dC1yZWQtNTAwIGFuaW1hdGUtcHVsc2UnIDogJ3RleHQtZ3JheS00MDAgaG92ZXI6dGV4dC1yYXktYmx1ZSd9YH1cclxuICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtpc0xpc3RlbmluZyA/IDxNaWNPZmYgY2xhc3NOYW1lPVwidy00IGgtNFwiIC8+IDogPE1pYyBjbGFzc05hbWU9XCJ3LTQgaC00XCIgLz59XHJcbiAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICApfVxyXG5cclxuICAgICAgPGJ1dHRvblxyXG4gICAgICAgIG9uQ2xpY2s9eygpID0+IHNldElzT3BlbighaXNPcGVuKX1cclxuICAgICAgICBjbGFzc05hbWU9e2Ake2lzT3BlbiA/ICdzY2FsZS0wJyA6ICdzY2FsZS0xMDAnfSB0cmFuc2l0aW9uLXRyYW5zZm9ybSBkdXJhdGlvbi0yMDAgYmctZ3JhZGllbnQtdG8tciBmcm9tLXJheS1ibHVlIHRvLWJsdWUtOTAwIHRleHQtd2hpdGUgcC00IHJvdW5kZWQtZnVsbCBzaGFkb3ctbGcgaG92ZXI6c2hhZG93LXhsIGhvdmVyOi10cmFuc2xhdGUteS0xIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIGdyb3VwYH1cclxuICAgICAgPlxyXG4gICAgICAgIDxTcGFya2xlcyBjbGFzc05hbWU9XCJ3LTcgaC03IHRleHQtcmF5LWdvbGQgYW5pbWF0ZS1wdWxzZVwiIC8+XHJcbiAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwic3Itb25seVwiPkNoYXQgd2l0aCBBSTwvc3Bhbj5cclxuICAgICAgPC9idXR0b24+XHJcbiAgICA8L2Rpdj5cclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgR2VtaW5pQXNzaXN0YW50O1xyXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsInVzZVJlZiIsInVzZUVmZmVjdCIsIlgiLCJTZW5kIiwiU3BhcmtsZXMiLCJMb2FkZXIyIiwiTWljIiwiTWljT2ZmIiwiZ2V0R2VtaW5pUmVzcG9uc2UiLCJHZW1pbmlBc3Npc3RhbnQiLCJjb250ZXh0IiwiaXNPcGVuIiwic2V0SXNPcGVuIiwiaW5wdXQiLCJzZXRJbnB1dCIsIm1lc3NhZ2VzIiwic2V0TWVzc2FnZXMiLCJpZCIsInRleHQiLCJzZW5kZXIiLCJpc0xvYWRpbmciLCJzZXRJc0xvYWRpbmciLCJpc0xpc3RlbmluZyIsInNldElzTGlzdGVuaW5nIiwibWVzc2FnZXNFbmRSZWYiLCJyZWNvZ25pdGlvblJlZiIsImhhc1NwZWVjaFN1cHBvcnQiLCJzZXRIYXNTcGVlY2hTdXBwb3J0Iiwic2Nyb2xsVG9Cb3R0b20iLCJjdXJyZW50Iiwic2Nyb2xsSW50b1ZpZXciLCJiZWhhdmlvciIsIndpbmRvdyIsIlNwZWVjaFJlY29nbml0aW9uIiwid2Via2l0U3BlZWNoUmVjb2duaXRpb24iLCJjb250aW51b3VzIiwibGFuZyIsImludGVyaW1SZXN1bHRzIiwib25yZXN1bHQiLCJldmVudCIsInRyYW5zY3JpcHQiLCJyZXN1bHRzIiwib25lcnJvciIsImNvbnNvbGUiLCJlcnJvciIsIm9uZW5kIiwidG9nZ2xlTGlzdGVuaW5nIiwic3RvcCIsInN0YXJ0IiwiaGFuZGxlU2VuZCIsInRyaW0iLCJ1c2VyTXNnIiwiRGF0ZSIsIm5vdyIsInRvU3RyaW5nIiwicHJldiIsInJlc3BvbnNlVGV4dCIsImJvdE1zZyIsImRpdiIsImNsYXNzTmFtZSIsImgzIiwiYnV0dG9uIiwib25DbGljayIsIm1hcCIsIm1zZyIsInJlZiIsImRpc2FibGVkIiwidHlwZSIsInZhbHVlIiwib25DaGFuZ2UiLCJlIiwidGFyZ2V0Iiwib25LZXlEb3duIiwia2V5IiwicGxhY2Vob2xkZXIiLCJzcGFuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/common/GeminiAssistant.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/common/ThemeContext.tsx":
/*!********************************************!*\
  !*** ./components/common/ThemeContext.tsx ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ThemeProvider: function() { return /* binding */ ThemeProvider; },\n/* harmony export */   useTheme: function() { return /* binding */ useTheme; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ ThemeProvider,useTheme auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\nconst ThemeContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nconst ThemeProvider = (param)=>{\n    let { children } = param;\n    _s();\n    const [isDarkMode, setIsDarkMode] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [mounted, setMounted] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        setMounted(true);\n        // Check local storage or system preference on mount\n        const savedTheme = localStorage.getItem(\"ray_theme\");\n        const systemPrefersDark = window.matchMedia(\"(prefers-color-scheme: dark)\").matches;\n        if (savedTheme === \"dark\" || !savedTheme && systemPrefersDark) {\n            setIsDarkMode(true);\n            document.documentElement.classList.add(\"dark\");\n        } else {\n            setIsDarkMode(false);\n            document.documentElement.classList.remove(\"dark\");\n        }\n    }, []);\n    const toggleTheme = ()=>{\n        setIsDarkMode((prev)=>{\n            const newMode = !prev;\n            if (newMode) {\n                document.documentElement.classList.add(\"dark\");\n                localStorage.setItem(\"ray_theme\", \"dark\");\n            } else {\n                document.documentElement.classList.remove(\"dark\");\n                localStorage.setItem(\"ray_theme\", \"light\");\n            }\n            return newMode;\n        });\n    };\n    // Prevent hydration mismatch by waiting for mount to render specific theme-dependent UI if needed,\n    // but here we provide the context immediately so the app tree structure is stable.\n    // The 'isDarkMode' state will be accurate after the first effect.\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ThemeContext.Provider, {\n        value: {\n            isDarkMode,\n            toggleTheme\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\Dream\\\\ray-egypt-8\\\\components\\\\common\\\\ThemeContext.tsx\",\n        lineNumber: 51,\n        columnNumber: 5\n    }, undefined);\n};\n_s(ThemeProvider, \"q+x0zdt/XGteXtZ2heTYS/042UQ=\");\n_c = ThemeProvider;\nconst useTheme = ()=>{\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ThemeContext);\n    if (!context) {\n        throw new Error(\"useTheme must be used within a ThemeProvider\");\n    }\n    return context;\n};\n_s1(useTheme, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"ThemeProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvY29tbW9uL1RoZW1lQ29udGV4dC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUc4RTtBQU85RSxNQUFNSyw2QkFBZUosb0RBQWFBLENBQStCSztBQUUxRCxNQUFNQyxnQkFBeUQ7UUFBQyxFQUFFQyxRQUFRLEVBQUU7O0lBQ2pGLE1BQU0sQ0FBQ0MsWUFBWUMsY0FBYyxHQUFHTiwrQ0FBUUEsQ0FBQztJQUM3QyxNQUFNLENBQUNPLFNBQVNDLFdBQVcsR0FBR1IsK0NBQVFBLENBQUM7SUFFdkNELGdEQUFTQSxDQUFDO1FBQ1JTLFdBQVc7UUFDWCxvREFBb0Q7UUFDcEQsTUFBTUMsYUFBYUMsYUFBYUMsT0FBTyxDQUFDO1FBQ3hDLE1BQU1DLG9CQUFvQkMsT0FBT0MsVUFBVSxDQUFDLGdDQUFnQ0MsT0FBTztRQUVuRixJQUFJTixlQUFlLFVBQVcsQ0FBQ0EsY0FBY0csbUJBQW9CO1lBQy9ETixjQUFjO1lBQ2RVLFNBQVNDLGVBQWUsQ0FBQ0MsU0FBUyxDQUFDQyxHQUFHLENBQUM7UUFDekMsT0FBTztZQUNMYixjQUFjO1lBQ2RVLFNBQVNDLGVBQWUsQ0FBQ0MsU0FBUyxDQUFDRSxNQUFNLENBQUM7UUFDNUM7SUFDRixHQUFHLEVBQUU7SUFFTCxNQUFNQyxjQUFjO1FBQ2xCZixjQUFjLENBQUNnQjtZQUNiLE1BQU1DLFVBQVUsQ0FBQ0Q7WUFDakIsSUFBSUMsU0FBUztnQkFDWFAsU0FBU0MsZUFBZSxDQUFDQyxTQUFTLENBQUNDLEdBQUcsQ0FBQztnQkFDdkNULGFBQWFjLE9BQU8sQ0FBQyxhQUFhO1lBQ3BDLE9BQU87Z0JBQ0xSLFNBQVNDLGVBQWUsQ0FBQ0MsU0FBUyxDQUFDRSxNQUFNLENBQUM7Z0JBQzFDVixhQUFhYyxPQUFPLENBQUMsYUFBYTtZQUNwQztZQUNBLE9BQU9EO1FBQ1Q7SUFDRjtJQUVBLG1HQUFtRztJQUNuRyxtRkFBbUY7SUFDbkYsa0VBQWtFO0lBRWxFLHFCQUNFLDhEQUFDdEIsYUFBYXdCLFFBQVE7UUFBQ0MsT0FBTztZQUFFckI7WUFBWWdCO1FBQVk7a0JBSXJEakI7Ozs7OztBQUdQLEVBQUU7R0E3Q1dEO0tBQUFBO0FBK0NOLE1BQU13QixXQUFXOztJQUN0QixNQUFNQyxVQUFVOUIsaURBQVVBLENBQUNHO0lBQzNCLElBQUksQ0FBQzJCLFNBQVM7UUFDWixNQUFNLElBQUlDLE1BQU07SUFDbEI7SUFDQSxPQUFPRDtBQUNULEVBQUU7SUFOV0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9jb21tb24vVGhlbWVDb250ZXh0LnRzeD8zMmI5Il0sInNvdXJjZXNDb250ZW50IjpbIlxyXG5cInVzZSBjbGllbnRcIjtcclxuXHJcbmltcG9ydCBSZWFjdCwgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xyXG5cclxuaW50ZXJmYWNlIFRoZW1lQ29udGV4dFR5cGUge1xyXG4gIGlzRGFya01vZGU6IGJvb2xlYW47XHJcbiAgdG9nZ2xlVGhlbWU6ICgpID0+IHZvaWQ7XHJcbn1cclxuXHJcbmNvbnN0IFRoZW1lQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VGhlbWVDb250ZXh0VHlwZSB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcclxuXHJcbmV4cG9ydCBjb25zdCBUaGVtZVByb3ZpZGVyOiBSZWFjdC5GQzx7IGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGUgfT4gPSAoeyBjaGlsZHJlbiB9KSA9PiB7XHJcbiAgY29uc3QgW2lzRGFya01vZGUsIHNldElzRGFya01vZGVdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIGNvbnN0IFttb3VudGVkLCBzZXRNb3VudGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIHNldE1vdW50ZWQodHJ1ZSk7XHJcbiAgICAvLyBDaGVjayBsb2NhbCBzdG9yYWdlIG9yIHN5c3RlbSBwcmVmZXJlbmNlIG9uIG1vdW50XHJcbiAgICBjb25zdCBzYXZlZFRoZW1lID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3JheV90aGVtZScpO1xyXG4gICAgY29uc3Qgc3lzdGVtUHJlZmVyc0RhcmsgPSB3aW5kb3cubWF0Y2hNZWRpYSgnKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKScpLm1hdGNoZXM7XHJcblxyXG4gICAgaWYgKHNhdmVkVGhlbWUgPT09ICdkYXJrJyB8fCAoIXNhdmVkVGhlbWUgJiYgc3lzdGVtUHJlZmVyc0RhcmspKSB7XHJcbiAgICAgIHNldElzRGFya01vZGUodHJ1ZSk7XHJcbiAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdkYXJrJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzZXRJc0RhcmtNb2RlKGZhbHNlKTtcclxuICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2RhcmsnKTtcclxuICAgIH1cclxuICB9LCBbXSk7XHJcblxyXG4gIGNvbnN0IHRvZ2dsZVRoZW1lID0gKCkgPT4ge1xyXG4gICAgc2V0SXNEYXJrTW9kZSgocHJldikgPT4ge1xyXG4gICAgICBjb25zdCBuZXdNb2RlID0gIXByZXY7XHJcbiAgICAgIGlmIChuZXdNb2RlKSB7XHJcbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2RhcmsnKTtcclxuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgncmF5X3RoZW1lJywgJ2RhcmsnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnZGFyaycpO1xyXG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdyYXlfdGhlbWUnLCAnbGlnaHQnKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbmV3TW9kZTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8vIFByZXZlbnQgaHlkcmF0aW9uIG1pc21hdGNoIGJ5IHdhaXRpbmcgZm9yIG1vdW50IHRvIHJlbmRlciBzcGVjaWZpYyB0aGVtZS1kZXBlbmRlbnQgVUkgaWYgbmVlZGVkLFxyXG4gIC8vIGJ1dCBoZXJlIHdlIHByb3ZpZGUgdGhlIGNvbnRleHQgaW1tZWRpYXRlbHkgc28gdGhlIGFwcCB0cmVlIHN0cnVjdHVyZSBpcyBzdGFibGUuXHJcbiAgLy8gVGhlICdpc0RhcmtNb2RlJyBzdGF0ZSB3aWxsIGJlIGFjY3VyYXRlIGFmdGVyIHRoZSBmaXJzdCBlZmZlY3QuXHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8VGhlbWVDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt7IGlzRGFya01vZGUsIHRvZ2dsZVRoZW1lIH19PlxyXG4gICAgICB7LyogV2UgcmVuZGVyIGNoaWxkcmVuIGV2ZW4gaWYgbm90IG1vdW50ZWQgdG8gYWxsb3cgU0VPL0luaXRpYWwgSFRNTCwgXHJcbiAgICAgICAgICBidXQgc3BlY2lmaWMgaWNvbnMgcmVseWluZyBvbiBpc0RhcmtNb2RlIG1pZ2h0IGZsaWNrZXIgc2xpZ2h0bHkgb24gZmlyc3QgbG9hZCB3aXRob3V0IFNTUiBzdXBwb3J0IGZvciB0aGVtZS4gXHJcbiAgICAgICAgICBHaXZlbiB0aGlzIGlzIGEgQ2xpZW50IENvbXBvbmVudCB3cmFwcGVyLCBpdCdzIGFjY2VwdGFibGUuICovfVxyXG4gICAgICB7Y2hpbGRyZW59XHJcbiAgICA8L1RoZW1lQ29udGV4dC5Qcm92aWRlcj5cclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHVzZVRoZW1lID0gKCkgPT4ge1xyXG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KFRoZW1lQ29udGV4dCk7XHJcbiAgaWYgKCFjb250ZXh0KSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZVRoZW1lIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBUaGVtZVByb3ZpZGVyJyk7XHJcbiAgfVxyXG4gIHJldHVybiBjb250ZXh0O1xyXG59O1xyXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZUVmZmVjdCIsInVzZVN0YXRlIiwiVGhlbWVDb250ZXh0IiwidW5kZWZpbmVkIiwiVGhlbWVQcm92aWRlciIsImNoaWxkcmVuIiwiaXNEYXJrTW9kZSIsInNldElzRGFya01vZGUiLCJtb3VudGVkIiwic2V0TW91bnRlZCIsInNhdmVkVGhlbWUiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwic3lzdGVtUHJlZmVyc0RhcmsiLCJ3aW5kb3ciLCJtYXRjaE1lZGlhIiwibWF0Y2hlcyIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiY2xhc3NMaXN0IiwiYWRkIiwicmVtb3ZlIiwidG9nZ2xlVGhlbWUiLCJwcmV2IiwibmV3TW9kZSIsInNldEl0ZW0iLCJQcm92aWRlciIsInZhbHVlIiwidXNlVGhlbWUiLCJjb250ZXh0IiwiRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/common/ThemeContext.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/common/ToastContext.tsx":
/*!********************************************!*\
  !*** ./components/common/ToastContext.tsx ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ToastProvider: function() { return /* binding */ ToastProvider; },\n/* harmony export */   useToast: function() { return /* binding */ useToast; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _barrel_optimize_names_AlertCircle_CheckCircle_Info_X_lucide_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! __barrel_optimize__?names=AlertCircle,CheckCircle,Info,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/circle-check-big.js\");\n/* harmony import */ var _barrel_optimize_names_AlertCircle_CheckCircle_Info_X_lucide_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! __barrel_optimize__?names=AlertCircle,CheckCircle,Info,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/circle-alert.js\");\n/* harmony import */ var _barrel_optimize_names_AlertCircle_CheckCircle_Info_X_lucide_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! __barrel_optimize__?names=AlertCircle,CheckCircle,Info,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/info.js\");\n/* harmony import */ var _barrel_optimize_names_AlertCircle_CheckCircle_Info_X_lucide_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! __barrel_optimize__?names=AlertCircle,CheckCircle,Info,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/x.js\");\n/* __next_internal_client_entry_do_not_use__ ToastProvider,useToast auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\nconst ToastContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nconst ToastProvider = (param)=>{\n    let { children } = param;\n    _s();\n    const [toasts, setToasts] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const showToast = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(message) {\n        let type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"success\";\n        const id = Date.now();\n        setToasts((prev)=>[\n                ...prev,\n                {\n                    id,\n                    message,\n                    type\n                }\n            ]);\n        // Auto remove after 3 seconds\n        setTimeout(()=>{\n            setToasts((prev)=>prev.filter((t)=>t.id !== id));\n        }, 3500);\n    }, []);\n    const removeToast = (id)=>{\n        setToasts((prev)=>prev.filter((t)=>t.id !== id));\n    };\n    const getIcon = (type)=>{\n        switch(type){\n            case \"success\":\n                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_AlertCircle_CheckCircle_Info_X_lucide_react__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                    className: \"w-5 h-5 text-green-500\"\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\Dream\\\\ray-egypt-8\\\\components\\\\common\\\\ToastContext.tsx\",\n                    lineNumber: 40,\n                    columnNumber: 30\n                }, undefined);\n            case \"error\":\n                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_AlertCircle_CheckCircle_Info_X_lucide_react__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                    className: \"w-5 h-5 text-red-500\"\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\Dream\\\\ray-egypt-8\\\\components\\\\common\\\\ToastContext.tsx\",\n                    lineNumber: 41,\n                    columnNumber: 28\n                }, undefined);\n            case \"info\":\n                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_AlertCircle_CheckCircle_Info_X_lucide_react__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                    className: \"w-5 h-5 text-blue-500\"\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\Dream\\\\ray-egypt-8\\\\components\\\\common\\\\ToastContext.tsx\",\n                    lineNumber: 42,\n                    columnNumber: 27\n                }, undefined);\n        }\n    };\n    const getStyles = (type)=>{\n        switch(type){\n            case \"success\":\n                return \"border-green-100 bg-white\";\n            case \"error\":\n                return \"border-red-100 bg-white\";\n            case \"info\":\n                return \"border-blue-100 bg-white\";\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ToastContext.Provider, {\n        value: {\n            showToast\n        },\n        children: [\n            children,\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"fixed bottom-6 left-1/2 -translate-x-1/2 z-[100] flex flex-col gap-3 w-full max-w-md px-4 pointer-events-none\",\n                children: toasts.map((toast)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"pointer-events-auto flex items-center gap-3 p-4 rounded-xl border shadow-lg animate-in slide-in-from-bottom-5 fade-in duration-300 \".concat(getStyles(toast.type)),\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"shrink-0\",\n                                children: getIcon(toast.type)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Dream\\\\ray-egypt-8\\\\components\\\\common\\\\ToastContext.tsx\",\n                                lineNumber: 63,\n                                columnNumber: 13\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: \"flex-1 text-sm font-bold text-gray-800\",\n                                children: toast.message\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Dream\\\\ray-egypt-8\\\\components\\\\common\\\\ToastContext.tsx\",\n                                lineNumber: 64,\n                                columnNumber: 13\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: ()=>removeToast(toast.id),\n                                className: \"p-1 hover:bg-gray-100 rounded-full transition text-gray-400\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_AlertCircle_CheckCircle_Info_X_lucide_react__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                                    className: \"w-4 h-4\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\Dream\\\\ray-egypt-8\\\\components\\\\common\\\\ToastContext.tsx\",\n                                    lineNumber: 69,\n                                    columnNumber: 15\n                                }, undefined)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Dream\\\\ray-egypt-8\\\\components\\\\common\\\\ToastContext.tsx\",\n                                lineNumber: 65,\n                                columnNumber: 13\n                            }, undefined)\n                        ]\n                    }, toast.id, true, {\n                        fileName: \"C:\\\\Users\\\\Dream\\\\ray-egypt-8\\\\components\\\\common\\\\ToastContext.tsx\",\n                        lineNumber: 59,\n                        columnNumber: 11\n                    }, undefined))\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\Dream\\\\ray-egypt-8\\\\components\\\\common\\\\ToastContext.tsx\",\n                lineNumber: 57,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\Dream\\\\ray-egypt-8\\\\components\\\\common\\\\ToastContext.tsx\",\n        lineNumber: 55,\n        columnNumber: 5\n    }, undefined);\n};\n_s(ToastProvider, \"bva7iOXLAgwOJBzZ6Hx6GD8IQA4=\");\n_c = ToastProvider;\nconst useToast = ()=>{\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ToastContext);\n    if (!context) {\n        throw new Error(\"useToast must be used within a ToastProvider\");\n    }\n    return context;\n};\n_s1(useToast, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"ToastProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvY29tbW9uL1RvYXN0Q29udGV4dC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFHZ0Y7QUFDZjtBQWNqRSxNQUFNUyw2QkFBZVIsb0RBQWFBLENBQStCUztBQUUxRCxNQUFNQyxnQkFBeUQ7UUFBQyxFQUFFQyxRQUFRLEVBQUU7O0lBQ2pGLE1BQU0sQ0FBQ0MsUUFBUUMsVUFBVSxHQUFHWCwrQ0FBUUEsQ0FBVSxFQUFFO0lBRWhELE1BQU1ZLFlBQVlYLGtEQUFXQSxDQUFDLFNBQUNZO1lBQWlCQyx3RUFBa0I7UUFDaEUsTUFBTUMsS0FBS0MsS0FBS0MsR0FBRztRQUNuQk4sVUFBVSxDQUFDTyxPQUFTO21CQUFJQTtnQkFBTTtvQkFBRUg7b0JBQUlGO29CQUFTQztnQkFBSzthQUFFO1FBRXBELDhCQUE4QjtRQUM5QkssV0FBVztZQUNUUixVQUFVLENBQUNPLE9BQVNBLEtBQUtFLE1BQU0sQ0FBQyxDQUFDQyxJQUFNQSxFQUFFTixFQUFFLEtBQUtBO1FBQ2xELEdBQUc7SUFDTCxHQUFHLEVBQUU7SUFFTCxNQUFNTyxjQUFjLENBQUNQO1FBQ25CSixVQUFVLENBQUNPLE9BQVNBLEtBQUtFLE1BQU0sQ0FBQyxDQUFDQyxJQUFNQSxFQUFFTixFQUFFLEtBQUtBO0lBQ2xEO0lBRUEsTUFBTVEsVUFBVSxDQUFDVDtRQUNmLE9BQVFBO1lBQ04sS0FBSztnQkFBVyxxQkFBTyw4REFBQ1osMEdBQVdBO29CQUFDc0IsV0FBVTs7Ozs7O1lBQzlDLEtBQUs7Z0JBQVMscUJBQU8sOERBQUNyQiwwR0FBV0E7b0JBQUNxQixXQUFVOzs7Ozs7WUFDNUMsS0FBSztnQkFBUSxxQkFBTyw4REFBQ3BCLDBHQUFJQTtvQkFBQ29CLFdBQVU7Ozs7OztRQUN0QztJQUNGO0lBRUEsTUFBTUMsWUFBWSxDQUFDWDtRQUNqQixPQUFRQTtZQUNOLEtBQUs7Z0JBQVcsT0FBTztZQUN2QixLQUFLO2dCQUFTLE9BQU87WUFDckIsS0FBSztnQkFBUSxPQUFPO1FBQ3RCO0lBQ0Y7SUFFQSxxQkFDRSw4REFBQ1IsYUFBYW9CLFFBQVE7UUFBQ0MsT0FBTztZQUFFZjtRQUFVOztZQUN2Q0g7MEJBQ0QsOERBQUNtQjtnQkFBSUosV0FBVTswQkFDWmQsT0FBT21CLEdBQUcsQ0FBQyxDQUFDQyxzQkFDWCw4REFBQ0Y7d0JBRUNKLFdBQVcsc0lBQTRKLE9BQXRCQyxVQUFVSyxNQUFNaEIsSUFBSTs7MENBRXJLLDhEQUFDYztnQ0FBSUosV0FBVTswQ0FBWUQsUUFBUU8sTUFBTWhCLElBQUk7Ozs7OzswQ0FDN0MsOERBQUNpQjtnQ0FBRVAsV0FBVTswQ0FBMENNLE1BQU1qQixPQUFPOzs7Ozs7MENBQ3BFLDhEQUFDbUI7Z0NBQ0NDLFNBQVMsSUFBTVgsWUFBWVEsTUFBTWYsRUFBRTtnQ0FDbkNTLFdBQVU7MENBRVYsNEVBQUNuQiwwR0FBQ0E7b0NBQUNtQixXQUFVOzs7Ozs7Ozs7Ozs7dUJBVFZNLE1BQU1mLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQnpCLEVBQUU7R0F2RFdQO0tBQUFBO0FBeUROLE1BQU0wQixXQUFXOztJQUN0QixNQUFNQyxVQUFVcEMsaURBQVVBLENBQUNPO0lBQzNCLElBQUksQ0FBQzZCLFNBQVM7UUFDWixNQUFNLElBQUlDLE1BQU07SUFDbEI7SUFDQSxPQUFPRDtBQUNULEVBQUU7SUFOV0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9jb21tb24vVG9hc3RDb250ZXh0LnRzeD8wMjA5Il0sInNvdXJjZXNDb250ZW50IjpbIlxyXG5cInVzZSBjbGllbnRcIjtcclxuXHJcbmltcG9ydCBSZWFjdCwgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IENoZWNrQ2lyY2xlLCBBbGVydENpcmNsZSwgSW5mbywgWCB9IGZyb20gJ2x1Y2lkZS1yZWFjdCc7XHJcblxyXG5leHBvcnQgdHlwZSBUb2FzdFR5cGUgPSAnc3VjY2VzcycgfCAnZXJyb3InIHwgJ2luZm8nO1xyXG5cclxuaW50ZXJmYWNlIFRvYXN0IHtcclxuICBpZDogbnVtYmVyO1xyXG4gIG1lc3NhZ2U6IHN0cmluZztcclxuICB0eXBlOiBUb2FzdFR5cGU7XHJcbn1cclxuXHJcbmludGVyZmFjZSBUb2FzdENvbnRleHRUeXBlIHtcclxuICBzaG93VG9hc3Q6IChtZXNzYWdlOiBzdHJpbmcsIHR5cGU/OiBUb2FzdFR5cGUpID0+IHZvaWQ7XHJcbn1cclxuXHJcbmNvbnN0IFRvYXN0Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VG9hc3RDb250ZXh0VHlwZSB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcclxuXHJcbmV4cG9ydCBjb25zdCBUb2FzdFByb3ZpZGVyOiBSZWFjdC5GQzx7IGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGUgfT4gPSAoeyBjaGlsZHJlbiB9KSA9PiB7XHJcbiAgY29uc3QgW3RvYXN0cywgc2V0VG9hc3RzXSA9IHVzZVN0YXRlPFRvYXN0W10+KFtdKTtcclxuXHJcbiAgY29uc3Qgc2hvd1RvYXN0ID0gdXNlQ2FsbGJhY2soKG1lc3NhZ2U6IHN0cmluZywgdHlwZTogVG9hc3RUeXBlID0gJ3N1Y2Nlc3MnKSA9PiB7XHJcbiAgICBjb25zdCBpZCA9IERhdGUubm93KCk7XHJcbiAgICBzZXRUb2FzdHMoKHByZXYpID0+IFsuLi5wcmV2LCB7IGlkLCBtZXNzYWdlLCB0eXBlIH1dKTtcclxuXHJcbiAgICAvLyBBdXRvIHJlbW92ZSBhZnRlciAzIHNlY29uZHNcclxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICBzZXRUb2FzdHMoKHByZXYpID0+IHByZXYuZmlsdGVyKCh0KSA9PiB0LmlkICE9PSBpZCkpO1xyXG4gICAgfSwgMzUwMCk7XHJcbiAgfSwgW10pO1xyXG5cclxuICBjb25zdCByZW1vdmVUb2FzdCA9IChpZDogbnVtYmVyKSA9PiB7XHJcbiAgICBzZXRUb2FzdHMoKHByZXYpID0+IHByZXYuZmlsdGVyKCh0KSA9PiB0LmlkICE9PSBpZCkpO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGdldEljb24gPSAodHlwZTogVG9hc3RUeXBlKSA9PiB7XHJcbiAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgY2FzZSAnc3VjY2Vzcyc6IHJldHVybiA8Q2hlY2tDaXJjbGUgY2xhc3NOYW1lPVwidy01IGgtNSB0ZXh0LWdyZWVuLTUwMFwiIC8+O1xyXG4gICAgICBjYXNlICdlcnJvcic6IHJldHVybiA8QWxlcnRDaXJjbGUgY2xhc3NOYW1lPVwidy01IGgtNSB0ZXh0LXJlZC01MDBcIiAvPjtcclxuICAgICAgY2FzZSAnaW5mbyc6IHJldHVybiA8SW5mbyBjbGFzc05hbWU9XCJ3LTUgaC01IHRleHQtYmx1ZS01MDBcIiAvPjtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCBnZXRTdHlsZXMgPSAodHlwZTogVG9hc3RUeXBlKSA9PiB7XHJcbiAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgY2FzZSAnc3VjY2Vzcyc6IHJldHVybiAnYm9yZGVyLWdyZWVuLTEwMCBiZy13aGl0ZSc7XHJcbiAgICAgIGNhc2UgJ2Vycm9yJzogcmV0dXJuICdib3JkZXItcmVkLTEwMCBiZy13aGl0ZSc7XHJcbiAgICAgIGNhc2UgJ2luZm8nOiByZXR1cm4gJ2JvcmRlci1ibHVlLTEwMCBiZy13aGl0ZSc7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxUb2FzdENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3sgc2hvd1RvYXN0IH19PlxyXG4gICAgICB7Y2hpbGRyZW59XHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZml4ZWQgYm90dG9tLTYgbGVmdC0xLzIgLXRyYW5zbGF0ZS14LTEvMiB6LVsxMDBdIGZsZXggZmxleC1jb2wgZ2FwLTMgdy1mdWxsIG1heC13LW1kIHB4LTQgcG9pbnRlci1ldmVudHMtbm9uZVwiPlxyXG4gICAgICAgIHt0b2FzdHMubWFwKCh0b2FzdCkgPT4gKFxyXG4gICAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICBrZXk9e3RvYXN0LmlkfVxyXG4gICAgICAgICAgICBjbGFzc05hbWU9e2Bwb2ludGVyLWV2ZW50cy1hdXRvIGZsZXggaXRlbXMtY2VudGVyIGdhcC0zIHAtNCByb3VuZGVkLXhsIGJvcmRlciBzaGFkb3ctbGcgYW5pbWF0ZS1pbiBzbGlkZS1pbi1mcm9tLWJvdHRvbS01IGZhZGUtaW4gZHVyYXRpb24tMzAwICR7Z2V0U3R5bGVzKHRvYXN0LnR5cGUpfWB9XHJcbiAgICAgICAgICA+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic2hyaW5rLTBcIj57Z2V0SWNvbih0b2FzdC50eXBlKX08L2Rpdj5cclxuICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwiZmxleC0xIHRleHQtc20gZm9udC1ib2xkIHRleHQtZ3JheS04MDBcIj57dG9hc3QubWVzc2FnZX08L3A+XHJcbiAgICAgICAgICAgIDxidXR0b24gXHJcbiAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gcmVtb3ZlVG9hc3QodG9hc3QuaWQpfVxyXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cInAtMSBob3ZlcjpiZy1ncmF5LTEwMCByb3VuZGVkLWZ1bGwgdHJhbnNpdGlvbiB0ZXh0LWdyYXktNDAwXCJcclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgIDxYIGNsYXNzTmFtZT1cInctNCBoLTRcIiAvPlxyXG4gICAgICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICkpfVxyXG4gICAgICA8L2Rpdj5cclxuICAgIDwvVG9hc3RDb250ZXh0LlByb3ZpZGVyPlxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgdXNlVG9hc3QgPSAoKSA9PiB7XHJcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoVG9hc3RDb250ZXh0KTtcclxuICBpZiAoIWNvbnRleHQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcigndXNlVG9hc3QgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIFRvYXN0UHJvdmlkZXInKTtcclxuICB9XHJcbiAgcmV0dXJuIGNvbnRleHQ7XHJcbn07XHJcbiJdLCJuYW1lcyI6WyJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsIkNoZWNrQ2lyY2xlIiwiQWxlcnRDaXJjbGUiLCJJbmZvIiwiWCIsIlRvYXN0Q29udGV4dCIsInVuZGVmaW5lZCIsIlRvYXN0UHJvdmlkZXIiLCJjaGlsZHJlbiIsInRvYXN0cyIsInNldFRvYXN0cyIsInNob3dUb2FzdCIsIm1lc3NhZ2UiLCJ0eXBlIiwiaWQiLCJEYXRlIiwibm93IiwicHJldiIsInNldFRpbWVvdXQiLCJmaWx0ZXIiLCJ0IiwicmVtb3ZlVG9hc3QiLCJnZXRJY29uIiwiY2xhc3NOYW1lIiwiZ2V0U3R5bGVzIiwiUHJvdmlkZXIiLCJ2YWx1ZSIsImRpdiIsIm1hcCIsInRvYXN0IiwicCIsImJ1dHRvbiIsIm9uQ2xpY2siLCJ1c2VUb2FzdCIsImNvbnRleHQiLCJFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/common/ToastContext.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./context/AuthContext.tsx":
/*!*********************************!*\
  !*** ./context/AuthContext.tsx ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthProvider: function() { return /* binding */ AuthProvider; },\n/* harmony export */   useAuth: function() { return /* binding */ useAuth; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ AuthProvider,useAuth auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\nconst AuthContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nconst AuthProvider = (param)=>{\n    let { children } = param;\n    _s();\n    const [user, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Check local storage for existing session\n        const storedUser = localStorage.getItem(\"ray_user\");\n        if (storedUser) {\n            try {\n                setUser(JSON.parse(storedUser));\n            } catch (e) {\n                console.error(\"Failed to parse user data\", e);\n                localStorage.removeItem(\"ray_user\");\n            }\n        }\n        setIsLoading(false);\n    }, []);\n    const login = async function(email) {\n        let role = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"merchant\";\n        setIsLoading(true);\n        // Simulate API Delay\n        await new Promise((resolve)=>setTimeout(resolve, 1000));\n        const mockUser = {\n            id: \"u-\" + Date.now(),\n            name: role === \"merchant\" ? \" \" : \" \",\n            email: email,\n            role: role,\n            avatar: role === \"merchant\" ? \"AM\" : \"RC\",\n            businessName: role === \"merchant\" ? \" \" : undefined\n        };\n        setUser(mockUser);\n        localStorage.setItem(\"ray_user\", JSON.stringify(mockUser));\n        setIsLoading(false);\n    };\n    const logout = ()=>{\n        setUser(null);\n        localStorage.removeItem(\"ray_user\");\n    // Optional: Redirect logic can be handled by consumers or a router wrapper\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AuthContext.Provider, {\n        value: {\n            user,\n            isLoading,\n            login,\n            logout,\n            isAuthenticated: !!user\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\Dream\\\\ray-egypt-8\\\\context\\\\AuthContext.tsx\",\n        lineNumber: 69,\n        columnNumber: 5\n    }, undefined);\n};\n_s(AuthProvider, \"YajQB7LURzRD+QP5gw0+K2TZIWA=\");\n_c = AuthProvider;\nconst useAuth = ()=>{\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(AuthContext);\n    if (!context) {\n        throw new Error(\"useAuth must be used within an AuthProvider\");\n    }\n    return context;\n};\n_s1(useAuth, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbnRleHQvQXV0aENvbnRleHQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFHOEU7QUFtQjlFLE1BQU1LLDRCQUFjSixvREFBYUEsQ0FBOEJLO0FBRXhELE1BQU1DLGVBQXdEO1FBQUMsRUFBRUMsUUFBUSxFQUFFOztJQUNoRixNQUFNLENBQUNDLE1BQU1DLFFBQVEsR0FBR1AsK0NBQVFBLENBQWM7SUFDOUMsTUFBTSxDQUFDUSxXQUFXQyxhQUFhLEdBQUdULCtDQUFRQSxDQUFDO0lBRTNDQyxnREFBU0EsQ0FBQztRQUNSLDJDQUEyQztRQUMzQyxNQUFNUyxhQUFhQyxhQUFhQyxPQUFPLENBQUM7UUFDeEMsSUFBSUYsWUFBWTtZQUNkLElBQUk7Z0JBQ0ZILFFBQVFNLEtBQUtDLEtBQUssQ0FBQ0o7WUFDckIsRUFBRSxPQUFPSyxHQUFHO2dCQUNWQyxRQUFRQyxLQUFLLENBQUMsNkJBQTZCRjtnQkFDM0NKLGFBQWFPLFVBQVUsQ0FBQztZQUMxQjtRQUNGO1FBQ0FULGFBQWE7SUFDZixHQUFHLEVBQUU7SUFFTCxNQUFNVSxRQUFRLGVBQU9DO1lBQWVDLHdFQUFnQztRQUNsRVosYUFBYTtRQUNiLHFCQUFxQjtRQUNyQixNQUFNLElBQUlhLFFBQVFDLENBQUFBLFVBQVdDLFdBQVdELFNBQVM7UUFFakQsTUFBTUUsV0FBaUI7WUFDckJDLElBQUksT0FBT0MsS0FBS0MsR0FBRztZQUNuQkMsTUFBTVIsU0FBUyxhQUFhLGNBQWM7WUFDMUNELE9BQU9BO1lBQ1BDLE1BQU1BO1lBQ05TLFFBQVFULFNBQVMsYUFBYSxPQUFPO1lBQ3JDVSxjQUFjVixTQUFTLGFBQWEsZUFBZWxCO1FBQ3JEO1FBRUFJLFFBQVFrQjtRQUNSZCxhQUFhcUIsT0FBTyxDQUFDLFlBQVluQixLQUFLb0IsU0FBUyxDQUFDUjtRQUNoRGhCLGFBQWE7SUFDZjtJQUVBLE1BQU15QixTQUFTO1FBQ2IzQixRQUFRO1FBQ1JJLGFBQWFPLFVBQVUsQ0FBQztJQUN4QiwyRUFBMkU7SUFDN0U7SUFFQSxxQkFDRSw4REFBQ2hCLFlBQVlpQyxRQUFRO1FBQUNDLE9BQU87WUFBRTlCO1lBQU1FO1lBQVdXO1lBQU9lO1lBQVFHLGlCQUFpQixDQUFDLENBQUMvQjtRQUFLO2tCQUNwRkQ7Ozs7OztBQUdQLEVBQUU7R0FoRFdEO0tBQUFBO0FBa0ROLE1BQU1rQyxVQUFVOztJQUNyQixNQUFNQyxVQUFVeEMsaURBQVVBLENBQUNHO0lBQzNCLElBQUksQ0FBQ3FDLFNBQVM7UUFDWixNQUFNLElBQUlDLE1BQU07SUFDbEI7SUFDQSxPQUFPRDtBQUNULEVBQUU7SUFOV0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29udGV4dC9BdXRoQ29udGV4dC50c3g/ZmRmZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcclxuXCJ1c2UgY2xpZW50XCI7XHJcblxyXG5pbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcclxuXHJcbmludGVyZmFjZSBVc2VyIHtcclxuICBpZDogc3RyaW5nO1xyXG4gIG5hbWU6IHN0cmluZztcclxuICBlbWFpbDogc3RyaW5nO1xyXG4gIHJvbGU6ICdtZXJjaGFudCcgfCAnY3VzdG9tZXInIHwgJ2FkbWluJztcclxuICBhdmF0YXI/OiBzdHJpbmc7XHJcbiAgYnVzaW5lc3NOYW1lPzogc3RyaW5nO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgQXV0aENvbnRleHRUeXBlIHtcclxuICB1c2VyOiBVc2VyIHwgbnVsbDtcclxuICBpc0xvYWRpbmc6IGJvb2xlYW47XHJcbiAgbG9naW46IChlbWFpbDogc3RyaW5nLCByb2xlPzogJ21lcmNoYW50JyB8ICdjdXN0b21lcicpID0+IFByb21pc2U8dm9pZD47XHJcbiAgbG9nb3V0OiAoKSA9PiB2b2lkO1xyXG4gIGlzQXV0aGVudGljYXRlZDogYm9vbGVhbjtcclxufVxyXG5cclxuY29uc3QgQXV0aENvbnRleHQgPSBjcmVhdGVDb250ZXh0PEF1dGhDb250ZXh0VHlwZSB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcclxuXHJcbmV4cG9ydCBjb25zdCBBdXRoUHJvdmlkZXI6IFJlYWN0LkZDPHsgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSB9PiA9ICh7IGNoaWxkcmVuIH0pID0+IHtcclxuICBjb25zdCBbdXNlciwgc2V0VXNlcl0gPSB1c2VTdGF0ZTxVc2VyIHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgLy8gQ2hlY2sgbG9jYWwgc3RvcmFnZSBmb3IgZXhpc3Rpbmcgc2Vzc2lvblxyXG4gICAgY29uc3Qgc3RvcmVkVXNlciA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdyYXlfdXNlcicpO1xyXG4gICAgaWYgKHN0b3JlZFVzZXIpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBzZXRVc2VyKEpTT04ucGFyc2Uoc3RvcmVkVXNlcikpO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHBhcnNlIHVzZXIgZGF0YScsIGUpO1xyXG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdyYXlfdXNlcicpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xyXG4gIH0sIFtdKTtcclxuXHJcbiAgY29uc3QgbG9naW4gPSBhc3luYyAoZW1haWw6IHN0cmluZywgcm9sZTogJ21lcmNoYW50JyB8ICdjdXN0b21lcicgPSAnbWVyY2hhbnQnKSA9PiB7XHJcbiAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XHJcbiAgICAvLyBTaW11bGF0ZSBBUEkgRGVsYXlcclxuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSk7XHJcblxyXG4gICAgY29uc3QgbW9ja1VzZXI6IFVzZXIgPSB7XHJcbiAgICAgIGlkOiAndS0nICsgRGF0ZS5ub3coKSxcclxuICAgICAgbmFtZTogcm9sZSA9PT0gJ21lcmNoYW50JyA/ICfYo9it2YXYryDZhdit2YXYrycgOiAn2LnZhdmK2YQg2LHYp9mKJyxcclxuICAgICAgZW1haWw6IGVtYWlsLFxyXG4gICAgICByb2xlOiByb2xlLFxyXG4gICAgICBhdmF0YXI6IHJvbGUgPT09ICdtZXJjaGFudCcgPyAnQU0nIDogJ1JDJyxcclxuICAgICAgYnVzaW5lc3NOYW1lOiByb2xlID09PSAnbWVyY2hhbnQnID8gJ9mF2LfYudmFINin2YTZhtmI2LEnIDogdW5kZWZpbmVkXHJcbiAgICB9O1xyXG5cclxuICAgIHNldFVzZXIobW9ja1VzZXIpO1xyXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3JheV91c2VyJywgSlNPTi5zdHJpbmdpZnkobW9ja1VzZXIpKTtcclxuICAgIHNldElzTG9hZGluZyhmYWxzZSk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgbG9nb3V0ID0gKCkgPT4ge1xyXG4gICAgc2V0VXNlcihudWxsKTtcclxuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdyYXlfdXNlcicpO1xyXG4gICAgLy8gT3B0aW9uYWw6IFJlZGlyZWN0IGxvZ2ljIGNhbiBiZSBoYW5kbGVkIGJ5IGNvbnN1bWVycyBvciBhIHJvdXRlciB3cmFwcGVyXHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxBdXRoQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17eyB1c2VyLCBpc0xvYWRpbmcsIGxvZ2luLCBsb2dvdXQsIGlzQXV0aGVudGljYXRlZDogISF1c2VyIH19PlxyXG4gICAgICB7Y2hpbGRyZW59XHJcbiAgICA8L0F1dGhDb250ZXh0LlByb3ZpZGVyPlxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgdXNlQXV0aCA9ICgpID0+IHtcclxuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChBdXRoQ29udGV4dCk7XHJcbiAgaWYgKCFjb250ZXh0KSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZUF1dGggbXVzdCBiZSB1c2VkIHdpdGhpbiBhbiBBdXRoUHJvdmlkZXInKTtcclxuICB9XHJcbiAgcmV0dXJuIGNvbnRleHQ7XHJcbn07XHJcbiJdLCJuYW1lcyI6WyJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJBdXRoQ29udGV4dCIsInVuZGVmaW5lZCIsIkF1dGhQcm92aWRlciIsImNoaWxkcmVuIiwidXNlciIsInNldFVzZXIiLCJpc0xvYWRpbmciLCJzZXRJc0xvYWRpbmciLCJzdG9yZWRVc2VyIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsIkpTT04iLCJwYXJzZSIsImUiLCJjb25zb2xlIiwiZXJyb3IiLCJyZW1vdmVJdGVtIiwibG9naW4iLCJlbWFpbCIsInJvbGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJtb2NrVXNlciIsImlkIiwiRGF0ZSIsIm5vdyIsIm5hbWUiLCJhdmF0YXIiLCJidXNpbmVzc05hbWUiLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwibG9nb3V0IiwiUHJvdmlkZXIiLCJ2YWx1ZSIsImlzQXV0aGVudGljYXRlZCIsInVzZUF1dGgiLCJjb250ZXh0IiwiRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./context/AuthContext.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./context/LanguageContext.tsx":
/*!*************************************!*\
  !*** ./context/LanguageContext.tsx ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LanguageProvider: function() { return /* binding */ LanguageProvider; },\n/* harmony export */   useLanguage: function() { return /* binding */ useLanguage; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ LanguageProvider,useLanguage auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\nconst translations = {\n    ar: {\n        // Navigation\n        \"nav.home\": \"\",\n        \"nav.offers\": \" \",\n        \"nav.cart\": \"\",\n        \"nav.favorites\": \"\",\n        \"nav.profile\": \"\",\n        \"nav.login\": \" \",\n        \"nav.register\": \" \",\n        \"nav.logout\": \" \",\n        \"nav.search\": \"...\",\n        \"nav.categories\": \"\",\n        \"nav.register_business\": \"  ()\",\n        // Categories\n        \"cat.restaurants\": \"\",\n        \"cat.shopping\": \"\",\n        \"cat.services\": \"\",\n        \"cat.health\": \"\",\n        \"cat.education\": \"\",\n        \"cat.entertainment\": \"\",\n        \"cat.automotive\": \"\",\n        \"cat.real_estate\": \"\",\n        \"cat.beauty\": \"\",\n        \"cat.sports\": \"\",\n        \"cat.technology\": \"\",\n        // Common\n        \"common.loading\": \" ...\",\n        \"common.error\": \" \",\n        \"common.success\": \" \",\n        \"common.cancel\": \"\",\n        \"common.save\": \"\",\n        \"common.edit\": \"\",\n        \"common.delete\": \"\",\n        \"common.add\": \"\",\n        \"common.view\": \"\",\n        \"common.more\": \"\",\n        \"common.less\": \"\",\n        \"common.close\": \"\",\n        \"common.open\": \"\",\n        \"common.next\": \"\",\n        \"common.previous\": \"\",\n        \"common.submit\": \"\",\n        \"common.reset\": \" \",\n        \"common.clear\": \"\",\n        \"common.filter\": \"\",\n        \"common.sort\": \"\",\n        \"common.search\": \"\",\n        \"common.all\": \"\",\n        \"common.none\": \" \",\n        \"common.yes\": \"\",\n        \"common.no\": \"\",\n        \"common.ok\": \"\",\n        \"common.back\": \"\",\n        \"common.continue\": \"\",\n        \"common.finish\": \"\",\n        \"common.start\": \"\",\n        \"common.stop\": \"\",\n        \"common.pause\": \" \",\n        \"common.play\": \"\",\n        // Messages\n        \"msg.no_results\": \"  \",\n        \"msg.network_error\": \"   \",\n        \"msg.server_error\": \"  \",\n        \"msg.validation_error\": \"    \",\n        \"msg.auth_required\": \"   \",\n        \"msg.permission_denied\": \"    \",\n        \"msg.session_expired\": \"      \",\n        \"msg.confirm_delete\": \"    \",\n        \"msg.confirm_logout\": \"     \",\n        \"msg.saved_successfully\": \"  \",\n        \"msg.updated_successfully\": \"  \",\n        \"msg.deleted_successfully\": \"  \",\n        \"msg.added_successfully\": \"  \",\n        \"msg.login_successfully\": \"   \",\n        \"msg.logout_successfully\": \"   \",\n        // Forms\n        \"form.name\": \"\",\n        \"form.email\": \" \",\n        \"form.phone\": \" \",\n        \"form.password\": \" \",\n        \"form.confirm_password\": \"  \",\n        \"form.address\": \"\",\n        \"form.city\": \"\",\n        \"form.country\": \"\",\n        \"form.postal_code\": \" \",\n        \"form.description\": \"\",\n        \"form.price\": \"\",\n        \"form.quantity\": \"\",\n        \"form.category\": \"\",\n        \"form.subcategory\": \" \",\n        \"form.image\": \"\",\n        \"form.images\": \"\",\n        \"form.website\": \" \",\n        \"form.social_media\": \"  \",\n        \"form.working_hours\": \" \",\n        \"form.contact_info\": \" \",\n        // Validation\n        \"validation.required\": \"  \",\n        \"validation.email\": \"   \",\n        \"validation.phone\": \"   \",\n        \"validation.password_min\": \"     8   \",\n        \"validation.password_match\": \"   \",\n        \"validation.min_length\": \"   {field}   {min} \",\n        \"validation.max_length\": \"   {field}   {max} \",\n        \"validation.number\": \"   \",\n        \"validation.positive\": \"    \",\n        \"validation.url\": \"  \",\n        \"validation.image\": \"   \",\n        \"validation.file_size\": \"   \",\n        \"validation.file_type\": \"   \",\n        // Dashboard\n        \"dashboard.title\": \" \",\n        \"dashboard.overview\": \" \",\n        \"dashboard.analytics\": \"\",\n        \"dashboard.reports\": \"\",\n        \"dashboard.settings\": \"\",\n        \"dashboard.profile\": \" \",\n        \"dashboard.notifications\": \"\",\n        \"dashboard.messages\": \"\",\n        \"dashboard.orders\": \"\",\n        \"dashboard.products\": \"\",\n        \"dashboard.customers\": \"\",\n        \"dashboard.revenue\": \"\",\n        \"dashboard.sales\": \"\",\n        \"dashboard.visitors\": \"\",\n        \"dashboard.conversion\": \" \",\n        // Marketplace\n        \"marketplace.title\": \"\",\n        \"marketplace.all_products\": \" \",\n        \"marketplace.featured\": \"\",\n        \"marketplace.new_arrivals\": \" \",\n        \"marketplace.best_sellers\": \" \",\n        \"marketplace.offers\": \"\",\n        \"marketplace.categories\": \"\",\n        \"marketplace.filters\": \"\",\n        \"marketplace.sort_by\": \" \",\n        \"marketplace.price_low_high\": \":   \",\n        \"marketplace.price_high_low\": \":   \",\n        \"marketplace.newest\": \"\",\n        \"marketplace.popular\": \" \",\n        \"marketplace.rating\": \"\",\n        \"marketplace.free_shipping\": \" \",\n        \"marketplace.in_stock\": \"\",\n        \"marketplace.out_of_stock\": \" \",\n        \"marketplace.add_to_cart\": \" \",\n        \"marketplace.buy_now\": \" \",\n        \"marketplace.product_details\": \" \",\n        \"marketplace.product_description\": \" \",\n        \"marketplace.product_specifications\": \" \",\n        \"marketplace.product_reviews\": \" \",\n        \"marketplace.write_review\": \" \",\n        // Currency\n        \"currency.egp\": \".\",\n        \"currency.usd\": \"$\",\n        \"currency.eur\": \"\",\n        \"currency.gbp\": \"\\xa3\",\n        // Time\n        \"time.now\": \"\",\n        \"time.minute_ago\": \" \",\n        \"time.minutes_ago\": \" {count} \",\n        \"time.hour_ago\": \" \",\n        \"time.hours_ago\": \" {count} \",\n        \"time.day_ago\": \" \",\n        \"time.days_ago\": \" {count} \",\n        \"time.week_ago\": \" \",\n        \"time.weeks_ago\": \" {count} \",\n        \"time.month_ago\": \" \",\n        \"time.months_ago\": \" {count} \",\n        \"time.year_ago\": \" \",\n        \"time.years_ago\": \" {count} \"\n    },\n    en: {\n        // Navigation\n        \"nav.home\": \"Home\",\n        \"nav.offers\": \"Offers & Discounts\",\n        \"nav.cart\": \"Cart\",\n        \"nav.favorites\": \"Favorites\",\n        \"nav.profile\": \"My Account\",\n        \"nav.login\": \"Login\",\n        \"nav.register\": \"Register\",\n        \"nav.logout\": \"Logout\",\n        \"nav.search\": \"Search...\",\n        \"nav.categories\": \"Categories\",\n        \"nav.register_business\": \"Register Your Business (Merchants)\",\n        // Categories\n        \"cat.restaurants\": \"Restaurants\",\n        \"cat.shopping\": \"Shopping\",\n        \"cat.services\": \"Services\",\n        \"cat.health\": \"Health\",\n        \"cat.education\": \"Education\",\n        \"cat.entertainment\": \"Entertainment\",\n        \"cat.automotive\": \"Automotive\",\n        \"cat.real_estate\": \"Real Estate\",\n        \"cat.beauty\": \"Beauty\",\n        \"cat.sports\": \"Sports\",\n        \"cat.technology\": \"Technology\",\n        // Common\n        \"common.loading\": \"Loading...\",\n        \"common.error\": \"Error occurred\",\n        \"common.success\": \"Success\",\n        \"common.cancel\": \"Cancel\",\n        \"common.save\": \"Save\",\n        \"common.edit\": \"Edit\",\n        \"common.delete\": \"Delete\",\n        \"common.add\": \"Add\",\n        \"common.view\": \"View\",\n        \"common.more\": \"More\",\n        \"common.less\": \"Less\",\n        \"common.close\": \"Close\",\n        \"common.open\": \"Open\",\n        \"common.next\": \"Next\",\n        \"common.previous\": \"Previous\",\n        \"common.submit\": \"Submit\",\n        \"common.reset\": \"Reset\",\n        \"common.clear\": \"Clear\",\n        \"common.filter\": \"Filter\",\n        \"common.sort\": \"Sort\",\n        \"common.search\": \"Search\",\n        \"common.all\": \"All\",\n        \"common.none\": \"None\",\n        \"common.yes\": \"Yes\",\n        \"common.no\": \"No\",\n        \"common.ok\": \"OK\",\n        \"common.back\": \"Back\",\n        \"common.continue\": \"Continue\",\n        \"common.finish\": \"Finish\",\n        \"common.start\": \"Start\",\n        \"common.stop\": \"Stop\",\n        \"common.pause\": \"Pause\",\n        \"common.play\": \"Play\",\n        // Messages\n        \"msg.no_results\": \"No results found\",\n        \"msg.network_error\": \"Network error\",\n        \"msg.server_error\": \"Server error\",\n        \"msg.validation_error\": \"Validation error\",\n        \"msg.auth_required\": \"Authentication required\",\n        \"msg.permission_denied\": \"Permission denied\",\n        \"msg.session_expired\": \"Session expired, please login again\",\n        \"msg.confirm_delete\": \"Are you sure you want to delete?\",\n        \"msg.confirm_logout\": \"Are you sure you want to logout?\",\n        \"msg.saved_successfully\": \"Saved successfully\",\n        \"msg.updated_successfully\": \"Updated successfully\",\n        \"msg.deleted_successfully\": \"Deleted successfully\",\n        \"msg.added_successfully\": \"Added successfully\",\n        \"msg.login_successfully\": \"Logged in successfully\",\n        \"msg.logout_successfully\": \"Logged out successfully\",\n        // Forms\n        \"form.name\": \"Name\",\n        \"form.email\": \"Email\",\n        \"form.phone\": \"Phone\",\n        \"form.password\": \"Password\",\n        \"form.confirm_password\": \"Confirm Password\",\n        \"form.address\": \"Address\",\n        \"form.city\": \"City\",\n        \"form.country\": \"Country\",\n        \"form.postal_code\": \"Postal Code\",\n        \"form.description\": \"Description\",\n        \"form.price\": \"Price\",\n        \"form.quantity\": \"Quantity\",\n        \"form.category\": \"Category\",\n        \"form.subcategory\": \"Subcategory\",\n        \"form.image\": \"Image\",\n        \"form.images\": \"Images\",\n        \"form.website\": \"Website\",\n        \"form.social_media\": \"Social Media\",\n        \"form.working_hours\": \"Working Hours\",\n        \"form.contact_info\": \"Contact Information\",\n        // Validation\n        \"validation.required\": \"This field is required\",\n        \"validation.email\": \"Invalid email address\",\n        \"validation.phone\": \"Invalid phone number\",\n        \"validation.password_min\": \"Password must be at least 8 characters\",\n        \"validation.password_match\": \"Passwords do not match\",\n        \"validation.min_length\": \"{field} must be at least {min} characters\",\n        \"validation.max_length\": \"{field} must be at most {max} characters\",\n        \"validation.number\": \"Must be a number\",\n        \"validation.positive\": \"Must be a positive number\",\n        \"validation.url\": \"Invalid URL\",\n        \"validation.image\": \"Must be an image\",\n        \"validation.file_size\": \"File size too large\",\n        \"validation.file_type\": \"File type not supported\",\n        // Dashboard\n        \"dashboard.title\": \"Dashboard\",\n        \"dashboard.overview\": \"Overview\",\n        \"dashboard.analytics\": \"Analytics\",\n        \"dashboard.reports\": \"Reports\",\n        \"dashboard.settings\": \"Settings\",\n        \"dashboard.profile\": \"Profile\",\n        \"dashboard.notifications\": \"Notifications\",\n        \"dashboard.messages\": \"Messages\",\n        \"dashboard.orders\": \"Orders\",\n        \"dashboard.products\": \"Products\",\n        \"dashboard.customers\": \"Customers\",\n        \"dashboard.revenue\": \"Revenue\",\n        \"dashboard.sales\": \"Sales\",\n        \"dashboard.visitors\": \"Visitors\",\n        \"dashboard.conversion\": \"Conversion Rate\",\n        // Marketplace\n        \"marketplace.title\": \"Marketplace\",\n        \"marketplace.all_products\": \"All Products\",\n        \"marketplace.featured\": \"Featured\",\n        \"marketplace.new_arrivals\": \"New Arrivals\",\n        \"marketplace.best_sellers\": \"Best Sellers\",\n        \"marketplace.offers\": \"Offers\",\n        \"marketplace.categories\": \"Categories\",\n        \"marketplace.filters\": \"Filters\",\n        \"marketplace.sort_by\": \"Sort by\",\n        \"marketplace.price_low_high\": \"Price: Low to High\",\n        \"marketplace.price_high_low\": \"Price: High to Low\",\n        \"marketplace.newest\": \"Newest\",\n        \"marketplace.popular\": \"Most Popular\",\n        \"marketplace.rating\": \"Rating\",\n        \"marketplace.free_shipping\": \"Free Shipping\",\n        \"marketplace.in_stock\": \"In Stock\",\n        \"marketplace.out_of_stock\": \"Out of Stock\",\n        \"marketplace.add_to_cart\": \"Add to Cart\",\n        \"marketplace.buy_now\": \"Buy Now\",\n        \"marketplace.product_details\": \"Product Details\",\n        \"marketplace.product_description\": \"Product Description\",\n        \"marketplace.product_specifications\": \"Product Specifications\",\n        \"marketplace.product_reviews\": \"Product Reviews\",\n        \"marketplace.write_review\": \"Write Review\",\n        // Currency\n        \"currency.egp\": \"EGP\",\n        \"currency.usd\": \"$\",\n        \"currency.eur\": \"\",\n        \"currency.gbp\": \"\\xa3\",\n        // Time\n        \"time.now\": \"Now\",\n        \"time.minute_ago\": \"A minute ago\",\n        \"time.minutes_ago\": \"{count} minutes ago\",\n        \"time.hour_ago\": \"An hour ago\",\n        \"time.hours_ago\": \"{count} hours ago\",\n        \"time.day_ago\": \"A day ago\",\n        \"time.days_ago\": \"{count} days ago\",\n        \"time.week_ago\": \"A week ago\",\n        \"time.weeks_ago\": \"{count} weeks ago\",\n        \"time.month_ago\": \"A month ago\",\n        \"time.months_ago\": \"{count} months ago\",\n        \"time.year_ago\": \"A year ago\",\n        \"time.years_ago\": \"{count} years ago\"\n    }\n};\nconst LanguageContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nconst LanguageProvider = (param)=>{\n    let { children } = param;\n    _s();\n    const [language, setLanguage] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"ar\");\n    const [mounted, setMounted] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        setMounted(true);\n        // Check local storage or browser language on mount\n        const savedLanguage = localStorage.getItem(\"ray_language\");\n        const browserLang = navigator.language.startsWith(\"ar\") ? \"ar\" : \"en\";\n        const initialLang = savedLanguage || browserLang;\n        setLanguage(initialLang);\n        localStorage.setItem(\"ray_language\", initialLang);\n        // Update document direction and lang\n        document.documentElement.dir = initialLang === \"ar\" ? \"rtl\" : \"ltr\";\n        document.documentElement.lang = initialLang;\n    }, []);\n    const toggleLanguage = ()=>{\n        const newLang = language === \"ar\" ? \"en\" : \"ar\";\n        setLanguage(newLang);\n        localStorage.setItem(\"ray_language\", newLang);\n        // Update document direction and lang\n        document.documentElement.dir = newLang === \"ar\" ? \"rtl\" : \"ltr\";\n        document.documentElement.lang = newLang;\n    };\n    const setLanguageHandler = (lang)=>{\n        setLanguage(lang);\n        localStorage.setItem(\"ray_language\", lang);\n        // Update document direction and lang\n        document.documentElement.dir = lang === \"ar\" ? \"rtl\" : \"ltr\";\n        document.documentElement.lang = lang;\n    };\n    const t = (key)=>{\n        const translation = translations[language][key];\n        return translation || key;\n    };\n    const direction = language === \"ar\" ? \"rtl\" : \"ltr\";\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(LanguageContext.Provider, {\n        value: {\n            language,\n            direction,\n            toggleLanguage,\n            setLanguage: setLanguageHandler,\n            t\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\Dream\\\\ray-egypt-8\\\\context\\\\LanguageContext.tsx\",\n        lineNumber: 427,\n        columnNumber: 5\n    }, undefined);\n};\n_s(LanguageProvider, \"OrFYPTD0SZRN77xkuvbXZ3gGFpE=\");\n_c = LanguageProvider;\nconst useLanguage = ()=>{\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(LanguageContext);\n    if (!context) {\n        throw new Error(\"useLanguage must be used within a LanguageProvider\");\n    }\n    return context;\n};\n_s1(useLanguage, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"LanguageProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbnRleHQvTGFuZ3VhZ2VDb250ZXh0LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBRThFO0FBYTlFLE1BQU1LLGVBQWU7SUFDbkJDLElBQUk7UUFDRixhQUFhO1FBQ2IsWUFBWTtRQUNaLGNBQWM7UUFDZCxZQUFZO1FBQ1osaUJBQWlCO1FBQ2pCLGVBQWU7UUFDZixhQUFhO1FBQ2IsZ0JBQWdCO1FBQ2hCLGNBQWM7UUFDZCxjQUFjO1FBQ2Qsa0JBQWtCO1FBQ2xCLHlCQUF5QjtRQUV6QixhQUFhO1FBQ2IsbUJBQW1CO1FBQ25CLGdCQUFnQjtRQUNoQixnQkFBZ0I7UUFDaEIsY0FBYztRQUNkLGlCQUFpQjtRQUNqQixxQkFBcUI7UUFDckIsa0JBQWtCO1FBQ2xCLG1CQUFtQjtRQUNuQixjQUFjO1FBQ2QsY0FBYztRQUNkLGtCQUFrQjtRQUVsQixTQUFTO1FBQ1Qsa0JBQWtCO1FBQ2xCLGdCQUFnQjtRQUNoQixrQkFBa0I7UUFDbEIsaUJBQWlCO1FBQ2pCLGVBQWU7UUFDZixlQUFlO1FBQ2YsaUJBQWlCO1FBQ2pCLGNBQWM7UUFDZCxlQUFlO1FBQ2YsZUFBZTtRQUNmLGVBQWU7UUFDZixnQkFBZ0I7UUFDaEIsZUFBZTtRQUNmLGVBQWU7UUFDZixtQkFBbUI7UUFDbkIsaUJBQWlCO1FBQ2pCLGdCQUFnQjtRQUNoQixnQkFBZ0I7UUFDaEIsaUJBQWlCO1FBQ2pCLGVBQWU7UUFDZixpQkFBaUI7UUFDakIsY0FBYztRQUNkLGVBQWU7UUFDZixjQUFjO1FBQ2QsYUFBYTtRQUNiLGFBQWE7UUFDYixlQUFlO1FBQ2YsbUJBQW1CO1FBQ25CLGlCQUFpQjtRQUNqQixnQkFBZ0I7UUFDaEIsZUFBZTtRQUNmLGdCQUFnQjtRQUNoQixlQUFlO1FBRWYsV0FBVztRQUNYLGtCQUFrQjtRQUNsQixxQkFBcUI7UUFDckIsb0JBQW9CO1FBQ3BCLHdCQUF3QjtRQUN4QixxQkFBcUI7UUFDckIseUJBQXlCO1FBQ3pCLHVCQUF1QjtRQUN2Qixz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QUFjOztJQUN6QixNQUFNQyxVQUFVcEMsaURBQVVBLENBQUNNO0lBQzNCLElBQUksQ0FBQzhCLFNBQVM7UUFDWixNQUFNLElBQUlDLE1BQU07SUFDbEI7SUFDQSxPQUFPRDtBQUNULEVBQUU7SUFOV0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29udGV4dC9MYW5ndWFnZUNvbnRleHQudHN4P2E3NzkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XHJcblxyXG5pbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuXHJcbnR5cGUgTGFuZ3VhZ2UgPSAnYXInIHwgJ2VuJztcclxudHlwZSBEaXJlY3Rpb24gPSAncnRsJyB8ICdsdHInO1xyXG5cclxuaW50ZXJmYWNlIExhbmd1YWdlQ29udGV4dFR5cGUge1xyXG4gIGxhbmd1YWdlOiBMYW5ndWFnZTtcclxuICBkaXJlY3Rpb246IERpcmVjdGlvbjtcclxuICB0b2dnbGVMYW5ndWFnZTogKCkgPT4gdm9pZDtcclxuICBzZXRMYW5ndWFnZTogKGxhbmc6IExhbmd1YWdlKSA9PiB2b2lkO1xyXG4gIHQ6IChrZXk6IHN0cmluZykgPT4gc3RyaW5nO1xyXG59XHJcblxyXG5jb25zdCB0cmFuc2xhdGlvbnMgPSB7XHJcbiAgYXI6IHtcclxuICAgIC8vIE5hdmlnYXRpb25cclxuICAgICduYXYuaG9tZSc6ICfYp9mE2LHYptmK2LPZitipJyxcclxuICAgICduYXYub2ZmZXJzJzogJ9in2YTYudix2YjYtiDZiNin2YTYrti12YjZhdin2KonLFxyXG4gICAgJ25hdi5jYXJ0JzogJ9in2YTYs9mE2KknLFxyXG4gICAgJ25hdi5mYXZvcml0ZXMnOiAn2KfZhNmF2YHYttmE2KknLFxyXG4gICAgJ25hdi5wcm9maWxlJzogJ9it2LPYp9io2YonLFxyXG4gICAgJ25hdi5sb2dpbic6ICfYqtiz2KzZitmEINin2YTYr9iu2YjZhCcsXHJcbiAgICAnbmF2LnJlZ2lzdGVyJzogJ9il2YbYtNin2KEg2K3Ys9in2KgnLFxyXG4gICAgJ25hdi5sb2dvdXQnOiAn2KrYs9is2YrZhCDYp9mE2K7YsdmI2KwnLFxyXG4gICAgJ25hdi5zZWFyY2gnOiAn2KjYrdirLi4uJyxcclxuICAgICduYXYuY2F0ZWdvcmllcyc6ICfYp9mE2KPZgtiz2KfZhScsXHJcbiAgICAnbmF2LnJlZ2lzdGVyX2J1c2luZXNzJzogJ9iz2KzZkdmEINmG2LTYp9i32YMgKNiq2KzYp9ixKScsXHJcbiAgICBcclxuICAgIC8vIENhdGVnb3JpZXNcclxuICAgICdjYXQucmVzdGF1cmFudHMnOiAn2YXYt9in2LnZhScsXHJcbiAgICAnY2F0LnNob3BwaW5nJzogJ9iq2LPZiNmCJyxcclxuICAgICdjYXQuc2VydmljZXMnOiAn2K7Yr9mF2KfYqicsXHJcbiAgICAnY2F0LmhlYWx0aCc6ICfYtdit2KknLFxyXG4gICAgJ2NhdC5lZHVjYXRpb24nOiAn2KrYudmE2YrZhScsXHJcbiAgICAnY2F0LmVudGVydGFpbm1lbnQnOiAn2KrYsdmB2YrZhycsXHJcbiAgICAnY2F0LmF1dG9tb3RpdmUnOiAn2LPZitin2LHYp9iqJyxcclxuICAgICdjYXQucmVhbF9lc3RhdGUnOiAn2LnZgtin2LHYp9iqJyxcclxuICAgICdjYXQuYmVhdXR5JzogJ9is2YXYp9mEJyxcclxuICAgICdjYXQuc3BvcnRzJzogJ9ix2YrYp9i22KknLFxyXG4gICAgJ2NhdC50ZWNobm9sb2d5JzogJ9iq2YLZhtmK2KknLFxyXG4gICAgXHJcbiAgICAvLyBDb21tb25cclxuICAgICdjb21tb24ubG9hZGluZyc6ICfYrNin2LHZiiDYp9mE2KrYrdmF2YrZhC4uLicsXHJcbiAgICAnY29tbW9uLmVycm9yJzogJ9it2K/YqyDYrti32KMnLFxyXG4gICAgJ2NvbW1vbi5zdWNjZXNzJzogJ9iq2YUg2KjZhtis2KfYrScsXHJcbiAgICAnY29tbW9uLmNhbmNlbCc6ICfYpdmE2LrYp9ihJyxcclxuICAgICdjb21tb24uc2F2ZSc6ICfYrdmB2LgnLFxyXG4gICAgJ2NvbW1vbi5lZGl0JzogJ9iq2LnYr9mK2YQnLFxyXG4gICAgJ2NvbW1vbi5kZWxldGUnOiAn2K3YsNmBJyxcclxuICAgICdjb21tb24uYWRkJzogJ9il2LbYp9mB2KknLFxyXG4gICAgJ2NvbW1vbi52aWV3JzogJ9i52LHYticsXHJcbiAgICAnY29tbW9uLm1vcmUnOiAn2KfZhNmF2LLZitivJyxcclxuICAgICdjb21tb24ubGVzcyc6ICfYo9mC2YQnLFxyXG4gICAgJ2NvbW1vbi5jbG9zZSc6ICfYpdi62YTYp9mCJyxcclxuICAgICdjb21tb24ub3Blbic6ICfZgdiq2K0nLFxyXG4gICAgJ2NvbW1vbi5uZXh0JzogJ9in2YTYqtin2YTZiicsXHJcbiAgICAnY29tbW9uLnByZXZpb3VzJzogJ9in2YTYs9in2KjZgicsXHJcbiAgICAnY29tbW9uLnN1Ym1pdCc6ICfYpdix2LPYp9mEJyxcclxuICAgICdjb21tb24ucmVzZXQnOiAn2KXYudin2K/YqSDYqti52YrZitmGJyxcclxuICAgICdjb21tb24uY2xlYXInOiAn2YXYs9itJyxcclxuICAgICdjb21tb24uZmlsdGVyJzogJ9iq2LXZgdmK2KknLFxyXG4gICAgJ2NvbW1vbi5zb3J0JzogJ9iq2LHYqtmK2KgnLFxyXG4gICAgJ2NvbW1vbi5zZWFyY2gnOiAn2KjYrdirJyxcclxuICAgICdjb21tb24uYWxsJzogJ9in2YTZg9mEJyxcclxuICAgICdjb21tb24ubm9uZSc6ICfZhNinINi02YrYoScsXHJcbiAgICAnY29tbW9uLnllcyc6ICfZhti52YUnLFxyXG4gICAgJ2NvbW1vbi5ubyc6ICfZhNinJyxcclxuICAgICdjb21tb24ub2snOiAn2YXZiNin2YHZgicsXHJcbiAgICAnY29tbW9uLmJhY2snOiAn2LHYrNmI2LknLFxyXG4gICAgJ2NvbW1vbi5jb250aW51ZSc6ICfZhdiq2KfYqNi52KknLFxyXG4gICAgJ2NvbW1vbi5maW5pc2gnOiAn2KXZhtmH2KfYoScsXHJcbiAgICAnY29tbW9uLnN0YXJ0JzogJ9io2K/YoScsXHJcbiAgICAnY29tbW9uLnN0b3AnOiAn2KXZitmC2KfZgScsXHJcbiAgICAnY29tbW9uLnBhdXNlJzogJ9il2YrZgtin2YEg2YXYpNmC2KonLFxyXG4gICAgJ2NvbW1vbi5wbGF5JzogJ9iq2LTYutmK2YQnLFxyXG4gICAgXHJcbiAgICAvLyBNZXNzYWdlc1xyXG4gICAgJ21zZy5ub19yZXN1bHRzJzogJ9mE2Kcg2KrZiNis2K8g2YbYqtin2KbYrCcsXHJcbiAgICAnbXNnLm5ldHdvcmtfZXJyb3InOiAn2K7Yt9ijINmB2Yog2KfZhNin2KrYtdin2YQg2KjYp9mE2LTYqNmD2KknLFxyXG4gICAgJ21zZy5zZXJ2ZXJfZXJyb3InOiAn2K7Yt9ijINmB2Yog2KfZhNiu2KfYr9mFJyxcclxuICAgICdtc2cudmFsaWRhdGlvbl9lcnJvcic6ICfYrti32KMg2YHZiiDYp9mE2KrYrdmC2YIg2YXZhiDYp9mE2KjZitin2YbYp9iqJyxcclxuICAgICdtc2cuYXV0aF9yZXF1aXJlZCc6ICfZitis2Kgg2KrYs9is2YrZhCDYp9mE2K/YrtmI2YQg2KPZiNmE2KfZiycsXHJcbiAgICAnbXNnLnBlcm1pc3Npb25fZGVuaWVkJzogJ9mE2YrYsyDZhNiv2YrZgyDYtdmE2KfYrdmK2Kkg2YTZhNmC2YrYp9mFINio2YfYsNinJyxcclxuICAgICdtc2cuc2Vzc2lvbl9leHBpcmVkJzogJ9in2YbYqtmH2Kog2KfZhNis2YTYs9ip2Iwg2YrYsdis2Ykg2KrYs9is2YrZhCDYp9mE2K/YrtmI2YQg2YXYsdipINij2K7YsdmJJyxcclxuICAgICdtc2cuY29uZmlybV9kZWxldGUnOiAn2YfZhCDYo9mG2Kog2YXYqtij2YPYryDZhdmGINin2YTYrdiw2YHYnycsXHJcbiAgICAnbXNnLmNvbmZpcm1fbG9nb3V0JzogJ9mH2YQg2KPZhtiqINmF2KrYo9mD2K8g2YXZhiDYqtiz2KzZitmEINin2YTYrtix2YjYrNifJyxcclxuICAgICdtc2cuc2F2ZWRfc3VjY2Vzc2Z1bGx5JzogJ9iq2YUg2KfZhNit2YHYuCDYqNmG2KzYp9itJyxcclxuICAgICdtc2cudXBkYXRlZF9zdWNjZXNzZnVsbHknOiAn2KrZhSDYp9mE2KrYrdiv2YrYqyDYqNmG2KzYp9itJyxcclxuICAgICdtc2cuZGVsZXRlZF9zdWNjZXNzZnVsbHknOiAn2KrZhSDYp9mE2K3YsNmBINio2YbYrNin2K0nLFxyXG4gICAgJ21zZy5hZGRlZF9zdWNjZXNzZnVsbHknOiAn2KrZhdiqINin2YTYpdi22KfZgdipINio2YbYrNin2K0nLFxyXG4gICAgJ21zZy5sb2dpbl9zdWNjZXNzZnVsbHknOiAn2KrZhSDYqtiz2KzZitmEINin2YTYr9iu2YjZhCDYqNmG2KzYp9itJyxcclxuICAgICdtc2cubG9nb3V0X3N1Y2Nlc3NmdWxseSc6ICfYqtmFINiq2LPYrNmK2YQg2KfZhNiu2LHZiNisINio2YbYrNin2K0nLFxyXG4gICAgXHJcbiAgICAvLyBGb3Jtc1xyXG4gICAgJ2Zvcm0ubmFtZSc6ICfYp9mE2KfYs9mFJyxcclxuICAgICdmb3JtLmVtYWlsJzogJ9in2YTYqNix2YrYryDYp9mE2KXZhNmD2KrYsdmI2YbZiicsXHJcbiAgICAnZm9ybS5waG9uZSc6ICfYsdmC2YUg2KfZhNmH2KfYqtmBJyxcclxuICAgICdmb3JtLnBhc3N3b3JkJzogJ9mD2YTZhdipINin2YTZhdix2YjYsScsXHJcbiAgICAnZm9ybS5jb25maXJtX3Bhc3N3b3JkJzogJ9iq2KPZg9mK2K8g2YPZhNmF2Kkg2KfZhNmF2LHZiNixJyxcclxuICAgICdmb3JtLmFkZHJlc3MnOiAn2KfZhNi52YbZiNin2YYnLFxyXG4gICAgJ2Zvcm0uY2l0eSc6ICfYp9mE2YXYr9mK2YbYqScsXHJcbiAgICAnZm9ybS5jb3VudHJ5JzogJ9in2YTYr9mI2YTYqScsXHJcbiAgICAnZm9ybS5wb3N0YWxfY29kZSc6ICfYp9mE2LHZhdiyINin2YTYqNix2YrYr9mKJyxcclxuICAgICdmb3JtLmRlc2NyaXB0aW9uJzogJ9in2YTZiNi12YEnLFxyXG4gICAgJ2Zvcm0ucHJpY2UnOiAn2KfZhNiz2LnYsScsXHJcbiAgICAnZm9ybS5xdWFudGl0eSc6ICfYp9mE2YPZhdmK2KknLFxyXG4gICAgJ2Zvcm0uY2F0ZWdvcnknOiAn2KfZhNmB2KbYqScsXHJcbiAgICAnZm9ybS5zdWJjYXRlZ29yeSc6ICfYp9mE2YHYptipINin2YTZgdix2LnZitipJyxcclxuICAgICdmb3JtLmltYWdlJzogJ9in2YTYtdmI2LHYqScsXHJcbiAgICAnZm9ybS5pbWFnZXMnOiAn2KfZhNi12YjYsScsXHJcbiAgICAnZm9ybS53ZWJzaXRlJzogJ9in2YTZhdmI2YLYuSDYp9mE2KXZhNmD2KrYsdmI2YbZiicsXHJcbiAgICAnZm9ybS5zb2NpYWxfbWVkaWEnOiAn2YjYs9in2KbZhCDYp9mE2KrZiNin2LXZhCDYp9mE2KfYrNiq2YXYp9i52YonLFxyXG4gICAgJ2Zvcm0ud29ya2luZ19ob3Vycyc6ICfYs9in2LnYp9iqINin2YTYudmF2YQnLFxyXG4gICAgJ2Zvcm0uY29udGFjdF9pbmZvJzogJ9mF2LnZhNmI2YXYp9iqINin2YTYp9iq2LXYp9mEJyxcclxuICAgIFxyXG4gICAgLy8gVmFsaWRhdGlvblxyXG4gICAgJ3ZhbGlkYXRpb24ucmVxdWlyZWQnOiAn2YfYsNinINin2YTYrdmC2YQg2YXYt9mE2YjYqCcsXHJcbiAgICAndmFsaWRhdGlvbi5lbWFpbCc6ICfYp9mE2KjYsdmK2K8g2KfZhNil2YTZg9iq2LHZiNmG2Yog2LrZitixINi12K3ZititJyxcclxuICAgICd2YWxpZGF0aW9uLnBob25lJzogJ9ix2YLZhSDYp9mE2YfYp9iq2YEg2LrZitixINi12K3ZititJyxcclxuICAgICd2YWxpZGF0aW9uLnBhc3N3b3JkX21pbic6ICfZg9mE2YXYqSDYp9mE2YXYsdmI2LEg2YrYrNioINij2YYg2KrZg9mI2YYgOCDYo9it2LHZgSDYudmE2Ykg2KfZhNij2YLZhCcsXHJcbiAgICAndmFsaWRhdGlvbi5wYXNzd29yZF9tYXRjaCc6ICfZg9mE2YXYp9iqINin2YTZhdix2YjYsSDYutmK2LEg2YXYqti32KfYqNmC2KknLFxyXG4gICAgJ3ZhbGlkYXRpb24ubWluX2xlbmd0aCc6ICfZitis2Kgg2KPZhiDZitmD2YjZhiB7ZmllbGR9INi52YTZiSDYp9mE2KPZgtmEIHttaW59INij2K3YsdmBJyxcclxuICAgICd2YWxpZGF0aW9uLm1heF9sZW5ndGgnOiAn2YrYrNioINij2YYg2YrZg9mI2YYge2ZpZWxkfSDYudmE2Ykg2KfZhNij2YPYq9ixIHttYXh9INij2K3YsdmBJyxcclxuICAgICd2YWxpZGF0aW9uLm51bWJlcic6ICfZitis2Kgg2KPZhiDZitmD2YjZhiDYsdmC2YXYp9mLJyxcclxuICAgICd2YWxpZGF0aW9uLnBvc2l0aXZlJzogJ9mK2KzYqCDYo9mGINmK2YPZiNmGINix2YLZhdin2Ysg2YXZiNis2KjYp9mLJyxcclxuICAgICd2YWxpZGF0aW9uLnVybCc6ICfYp9mE2LHYp9io2Lcg2LrZitixINi12K3ZititJyxcclxuICAgICd2YWxpZGF0aW9uLmltYWdlJzogJ9mK2KzYqCDYo9mGINmK2YPZiNmGINi12YjYsdipJyxcclxuICAgICd2YWxpZGF0aW9uLmZpbGVfc2l6ZSc6ICfYrdis2YUg2KfZhNmF2YTZgSDZg9io2YrYsSDYrNiv2KfZiycsXHJcbiAgICAndmFsaWRhdGlvbi5maWxlX3R5cGUnOiAn2YbZiNi5INin2YTZhdmE2YEg2LrZitixINmF2K/YudmI2YUnLFxyXG4gICAgXHJcbiAgICAvLyBEYXNoYm9hcmRcclxuICAgICdkYXNoYm9hcmQudGl0bGUnOiAn2YTZiNit2Kkg2KfZhNiq2K3Zg9mFJyxcclxuICAgICdkYXNoYm9hcmQub3ZlcnZpZXcnOiAn2YbYuNix2Kkg2LnYp9mF2KknLFxyXG4gICAgJ2Rhc2hib2FyZC5hbmFseXRpY3MnOiAn2KfZhNiq2K3ZhNmK2YTYp9iqJyxcclxuICAgICdkYXNoYm9hcmQucmVwb3J0cyc6ICfYp9mE2KrZgtin2LHZitixJyxcclxuICAgICdkYXNoYm9hcmQuc2V0dGluZ3MnOiAn2KfZhNil2LnYr9in2K/Yp9iqJyxcclxuICAgICdkYXNoYm9hcmQucHJvZmlsZSc6ICfYp9mE2YXZhNmBINin2YTYtNiu2LXZiicsXHJcbiAgICAnZGFzaGJvYXJkLm5vdGlmaWNhdGlvbnMnOiAn2KfZhNil2LTYudin2LHYp9iqJyxcclxuICAgICdkYXNoYm9hcmQubWVzc2FnZXMnOiAn2KfZhNix2LPYp9im2YQnLFxyXG4gICAgJ2Rhc2hib2FyZC5vcmRlcnMnOiAn2KfZhNi32YTYqNin2KonLFxyXG4gICAgJ2Rhc2hib2FyZC5wcm9kdWN0cyc6ICfYp9mE2YXZhtiq2KzYp9iqJyxcclxuICAgICdkYXNoYm9hcmQuY3VzdG9tZXJzJzogJ9in2YTYudmF2YTYp9ihJyxcclxuICAgICdkYXNoYm9hcmQucmV2ZW51ZSc6ICfYp9mE2KXZitix2KfYr9in2KonLFxyXG4gICAgJ2Rhc2hib2FyZC5zYWxlcyc6ICfYp9mE2YXYqNmK2LnYp9iqJyxcclxuICAgICdkYXNoYm9hcmQudmlzaXRvcnMnOiAn2KfZhNiy2YjYp9ixJyxcclxuICAgICdkYXNoYm9hcmQuY29udmVyc2lvbic6ICfZhdi52K/ZhCDYp9mE2KrYrdmI2YrZhCcsXHJcbiAgICBcclxuICAgIC8vIE1hcmtldHBsYWNlXHJcbiAgICAnbWFya2V0cGxhY2UudGl0bGUnOiAn2KfZhNiz2YjZgicsXHJcbiAgICAnbWFya2V0cGxhY2UuYWxsX3Byb2R1Y3RzJzogJ9is2YXZiti5INin2YTZhdmG2KrYrNin2KonLFxyXG4gICAgJ21hcmtldHBsYWNlLmZlYXR1cmVkJzogJ9in2YTZhdmF2YrYstipJyxcclxuICAgICdtYXJrZXRwbGFjZS5uZXdfYXJyaXZhbHMnOiAn2KfZhNmI2KfZgdiv2YjZhiDYp9mE2KzYr9ivJyxcclxuICAgICdtYXJrZXRwbGFjZS5iZXN0X3NlbGxlcnMnOiAn2KfZhNij2YPYq9ixINmF2KjZiti52KfZiycsXHJcbiAgICAnbWFya2V0cGxhY2Uub2ZmZXJzJzogJ9in2YTYudix2YjYticsXHJcbiAgICAnbWFya2V0cGxhY2UuY2F0ZWdvcmllcyc6ICfYp9mE2YHYptin2KonLFxyXG4gICAgJ21hcmtldHBsYWNlLmZpbHRlcnMnOiAn2KfZhNmB2YTYp9iq2LEnLFxyXG4gICAgJ21hcmtldHBsYWNlLnNvcnRfYnknOiAn2KrYsdiq2YrYqCDYrdiz2KgnLFxyXG4gICAgJ21hcmtldHBsYWNlLnByaWNlX2xvd19oaWdoJzogJ9in2YTYs9i52LE6INmF2YYg2KfZhNij2YLZhCDZhNmE2KPYudmE2YknLFxyXG4gICAgJ21hcmtldHBsYWNlLnByaWNlX2hpZ2hfbG93JzogJ9in2YTYs9i52LE6INmF2YYg2KfZhNij2LnZhNmJINmE2YTYo9mC2YQnLFxyXG4gICAgJ21hcmtldHBsYWNlLm5ld2VzdCc6ICfYp9mE2KPYrdiv2KsnLFxyXG4gICAgJ21hcmtldHBsYWNlLnBvcHVsYXInOiAn2KfZhNij2YPYq9ixINi02LnYqNmK2KknLFxyXG4gICAgJ21hcmtldHBsYWNlLnJhdGluZyc6ICfYp9mE2KrZgtmK2YrZhScsXHJcbiAgICAnbWFya2V0cGxhY2UuZnJlZV9zaGlwcGluZyc6ICfYtNit2YYg2YXYrNin2YbZiicsXHJcbiAgICAnbWFya2V0cGxhY2UuaW5fc3RvY2snOiAn2YXYqtmI2YHYsScsXHJcbiAgICAnbWFya2V0cGxhY2Uub3V0X29mX3N0b2NrJzogJ9mG2YHYryDYp9mE2YXYrtiy2YjZhicsXHJcbiAgICAnbWFya2V0cGxhY2UuYWRkX3RvX2NhcnQnOiAn2KPYttmBINmE2YTYs9mE2KknLFxyXG4gICAgJ21hcmtldHBsYWNlLmJ1eV9ub3cnOiAn2KfYtNiq2LEg2KfZhNii2YYnLFxyXG4gICAgJ21hcmtldHBsYWNlLnByb2R1Y3RfZGV0YWlscyc6ICfYqtmB2KfYtdmK2YQg2KfZhNmF2YbYqtisJyxcclxuICAgICdtYXJrZXRwbGFjZS5wcm9kdWN0X2Rlc2NyaXB0aW9uJzogJ9mI2LXZgSDYp9mE2YXZhtiq2KwnLFxyXG4gICAgJ21hcmtldHBsYWNlLnByb2R1Y3Rfc3BlY2lmaWNhdGlvbnMnOiAn2YXZiNin2LXZgdin2Kog2KfZhNmF2YbYqtisJyxcclxuICAgICdtYXJrZXRwbGFjZS5wcm9kdWN0X3Jldmlld3MnOiAn2YXYsdin2KzYudin2Kog2KfZhNmF2YbYqtisJyxcclxuICAgICdtYXJrZXRwbGFjZS53cml0ZV9yZXZpZXcnOiAn2YPYqtin2KjYqSDZhdix2KfYrNi52KknLFxyXG4gICAgXHJcbiAgICAvLyBDdXJyZW5jeVxyXG4gICAgJ2N1cnJlbmN5LmVncCc6ICfYrC7ZhScsXHJcbiAgICAnY3VycmVuY3kudXNkJzogJyQnLFxyXG4gICAgJ2N1cnJlbmN5LmV1cic6ICfigqwnLFxyXG4gICAgJ2N1cnJlbmN5LmdicCc6ICfCoycsXHJcbiAgICBcclxuICAgIC8vIFRpbWVcclxuICAgICd0aW1lLm5vdyc6ICfYp9mE2KLZhicsXHJcbiAgICAndGltZS5taW51dGVfYWdvJzogJ9mF2YbYsCDYr9mC2YrZgtipJyxcclxuICAgICd0aW1lLm1pbnV0ZXNfYWdvJzogJ9mF2YbYsCB7Y291bnR9INiv2YLYp9im2YInLFxyXG4gICAgJ3RpbWUuaG91cl9hZ28nOiAn2YXZhtiwINiz2KfYudipJyxcclxuICAgICd0aW1lLmhvdXJzX2Fnbyc6ICfZhdmG2LAge2NvdW50fSDYs9in2LnYp9iqJyxcclxuICAgICd0aW1lLmRheV9hZ28nOiAn2YXZhtiwINmK2YjZhScsXHJcbiAgICAndGltZS5kYXlzX2Fnbyc6ICfZhdmG2LAge2NvdW50fSDYo9mK2KfZhScsXHJcbiAgICAndGltZS53ZWVrX2Fnbyc6ICfZhdmG2LAg2KPYs9io2YjYuScsXHJcbiAgICAndGltZS53ZWVrc19hZ28nOiAn2YXZhtiwIHtjb3VudH0g2KPYs9in2KjZiti5JyxcclxuICAgICd0aW1lLm1vbnRoX2Fnbyc6ICfZhdmG2LAg2LTZh9ixJyxcclxuICAgICd0aW1lLm1vbnRoc19hZ28nOiAn2YXZhtiwIHtjb3VudH0g2KPYtNmH2LEnLFxyXG4gICAgJ3RpbWUueWVhcl9hZ28nOiAn2YXZhtiwINi52KfZhScsXHJcbiAgICAndGltZS55ZWFyc19hZ28nOiAn2YXZhtiwIHtjb3VudH0g2KPYudmI2KfZhScsXHJcbiAgfSxcclxuICBlbjoge1xyXG4gICAgLy8gTmF2aWdhdGlvblxyXG4gICAgJ25hdi5ob21lJzogJ0hvbWUnLFxyXG4gICAgJ25hdi5vZmZlcnMnOiAnT2ZmZXJzICYgRGlzY291bnRzJyxcclxuICAgICduYXYuY2FydCc6ICdDYXJ0JyxcclxuICAgICduYXYuZmF2b3JpdGVzJzogJ0Zhdm9yaXRlcycsXHJcbiAgICAnbmF2LnByb2ZpbGUnOiAnTXkgQWNjb3VudCcsXHJcbiAgICAnbmF2LmxvZ2luJzogJ0xvZ2luJyxcclxuICAgICduYXYucmVnaXN0ZXInOiAnUmVnaXN0ZXInLFxyXG4gICAgJ25hdi5sb2dvdXQnOiAnTG9nb3V0JyxcclxuICAgICduYXYuc2VhcmNoJzogJ1NlYXJjaC4uLicsXHJcbiAgICAnbmF2LmNhdGVnb3JpZXMnOiAnQ2F0ZWdvcmllcycsXHJcbiAgICAnbmF2LnJlZ2lzdGVyX2J1c2luZXNzJzogJ1JlZ2lzdGVyIFlvdXIgQnVzaW5lc3MgKE1lcmNoYW50cyknLFxyXG4gICAgXHJcbiAgICAvLyBDYXRlZ29yaWVzXHJcbiAgICAnY2F0LnJlc3RhdXJhbnRzJzogJ1Jlc3RhdXJhbnRzJyxcclxuICAgICdjYXQuc2hvcHBpbmcnOiAnU2hvcHBpbmcnLFxyXG4gICAgJ2NhdC5zZXJ2aWNlcyc6ICdTZXJ2aWNlcycsXHJcbiAgICAnY2F0LmhlYWx0aCc6ICdIZWFsdGgnLFxyXG4gICAgJ2NhdC5lZHVjYXRpb24nOiAnRWR1Y2F0aW9uJyxcclxuICAgICdjYXQuZW50ZXJ0YWlubWVudCc6ICdFbnRlcnRhaW5tZW50JyxcclxuICAgICdjYXQuYXV0b21vdGl2ZSc6ICdBdXRvbW90aXZlJyxcclxuICAgICdjYXQucmVhbF9lc3RhdGUnOiAnUmVhbCBFc3RhdGUnLFxyXG4gICAgJ2NhdC5iZWF1dHknOiAnQmVhdXR5JyxcclxuICAgICdjYXQuc3BvcnRzJzogJ1Nwb3J0cycsXHJcbiAgICAnY2F0LnRlY2hub2xvZ3knOiAnVGVjaG5vbG9neScsXHJcbiAgICBcclxuICAgIC8vIENvbW1vblxyXG4gICAgJ2NvbW1vbi5sb2FkaW5nJzogJ0xvYWRpbmcuLi4nLFxyXG4gICAgJ2NvbW1vbi5lcnJvcic6ICdFcnJvciBvY2N1cnJlZCcsXHJcbiAgICAnY29tbW9uLnN1Y2Nlc3MnOiAnU3VjY2VzcycsXHJcbiAgICAnY29tbW9uLmNhbmNlbCc6ICdDYW5jZWwnLFxyXG4gICAgJ2NvbW1vbi5zYXZlJzogJ1NhdmUnLFxyXG4gICAgJ2NvbW1vbi5lZGl0JzogJ0VkaXQnLFxyXG4gICAgJ2NvbW1vbi5kZWxldGUnOiAnRGVsZXRlJyxcclxuICAgICdjb21tb24uYWRkJzogJ0FkZCcsXHJcbiAgICAnY29tbW9uLnZpZXcnOiAnVmlldycsXHJcbiAgICAnY29tbW9uLm1vcmUnOiAnTW9yZScsXHJcbiAgICAnY29tbW9uLmxlc3MnOiAnTGVzcycsXHJcbiAgICAnY29tbW9uLmNsb3NlJzogJ0Nsb3NlJyxcclxuICAgICdjb21tb24ub3Blbic6ICdPcGVuJyxcclxuICAgICdjb21tb24ubmV4dCc6ICdOZXh0JyxcclxuICAgICdjb21tb24ucHJldmlvdXMnOiAnUHJldmlvdXMnLFxyXG4gICAgJ2NvbW1vbi5zdWJtaXQnOiAnU3VibWl0JyxcclxuICAgICdjb21tb24ucmVzZXQnOiAnUmVzZXQnLFxyXG4gICAgJ2NvbW1vbi5jbGVhcic6ICdDbGVhcicsXHJcbiAgICAnY29tbW9uLmZpbHRlcic6ICdGaWx0ZXInLFxyXG4gICAgJ2NvbW1vbi5zb3J0JzogJ1NvcnQnLFxyXG4gICAgJ2NvbW1vbi5zZWFyY2gnOiAnU2VhcmNoJyxcclxuICAgICdjb21tb24uYWxsJzogJ0FsbCcsXHJcbiAgICAnY29tbW9uLm5vbmUnOiAnTm9uZScsXHJcbiAgICAnY29tbW9uLnllcyc6ICdZZXMnLFxyXG4gICAgJ2NvbW1vbi5ubyc6ICdObycsXHJcbiAgICAnY29tbW9uLm9rJzogJ09LJyxcclxuICAgICdjb21tb24uYmFjayc6ICdCYWNrJyxcclxuICAgICdjb21tb24uY29udGludWUnOiAnQ29udGludWUnLFxyXG4gICAgJ2NvbW1vbi5maW5pc2gnOiAnRmluaXNoJyxcclxuICAgICdjb21tb24uc3RhcnQnOiAnU3RhcnQnLFxyXG4gICAgJ2NvbW1vbi5zdG9wJzogJ1N0b3AnLFxyXG4gICAgJ2NvbW1vbi5wYXVzZSc6ICdQYXVzZScsXHJcbiAgICAnY29tbW9uLnBsYXknOiAnUGxheScsXHJcbiAgICBcclxuICAgIC8vIE1lc3NhZ2VzXHJcbiAgICAnbXNnLm5vX3Jlc3VsdHMnOiAnTm8gcmVzdWx0cyBmb3VuZCcsXHJcbiAgICAnbXNnLm5ldHdvcmtfZXJyb3InOiAnTmV0d29yayBlcnJvcicsXHJcbiAgICAnbXNnLnNlcnZlcl9lcnJvcic6ICdTZXJ2ZXIgZXJyb3InLFxyXG4gICAgJ21zZy52YWxpZGF0aW9uX2Vycm9yJzogJ1ZhbGlkYXRpb24gZXJyb3InLFxyXG4gICAgJ21zZy5hdXRoX3JlcXVpcmVkJzogJ0F1dGhlbnRpY2F0aW9uIHJlcXVpcmVkJyxcclxuICAgICdtc2cucGVybWlzc2lvbl9kZW5pZWQnOiAnUGVybWlzc2lvbiBkZW5pZWQnLFxyXG4gICAgJ21zZy5zZXNzaW9uX2V4cGlyZWQnOiAnU2Vzc2lvbiBleHBpcmVkLCBwbGVhc2UgbG9naW4gYWdhaW4nLFxyXG4gICAgJ21zZy5jb25maXJtX2RlbGV0ZSc6ICdBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZGVsZXRlPycsXHJcbiAgICAnbXNnLmNvbmZpcm1fbG9nb3V0JzogJ0FyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBsb2dvdXQ/JyxcclxuICAgICdtc2cuc2F2ZWRfc3VjY2Vzc2Z1bGx5JzogJ1NhdmVkIHN1Y2Nlc3NmdWxseScsXHJcbiAgICAnbXNnLnVwZGF0ZWRfc3VjY2Vzc2Z1bGx5JzogJ1VwZGF0ZWQgc3VjY2Vzc2Z1bGx5JyxcclxuICAgICdtc2cuZGVsZXRlZF9zdWNjZXNzZnVsbHknOiAnRGVsZXRlZCBzdWNjZXNzZnVsbHknLFxyXG4gICAgJ21zZy5hZGRlZF9zdWNjZXNzZnVsbHknOiAnQWRkZWQgc3VjY2Vzc2Z1bGx5JyxcclxuICAgICdtc2cubG9naW5fc3VjY2Vzc2Z1bGx5JzogJ0xvZ2dlZCBpbiBzdWNjZXNzZnVsbHknLFxyXG4gICAgJ21zZy5sb2dvdXRfc3VjY2Vzc2Z1bGx5JzogJ0xvZ2dlZCBvdXQgc3VjY2Vzc2Z1bGx5JyxcclxuICAgIFxyXG4gICAgLy8gRm9ybXNcclxuICAgICdmb3JtLm5hbWUnOiAnTmFtZScsXHJcbiAgICAnZm9ybS5lbWFpbCc6ICdFbWFpbCcsXHJcbiAgICAnZm9ybS5waG9uZSc6ICdQaG9uZScsXHJcbiAgICAnZm9ybS5wYXNzd29yZCc6ICdQYXNzd29yZCcsXHJcbiAgICAnZm9ybS5jb25maXJtX3Bhc3N3b3JkJzogJ0NvbmZpcm0gUGFzc3dvcmQnLFxyXG4gICAgJ2Zvcm0uYWRkcmVzcyc6ICdBZGRyZXNzJyxcclxuICAgICdmb3JtLmNpdHknOiAnQ2l0eScsXHJcbiAgICAnZm9ybS5jb3VudHJ5JzogJ0NvdW50cnknLFxyXG4gICAgJ2Zvcm0ucG9zdGFsX2NvZGUnOiAnUG9zdGFsIENvZGUnLFxyXG4gICAgJ2Zvcm0uZGVzY3JpcHRpb24nOiAnRGVzY3JpcHRpb24nLFxyXG4gICAgJ2Zvcm0ucHJpY2UnOiAnUHJpY2UnLFxyXG4gICAgJ2Zvcm0ucXVhbnRpdHknOiAnUXVhbnRpdHknLFxyXG4gICAgJ2Zvcm0uY2F0ZWdvcnknOiAnQ2F0ZWdvcnknLFxyXG4gICAgJ2Zvcm0uc3ViY2F0ZWdvcnknOiAnU3ViY2F0ZWdvcnknLFxyXG4gICAgJ2Zvcm0uaW1hZ2UnOiAnSW1hZ2UnLFxyXG4gICAgJ2Zvcm0uaW1hZ2VzJzogJ0ltYWdlcycsXHJcbiAgICAnZm9ybS53ZWJzaXRlJzogJ1dlYnNpdGUnLFxyXG4gICAgJ2Zvcm0uc29jaWFsX21lZGlhJzogJ1NvY2lhbCBNZWRpYScsXHJcbiAgICAnZm9ybS53b3JraW5nX2hvdXJzJzogJ1dvcmtpbmcgSG91cnMnLFxyXG4gICAgJ2Zvcm0uY29udGFjdF9pbmZvJzogJ0NvbnRhY3QgSW5mb3JtYXRpb24nLFxyXG4gICAgXHJcbiAgICAvLyBWYWxpZGF0aW9uXHJcbiAgICAndmFsaWRhdGlvbi5yZXF1aXJlZCc6ICdUaGlzIGZpZWxkIGlzIHJlcXVpcmVkJyxcclxuICAgICd2YWxpZGF0aW9uLmVtYWlsJzogJ0ludmFsaWQgZW1haWwgYWRkcmVzcycsXHJcbiAgICAndmFsaWRhdGlvbi5waG9uZSc6ICdJbnZhbGlkIHBob25lIG51bWJlcicsXHJcbiAgICAndmFsaWRhdGlvbi5wYXNzd29yZF9taW4nOiAnUGFzc3dvcmQgbXVzdCBiZSBhdCBsZWFzdCA4IGNoYXJhY3RlcnMnLFxyXG4gICAgJ3ZhbGlkYXRpb24ucGFzc3dvcmRfbWF0Y2gnOiAnUGFzc3dvcmRzIGRvIG5vdCBtYXRjaCcsXHJcbiAgICAndmFsaWRhdGlvbi5taW5fbGVuZ3RoJzogJ3tmaWVsZH0gbXVzdCBiZSBhdCBsZWFzdCB7bWlufSBjaGFyYWN0ZXJzJyxcclxuICAgICd2YWxpZGF0aW9uLm1heF9sZW5ndGgnOiAne2ZpZWxkfSBtdXN0IGJlIGF0IG1vc3Qge21heH0gY2hhcmFjdGVycycsXHJcbiAgICAndmFsaWRhdGlvbi5udW1iZXInOiAnTXVzdCBiZSBhIG51bWJlcicsXHJcbiAgICAndmFsaWRhdGlvbi5wb3NpdGl2ZSc6ICdNdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyxcclxuICAgICd2YWxpZGF0aW9uLnVybCc6ICdJbnZhbGlkIFVSTCcsXHJcbiAgICAndmFsaWRhdGlvbi5pbWFnZSc6ICdNdXN0IGJlIGFuIGltYWdlJyxcclxuICAgICd2YWxpZGF0aW9uLmZpbGVfc2l6ZSc6ICdGaWxlIHNpemUgdG9vIGxhcmdlJyxcclxuICAgICd2YWxpZGF0aW9uLmZpbGVfdHlwZSc6ICdGaWxlIHR5cGUgbm90IHN1cHBvcnRlZCcsXHJcbiAgICBcclxuICAgIC8vIERhc2hib2FyZFxyXG4gICAgJ2Rhc2hib2FyZC50aXRsZSc6ICdEYXNoYm9hcmQnLFxyXG4gICAgJ2Rhc2hib2FyZC5vdmVydmlldyc6ICdPdmVydmlldycsXHJcbiAgICAnZGFzaGJvYXJkLmFuYWx5dGljcyc6ICdBbmFseXRpY3MnLFxyXG4gICAgJ2Rhc2hib2FyZC5yZXBvcnRzJzogJ1JlcG9ydHMnLFxyXG4gICAgJ2Rhc2hib2FyZC5zZXR0aW5ncyc6ICdTZXR0aW5ncycsXHJcbiAgICAnZGFzaGJvYXJkLnByb2ZpbGUnOiAnUHJvZmlsZScsXHJcbiAgICAnZGFzaGJvYXJkLm5vdGlmaWNhdGlvbnMnOiAnTm90aWZpY2F0aW9ucycsXHJcbiAgICAnZGFzaGJvYXJkLm1lc3NhZ2VzJzogJ01lc3NhZ2VzJyxcclxuICAgICdkYXNoYm9hcmQub3JkZXJzJzogJ09yZGVycycsXHJcbiAgICAnZGFzaGJvYXJkLnByb2R1Y3RzJzogJ1Byb2R1Y3RzJyxcclxuICAgICdkYXNoYm9hcmQuY3VzdG9tZXJzJzogJ0N1c3RvbWVycycsXHJcbiAgICAnZGFzaGJvYXJkLnJldmVudWUnOiAnUmV2ZW51ZScsXHJcbiAgICAnZGFzaGJvYXJkLnNhbGVzJzogJ1NhbGVzJyxcclxuICAgICdkYXNoYm9hcmQudmlzaXRvcnMnOiAnVmlzaXRvcnMnLFxyXG4gICAgJ2Rhc2hib2FyZC5jb252ZXJzaW9uJzogJ0NvbnZlcnNpb24gUmF0ZScsXHJcbiAgICBcclxuICAgIC8vIE1hcmtldHBsYWNlXHJcbiAgICAnbWFya2V0cGxhY2UudGl0bGUnOiAnTWFya2V0cGxhY2UnLFxyXG4gICAgJ21hcmtldHBsYWNlLmFsbF9wcm9kdWN0cyc6ICdBbGwgUHJvZHVjdHMnLFxyXG4gICAgJ21hcmtldHBsYWNlLmZlYXR1cmVkJzogJ0ZlYXR1cmVkJyxcclxuICAgICdtYXJrZXRwbGFjZS5uZXdfYXJyaXZhbHMnOiAnTmV3IEFycml2YWxzJyxcclxuICAgICdtYXJrZXRwbGFjZS5iZXN0X3NlbGxlcnMnOiAnQmVzdCBTZWxsZXJzJyxcclxuICAgICdtYXJrZXRwbGFjZS5vZmZlcnMnOiAnT2ZmZXJzJyxcclxuICAgICdtYXJrZXRwbGFjZS5jYXRlZ29yaWVzJzogJ0NhdGVnb3JpZXMnLFxyXG4gICAgJ21hcmtldHBsYWNlLmZpbHRlcnMnOiAnRmlsdGVycycsXHJcbiAgICAnbWFya2V0cGxhY2Uuc29ydF9ieSc6ICdTb3J0IGJ5JyxcclxuICAgICdtYXJrZXRwbGFjZS5wcmljZV9sb3dfaGlnaCc6ICdQcmljZTogTG93IHRvIEhpZ2gnLFxyXG4gICAgJ21hcmtldHBsYWNlLnByaWNlX2hpZ2hfbG93JzogJ1ByaWNlOiBIaWdoIHRvIExvdycsXHJcbiAgICAnbWFya2V0cGxhY2UubmV3ZXN0JzogJ05ld2VzdCcsXHJcbiAgICAnbWFya2V0cGxhY2UucG9wdWxhcic6ICdNb3N0IFBvcHVsYXInLFxyXG4gICAgJ21hcmtldHBsYWNlLnJhdGluZyc6ICdSYXRpbmcnLFxyXG4gICAgJ21hcmtldHBsYWNlLmZyZWVfc2hpcHBpbmcnOiAnRnJlZSBTaGlwcGluZycsXHJcbiAgICAnbWFya2V0cGxhY2UuaW5fc3RvY2snOiAnSW4gU3RvY2snLFxyXG4gICAgJ21hcmtldHBsYWNlLm91dF9vZl9zdG9jayc6ICdPdXQgb2YgU3RvY2snLFxyXG4gICAgJ21hcmtldHBsYWNlLmFkZF90b19jYXJ0JzogJ0FkZCB0byBDYXJ0JyxcclxuICAgICdtYXJrZXRwbGFjZS5idXlfbm93JzogJ0J1eSBOb3cnLFxyXG4gICAgJ21hcmtldHBsYWNlLnByb2R1Y3RfZGV0YWlscyc6ICdQcm9kdWN0IERldGFpbHMnLFxyXG4gICAgJ21hcmtldHBsYWNlLnByb2R1Y3RfZGVzY3JpcHRpb24nOiAnUHJvZHVjdCBEZXNjcmlwdGlvbicsXHJcbiAgICAnbWFya2V0cGxhY2UucHJvZHVjdF9zcGVjaWZpY2F0aW9ucyc6ICdQcm9kdWN0IFNwZWNpZmljYXRpb25zJyxcclxuICAgICdtYXJrZXRwbGFjZS5wcm9kdWN0X3Jldmlld3MnOiAnUHJvZHVjdCBSZXZpZXdzJyxcclxuICAgICdtYXJrZXRwbGFjZS53cml0ZV9yZXZpZXcnOiAnV3JpdGUgUmV2aWV3JyxcclxuICAgIFxyXG4gICAgLy8gQ3VycmVuY3lcclxuICAgICdjdXJyZW5jeS5lZ3AnOiAnRUdQJyxcclxuICAgICdjdXJyZW5jeS51c2QnOiAnJCcsXHJcbiAgICAnY3VycmVuY3kuZXVyJzogJ+KCrCcsXHJcbiAgICAnY3VycmVuY3kuZ2JwJzogJ8KjJyxcclxuICAgIFxyXG4gICAgLy8gVGltZVxyXG4gICAgJ3RpbWUubm93JzogJ05vdycsXHJcbiAgICAndGltZS5taW51dGVfYWdvJzogJ0EgbWludXRlIGFnbycsXHJcbiAgICAndGltZS5taW51dGVzX2Fnbyc6ICd7Y291bnR9IG1pbnV0ZXMgYWdvJyxcclxuICAgICd0aW1lLmhvdXJfYWdvJzogJ0FuIGhvdXIgYWdvJyxcclxuICAgICd0aW1lLmhvdXJzX2Fnbyc6ICd7Y291bnR9IGhvdXJzIGFnbycsXHJcbiAgICAndGltZS5kYXlfYWdvJzogJ0EgZGF5IGFnbycsXHJcbiAgICAndGltZS5kYXlzX2Fnbyc6ICd7Y291bnR9IGRheXMgYWdvJyxcclxuICAgICd0aW1lLndlZWtfYWdvJzogJ0Egd2VlayBhZ28nLFxyXG4gICAgJ3RpbWUud2Vla3NfYWdvJzogJ3tjb3VudH0gd2Vla3MgYWdvJyxcclxuICAgICd0aW1lLm1vbnRoX2Fnbyc6ICdBIG1vbnRoIGFnbycsXHJcbiAgICAndGltZS5tb250aHNfYWdvJzogJ3tjb3VudH0gbW9udGhzIGFnbycsXHJcbiAgICAndGltZS55ZWFyX2Fnbyc6ICdBIHllYXIgYWdvJyxcclxuICAgICd0aW1lLnllYXJzX2Fnbyc6ICd7Y291bnR9IHllYXJzIGFnbycsXHJcbiAgfVxyXG59O1xyXG5cclxuY29uc3QgTGFuZ3VhZ2VDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxMYW5ndWFnZUNvbnRleHRUeXBlIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xyXG5cclxuZXhwb3J0IGNvbnN0IExhbmd1YWdlUHJvdmlkZXI6IFJlYWN0LkZDPHsgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSB9PiA9ICh7IGNoaWxkcmVuIH0pID0+IHtcclxuICBjb25zdCBbbGFuZ3VhZ2UsIHNldExhbmd1YWdlXSA9IHVzZVN0YXRlPExhbmd1YWdlPignYXInKTtcclxuICBjb25zdCBbbW91bnRlZCwgc2V0TW91bnRlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBzZXRNb3VudGVkKHRydWUpO1xyXG4gICAgLy8gQ2hlY2sgbG9jYWwgc3RvcmFnZSBvciBicm93c2VyIGxhbmd1YWdlIG9uIG1vdW50XHJcbiAgICBjb25zdCBzYXZlZExhbmd1YWdlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3JheV9sYW5ndWFnZScpIGFzIExhbmd1YWdlO1xyXG4gICAgY29uc3QgYnJvd3NlckxhbmcgPSBuYXZpZ2F0b3IubGFuZ3VhZ2Uuc3RhcnRzV2l0aCgnYXInKSA/ICdhcicgOiAnZW4nO1xyXG4gICAgXHJcbiAgICBjb25zdCBpbml0aWFsTGFuZyA9IHNhdmVkTGFuZ3VhZ2UgfHwgYnJvd3Nlckxhbmc7XHJcbiAgICBzZXRMYW5ndWFnZShpbml0aWFsTGFuZyk7XHJcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgncmF5X2xhbmd1YWdlJywgaW5pdGlhbExhbmcpO1xyXG4gICAgXHJcbiAgICAvLyBVcGRhdGUgZG9jdW1lbnQgZGlyZWN0aW9uIGFuZCBsYW5nXHJcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZGlyID0gaW5pdGlhbExhbmcgPT09ICdhcicgPyAncnRsJyA6ICdsdHInO1xyXG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmxhbmcgPSBpbml0aWFsTGFuZztcclxuICB9LCBbXSk7XHJcblxyXG4gIGNvbnN0IHRvZ2dsZUxhbmd1YWdlID0gKCkgPT4ge1xyXG4gICAgY29uc3QgbmV3TGFuZyA9IGxhbmd1YWdlID09PSAnYXInID8gJ2VuJyA6ICdhcic7XHJcbiAgICBzZXRMYW5ndWFnZShuZXdMYW5nKTtcclxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdyYXlfbGFuZ3VhZ2UnLCBuZXdMYW5nKTtcclxuICAgIFxyXG4gICAgLy8gVXBkYXRlIGRvY3VtZW50IGRpcmVjdGlvbiBhbmQgbGFuZ1xyXG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRpciA9IG5ld0xhbmcgPT09ICdhcicgPyAncnRsJyA6ICdsdHInO1xyXG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmxhbmcgPSBuZXdMYW5nO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IHNldExhbmd1YWdlSGFuZGxlciA9IChsYW5nOiBMYW5ndWFnZSkgPT4ge1xyXG4gICAgc2V0TGFuZ3VhZ2UobGFuZyk7XHJcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgncmF5X2xhbmd1YWdlJywgbGFuZyk7XHJcbiAgICBcclxuICAgIC8vIFVwZGF0ZSBkb2N1bWVudCBkaXJlY3Rpb24gYW5kIGxhbmdcclxuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kaXIgPSBsYW5nID09PSAnYXInID8gJ3J0bCcgOiAnbHRyJztcclxuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5sYW5nID0gbGFuZztcclxuICB9O1xyXG5cclxuICBjb25zdCB0ID0gKGtleTogc3RyaW5nKTogc3RyaW5nID0+IHtcclxuICAgIGNvbnN0IHRyYW5zbGF0aW9uID0gdHJhbnNsYXRpb25zW2xhbmd1YWdlXVtrZXkgYXMga2V5b2YgdHlwZW9mIHRyYW5zbGF0aW9uc1snYXInXV07XHJcbiAgICByZXR1cm4gdHJhbnNsYXRpb24gfHwga2V5O1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGRpcmVjdGlvbjogRGlyZWN0aW9uID0gbGFuZ3VhZ2UgPT09ICdhcicgPyAncnRsJyA6ICdsdHInO1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPExhbmd1YWdlQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17eyBcclxuICAgICAgbGFuZ3VhZ2UsIFxyXG4gICAgICBkaXJlY3Rpb24sIFxyXG4gICAgICB0b2dnbGVMYW5ndWFnZSwgXHJcbiAgICAgIHNldExhbmd1YWdlOiBzZXRMYW5ndWFnZUhhbmRsZXIsXHJcbiAgICAgIHQgXHJcbiAgICB9fT5cclxuICAgICAge2NoaWxkcmVufVxyXG4gICAgPC9MYW5ndWFnZUNvbnRleHQuUHJvdmlkZXI+XHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCB1c2VMYW5ndWFnZSA9ICgpID0+IHtcclxuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChMYW5ndWFnZUNvbnRleHQpO1xyXG4gIGlmICghY29udGV4dCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCd1c2VMYW5ndWFnZSBtdXN0IGJlIHVzZWQgd2l0aGluIGEgTGFuZ3VhZ2VQcm92aWRlcicpO1xyXG4gIH1cclxuICByZXR1cm4gY29udGV4dDtcclxufTtcclxuICJdLCJuYW1lcyI6WyJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJ0cmFuc2xhdGlvbnMiLCJhciIsImVuIiwiTGFuZ3VhZ2VDb250ZXh0IiwidW5kZWZpbmVkIiwiTGFuZ3VhZ2VQcm92aWRlciIsImNoaWxkcmVuIiwibGFuZ3VhZ2UiLCJzZXRMYW5ndWFnZSIsIm1vdW50ZWQiLCJzZXRNb3VudGVkIiwic2F2ZWRMYW5ndWFnZSIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJicm93c2VyTGFuZyIsIm5hdmlnYXRvciIsInN0YXJ0c1dpdGgiLCJpbml0aWFsTGFuZyIsInNldEl0ZW0iLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImRpciIsImxhbmciLCJ0b2dnbGVMYW5ndWFnZSIsIm5ld0xhbmciLCJzZXRMYW5ndWFnZUhhbmRsZXIiLCJ0Iiwia2V5IiwidHJhbnNsYXRpb24iLCJkaXJlY3Rpb24iLCJQcm92aWRlciIsInZhbHVlIiwidXNlTGFuZ3VhZ2UiLCJjb250ZXh0IiwiRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./context/LanguageContext.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./services/geminiService.ts":
/*!***********************************!*\
  !*** ./services/geminiService.ts ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getGeminiResponse: function() { return /* binding */ getGeminiResponse; }\n/* harmony export */ });\n/* harmony import */ var _google_genai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @google/genai */ \"(app-pages-browser)/./node_modules/@google/genai/dist/web/index.mjs\");\n\n// Initialize the client with NEXT_PUBLIC_ prefix for client-side access in Next.js\nconst ai = new _google_genai__WEBPACK_IMPORTED_MODULE_0__.GoogleGenAI({\n    apiKey: \"AIzaSyAlNFXCOq9xBdGaXLfbDsA4J_a_gwro6NQ\" || 0\n});\nconst getGeminiResponse = async function(userMessage) {\n    let context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"general\";\n    try {\n        if (false) {}\n        const modelId = \"gemini-2.5-flash\";\n        let systemInstruction = \"\";\n        if (context === \"merchant\") {\n            systemInstruction = '\\n            \"\" (RAY) .\\n                   .\\n              .\\n         \" \".\\n      ';\n        } else {\n            systemInstruction = '\\n            \"\" (RAY) .\\n                .\\n             .\\n         \" \".\\n      ';\n        }\n        const response = await ai.models.generateContent({\n            model: modelId,\n            contents: userMessage,\n            config: {\n                systemInstruction: systemInstruction,\n                temperature: 0.7\n            }\n        });\n        return response.text || \"    .\";\n    } catch (error) {\n        console.error(\"Gemini API Error:\", error);\n        return \"     .   .\";\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NlcnZpY2VzL2dlbWluaVNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNEM7QUFFNUMsbUZBQW1GO0FBQ25GLE1BQU1DLEtBQUssSUFBSUQsc0RBQVdBLENBQUM7SUFBRUUsUUFBUUMseUNBQXNDLElBQUk7QUFBRztBQUUzRSxNQUFNRyxvQkFBb0IsZUFDL0JDO1FBQ0FDLDJFQUFrQjtJQUVsQixJQUFJO1FBQ0YsSUFBSSxLQUF1QyxFQUFFLEVBRzVDO1FBRUQsTUFBTUcsVUFBVTtRQUVoQixJQUFJQyxvQkFBb0I7UUFFeEIsSUFBSUosWUFBWSxZQUFZO1lBQzFCSSxvQkFBcUI7UUFNdkIsT0FBTztZQUNMQSxvQkFBcUI7UUFNdkI7UUFFQSxNQUFNQyxXQUFXLE1BQU1aLEdBQUdhLE1BQU0sQ0FBQ0MsZUFBZSxDQUFDO1lBQy9DQyxPQUFPTDtZQUNQTSxVQUFVVjtZQUNWVyxRQUFRO2dCQUNOTixtQkFBbUJBO2dCQUNuQk8sYUFBYTtZQUNmO1FBQ0Y7UUFFQSxPQUFPTixTQUFTTyxJQUFJLElBQUk7SUFDMUIsRUFBRSxPQUFPQyxPQUFPO1FBQ2RaLFFBQVFZLEtBQUssQ0FBQyxxQkFBcUJBO1FBQ25DLE9BQU87SUFDVDtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc2VydmljZXMvZ2VtaW5pU2VydmljZS50cz9kMmEzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEdvb2dsZUdlbkFJIH0gZnJvbSBcIkBnb29nbGUvZ2VuYWlcIjtcclxuXHJcbi8vIEluaXRpYWxpemUgdGhlIGNsaWVudCB3aXRoIE5FWFRfUFVCTElDXyBwcmVmaXggZm9yIGNsaWVudC1zaWRlIGFjY2VzcyBpbiBOZXh0LmpzXHJcbmNvbnN0IGFpID0gbmV3IEdvb2dsZUdlbkFJKHsgYXBpS2V5OiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19HRU1JTklfQVBJX0tFWSB8fCAnJyB9KTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRHZW1pbmlSZXNwb25zZSA9IGFzeW5jIChcclxuICB1c2VyTWVzc2FnZTogc3RyaW5nLFxyXG4gIGNvbnRleHQ6IHN0cmluZyA9IFwiZ2VuZXJhbFwiXHJcbik6IFByb21pc2U8c3RyaW5nPiA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGlmICghcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfR0VNSU5JX0FQSV9LRVkpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oXCJHZW1pbmkgQVBJIEtleSBpcyBtaXNzaW5nXCIpO1xyXG4gICAgICAgIHJldHVybiBcIti52LDYsdin2YvYjCDYp9mE2K7Yr9mF2Kkg2LrZitixINmF2KrZiNmB2LHYqSDYrdin2YTZitin2YsgKEFQSSBLZXkgTWlzc2luZykuXCI7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbW9kZWxJZCA9ICdnZW1pbmktMi41LWZsYXNoJzsgXHJcbiAgICBcclxuICAgIGxldCBzeXN0ZW1JbnN0cnVjdGlvbiA9IFwiXCI7XHJcbiAgICBcclxuICAgIGlmIChjb250ZXh0ID09PSAnbWVyY2hhbnQnKSB7XHJcbiAgICAgIHN5c3RlbUluc3RydWN0aW9uID0gYFxyXG4gICAgICAgINij2YbYqiDZhdiz2KfYudivINiw2YPZiiDZhNmF2YbYtdipIFwi2LHYp9mKXCIgKFJBWSkg2YTZhNiq2KzYp9ixLlxyXG4gICAgICAgINiv2YjYsdmDINmF2LPYp9i52K/YqSDYp9mE2KrYp9is2LEg2YHZiiDZg9iq2KfYqNipINmI2LXZgSDZhNmE2YXZhtiq2KzYp9iq2Iwg2KrYrdmE2YrZhCDYp9mE2YXYqNmK2LnYp9iq2Iwg2YjYp9mC2KrYsdin2K0g2KPZgdmD2KfYsSDYqtiz2YjZitmC2YrYqS5cclxuICAgICAgICDYqtit2K/YqyDYqNin2YTZhNi62Kkg2KfZhNi52LHYqNmK2Kkg2KjZhNmH2KzYqSDZhdi12LHZitipINmF2YfZhtmK2Kkg2YjZhdit2KrYsdmB2KkuXHJcbiAgICAgICAg2KfYs9mF2YMgXCLZhdiz2KfYudivINix2KfZilwiLlxyXG4gICAgICBgO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc3lzdGVtSW5zdHJ1Y3Rpb24gPSBgXHJcbiAgICAgICAg2KPZhtiqINmF2LPYp9i52K8g2LDZg9mKINmE2YXZhti12KkgXCLYsdin2YpcIiAoUkFZKSDZhNmE2YXYqtiz2YjZgtmK2YYuXHJcbiAgICAgICAg2K/ZiNix2YMg2YXYs9in2LnYr9ipINin2YTZhdiz2KrYrtiv2YUg2YHZiiDYp9mE2LnYq9mI2LEg2LnZhNmJINin2YTZhdi32KfYudmF2Iwg2KfZhNmF2K3ZhNin2KrYjCDZiNin2YTYrtiv2YXYp9iqLlxyXG4gICAgICAgINiq2K3Yr9irINio2KfZhNmE2LrYqSDYp9mE2LnYsdio2YrYqSDYqNmE2YfYrNipINmF2LXYsdmK2Kkg2YjYr9mI2K/YqS5cclxuICAgICAgICDYp9iz2YXZgyBcItmF2LPYp9i52K8g2LHYp9mKXCIuXHJcbiAgICAgIGA7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5tb2RlbHMuZ2VuZXJhdGVDb250ZW50KHtcclxuICAgICAgbW9kZWw6IG1vZGVsSWQsXHJcbiAgICAgIGNvbnRlbnRzOiB1c2VyTWVzc2FnZSxcclxuICAgICAgY29uZmlnOiB7XHJcbiAgICAgICAgc3lzdGVtSW5zdHJ1Y3Rpb246IHN5c3RlbUluc3RydWN0aW9uLFxyXG4gICAgICAgIHRlbXBlcmF0dXJlOiAwLjcsXHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gcmVzcG9uc2UudGV4dCB8fCBcIti52LDYsdin2YvYjCDZhNmFINij2LPYqti32Lkg2YHZh9mFINiw2YTZgy5cIjtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIkdlbWluaSBBUEkgRXJyb3I6XCIsIGVycm9yKTtcclxuICAgIHJldHVybiBcItit2K/YqyDYrti32KMg2YHZiiDYp9mE2KfYqti12KfZhCDYqNin2YTZhdiz2KfYudivINin2YTYsNmD2YouINmK2LHYrNmJINin2YTZhdit2KfZiNmE2Kkg2YTYp9it2YLYp9mLLlwiO1xyXG4gIH1cclxufTsiXSwibmFtZXMiOlsiR29vZ2xlR2VuQUkiLCJhaSIsImFwaUtleSIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19HRU1JTklfQVBJX0tFWSIsImdldEdlbWluaVJlc3BvbnNlIiwidXNlck1lc3NhZ2UiLCJjb250ZXh0IiwiY29uc29sZSIsIndhcm4iLCJtb2RlbElkIiwic3lzdGVtSW5zdHJ1Y3Rpb24iLCJyZXNwb25zZSIsIm1vZGVscyIsImdlbmVyYXRlQ29udGVudCIsIm1vZGVsIiwiY29udGVudHMiLCJjb25maWciLCJ0ZW1wZXJhdHVyZSIsInRleHQiLCJlcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./services/geminiService.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/font/google/target.css?{\"path\":\"app\\\\layout.tsx\",\"import\":\"Cairo\",\"arguments\":[{\"subsets\":[\"arabic\",\"latin\"],\"variable\":\"--font-cairo\"}],\"variableName\":\"cairo\"}":
/*!********************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/font/google/target.css?{"path":"app\\layout.tsx","import":"Cairo","arguments":[{"subsets":["arabic","latin"],"variable":"--font-cairo"}],"variableName":"cairo"} ***!
  \********************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"style\":{\"fontFamily\":\"'__Cairo_45314e', '__Cairo_Fallback_45314e'\",\"fontStyle\":\"normal\"},\"className\":\"__className_45314e\",\"variable\":\"__variable_45314e\"};\n    if(true) {\n      // 1764839036199\n      var cssReload = __webpack_require__(/*! ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2ZvbnQvZ29vZ2xlL3RhcmdldC5jc3M/e1wicGF0aFwiOlwiYXBwXFxcXGxheW91dC50c3hcIixcImltcG9ydFwiOlwiQ2Fpcm9cIixcImFyZ3VtZW50c1wiOlt7XCJzdWJzZXRzXCI6W1wiYXJhYmljXCIsXCJsYXRpblwiXSxcInZhcmlhYmxlXCI6XCItLWZvbnQtY2Fpcm9cIn1dLFwidmFyaWFibGVOYW1lXCI6XCJjYWlyb1wifSIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGtCQUFrQixTQUFTLGdGQUFnRjtBQUMzRyxPQUFPLElBQVU7QUFDakI7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyx3TUFBZ0gsY0FBYyxzREFBc0Q7QUFDbE4sTUFBTSxVQUFVO0FBQ2hCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9mb250L2dvb2dsZS90YXJnZXQuY3NzP2I3NjMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5tb2R1bGUuZXhwb3J0cyA9IHtcInN0eWxlXCI6e1wiZm9udEZhbWlseVwiOlwiJ19fQ2Fpcm9fNDUzMTRlJywgJ19fQ2Fpcm9fRmFsbGJhY2tfNDUzMTRlJ1wiLFwiZm9udFN0eWxlXCI6XCJub3JtYWxcIn0sXCJjbGFzc05hbWVcIjpcIl9fY2xhc3NOYW1lXzQ1MzE0ZVwiLFwidmFyaWFibGVcIjpcIl9fdmFyaWFibGVfNDUzMTRlXCJ9O1xuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIC8vIDE3NjQ4MzkwMzYxOTlcbiAgICAgIHZhciBjc3NSZWxvYWQgPSByZXF1aXJlKFwiQzovVXNlcnMvRHJlYW0vcmF5LWVneXB0LTgvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9obXIvaG90TW9kdWxlUmVwbGFjZW1lbnQuanNcIikobW9kdWxlLmlkLCB7XCJwdWJsaWNQYXRoXCI6XCIvX25leHQvXCIsXCJlc01vZHVsZVwiOmZhbHNlLFwibG9jYWxzXCI6dHJ1ZX0pO1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGNzc1JlbG9hZCk7XG4gICAgICBcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/font/google/target.css?{\"path\":\"app\\\\layout.tsx\",\"import\":\"Cairo\",\"arguments\":[{\"subsets\":[\"arabic\",\"latin\"],\"variable\":\"--font-cairo\"}],\"variableName\":\"cairo\"}\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/font/google/target.css?{\"path\":\"app\\\\layout.tsx\",\"import\":\"Dancing_Script\",\"arguments\":[{\"subsets\":[\"latin\"],\"variable\":\"--font-dancing\"}],\"variableName\":\"dancing\"}":
/*!************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/font/google/target.css?{"path":"app\\layout.tsx","import":"Dancing_Script","arguments":[{"subsets":["latin"],"variable":"--font-dancing"}],"variableName":"dancing"} ***!
  \************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"style\":{\"fontFamily\":\"'__Dancing_Script_b75cb0', '__Dancing_Script_Fallback_b75cb0'\",\"fontStyle\":\"normal\"},\"className\":\"__className_b75cb0\",\"variable\":\"__variable_b75cb0\"};\n    if(true) {\n      // 1764839036210\n      var cssReload = __webpack_require__(/*! ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2ZvbnQvZ29vZ2xlL3RhcmdldC5jc3M/e1wicGF0aFwiOlwiYXBwXFxcXGxheW91dC50c3hcIixcImltcG9ydFwiOlwiRGFuY2luZ19TY3JpcHRcIixcImFyZ3VtZW50c1wiOlt7XCJzdWJzZXRzXCI6W1wibGF0aW5cIl0sXCJ2YXJpYWJsZVwiOlwiLS1mb250LWRhbmNpbmdcIn1dLFwidmFyaWFibGVOYW1lXCI6XCJkYW5jaW5nXCJ9IiwibWFwcGluZ3MiOiJBQUFBO0FBQ0Esa0JBQWtCLFNBQVMsa0dBQWtHO0FBQzdILE9BQU8sSUFBVTtBQUNqQjtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLHdNQUFnSCxjQUFjLHNEQUFzRDtBQUNsTixNQUFNLFVBQVU7QUFDaEI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2ZvbnQvZ29vZ2xlL3RhcmdldC5jc3M/MDdiMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbm1vZHVsZS5leHBvcnRzID0ge1wic3R5bGVcIjp7XCJmb250RmFtaWx5XCI6XCInX19EYW5jaW5nX1NjcmlwdF9iNzVjYjAnLCAnX19EYW5jaW5nX1NjcmlwdF9GYWxsYmFja19iNzVjYjAnXCIsXCJmb250U3R5bGVcIjpcIm5vcm1hbFwifSxcImNsYXNzTmFtZVwiOlwiX19jbGFzc05hbWVfYjc1Y2IwXCIsXCJ2YXJpYWJsZVwiOlwiX192YXJpYWJsZV9iNzVjYjBcIn07XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgLy8gMTc2NDgzOTAzNjIxMFxuICAgICAgdmFyIGNzc1JlbG9hZCA9IHJlcXVpcmUoXCJDOi9Vc2Vycy9EcmVhbS9yYXktZWd5cHQtOC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qc1wiKShtb2R1bGUuaWQsIHtcInB1YmxpY1BhdGhcIjpcIi9fbmV4dC9cIixcImVzTW9kdWxlXCI6ZmFsc2UsXCJsb2NhbHNcIjp0cnVlfSk7XG4gICAgICBtb2R1bGUuaG90LmRpc3Bvc2UoY3NzUmVsb2FkKTtcbiAgICAgIFxuICAgIH1cbiAgIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/font/google/target.css?{\"path\":\"app\\\\layout.tsx\",\"import\":\"Dancing_Script\",\"arguments\":[{\"subsets\":[\"latin\"],\"variable\":\"--font-dancing\"}],\"variableName\":\"dancing\"}\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@google/genai/dist/web/index.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@google/genai/dist/web/index.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActivityHandling: function() { return /* binding */ ActivityHandling; },\n/* harmony export */   AdapterSize: function() { return /* binding */ AdapterSize; },\n/* harmony export */   ApiError: function() { return /* binding */ ApiError; },\n/* harmony export */   ApiSpec: function() { return /* binding */ ApiSpec; },\n/* harmony export */   AuthType: function() { return /* binding */ AuthType; },\n/* harmony export */   Batches: function() { return /* binding */ Batches; },\n/* harmony export */   Behavior: function() { return /* binding */ Behavior; },\n/* harmony export */   BlockedReason: function() { return /* binding */ BlockedReason; },\n/* harmony export */   Caches: function() { return /* binding */ Caches; },\n/* harmony export */   CancelTuningJobResponse: function() { return /* binding */ CancelTuningJobResponse; },\n/* harmony export */   Chat: function() { return /* binding */ Chat; },\n/* harmony export */   Chats: function() { return /* binding */ Chats; },\n/* harmony export */   ComputeTokensResponse: function() { return /* binding */ ComputeTokensResponse; },\n/* harmony export */   ContentReferenceImage: function() { return /* binding */ ContentReferenceImage; },\n/* harmony export */   ControlReferenceImage: function() { return /* binding */ ControlReferenceImage; },\n/* harmony export */   ControlReferenceType: function() { return /* binding */ ControlReferenceType; },\n/* harmony export */   CountTokensResponse: function() { return /* binding */ CountTokensResponse; },\n/* harmony export */   CreateFileResponse: function() { return /* binding */ CreateFileResponse; },\n/* harmony export */   DeleteCachedContentResponse: function() { return /* binding */ DeleteCachedContentResponse; },\n/* harmony export */   DeleteFileResponse: function() { return /* binding */ DeleteFileResponse; },\n/* harmony export */   DeleteModelResponse: function() { return /* binding */ DeleteModelResponse; },\n/* harmony export */   DocumentState: function() { return /* binding */ DocumentState; },\n/* harmony export */   DynamicRetrievalConfigMode: function() { return /* binding */ DynamicRetrievalConfigMode; },\n/* harmony export */   EditImageResponse: function() { return /* binding */ EditImageResponse; },\n/* harmony export */   EditMode: function() { return /* binding */ EditMode; },\n/* harmony export */   EmbedContentResponse: function() { return /* binding */ EmbedContentResponse; },\n/* harmony export */   EndSensitivity: function() { return /* binding */ EndSensitivity; },\n/* harmony export */   Environment: function() { return /* binding */ Environment; },\n/* harmony export */   FeatureSelectionPreference: function() { return /* binding */ FeatureSelectionPreference; },\n/* harmony export */   FileSource: function() { return /* binding */ FileSource; },\n/* harmony export */   FileState: function() { return /* binding */ FileState; },\n/* harmony export */   Files: function() { return /* binding */ Files; },\n/* harmony export */   FinishReason: function() { return /* binding */ FinishReason; },\n/* harmony export */   FunctionCallingConfigMode: function() { return /* binding */ FunctionCallingConfigMode; },\n/* harmony export */   FunctionResponse: function() { return /* binding */ FunctionResponse; },\n/* harmony export */   FunctionResponseBlob: function() { return /* binding */ FunctionResponseBlob; },\n/* harmony export */   FunctionResponseFileData: function() { return /* binding */ FunctionResponseFileData; },\n/* harmony export */   FunctionResponsePart: function() { return /* binding */ FunctionResponsePart; },\n/* harmony export */   FunctionResponseScheduling: function() { return /* binding */ FunctionResponseScheduling; },\n/* harmony export */   GenerateContentResponse: function() { return /* binding */ GenerateContentResponse; },\n/* harmony export */   GenerateContentResponsePromptFeedback: function() { return /* binding */ GenerateContentResponsePromptFeedback; },\n/* harmony export */   GenerateContentResponseUsageMetadata: function() { return /* binding */ GenerateContentResponseUsageMetadata; },\n/* harmony export */   GenerateImagesResponse: function() { return /* binding */ GenerateImagesResponse; },\n/* harmony export */   GenerateVideosOperation: function() { return /* binding */ GenerateVideosOperation; },\n/* harmony export */   GenerateVideosResponse: function() { return /* binding */ GenerateVideosResponse; },\n/* harmony export */   GoogleGenAI: function() { return /* binding */ GoogleGenAI; },\n/* harmony export */   HarmBlockMethod: function() { return /* binding */ HarmBlockMethod; },\n/* harmony export */   HarmBlockThreshold: function() { return /* binding */ HarmBlockThreshold; },\n/* harmony export */   HarmCategory: function() { return /* binding */ HarmCategory; },\n/* harmony export */   HarmProbability: function() { return /* binding */ HarmProbability; },\n/* harmony export */   HarmSeverity: function() { return /* binding */ HarmSeverity; },\n/* harmony export */   HttpElementLocation: function() { return /* binding */ HttpElementLocation; },\n/* harmony export */   HttpResponse: function() { return /* binding */ HttpResponse; },\n/* harmony export */   ImagePromptLanguage: function() { return /* binding */ ImagePromptLanguage; },\n/* harmony export */   ImportFileOperation: function() { return /* binding */ ImportFileOperation; },\n/* harmony export */   ImportFileResponse: function() { return /* binding */ ImportFileResponse; },\n/* harmony export */   InlinedEmbedContentResponse: function() { return /* binding */ InlinedEmbedContentResponse; },\n/* harmony export */   InlinedResponse: function() { return /* binding */ InlinedResponse; },\n/* harmony export */   JobState: function() { return /* binding */ JobState; },\n/* harmony export */   Language: function() { return /* binding */ Language; },\n/* harmony export */   ListBatchJobsResponse: function() { return /* binding */ ListBatchJobsResponse; },\n/* harmony export */   ListCachedContentsResponse: function() { return /* binding */ ListCachedContentsResponse; },\n/* harmony export */   ListDocumentsResponse: function() { return /* binding */ ListDocumentsResponse; },\n/* harmony export */   ListFileSearchStoresResponse: function() { return /* binding */ ListFileSearchStoresResponse; },\n/* harmony export */   ListFilesResponse: function() { return /* binding */ ListFilesResponse; },\n/* harmony export */   ListModelsResponse: function() { return /* binding */ ListModelsResponse; },\n/* harmony export */   ListTuningJobsResponse: function() { return /* binding */ ListTuningJobsResponse; },\n/* harmony export */   Live: function() { return /* binding */ Live; },\n/* harmony export */   LiveClientToolResponse: function() { return /* binding */ LiveClientToolResponse; },\n/* harmony export */   LiveMusicPlaybackControl: function() { return /* binding */ LiveMusicPlaybackControl; },\n/* harmony export */   LiveMusicServerMessage: function() { return /* binding */ LiveMusicServerMessage; },\n/* harmony export */   LiveSendToolResponseParameters: function() { return /* binding */ LiveSendToolResponseParameters; },\n/* harmony export */   LiveServerMessage: function() { return /* binding */ LiveServerMessage; },\n/* harmony export */   MaskReferenceImage: function() { return /* binding */ MaskReferenceImage; },\n/* harmony export */   MaskReferenceMode: function() { return /* binding */ MaskReferenceMode; },\n/* harmony export */   MediaModality: function() { return /* binding */ MediaModality; },\n/* harmony export */   MediaResolution: function() { return /* binding */ MediaResolution; },\n/* harmony export */   Modality: function() { return /* binding */ Modality; },\n/* harmony export */   Mode: function() { return /* binding */ Mode; },\n/* harmony export */   Models: function() { return /* binding */ Models; },\n/* harmony export */   MusicGenerationMode: function() { return /* binding */ MusicGenerationMode; },\n/* harmony export */   Operations: function() { return /* binding */ Operations; },\n/* harmony export */   Outcome: function() { return /* binding */ Outcome; },\n/* harmony export */   PagedItem: function() { return /* binding */ PagedItem; },\n/* harmony export */   Pager: function() { return /* binding */ Pager; },\n/* harmony export */   PartMediaResolutionLevel: function() { return /* binding */ PartMediaResolutionLevel; },\n/* harmony export */   PersonGeneration: function() { return /* binding */ PersonGeneration; },\n/* harmony export */   PhishBlockThreshold: function() { return /* binding */ PhishBlockThreshold; },\n/* harmony export */   RawReferenceImage: function() { return /* binding */ RawReferenceImage; },\n/* harmony export */   RecontextImageResponse: function() { return /* binding */ RecontextImageResponse; },\n/* harmony export */   ReplayResponse: function() { return /* binding */ ReplayResponse; },\n/* harmony export */   SafetyFilterLevel: function() { return /* binding */ SafetyFilterLevel; },\n/* harmony export */   Scale: function() { return /* binding */ Scale; },\n/* harmony export */   SegmentImageResponse: function() { return /* binding */ SegmentImageResponse; },\n/* harmony export */   SegmentMode: function() { return /* binding */ SegmentMode; },\n/* harmony export */   Session: function() { return /* binding */ Session; },\n/* harmony export */   SingleEmbedContentResponse: function() { return /* binding */ SingleEmbedContentResponse; },\n/* harmony export */   StartSensitivity: function() { return /* binding */ StartSensitivity; },\n/* harmony export */   StyleReferenceImage: function() { return /* binding */ StyleReferenceImage; },\n/* harmony export */   SubjectReferenceImage: function() { return /* binding */ SubjectReferenceImage; },\n/* harmony export */   SubjectReferenceType: function() { return /* binding */ SubjectReferenceType; },\n/* harmony export */   ThinkingLevel: function() { return /* binding */ ThinkingLevel; },\n/* harmony export */   Tokens: function() { return /* binding */ Tokens; },\n/* harmony export */   TrafficType: function() { return /* binding */ TrafficType; },\n/* harmony export */   TuningMethod: function() { return /* binding */ TuningMethod; },\n/* harmony export */   TuningMode: function() { return /* binding */ TuningMode; },\n/* harmony export */   TuningTask: function() { return /* binding */ TuningTask; },\n/* harmony export */   TurnCompleteReason: function() { return /* binding */ TurnCompleteReason; },\n/* harmony export */   TurnCoverage: function() { return /* binding */ TurnCoverage; },\n/* harmony export */   Type: function() { return /* binding */ Type; },\n/* harmony export */   UploadToFileSearchStoreOperation: function() { return /* binding */ UploadToFileSearchStoreOperation; },\n/* harmony export */   UploadToFileSearchStoreResponse: function() { return /* binding */ UploadToFileSearchStoreResponse; },\n/* harmony export */   UploadToFileSearchStoreResumableResponse: function() { return /* binding */ UploadToFileSearchStoreResumableResponse; },\n/* harmony export */   UpscaleImageResponse: function() { return /* binding */ UpscaleImageResponse; },\n/* harmony export */   UrlRetrievalStatus: function() { return /* binding */ UrlRetrievalStatus; },\n/* harmony export */   VideoCompressionQuality: function() { return /* binding */ VideoCompressionQuality; },\n/* harmony export */   VideoGenerationMaskMode: function() { return /* binding */ VideoGenerationMaskMode; },\n/* harmony export */   VideoGenerationReferenceType: function() { return /* binding */ VideoGenerationReferenceType; },\n/* harmony export */   createFunctionResponsePartFromBase64: function() { return /* binding */ createFunctionResponsePartFromBase64; },\n/* harmony export */   createFunctionResponsePartFromUri: function() { return /* binding */ createFunctionResponsePartFromUri; },\n/* harmony export */   createModelContent: function() { return /* binding */ createModelContent; },\n/* harmony export */   createPartFromBase64: function() { return /* binding */ createPartFromBase64; },\n/* harmony export */   createPartFromCodeExecutionResult: function() { return /* binding */ createPartFromCodeExecutionResult; },\n/* harmony export */   createPartFromExecutableCode: function() { return /* binding */ createPartFromExecutableCode; },\n/* harmony export */   createPartFromFunctionCall: function() { return /* binding */ createPartFromFunctionCall; },\n/* harmony export */   createPartFromFunctionResponse: function() { return /* binding */ createPartFromFunctionResponse; },\n/* harmony export */   createPartFromText: function() { return /* binding */ createPartFromText; },\n/* harmony export */   createPartFromUri: function() { return /* binding */ createPartFromUri; },\n/* harmony export */   createUserContent: function() { return /* binding */ createUserContent; },\n/* harmony export */   mcpToTool: function() { return /* binding */ mcpToTool; },\n/* harmony export */   setDefaultBaseUrls: function() { return /* binding */ setDefaultBaseUrls; }\n/* harmony export */ });\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ let _defaultBaseGeminiUrl = undefined;\nlet _defaultBaseVertexUrl = undefined;\n/**\n * Overrides the base URLs for the Gemini API and Vertex AI API.\n *\n * @remarks This function should be called before initializing the SDK. If the\n * base URLs are set after initializing the SDK, the base URLs will not be\n * updated. Base URLs provided in the HttpOptions will also take precedence over\n * URLs set here.\n *\n * @example\n * ```ts\n * import {GoogleGenAI, setDefaultBaseUrls} from '@google/genai';\n * // Override the base URL for the Gemini API.\n * setDefaultBaseUrls({geminiUrl:'https://gemini.google.com'});\n *\n * // Override the base URL for the Vertex AI API.\n * setDefaultBaseUrls({vertexUrl: 'https://vertexai.googleapis.com'});\n *\n * const ai = new GoogleGenAI({apiKey: 'GEMINI_API_KEY'});\n * ```\n */ function setDefaultBaseUrls(baseUrlParams) {\n    _defaultBaseGeminiUrl = baseUrlParams.geminiUrl;\n    _defaultBaseVertexUrl = baseUrlParams.vertexUrl;\n}\n/**\n * Returns the default base URLs for the Gemini API and Vertex AI API.\n */ function getDefaultBaseUrls() {\n    return {\n        geminiUrl: _defaultBaseGeminiUrl,\n        vertexUrl: _defaultBaseVertexUrl\n    };\n}\n/**\n * Returns the default base URL based on the following priority:\n *   1. Base URLs set via HttpOptions.\n *   2. Base URLs set via the latest call to setDefaultBaseUrls.\n *   3. Base URLs set via environment variables.\n */ function getBaseUrl(httpOptions, vertexai, vertexBaseUrlFromEnv, geminiBaseUrlFromEnv) {\n    var _a, _b;\n    if (!(httpOptions === null || httpOptions === void 0 ? void 0 : httpOptions.baseUrl)) {\n        const defaultBaseUrls = getDefaultBaseUrls();\n        if (vertexai) {\n            return (_a = defaultBaseUrls.vertexUrl) !== null && _a !== void 0 ? _a : vertexBaseUrlFromEnv;\n        } else {\n            return (_b = defaultBaseUrls.geminiUrl) !== null && _b !== void 0 ? _b : geminiBaseUrlFromEnv;\n        }\n    }\n    return httpOptions.baseUrl;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class BaseModule {\n}\nfunction formatMap(templateString, valueMap) {\n    // Use a regular expression to find all placeholders in the template string\n    const regex = /\\{([^}]+)\\}/g;\n    // Replace each placeholder with its corresponding value from the valueMap\n    return templateString.replace(regex, (match, key)=>{\n        if (Object.prototype.hasOwnProperty.call(valueMap, key)) {\n            const value = valueMap[key];\n            // Convert the value to a string if it's not a string already\n            return value !== undefined && value !== null ? String(value) : \"\";\n        } else {\n            // Handle missing keys\n            throw new Error(\"Key '\".concat(key, \"' not found in valueMap.\"));\n        }\n    });\n}\nfunction setValueByPath(data, keys, value) {\n    for(let i = 0; i < keys.length - 1; i++){\n        const key = keys[i];\n        if (key.endsWith(\"[]\")) {\n            const keyName = key.slice(0, -2);\n            if (!(keyName in data)) {\n                if (Array.isArray(value)) {\n                    data[keyName] = Array.from({\n                        length: value.length\n                    }, ()=>({}));\n                } else {\n                    throw new Error(\"Value must be a list given an array path \".concat(key));\n                }\n            }\n            if (Array.isArray(data[keyName])) {\n                const arrayData = data[keyName];\n                if (Array.isArray(value)) {\n                    for(let j = 0; j < arrayData.length; j++){\n                        const entry = arrayData[j];\n                        setValueByPath(entry, keys.slice(i + 1), value[j]);\n                    }\n                } else {\n                    for (const d of arrayData){\n                        setValueByPath(d, keys.slice(i + 1), value);\n                    }\n                }\n            }\n            return;\n        } else if (key.endsWith(\"[0]\")) {\n            const keyName = key.slice(0, -3);\n            if (!(keyName in data)) {\n                data[keyName] = [\n                    {}\n                ];\n            }\n            const arrayData = data[keyName];\n            setValueByPath(arrayData[0], keys.slice(i + 1), value);\n            return;\n        }\n        if (!data[key] || typeof data[key] !== \"object\") {\n            data[key] = {};\n        }\n        data = data[key];\n    }\n    const keyToSet = keys[keys.length - 1];\n    const existingData = data[keyToSet];\n    if (existingData !== undefined) {\n        if (!value || typeof value === \"object\" && Object.keys(value).length === 0) {\n            return;\n        }\n        if (value === existingData) {\n            return;\n        }\n        if (typeof existingData === \"object\" && typeof value === \"object\" && existingData !== null && value !== null) {\n            Object.assign(existingData, value);\n        } else {\n            throw new Error(\"Cannot set value for an existing key. Key: \".concat(keyToSet));\n        }\n    } else {\n        if (keyToSet === \"_self\" && typeof value === \"object\" && value !== null && !Array.isArray(value)) {\n            const valueAsRecord = value;\n            Object.assign(data, valueAsRecord);\n        } else {\n            data[keyToSet] = value;\n        }\n    }\n}\nfunction getValueByPath(data, keys) {\n    let defaultValue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : undefined;\n    try {\n        if (keys.length === 1 && keys[0] === \"_self\") {\n            return data;\n        }\n        for(let i = 0; i < keys.length; i++){\n            if (typeof data !== \"object\" || data === null) {\n                return defaultValue;\n            }\n            const key = keys[i];\n            if (key.endsWith(\"[]\")) {\n                const keyName = key.slice(0, -2);\n                if (keyName in data) {\n                    const arrayData = data[keyName];\n                    if (!Array.isArray(arrayData)) {\n                        return defaultValue;\n                    }\n                    return arrayData.map((d)=>getValueByPath(d, keys.slice(i + 1), defaultValue));\n                } else {\n                    return defaultValue;\n                }\n            } else {\n                data = data[key];\n            }\n        }\n        return data;\n    } catch (error) {\n        if (error instanceof TypeError) {\n            return defaultValue;\n        }\n        throw error;\n    }\n}\n/**\n * Moves values from source paths to destination paths.\n *\n * Examples:\n *   moveValueByPath(\n *     {'requests': [{'content': v1}, {'content': v2}]},\n *     {'requests[].*': 'requests[].request.*'}\n *   )\n *     -> {'requests': [{'request': {'content': v1}}, {'request': {'content': v2}}]}\n */ function moveValueByPath(data, paths) {\n    for (const [sourcePath, destPath] of Object.entries(paths)){\n        const sourceKeys = sourcePath.split(\".\");\n        const destKeys = destPath.split(\".\");\n        // Determine keys to exclude from wildcard to avoid cyclic references\n        const excludeKeys = new Set();\n        let wildcardIdx = -1;\n        for(let i = 0; i < sourceKeys.length; i++){\n            if (sourceKeys[i] === \"*\") {\n                wildcardIdx = i;\n                break;\n            }\n        }\n        if (wildcardIdx !== -1 && destKeys.length > wildcardIdx) {\n            // Extract the intermediate key between source and dest paths\n            // Example: source=['requests[]', '*'], dest=['requests[]', 'request', '*']\n            // We want to exclude 'request'\n            for(let i = wildcardIdx; i < destKeys.length; i++){\n                const key = destKeys[i];\n                if (key !== \"*\" && !key.endsWith(\"[]\") && !key.endsWith(\"[0]\")) {\n                    excludeKeys.add(key);\n                }\n            }\n        }\n        _moveValueRecursive(data, sourceKeys, destKeys, 0, excludeKeys);\n    }\n}\n/**\n * Recursively moves values from source path to destination path.\n */ function _moveValueRecursive(data, sourceKeys, destKeys, keyIdx, excludeKeys) {\n    if (keyIdx >= sourceKeys.length) {\n        return;\n    }\n    if (typeof data !== \"object\" || data === null) {\n        return;\n    }\n    const key = sourceKeys[keyIdx];\n    if (key.endsWith(\"[]\")) {\n        const keyName = key.slice(0, -2);\n        const dataRecord = data;\n        if (keyName in dataRecord && Array.isArray(dataRecord[keyName])) {\n            for (const item of dataRecord[keyName]){\n                _moveValueRecursive(item, sourceKeys, destKeys, keyIdx + 1, excludeKeys);\n            }\n        }\n    } else if (key === \"*\") {\n        // wildcard - move all fields\n        if (typeof data === \"object\" && data !== null && !Array.isArray(data)) {\n            const dataRecord = data;\n            const keysToMove = Object.keys(dataRecord).filter((k)=>!k.startsWith(\"_\") && !excludeKeys.has(k));\n            const valuesToMove = {};\n            for (const k of keysToMove){\n                valuesToMove[k] = dataRecord[k];\n            }\n            // Set values at destination\n            for (const [k, v] of Object.entries(valuesToMove)){\n                const newDestKeys = [];\n                for (const dk of destKeys.slice(keyIdx)){\n                    if (dk === \"*\") {\n                        newDestKeys.push(k);\n                    } else {\n                        newDestKeys.push(dk);\n                    }\n                }\n                setValueByPath(dataRecord, newDestKeys, v);\n            }\n            for (const k of keysToMove){\n                delete dataRecord[k];\n            }\n        }\n    } else {\n        // Navigate to next level\n        const dataRecord = data;\n        if (key in dataRecord) {\n            _moveValueRecursive(dataRecord[key], sourceKeys, destKeys, keyIdx + 1, excludeKeys);\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function tBytes$1(fromBytes) {\n    if (typeof fromBytes !== \"string\") {\n        throw new Error(\"fromImageBytes must be a string\");\n    }\n    // TODO(b/389133914): Remove dummy bytes converter.\n    return fromBytes;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ // Code generated by the Google Gen AI SDK generator DO NOT EDIT.\nfunction fetchPredictOperationParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromOperationName = getValueByPath(fromObject, [\n        \"operationName\"\n    ]);\n    if (fromOperationName != null) {\n        setValueByPath(toObject, [\n            \"operationName\"\n        ], fromOperationName);\n    }\n    const fromResourceName = getValueByPath(fromObject, [\n        \"resourceName\"\n    ]);\n    if (fromResourceName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"resourceName\"\n        ], fromResourceName);\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\",\n        \"generateVideoResponse\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], generateVideosResponseFromMldev$1(fromResponse));\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], generateVideosResponseFromVertex$1(fromResponse));\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, [\n        \"generatedSamples\"\n    ]);\n    if (fromGeneratedVideos != null) {\n        let transformedList = fromGeneratedVideos;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedVideoFromMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedVideos\"\n        ], transformedList);\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        \"raiMediaFilteredCount\"\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredCount\"\n        ], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        \"raiMediaFilteredReasons\"\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredReasons\"\n        ], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, [\n        \"videos\"\n    ]);\n    if (fromGeneratedVideos != null) {\n        let transformedList = fromGeneratedVideos;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedVideoFromVertex$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedVideos\"\n        ], transformedList);\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        \"raiMediaFilteredCount\"\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredCount\"\n        ], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        \"raiMediaFilteredReasons\"\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredReasons\"\n        ], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generatedVideoFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, [\n        \"video\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"video\"\n        ], videoFromMldev$1(fromVideo));\n    }\n    return toObject;\n}\nfunction generatedVideoFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"video\"\n        ], videoFromVertex$1(fromVideo));\n    }\n    return toObject;\n}\nfunction getOperationParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromOperationName = getValueByPath(fromObject, [\n        \"operationName\"\n    ]);\n    if (fromOperationName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"operationName\"\n        ], fromOperationName);\n    }\n    return toObject;\n}\nfunction getOperationParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromOperationName = getValueByPath(fromObject, [\n        \"operationName\"\n    ]);\n    if (fromOperationName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"operationName\"\n        ], fromOperationName);\n    }\n    return toObject;\n}\nfunction importFileOperationFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], importFileResponseFromMldev$1(fromResponse));\n    }\n    return toObject;\n}\nfunction importFileResponseFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromParent = getValueByPath(fromObject, [\n        \"parent\"\n    ]);\n    if (fromParent != null) {\n        setValueByPath(toObject, [\n            \"parent\"\n        ], fromParent);\n    }\n    const fromDocumentName = getValueByPath(fromObject, [\n        \"documentName\"\n    ]);\n    if (fromDocumentName != null) {\n        setValueByPath(toObject, [\n            \"documentName\"\n        ], fromDocumentName);\n    }\n    return toObject;\n}\nfunction uploadToFileSearchStoreOperationFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], uploadToFileSearchStoreResponseFromMldev(fromResponse));\n    }\n    return toObject;\n}\nfunction uploadToFileSearchStoreResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromParent = getValueByPath(fromObject, [\n        \"parent\"\n    ]);\n    if (fromParent != null) {\n        setValueByPath(toObject, [\n            \"parent\"\n        ], fromParent);\n    }\n    const fromDocumentName = getValueByPath(fromObject, [\n        \"documentName\"\n    ]);\n    if (fromDocumentName != null) {\n        setValueByPath(toObject, [\n            \"documentName\"\n        ], fromDocumentName);\n    }\n    return toObject;\n}\nfunction videoFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, [\n        \"uri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"uri\"\n        ], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        \"encodedVideo\"\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, [\n            \"videoBytes\"\n        ], tBytes$1(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"encoding\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction videoFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"uri\"\n        ], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        \"bytesBase64Encoded\"\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, [\n            \"videoBytes\"\n        ], tBytes$1(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ /** Outcome of the code execution. */ var Outcome;\n(function(Outcome) {\n    /**\n     * Unspecified status. This value should not be used.\n     */ Outcome[\"OUTCOME_UNSPECIFIED\"] = \"OUTCOME_UNSPECIFIED\";\n    /**\n     * Code execution completed successfully.\n     */ Outcome[\"OUTCOME_OK\"] = \"OUTCOME_OK\";\n    /**\n     * Code execution finished but with a failure. `stderr` should contain the reason.\n     */ Outcome[\"OUTCOME_FAILED\"] = \"OUTCOME_FAILED\";\n    /**\n     * Code execution ran for too long, and was cancelled. There may or may not be a partial output present.\n     */ Outcome[\"OUTCOME_DEADLINE_EXCEEDED\"] = \"OUTCOME_DEADLINE_EXCEEDED\";\n})(Outcome || (Outcome = {}));\n/** Programming language of the `code`. */ var Language;\n(function(Language) {\n    /**\n     * Unspecified language. This value should not be used.\n     */ Language[\"LANGUAGE_UNSPECIFIED\"] = \"LANGUAGE_UNSPECIFIED\";\n    /**\n     * Python >= 3.10, with numpy and simpy available.\n     */ Language[\"PYTHON\"] = \"PYTHON\";\n})(Language || (Language = {}));\n/** Specifies how the response should be scheduled in the conversation. */ var FunctionResponseScheduling;\n(function(FunctionResponseScheduling) {\n    /**\n     * This value is unused.\n     */ FunctionResponseScheduling[\"SCHEDULING_UNSPECIFIED\"] = \"SCHEDULING_UNSPECIFIED\";\n    /**\n     * Only add the result to the conversation context, do not interrupt or trigger generation.\n     */ FunctionResponseScheduling[\"SILENT\"] = \"SILENT\";\n    /**\n     * Add the result to the conversation context, and prompt to generate output without interrupting ongoing generation.\n     */ FunctionResponseScheduling[\"WHEN_IDLE\"] = \"WHEN_IDLE\";\n    /**\n     * Add the result to the conversation context, interrupt ongoing generation and prompt to generate output.\n     */ FunctionResponseScheduling[\"INTERRUPT\"] = \"INTERRUPT\";\n})(FunctionResponseScheduling || (FunctionResponseScheduling = {}));\n/** The type of the data. */ var Type;\n(function(Type) {\n    /**\n     * Not specified, should not be used.\n     */ Type[\"TYPE_UNSPECIFIED\"] = \"TYPE_UNSPECIFIED\";\n    /**\n     * OpenAPI string type\n     */ Type[\"STRING\"] = \"STRING\";\n    /**\n     * OpenAPI number type\n     */ Type[\"NUMBER\"] = \"NUMBER\";\n    /**\n     * OpenAPI integer type\n     */ Type[\"INTEGER\"] = \"INTEGER\";\n    /**\n     * OpenAPI boolean type\n     */ Type[\"BOOLEAN\"] = \"BOOLEAN\";\n    /**\n     * OpenAPI array type\n     */ Type[\"ARRAY\"] = \"ARRAY\";\n    /**\n     * OpenAPI object type\n     */ Type[\"OBJECT\"] = \"OBJECT\";\n    /**\n     * Null type\n     */ Type[\"NULL\"] = \"NULL\";\n})(Type || (Type = {}));\n/** The mode of the predictor to be used in dynamic retrieval. */ var Mode;\n(function(Mode) {\n    /**\n     * Always trigger retrieval.\n     */ Mode[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n    /**\n     * Run retrieval only when system decides it is necessary.\n     */ Mode[\"MODE_DYNAMIC\"] = \"MODE_DYNAMIC\";\n})(Mode || (Mode = {}));\n/** The API spec that the external API implements. This enum is not supported in Gemini API. */ var ApiSpec;\n(function(ApiSpec) {\n    /**\n     * Unspecified API spec. This value should not be used.\n     */ ApiSpec[\"API_SPEC_UNSPECIFIED\"] = \"API_SPEC_UNSPECIFIED\";\n    /**\n     * Simple search API spec.\n     */ ApiSpec[\"SIMPLE_SEARCH\"] = \"SIMPLE_SEARCH\";\n    /**\n     * Elastic search API spec.\n     */ ApiSpec[\"ELASTIC_SEARCH\"] = \"ELASTIC_SEARCH\";\n})(ApiSpec || (ApiSpec = {}));\n/** Type of auth scheme. This enum is not supported in Gemini API. */ var AuthType;\n(function(AuthType) {\n    AuthType[\"AUTH_TYPE_UNSPECIFIED\"] = \"AUTH_TYPE_UNSPECIFIED\";\n    /**\n     * No Auth.\n     */ AuthType[\"NO_AUTH\"] = \"NO_AUTH\";\n    /**\n     * API Key Auth.\n     */ AuthType[\"API_KEY_AUTH\"] = \"API_KEY_AUTH\";\n    /**\n     * HTTP Basic Auth.\n     */ AuthType[\"HTTP_BASIC_AUTH\"] = \"HTTP_BASIC_AUTH\";\n    /**\n     * Google Service Account Auth.\n     */ AuthType[\"GOOGLE_SERVICE_ACCOUNT_AUTH\"] = \"GOOGLE_SERVICE_ACCOUNT_AUTH\";\n    /**\n     * OAuth auth.\n     */ AuthType[\"OAUTH\"] = \"OAUTH\";\n    /**\n     * OpenID Connect (OIDC) Auth.\n     */ AuthType[\"OIDC_AUTH\"] = \"OIDC_AUTH\";\n})(AuthType || (AuthType = {}));\n/** The location of the API key. This enum is not supported in Gemini API. */ var HttpElementLocation;\n(function(HttpElementLocation) {\n    HttpElementLocation[\"HTTP_IN_UNSPECIFIED\"] = \"HTTP_IN_UNSPECIFIED\";\n    /**\n     * Element is in the HTTP request query.\n     */ HttpElementLocation[\"HTTP_IN_QUERY\"] = \"HTTP_IN_QUERY\";\n    /**\n     * Element is in the HTTP request header.\n     */ HttpElementLocation[\"HTTP_IN_HEADER\"] = \"HTTP_IN_HEADER\";\n    /**\n     * Element is in the HTTP request path.\n     */ HttpElementLocation[\"HTTP_IN_PATH\"] = \"HTTP_IN_PATH\";\n    /**\n     * Element is in the HTTP request body.\n     */ HttpElementLocation[\"HTTP_IN_BODY\"] = \"HTTP_IN_BODY\";\n    /**\n     * Element is in the HTTP request cookie.\n     */ HttpElementLocation[\"HTTP_IN_COOKIE\"] = \"HTTP_IN_COOKIE\";\n})(HttpElementLocation || (HttpElementLocation = {}));\n/** Sites with confidence level chosen & above this value will be blocked from the search results. This enum is not supported in Gemini API. */ var PhishBlockThreshold;\n(function(PhishBlockThreshold) {\n    /**\n     * Defaults to unspecified.\n     */ PhishBlockThreshold[\"PHISH_BLOCK_THRESHOLD_UNSPECIFIED\"] = \"PHISH_BLOCK_THRESHOLD_UNSPECIFIED\";\n    /**\n     * Blocks Low and above confidence URL that is risky.\n     */ PhishBlockThreshold[\"BLOCK_LOW_AND_ABOVE\"] = \"BLOCK_LOW_AND_ABOVE\";\n    /**\n     * Blocks Medium and above confidence URL that is risky.\n     */ PhishBlockThreshold[\"BLOCK_MEDIUM_AND_ABOVE\"] = \"BLOCK_MEDIUM_AND_ABOVE\";\n    /**\n     * Blocks High and above confidence URL that is risky.\n     */ PhishBlockThreshold[\"BLOCK_HIGH_AND_ABOVE\"] = \"BLOCK_HIGH_AND_ABOVE\";\n    /**\n     * Blocks Higher and above confidence URL that is risky.\n     */ PhishBlockThreshold[\"BLOCK_HIGHER_AND_ABOVE\"] = \"BLOCK_HIGHER_AND_ABOVE\";\n    /**\n     * Blocks Very high and above confidence URL that is risky.\n     */ PhishBlockThreshold[\"BLOCK_VERY_HIGH_AND_ABOVE\"] = \"BLOCK_VERY_HIGH_AND_ABOVE\";\n    /**\n     * Blocks Extremely high confidence URL that is risky.\n     */ PhishBlockThreshold[\"BLOCK_ONLY_EXTREMELY_HIGH\"] = \"BLOCK_ONLY_EXTREMELY_HIGH\";\n})(PhishBlockThreshold || (PhishBlockThreshold = {}));\n/** The level of thoughts tokens that the model should generate. */ var ThinkingLevel;\n(function(ThinkingLevel) {\n    /**\n     * Default value.\n     */ ThinkingLevel[\"THINKING_LEVEL_UNSPECIFIED\"] = \"THINKING_LEVEL_UNSPECIFIED\";\n    /**\n     * Low thinking level.\n     */ ThinkingLevel[\"LOW\"] = \"LOW\";\n    /**\n     * High thinking level.\n     */ ThinkingLevel[\"HIGH\"] = \"HIGH\";\n})(ThinkingLevel || (ThinkingLevel = {}));\n/** Harm category. */ var HarmCategory;\n(function(HarmCategory) {\n    /**\n     * The harm category is unspecified.\n     */ HarmCategory[\"HARM_CATEGORY_UNSPECIFIED\"] = \"HARM_CATEGORY_UNSPECIFIED\";\n    /**\n     * The harm category is harassment.\n     */ HarmCategory[\"HARM_CATEGORY_HARASSMENT\"] = \"HARM_CATEGORY_HARASSMENT\";\n    /**\n     * The harm category is hate speech.\n     */ HarmCategory[\"HARM_CATEGORY_HATE_SPEECH\"] = \"HARM_CATEGORY_HATE_SPEECH\";\n    /**\n     * The harm category is sexually explicit content.\n     */ HarmCategory[\"HARM_CATEGORY_SEXUALLY_EXPLICIT\"] = \"HARM_CATEGORY_SEXUALLY_EXPLICIT\";\n    /**\n     * The harm category is dangerous content.\n     */ HarmCategory[\"HARM_CATEGORY_DANGEROUS_CONTENT\"] = \"HARM_CATEGORY_DANGEROUS_CONTENT\";\n    /**\n     * Deprecated: Election filter is not longer supported. The harm category is civic integrity.\n     */ HarmCategory[\"HARM_CATEGORY_CIVIC_INTEGRITY\"] = \"HARM_CATEGORY_CIVIC_INTEGRITY\";\n    /**\n     * The harm category is image hate. This enum value is not supported in Gemini API.\n     */ HarmCategory[\"HARM_CATEGORY_IMAGE_HATE\"] = \"HARM_CATEGORY_IMAGE_HATE\";\n    /**\n     * The harm category is image dangerous content. This enum value is not supported in Gemini API.\n     */ HarmCategory[\"HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT\"] = \"HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT\";\n    /**\n     * The harm category is image harassment. This enum value is not supported in Gemini API.\n     */ HarmCategory[\"HARM_CATEGORY_IMAGE_HARASSMENT\"] = \"HARM_CATEGORY_IMAGE_HARASSMENT\";\n    /**\n     * The harm category is image sexually explicit content. This enum value is not supported in Gemini API.\n     */ HarmCategory[\"HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT\"] = \"HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT\";\n    /**\n     * The harm category is for jailbreak prompts. This enum value is not supported in Gemini API.\n     */ HarmCategory[\"HARM_CATEGORY_JAILBREAK\"] = \"HARM_CATEGORY_JAILBREAK\";\n})(HarmCategory || (HarmCategory = {}));\n/** Specify if the threshold is used for probability or severity score. If not specified, the threshold is used for probability score. This enum is not supported in Gemini API. */ var HarmBlockMethod;\n(function(HarmBlockMethod) {\n    /**\n     * The harm block method is unspecified.\n     */ HarmBlockMethod[\"HARM_BLOCK_METHOD_UNSPECIFIED\"] = \"HARM_BLOCK_METHOD_UNSPECIFIED\";\n    /**\n     * The harm block method uses both probability and severity scores.\n     */ HarmBlockMethod[\"SEVERITY\"] = \"SEVERITY\";\n    /**\n     * The harm block method uses the probability score.\n     */ HarmBlockMethod[\"PROBABILITY\"] = \"PROBABILITY\";\n})(HarmBlockMethod || (HarmBlockMethod = {}));\n/** The harm block threshold. */ var HarmBlockThreshold;\n(function(HarmBlockThreshold) {\n    /**\n     * Unspecified harm block threshold.\n     */ HarmBlockThreshold[\"HARM_BLOCK_THRESHOLD_UNSPECIFIED\"] = \"HARM_BLOCK_THRESHOLD_UNSPECIFIED\";\n    /**\n     * Block low threshold and above (i.e. block more).\n     */ HarmBlockThreshold[\"BLOCK_LOW_AND_ABOVE\"] = \"BLOCK_LOW_AND_ABOVE\";\n    /**\n     * Block medium threshold and above.\n     */ HarmBlockThreshold[\"BLOCK_MEDIUM_AND_ABOVE\"] = \"BLOCK_MEDIUM_AND_ABOVE\";\n    /**\n     * Block only high threshold (i.e. block less).\n     */ HarmBlockThreshold[\"BLOCK_ONLY_HIGH\"] = \"BLOCK_ONLY_HIGH\";\n    /**\n     * Block none.\n     */ HarmBlockThreshold[\"BLOCK_NONE\"] = \"BLOCK_NONE\";\n    /**\n     * Turn off the safety filter.\n     */ HarmBlockThreshold[\"OFF\"] = \"OFF\";\n})(HarmBlockThreshold || (HarmBlockThreshold = {}));\n/** Output only. The reason why the model stopped generating tokens.\n\nIf empty, the model has not stopped generating the tokens. */ var FinishReason;\n(function(FinishReason) {\n    /**\n     * The finish reason is unspecified.\n     */ FinishReason[\"FINISH_REASON_UNSPECIFIED\"] = \"FINISH_REASON_UNSPECIFIED\";\n    /**\n     * Token generation reached a natural stopping point or a configured stop sequence.\n     */ FinishReason[\"STOP\"] = \"STOP\";\n    /**\n     * Token generation reached the configured maximum output tokens.\n     */ FinishReason[\"MAX_TOKENS\"] = \"MAX_TOKENS\";\n    /**\n     * Token generation stopped because the content potentially contains safety violations. NOTE: When streaming, [content][] is empty if content filters blocks the output.\n     */ FinishReason[\"SAFETY\"] = \"SAFETY\";\n    /**\n     * The token generation stopped because of potential recitation.\n     */ FinishReason[\"RECITATION\"] = \"RECITATION\";\n    /**\n     * The token generation stopped because of using an unsupported language.\n     */ FinishReason[\"LANGUAGE\"] = \"LANGUAGE\";\n    /**\n     * All other reasons that stopped the token generation.\n     */ FinishReason[\"OTHER\"] = \"OTHER\";\n    /**\n     * Token generation stopped because the content contains forbidden terms.\n     */ FinishReason[\"BLOCKLIST\"] = \"BLOCKLIST\";\n    /**\n     * Token generation stopped for potentially containing prohibited content.\n     */ FinishReason[\"PROHIBITED_CONTENT\"] = \"PROHIBITED_CONTENT\";\n    /**\n     * Token generation stopped because the content potentially contains Sensitive Personally Identifiable Information (SPII).\n     */ FinishReason[\"SPII\"] = \"SPII\";\n    /**\n     * The function call generated by the model is invalid.\n     */ FinishReason[\"MALFORMED_FUNCTION_CALL\"] = \"MALFORMED_FUNCTION_CALL\";\n    /**\n     * Token generation stopped because generated images have safety violations.\n     */ FinishReason[\"IMAGE_SAFETY\"] = \"IMAGE_SAFETY\";\n    /**\n     * The tool call generated by the model is invalid.\n     */ FinishReason[\"UNEXPECTED_TOOL_CALL\"] = \"UNEXPECTED_TOOL_CALL\";\n    /**\n     * Image generation stopped because the generated images have prohibited content.\n     */ FinishReason[\"IMAGE_PROHIBITED_CONTENT\"] = \"IMAGE_PROHIBITED_CONTENT\";\n    /**\n     * The model was expected to generate an image, but none was generated.\n     */ FinishReason[\"NO_IMAGE\"] = \"NO_IMAGE\";\n})(FinishReason || (FinishReason = {}));\n/** Output only. Harm probability levels in the content. */ var HarmProbability;\n(function(HarmProbability) {\n    /**\n     * Harm probability unspecified.\n     */ HarmProbability[\"HARM_PROBABILITY_UNSPECIFIED\"] = \"HARM_PROBABILITY_UNSPECIFIED\";\n    /**\n     * Negligible level of harm.\n     */ HarmProbability[\"NEGLIGIBLE\"] = \"NEGLIGIBLE\";\n    /**\n     * Low level of harm.\n     */ HarmProbability[\"LOW\"] = \"LOW\";\n    /**\n     * Medium level of harm.\n     */ HarmProbability[\"MEDIUM\"] = \"MEDIUM\";\n    /**\n     * High level of harm.\n     */ HarmProbability[\"HIGH\"] = \"HIGH\";\n})(HarmProbability || (HarmProbability = {}));\n/** Output only. Harm severity levels in the content. This enum is not supported in Gemini API. */ var HarmSeverity;\n(function(HarmSeverity) {\n    /**\n     * Harm severity unspecified.\n     */ HarmSeverity[\"HARM_SEVERITY_UNSPECIFIED\"] = \"HARM_SEVERITY_UNSPECIFIED\";\n    /**\n     * Negligible level of harm severity.\n     */ HarmSeverity[\"HARM_SEVERITY_NEGLIGIBLE\"] = \"HARM_SEVERITY_NEGLIGIBLE\";\n    /**\n     * Low level of harm severity.\n     */ HarmSeverity[\"HARM_SEVERITY_LOW\"] = \"HARM_SEVERITY_LOW\";\n    /**\n     * Medium level of harm severity.\n     */ HarmSeverity[\"HARM_SEVERITY_MEDIUM\"] = \"HARM_SEVERITY_MEDIUM\";\n    /**\n     * High level of harm severity.\n     */ HarmSeverity[\"HARM_SEVERITY_HIGH\"] = \"HARM_SEVERITY_HIGH\";\n})(HarmSeverity || (HarmSeverity = {}));\n/** Status of the url retrieval. */ var UrlRetrievalStatus;\n(function(UrlRetrievalStatus) {\n    /**\n     * Default value. This value is unused.\n     */ UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_UNSPECIFIED\"] = \"URL_RETRIEVAL_STATUS_UNSPECIFIED\";\n    /**\n     * Url retrieval is successful.\n     */ UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_SUCCESS\"] = \"URL_RETRIEVAL_STATUS_SUCCESS\";\n    /**\n     * Url retrieval is failed due to error.\n     */ UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_ERROR\"] = \"URL_RETRIEVAL_STATUS_ERROR\";\n    /**\n     * Url retrieval is failed because the content is behind paywall. This enum value is not supported in Vertex AI.\n     */ UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_PAYWALL\"] = \"URL_RETRIEVAL_STATUS_PAYWALL\";\n    /**\n     * Url retrieval is failed because the content is unsafe. This enum value is not supported in Vertex AI.\n     */ UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_UNSAFE\"] = \"URL_RETRIEVAL_STATUS_UNSAFE\";\n})(UrlRetrievalStatus || (UrlRetrievalStatus = {}));\n/** Output only. The reason why the prompt was blocked. */ var BlockedReason;\n(function(BlockedReason) {\n    /**\n     * The blocked reason is unspecified.\n     */ BlockedReason[\"BLOCKED_REASON_UNSPECIFIED\"] = \"BLOCKED_REASON_UNSPECIFIED\";\n    /**\n     * The prompt was blocked for safety reasons.\n     */ BlockedReason[\"SAFETY\"] = \"SAFETY\";\n    /**\n     * The prompt was blocked for other reasons. For example, it may be due to the prompt's language, or because it contains other harmful content.\n     */ BlockedReason[\"OTHER\"] = \"OTHER\";\n    /**\n     * The prompt was blocked because it contains a term from the terminology blocklist.\n     */ BlockedReason[\"BLOCKLIST\"] = \"BLOCKLIST\";\n    /**\n     * The prompt was blocked because it contains prohibited content.\n     */ BlockedReason[\"PROHIBITED_CONTENT\"] = \"PROHIBITED_CONTENT\";\n    /**\n     * The prompt was blocked because it contains content that is unsafe for image generation.\n     */ BlockedReason[\"IMAGE_SAFETY\"] = \"IMAGE_SAFETY\";\n    /**\n     * The prompt was blocked by Model Armor. This enum value is not supported in Gemini API.\n     */ BlockedReason[\"MODEL_ARMOR\"] = \"MODEL_ARMOR\";\n    /**\n     * The prompt was blocked as a jailbreak attempt. This enum value is not supported in Gemini API.\n     */ BlockedReason[\"JAILBREAK\"] = \"JAILBREAK\";\n})(BlockedReason || (BlockedReason = {}));\n/** Output only. The traffic type for this request. This enum is not supported in Gemini API. */ var TrafficType;\n(function(TrafficType) {\n    /**\n     * Unspecified request traffic type.\n     */ TrafficType[\"TRAFFIC_TYPE_UNSPECIFIED\"] = \"TRAFFIC_TYPE_UNSPECIFIED\";\n    /**\n     * The request was processed using Pay-As-You-Go quota.\n     */ TrafficType[\"ON_DEMAND\"] = \"ON_DEMAND\";\n    /**\n     * Type for Provisioned Throughput traffic.\n     */ TrafficType[\"PROVISIONED_THROUGHPUT\"] = \"PROVISIONED_THROUGHPUT\";\n})(TrafficType || (TrafficType = {}));\n/** Server content modalities. */ var Modality;\n(function(Modality) {\n    /**\n     * The modality is unspecified.\n     */ Modality[\"MODALITY_UNSPECIFIED\"] = \"MODALITY_UNSPECIFIED\";\n    /**\n     * Indicates the model should return text\n     */ Modality[\"TEXT\"] = \"TEXT\";\n    /**\n     * Indicates the model should return images.\n     */ Modality[\"IMAGE\"] = \"IMAGE\";\n    /**\n     * Indicates the model should return audio.\n     */ Modality[\"AUDIO\"] = \"AUDIO\";\n})(Modality || (Modality = {}));\n/** The media resolution to use. */ var MediaResolution;\n(function(MediaResolution) {\n    /**\n     * Media resolution has not been set\n     */ MediaResolution[\"MEDIA_RESOLUTION_UNSPECIFIED\"] = \"MEDIA_RESOLUTION_UNSPECIFIED\";\n    /**\n     * Media resolution set to low (64 tokens).\n     */ MediaResolution[\"MEDIA_RESOLUTION_LOW\"] = \"MEDIA_RESOLUTION_LOW\";\n    /**\n     * Media resolution set to medium (256 tokens).\n     */ MediaResolution[\"MEDIA_RESOLUTION_MEDIUM\"] = \"MEDIA_RESOLUTION_MEDIUM\";\n    /**\n     * Media resolution set to high (zoomed reframing with 256 tokens).\n     */ MediaResolution[\"MEDIA_RESOLUTION_HIGH\"] = \"MEDIA_RESOLUTION_HIGH\";\n})(MediaResolution || (MediaResolution = {}));\n/** Tuning mode. This enum is not supported in Gemini API. */ var TuningMode;\n(function(TuningMode) {\n    /**\n     * Tuning mode is unspecified.\n     */ TuningMode[\"TUNING_MODE_UNSPECIFIED\"] = \"TUNING_MODE_UNSPECIFIED\";\n    /**\n     * Full fine-tuning mode.\n     */ TuningMode[\"TUNING_MODE_FULL\"] = \"TUNING_MODE_FULL\";\n    /**\n     * PEFT adapter tuning mode.\n     */ TuningMode[\"TUNING_MODE_PEFT_ADAPTER\"] = \"TUNING_MODE_PEFT_ADAPTER\";\n})(TuningMode || (TuningMode = {}));\n/** Adapter size for tuning. This enum is not supported in Gemini API. */ var AdapterSize;\n(function(AdapterSize) {\n    /**\n     * Adapter size is unspecified.\n     */ AdapterSize[\"ADAPTER_SIZE_UNSPECIFIED\"] = \"ADAPTER_SIZE_UNSPECIFIED\";\n    /**\n     * Adapter size 1.\n     */ AdapterSize[\"ADAPTER_SIZE_ONE\"] = \"ADAPTER_SIZE_ONE\";\n    /**\n     * Adapter size 2.\n     */ AdapterSize[\"ADAPTER_SIZE_TWO\"] = \"ADAPTER_SIZE_TWO\";\n    /**\n     * Adapter size 4.\n     */ AdapterSize[\"ADAPTER_SIZE_FOUR\"] = \"ADAPTER_SIZE_FOUR\";\n    /**\n     * Adapter size 8.\n     */ AdapterSize[\"ADAPTER_SIZE_EIGHT\"] = \"ADAPTER_SIZE_EIGHT\";\n    /**\n     * Adapter size 16.\n     */ AdapterSize[\"ADAPTER_SIZE_SIXTEEN\"] = \"ADAPTER_SIZE_SIXTEEN\";\n    /**\n     * Adapter size 32.\n     */ AdapterSize[\"ADAPTER_SIZE_THIRTY_TWO\"] = \"ADAPTER_SIZE_THIRTY_TWO\";\n})(AdapterSize || (AdapterSize = {}));\n/** Job state. */ var JobState;\n(function(JobState) {\n    /**\n     * The job state is unspecified.\n     */ JobState[\"JOB_STATE_UNSPECIFIED\"] = \"JOB_STATE_UNSPECIFIED\";\n    /**\n     * The job has been just created or resumed and processing has not yet begun.\n     */ JobState[\"JOB_STATE_QUEUED\"] = \"JOB_STATE_QUEUED\";\n    /**\n     * The service is preparing to run the job.\n     */ JobState[\"JOB_STATE_PENDING\"] = \"JOB_STATE_PENDING\";\n    /**\n     * The job is in progress.\n     */ JobState[\"JOB_STATE_RUNNING\"] = \"JOB_STATE_RUNNING\";\n    /**\n     * The job completed successfully.\n     */ JobState[\"JOB_STATE_SUCCEEDED\"] = \"JOB_STATE_SUCCEEDED\";\n    /**\n     * The job failed.\n     */ JobState[\"JOB_STATE_FAILED\"] = \"JOB_STATE_FAILED\";\n    /**\n     * The job is being cancelled. From this state the job may only go to either `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED` or `JOB_STATE_CANCELLED`.\n     */ JobState[\"JOB_STATE_CANCELLING\"] = \"JOB_STATE_CANCELLING\";\n    /**\n     * The job has been cancelled.\n     */ JobState[\"JOB_STATE_CANCELLED\"] = \"JOB_STATE_CANCELLED\";\n    /**\n     * The job has been stopped, and can be resumed.\n     */ JobState[\"JOB_STATE_PAUSED\"] = \"JOB_STATE_PAUSED\";\n    /**\n     * The job has expired.\n     */ JobState[\"JOB_STATE_EXPIRED\"] = \"JOB_STATE_EXPIRED\";\n    /**\n     * The job is being updated. Only jobs in the `JOB_STATE_RUNNING` state can be updated. After updating, the job goes back to the `JOB_STATE_RUNNING` state.\n     */ JobState[\"JOB_STATE_UPDATING\"] = \"JOB_STATE_UPDATING\";\n    /**\n     * The job is partially succeeded, some results may be missing due to errors.\n     */ JobState[\"JOB_STATE_PARTIALLY_SUCCEEDED\"] = \"JOB_STATE_PARTIALLY_SUCCEEDED\";\n})(JobState || (JobState = {}));\n/** The tuning task. Either I2V or T2V. This enum is not supported in Gemini API. */ var TuningTask;\n(function(TuningTask) {\n    /**\n     * Default value. This value is unused.\n     */ TuningTask[\"TUNING_TASK_UNSPECIFIED\"] = \"TUNING_TASK_UNSPECIFIED\";\n    /**\n     * Tuning task for image to video.\n     */ TuningTask[\"TUNING_TASK_I2V\"] = \"TUNING_TASK_I2V\";\n    /**\n     * Tuning task for text to video.\n     */ TuningTask[\"TUNING_TASK_T2V\"] = \"TUNING_TASK_T2V\";\n    /**\n     * Tuning task for reference to video.\n     */ TuningTask[\"TUNING_TASK_R2V\"] = \"TUNING_TASK_R2V\";\n})(TuningTask || (TuningTask = {}));\n/** The tokenization quality used for given media. */ var PartMediaResolutionLevel;\n(function(PartMediaResolutionLevel) {\n    /**\n     * Media resolution has not been set.\n     */ PartMediaResolutionLevel[\"MEDIA_RESOLUTION_UNSPECIFIED\"] = \"MEDIA_RESOLUTION_UNSPECIFIED\";\n    /**\n     * Media resolution set to low.\n     */ PartMediaResolutionLevel[\"MEDIA_RESOLUTION_LOW\"] = \"MEDIA_RESOLUTION_LOW\";\n    /**\n     * Media resolution set to medium.\n     */ PartMediaResolutionLevel[\"MEDIA_RESOLUTION_MEDIUM\"] = \"MEDIA_RESOLUTION_MEDIUM\";\n    /**\n     * Media resolution set to high.\n     */ PartMediaResolutionLevel[\"MEDIA_RESOLUTION_HIGH\"] = \"MEDIA_RESOLUTION_HIGH\";\n})(PartMediaResolutionLevel || (PartMediaResolutionLevel = {}));\n/** Options for feature selection preference. */ var FeatureSelectionPreference;\n(function(FeatureSelectionPreference) {\n    FeatureSelectionPreference[\"FEATURE_SELECTION_PREFERENCE_UNSPECIFIED\"] = \"FEATURE_SELECTION_PREFERENCE_UNSPECIFIED\";\n    FeatureSelectionPreference[\"PRIORITIZE_QUALITY\"] = \"PRIORITIZE_QUALITY\";\n    FeatureSelectionPreference[\"BALANCED\"] = \"BALANCED\";\n    FeatureSelectionPreference[\"PRIORITIZE_COST\"] = \"PRIORITIZE_COST\";\n})(FeatureSelectionPreference || (FeatureSelectionPreference = {}));\n/** Defines the function behavior. Defaults to `BLOCKING`. */ var Behavior;\n(function(Behavior) {\n    /**\n     * This value is unused.\n     */ Behavior[\"UNSPECIFIED\"] = \"UNSPECIFIED\";\n    /**\n     * If set, the system will wait to receive the function response before continuing the conversation.\n     */ Behavior[\"BLOCKING\"] = \"BLOCKING\";\n    /**\n     * If set, the system will not wait to receive the function response. Instead, it will attempt to handle function responses as they become available while maintaining the conversation between the user and the model.\n     */ Behavior[\"NON_BLOCKING\"] = \"NON_BLOCKING\";\n})(Behavior || (Behavior = {}));\n/** Config for the dynamic retrieval config mode. */ var DynamicRetrievalConfigMode;\n(function(DynamicRetrievalConfigMode) {\n    /**\n     * Always trigger retrieval.\n     */ DynamicRetrievalConfigMode[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n    /**\n     * Run retrieval only when system decides it is necessary.\n     */ DynamicRetrievalConfigMode[\"MODE_DYNAMIC\"] = \"MODE_DYNAMIC\";\n})(DynamicRetrievalConfigMode || (DynamicRetrievalConfigMode = {}));\n/** The environment being operated. */ var Environment;\n(function(Environment) {\n    /**\n     * Defaults to browser.\n     */ Environment[\"ENVIRONMENT_UNSPECIFIED\"] = \"ENVIRONMENT_UNSPECIFIED\";\n    /**\n     * Operates in a web browser.\n     */ Environment[\"ENVIRONMENT_BROWSER\"] = \"ENVIRONMENT_BROWSER\";\n})(Environment || (Environment = {}));\n/** Config for the function calling config mode. */ var FunctionCallingConfigMode;\n(function(FunctionCallingConfigMode) {\n    /**\n     * The function calling config mode is unspecified. Should not be used.\n     */ FunctionCallingConfigMode[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n    /**\n     * Default model behavior, model decides to predict either function calls or natural language response.\n     */ FunctionCallingConfigMode[\"AUTO\"] = \"AUTO\";\n    /**\n     * Model is constrained to always predicting function calls only. If \"allowed_function_names\" are set, the predicted function calls will be limited to any one of \"allowed_function_names\", else the predicted function calls will be any one of the provided \"function_declarations\".\n     */ FunctionCallingConfigMode[\"ANY\"] = \"ANY\";\n    /**\n     * Model will not predict any function calls. Model behavior is same as when not passing any function declarations.\n     */ FunctionCallingConfigMode[\"NONE\"] = \"NONE\";\n    /**\n     * Model decides to predict either a function call or a natural language response, but will validate function calls with constrained decoding. If \"allowed_function_names\" are set, the predicted function call will be limited to any one of \"allowed_function_names\", else the predicted function call will be any one of the provided \"function_declarations\".\n     */ FunctionCallingConfigMode[\"VALIDATED\"] = \"VALIDATED\";\n})(FunctionCallingConfigMode || (FunctionCallingConfigMode = {}));\n/** Enum that controls the safety filter level for objectionable content. */ var SafetyFilterLevel;\n(function(SafetyFilterLevel) {\n    SafetyFilterLevel[\"BLOCK_LOW_AND_ABOVE\"] = \"BLOCK_LOW_AND_ABOVE\";\n    SafetyFilterLevel[\"BLOCK_MEDIUM_AND_ABOVE\"] = \"BLOCK_MEDIUM_AND_ABOVE\";\n    SafetyFilterLevel[\"BLOCK_ONLY_HIGH\"] = \"BLOCK_ONLY_HIGH\";\n    SafetyFilterLevel[\"BLOCK_NONE\"] = \"BLOCK_NONE\";\n})(SafetyFilterLevel || (SafetyFilterLevel = {}));\n/** Enum that controls the generation of people. */ var PersonGeneration;\n(function(PersonGeneration) {\n    /**\n     * Block generation of images of people.\n     */ PersonGeneration[\"DONT_ALLOW\"] = \"DONT_ALLOW\";\n    /**\n     * Generate images of adults, but not children.\n     */ PersonGeneration[\"ALLOW_ADULT\"] = \"ALLOW_ADULT\";\n    /**\n     * Generate images that include adults and children.\n     */ PersonGeneration[\"ALLOW_ALL\"] = \"ALLOW_ALL\";\n})(PersonGeneration || (PersonGeneration = {}));\n/** Enum that specifies the language of the text in the prompt. */ var ImagePromptLanguage;\n(function(ImagePromptLanguage) {\n    /**\n     * Auto-detect the language.\n     */ ImagePromptLanguage[\"auto\"] = \"auto\";\n    /**\n     * English\n     */ ImagePromptLanguage[\"en\"] = \"en\";\n    /**\n     * Japanese\n     */ ImagePromptLanguage[\"ja\"] = \"ja\";\n    /**\n     * Korean\n     */ ImagePromptLanguage[\"ko\"] = \"ko\";\n    /**\n     * Hindi\n     */ ImagePromptLanguage[\"hi\"] = \"hi\";\n    /**\n     * Chinese\n     */ ImagePromptLanguage[\"zh\"] = \"zh\";\n    /**\n     * Portuguese\n     */ ImagePromptLanguage[\"pt\"] = \"pt\";\n    /**\n     * Spanish\n     */ ImagePromptLanguage[\"es\"] = \"es\";\n})(ImagePromptLanguage || (ImagePromptLanguage = {}));\n/** Enum representing the mask mode of a mask reference image. */ var MaskReferenceMode;\n(function(MaskReferenceMode) {\n    MaskReferenceMode[\"MASK_MODE_DEFAULT\"] = \"MASK_MODE_DEFAULT\";\n    MaskReferenceMode[\"MASK_MODE_USER_PROVIDED\"] = \"MASK_MODE_USER_PROVIDED\";\n    MaskReferenceMode[\"MASK_MODE_BACKGROUND\"] = \"MASK_MODE_BACKGROUND\";\n    MaskReferenceMode[\"MASK_MODE_FOREGROUND\"] = \"MASK_MODE_FOREGROUND\";\n    MaskReferenceMode[\"MASK_MODE_SEMANTIC\"] = \"MASK_MODE_SEMANTIC\";\n})(MaskReferenceMode || (MaskReferenceMode = {}));\n/** Enum representing the control type of a control reference image. */ var ControlReferenceType;\n(function(ControlReferenceType) {\n    ControlReferenceType[\"CONTROL_TYPE_DEFAULT\"] = \"CONTROL_TYPE_DEFAULT\";\n    ControlReferenceType[\"CONTROL_TYPE_CANNY\"] = \"CONTROL_TYPE_CANNY\";\n    ControlReferenceType[\"CONTROL_TYPE_SCRIBBLE\"] = \"CONTROL_TYPE_SCRIBBLE\";\n    ControlReferenceType[\"CONTROL_TYPE_FACE_MESH\"] = \"CONTROL_TYPE_FACE_MESH\";\n})(ControlReferenceType || (ControlReferenceType = {}));\n/** Enum representing the subject type of a subject reference image. */ var SubjectReferenceType;\n(function(SubjectReferenceType) {\n    SubjectReferenceType[\"SUBJECT_TYPE_DEFAULT\"] = \"SUBJECT_TYPE_DEFAULT\";\n    SubjectReferenceType[\"SUBJECT_TYPE_PERSON\"] = \"SUBJECT_TYPE_PERSON\";\n    SubjectReferenceType[\"SUBJECT_TYPE_ANIMAL\"] = \"SUBJECT_TYPE_ANIMAL\";\n    SubjectReferenceType[\"SUBJECT_TYPE_PRODUCT\"] = \"SUBJECT_TYPE_PRODUCT\";\n})(SubjectReferenceType || (SubjectReferenceType = {}));\n/** Enum representing the editing mode. */ var EditMode;\n(function(EditMode) {\n    EditMode[\"EDIT_MODE_DEFAULT\"] = \"EDIT_MODE_DEFAULT\";\n    EditMode[\"EDIT_MODE_INPAINT_REMOVAL\"] = \"EDIT_MODE_INPAINT_REMOVAL\";\n    EditMode[\"EDIT_MODE_INPAINT_INSERTION\"] = \"EDIT_MODE_INPAINT_INSERTION\";\n    EditMode[\"EDIT_MODE_OUTPAINT\"] = \"EDIT_MODE_OUTPAINT\";\n    EditMode[\"EDIT_MODE_CONTROLLED_EDITING\"] = \"EDIT_MODE_CONTROLLED_EDITING\";\n    EditMode[\"EDIT_MODE_STYLE\"] = \"EDIT_MODE_STYLE\";\n    EditMode[\"EDIT_MODE_BGSWAP\"] = \"EDIT_MODE_BGSWAP\";\n    EditMode[\"EDIT_MODE_PRODUCT_IMAGE\"] = \"EDIT_MODE_PRODUCT_IMAGE\";\n})(EditMode || (EditMode = {}));\n/** Enum that represents the segmentation mode. */ var SegmentMode;\n(function(SegmentMode) {\n    SegmentMode[\"FOREGROUND\"] = \"FOREGROUND\";\n    SegmentMode[\"BACKGROUND\"] = \"BACKGROUND\";\n    SegmentMode[\"PROMPT\"] = \"PROMPT\";\n    SegmentMode[\"SEMANTIC\"] = \"SEMANTIC\";\n    SegmentMode[\"INTERACTIVE\"] = \"INTERACTIVE\";\n})(SegmentMode || (SegmentMode = {}));\n/** Enum for the reference type of a video generation reference image. */ var VideoGenerationReferenceType;\n(function(VideoGenerationReferenceType) {\n    /**\n     * A reference image that provides assets to the generated video,\n        such as the scene, an object, a character, etc.\n     */ VideoGenerationReferenceType[\"ASSET\"] = \"ASSET\";\n    /**\n     * A reference image that provides aesthetics including colors,\n        lighting, texture, etc., to be used as the style of the generated video,\n        such as 'anime', 'photography', 'origami', etc.\n     */ VideoGenerationReferenceType[\"STYLE\"] = \"STYLE\";\n})(VideoGenerationReferenceType || (VideoGenerationReferenceType = {}));\n/** Enum for the mask mode of a video generation mask. */ var VideoGenerationMaskMode;\n(function(VideoGenerationMaskMode) {\n    /**\n     * The image mask contains a masked rectangular region which is\n        applied on the first frame of the input video. The object described in\n        the prompt is inserted into this region and will appear in subsequent\n        frames.\n     */ VideoGenerationMaskMode[\"INSERT\"] = \"INSERT\";\n    /**\n     * The image mask is used to determine an object in the\n        first video frame to track. This object is removed from the video.\n     */ VideoGenerationMaskMode[\"REMOVE\"] = \"REMOVE\";\n    /**\n     * The image mask is used to determine a region in the\n        video. Objects in this region will be removed.\n     */ VideoGenerationMaskMode[\"REMOVE_STATIC\"] = \"REMOVE_STATIC\";\n    /**\n     * The image mask contains a masked rectangular region where\n        the input video will go. The remaining area will be generated. Video\n        masks are not supported.\n     */ VideoGenerationMaskMode[\"OUTPAINT\"] = \"OUTPAINT\";\n})(VideoGenerationMaskMode || (VideoGenerationMaskMode = {}));\n/** Enum that controls the compression quality of the generated videos. */ var VideoCompressionQuality;\n(function(VideoCompressionQuality) {\n    /**\n     * Optimized video compression quality. This will produce videos\n        with a compressed, smaller file size.\n     */ VideoCompressionQuality[\"OPTIMIZED\"] = \"OPTIMIZED\";\n    /**\n     * Lossless video compression quality. This will produce videos\n        with a larger file size.\n     */ VideoCompressionQuality[\"LOSSLESS\"] = \"LOSSLESS\";\n})(VideoCompressionQuality || (VideoCompressionQuality = {}));\n/** Enum representing the tuning method. */ var TuningMethod;\n(function(TuningMethod) {\n    /**\n     * Supervised fine tuning.\n     */ TuningMethod[\"SUPERVISED_FINE_TUNING\"] = \"SUPERVISED_FINE_TUNING\";\n    /**\n     * Preference optimization tuning.\n     */ TuningMethod[\"PREFERENCE_TUNING\"] = \"PREFERENCE_TUNING\";\n})(TuningMethod || (TuningMethod = {}));\n/** State for the lifecycle of a Document. */ var DocumentState;\n(function(DocumentState) {\n    DocumentState[\"STATE_UNSPECIFIED\"] = \"STATE_UNSPECIFIED\";\n    DocumentState[\"STATE_PENDING\"] = \"STATE_PENDING\";\n    DocumentState[\"STATE_ACTIVE\"] = \"STATE_ACTIVE\";\n    DocumentState[\"STATE_FAILED\"] = \"STATE_FAILED\";\n})(DocumentState || (DocumentState = {}));\n/** State for the lifecycle of a File. */ var FileState;\n(function(FileState) {\n    FileState[\"STATE_UNSPECIFIED\"] = \"STATE_UNSPECIFIED\";\n    FileState[\"PROCESSING\"] = \"PROCESSING\";\n    FileState[\"ACTIVE\"] = \"ACTIVE\";\n    FileState[\"FAILED\"] = \"FAILED\";\n})(FileState || (FileState = {}));\n/** Source of the File. */ var FileSource;\n(function(FileSource) {\n    FileSource[\"SOURCE_UNSPECIFIED\"] = \"SOURCE_UNSPECIFIED\";\n    FileSource[\"UPLOADED\"] = \"UPLOADED\";\n    FileSource[\"GENERATED\"] = \"GENERATED\";\n})(FileSource || (FileSource = {}));\n/** The reason why the turn is complete. */ var TurnCompleteReason;\n(function(TurnCompleteReason) {\n    /**\n     * Default value. Reason is unspecified.\n     */ TurnCompleteReason[\"TURN_COMPLETE_REASON_UNSPECIFIED\"] = \"TURN_COMPLETE_REASON_UNSPECIFIED\";\n    /**\n     * The function call generated by the model is invalid.\n     */ TurnCompleteReason[\"MALFORMED_FUNCTION_CALL\"] = \"MALFORMED_FUNCTION_CALL\";\n    /**\n     * The response is rejected by the model.\n     */ TurnCompleteReason[\"RESPONSE_REJECTED\"] = \"RESPONSE_REJECTED\";\n    /**\n     * Needs more input from the user.\n     */ TurnCompleteReason[\"NEED_MORE_INPUT\"] = \"NEED_MORE_INPUT\";\n})(TurnCompleteReason || (TurnCompleteReason = {}));\n/** Server content modalities. */ var MediaModality;\n(function(MediaModality) {\n    /**\n     * The modality is unspecified.\n     */ MediaModality[\"MODALITY_UNSPECIFIED\"] = \"MODALITY_UNSPECIFIED\";\n    /**\n     * Plain text.\n     */ MediaModality[\"TEXT\"] = \"TEXT\";\n    /**\n     * Images.\n     */ MediaModality[\"IMAGE\"] = \"IMAGE\";\n    /**\n     * Video.\n     */ MediaModality[\"VIDEO\"] = \"VIDEO\";\n    /**\n     * Audio.\n     */ MediaModality[\"AUDIO\"] = \"AUDIO\";\n    /**\n     * Document, e.g. PDF.\n     */ MediaModality[\"DOCUMENT\"] = \"DOCUMENT\";\n})(MediaModality || (MediaModality = {}));\n/** Start of speech sensitivity. */ var StartSensitivity;\n(function(StartSensitivity) {\n    /**\n     * The default is START_SENSITIVITY_LOW.\n     */ StartSensitivity[\"START_SENSITIVITY_UNSPECIFIED\"] = \"START_SENSITIVITY_UNSPECIFIED\";\n    /**\n     * Automatic detection will detect the start of speech more often.\n     */ StartSensitivity[\"START_SENSITIVITY_HIGH\"] = \"START_SENSITIVITY_HIGH\";\n    /**\n     * Automatic detection will detect the start of speech less often.\n     */ StartSensitivity[\"START_SENSITIVITY_LOW\"] = \"START_SENSITIVITY_LOW\";\n})(StartSensitivity || (StartSensitivity = {}));\n/** End of speech sensitivity. */ var EndSensitivity;\n(function(EndSensitivity) {\n    /**\n     * The default is END_SENSITIVITY_LOW.\n     */ EndSensitivity[\"END_SENSITIVITY_UNSPECIFIED\"] = \"END_SENSITIVITY_UNSPECIFIED\";\n    /**\n     * Automatic detection ends speech more often.\n     */ EndSensitivity[\"END_SENSITIVITY_HIGH\"] = \"END_SENSITIVITY_HIGH\";\n    /**\n     * Automatic detection ends speech less often.\n     */ EndSensitivity[\"END_SENSITIVITY_LOW\"] = \"END_SENSITIVITY_LOW\";\n})(EndSensitivity || (EndSensitivity = {}));\n/** The different ways of handling user activity. */ var ActivityHandling;\n(function(ActivityHandling) {\n    /**\n     * If unspecified, the default behavior is `START_OF_ACTIVITY_INTERRUPTS`.\n     */ ActivityHandling[\"ACTIVITY_HANDLING_UNSPECIFIED\"] = \"ACTIVITY_HANDLING_UNSPECIFIED\";\n    /**\n     * If true, start of activity will interrupt the model's response (also called \"barge in\"). The model's current response will be cut-off in the moment of the interruption. This is the default behavior.\n     */ ActivityHandling[\"START_OF_ACTIVITY_INTERRUPTS\"] = \"START_OF_ACTIVITY_INTERRUPTS\";\n    /**\n     * The model's response will not be interrupted.\n     */ ActivityHandling[\"NO_INTERRUPTION\"] = \"NO_INTERRUPTION\";\n})(ActivityHandling || (ActivityHandling = {}));\n/** Options about which input is included in the user's turn. */ var TurnCoverage;\n(function(TurnCoverage) {\n    /**\n     * If unspecified, the default behavior is `TURN_INCLUDES_ONLY_ACTIVITY`.\n     */ TurnCoverage[\"TURN_COVERAGE_UNSPECIFIED\"] = \"TURN_COVERAGE_UNSPECIFIED\";\n    /**\n     * The users turn only includes activity since the last turn, excluding inactivity (e.g. silence on the audio stream). This is the default behavior.\n     */ TurnCoverage[\"TURN_INCLUDES_ONLY_ACTIVITY\"] = \"TURN_INCLUDES_ONLY_ACTIVITY\";\n    /**\n     * The users turn includes all realtime input since the last turn, including inactivity (e.g. silence on the audio stream).\n     */ TurnCoverage[\"TURN_INCLUDES_ALL_INPUT\"] = \"TURN_INCLUDES_ALL_INPUT\";\n})(TurnCoverage || (TurnCoverage = {}));\n/** Scale of the generated music. */ var Scale;\n(function(Scale) {\n    /**\n     * Default value. This value is unused.\n     */ Scale[\"SCALE_UNSPECIFIED\"] = \"SCALE_UNSPECIFIED\";\n    /**\n     * C major or A minor.\n     */ Scale[\"C_MAJOR_A_MINOR\"] = \"C_MAJOR_A_MINOR\";\n    /**\n     * Db major or Bb minor.\n     */ Scale[\"D_FLAT_MAJOR_B_FLAT_MINOR\"] = \"D_FLAT_MAJOR_B_FLAT_MINOR\";\n    /**\n     * D major or B minor.\n     */ Scale[\"D_MAJOR_B_MINOR\"] = \"D_MAJOR_B_MINOR\";\n    /**\n     * Eb major or C minor\n     */ Scale[\"E_FLAT_MAJOR_C_MINOR\"] = \"E_FLAT_MAJOR_C_MINOR\";\n    /**\n     * E major or Db minor.\n     */ Scale[\"E_MAJOR_D_FLAT_MINOR\"] = \"E_MAJOR_D_FLAT_MINOR\";\n    /**\n     * F major or D minor.\n     */ Scale[\"F_MAJOR_D_MINOR\"] = \"F_MAJOR_D_MINOR\";\n    /**\n     * Gb major or Eb minor.\n     */ Scale[\"G_FLAT_MAJOR_E_FLAT_MINOR\"] = \"G_FLAT_MAJOR_E_FLAT_MINOR\";\n    /**\n     * G major or E minor.\n     */ Scale[\"G_MAJOR_E_MINOR\"] = \"G_MAJOR_E_MINOR\";\n    /**\n     * Ab major or F minor.\n     */ Scale[\"A_FLAT_MAJOR_F_MINOR\"] = \"A_FLAT_MAJOR_F_MINOR\";\n    /**\n     * A major or Gb minor.\n     */ Scale[\"A_MAJOR_G_FLAT_MINOR\"] = \"A_MAJOR_G_FLAT_MINOR\";\n    /**\n     * Bb major or G minor.\n     */ Scale[\"B_FLAT_MAJOR_G_MINOR\"] = \"B_FLAT_MAJOR_G_MINOR\";\n    /**\n     * B major or Ab minor.\n     */ Scale[\"B_MAJOR_A_FLAT_MINOR\"] = \"B_MAJOR_A_FLAT_MINOR\";\n})(Scale || (Scale = {}));\n/** The mode of music generation. */ var MusicGenerationMode;\n(function(MusicGenerationMode) {\n    /**\n     * Rely on the server default generation mode.\n     */ MusicGenerationMode[\"MUSIC_GENERATION_MODE_UNSPECIFIED\"] = \"MUSIC_GENERATION_MODE_UNSPECIFIED\";\n    /**\n     * Steer text prompts to regions of latent space with higher quality\n        music.\n     */ MusicGenerationMode[\"QUALITY\"] = \"QUALITY\";\n    /**\n     * Steer text prompts to regions of latent space with a larger\n        diversity of music.\n     */ MusicGenerationMode[\"DIVERSITY\"] = \"DIVERSITY\";\n    /**\n     * Steer text prompts to regions of latent space more likely to\n        generate music with vocals.\n     */ MusicGenerationMode[\"VOCALIZATION\"] = \"VOCALIZATION\";\n})(MusicGenerationMode || (MusicGenerationMode = {}));\n/** The playback control signal to apply to the music generation. */ var LiveMusicPlaybackControl;\n(function(LiveMusicPlaybackControl) {\n    /**\n     * This value is unused.\n     */ LiveMusicPlaybackControl[\"PLAYBACK_CONTROL_UNSPECIFIED\"] = \"PLAYBACK_CONTROL_UNSPECIFIED\";\n    /**\n     * Start generating the music.\n     */ LiveMusicPlaybackControl[\"PLAY\"] = \"PLAY\";\n    /**\n     * Hold the music generation. Use PLAY to resume from the current position.\n     */ LiveMusicPlaybackControl[\"PAUSE\"] = \"PAUSE\";\n    /**\n     * Stop the music generation and reset the context (prompts retained).\n        Use PLAY to restart the music generation.\n     */ LiveMusicPlaybackControl[\"STOP\"] = \"STOP\";\n    /**\n     * Reset the context of the music generation without stopping it.\n        Retains the current prompts and config.\n     */ LiveMusicPlaybackControl[\"RESET_CONTEXT\"] = \"RESET_CONTEXT\";\n})(LiveMusicPlaybackControl || (LiveMusicPlaybackControl = {}));\n/** Raw media bytes for function response.\n\nText should not be sent as raw bytes, use the FunctionResponse.response\nfield. */ class FunctionResponseBlob {\n}\n/** URI based data for function response. */ class FunctionResponseFileData {\n}\n/** A datatype containing media that is part of a `FunctionResponse` message.\n\nA `FunctionResponsePart` consists of data which has an associated datatype. A\n`FunctionResponsePart` can only contain one of the accepted types in\n`FunctionResponsePart.data`.\n\nA `FunctionResponsePart` must have a fixed IANA MIME type identifying the\ntype and subtype of the media if the `inline_data` field is filled with raw\nbytes. */ class FunctionResponsePart {\n}\n/**\n * Creates a `FunctionResponsePart` object from a `base64` encoded `string`.\n */ function createFunctionResponsePartFromBase64(data, mimeType) {\n    return {\n        inlineData: {\n            data: data,\n            mimeType: mimeType\n        }\n    };\n}\n/**\n * Creates a `FunctionResponsePart` object from a `URI` string.\n */ function createFunctionResponsePartFromUri(uri, mimeType) {\n    return {\n        fileData: {\n            fileUri: uri,\n            mimeType: mimeType\n        }\n    };\n}\n/** A function response. */ class FunctionResponse {\n}\n/**\n * Creates a `Part` object from a `URI` string.\n */ function createPartFromUri(uri, mimeType, mediaResolution) {\n    return Object.assign({\n        fileData: {\n            fileUri: uri,\n            mimeType: mimeType\n        }\n    }, mediaResolution && {\n        mediaResolution: {\n            level: mediaResolution\n        }\n    });\n}\n/**\n * Creates a `Part` object from a `text` string.\n */ function createPartFromText(text) {\n    return {\n        text: text\n    };\n}\n/**\n * Creates a `Part` object from a `FunctionCall` object.\n */ function createPartFromFunctionCall(name, args) {\n    return {\n        functionCall: {\n            name: name,\n            args: args\n        }\n    };\n}\n/**\n * Creates a `Part` object from a `FunctionResponse` object.\n */ function createPartFromFunctionResponse(id, name, response) {\n    let parts = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];\n    return {\n        functionResponse: Object.assign({\n            id: id,\n            name: name,\n            response: response\n        }, parts.length > 0 && {\n            parts\n        })\n    };\n}\n/**\n * Creates a `Part` object from a `base64` encoded `string`.\n */ function createPartFromBase64(data, mimeType, mediaResolution) {\n    return Object.assign({\n        inlineData: {\n            data: data,\n            mimeType: mimeType\n        }\n    }, mediaResolution && {\n        mediaResolution: {\n            level: mediaResolution\n        }\n    });\n}\n/**\n * Creates a `Part` object from the `outcome` and `output` of a `CodeExecutionResult` object.\n */ function createPartFromCodeExecutionResult(outcome, output) {\n    return {\n        codeExecutionResult: {\n            outcome: outcome,\n            output: output\n        }\n    };\n}\n/**\n * Creates a `Part` object from the `code` and `language` of an `ExecutableCode` object.\n */ function createPartFromExecutableCode(code, language) {\n    return {\n        executableCode: {\n            code: code,\n            language: language\n        }\n    };\n}\nfunction _isPart(obj) {\n    if (typeof obj === \"object\" && obj !== null) {\n        return \"fileData\" in obj || \"text\" in obj || \"functionCall\" in obj || \"functionResponse\" in obj || \"inlineData\" in obj || \"videoMetadata\" in obj || \"codeExecutionResult\" in obj || \"executableCode\" in obj;\n    }\n    return false;\n}\nfunction _toParts(partOrString) {\n    const parts = [];\n    if (typeof partOrString === \"string\") {\n        parts.push(createPartFromText(partOrString));\n    } else if (_isPart(partOrString)) {\n        parts.push(partOrString);\n    } else if (Array.isArray(partOrString)) {\n        if (partOrString.length === 0) {\n            throw new Error(\"partOrString cannot be an empty array\");\n        }\n        for (const part of partOrString){\n            if (typeof part === \"string\") {\n                parts.push(createPartFromText(part));\n            } else if (_isPart(part)) {\n                parts.push(part);\n            } else {\n                throw new Error(\"element in PartUnion must be a Part object or string\");\n            }\n        }\n    } else {\n        throw new Error(\"partOrString must be a Part object, string, or array\");\n    }\n    return parts;\n}\n/**\n * Creates a `Content` object with a user role from a `PartListUnion` object or `string`.\n */ function createUserContent(partOrString) {\n    return {\n        role: \"user\",\n        parts: _toParts(partOrString)\n    };\n}\n/**\n * Creates a `Content` object with a model role from a `PartListUnion` object or `string`.\n */ function createModelContent(partOrString) {\n    return {\n        role: \"model\",\n        parts: _toParts(partOrString)\n    };\n}\n/** A wrapper class for the http response. */ class HttpResponse {\n    json() {\n        return this.responseInternal.json();\n    }\n    constructor(response){\n        // Process the headers.\n        const headers = {};\n        for (const pair of response.headers.entries()){\n            headers[pair[0]] = pair[1];\n        }\n        this.headers = headers;\n        // Keep the original response.\n        this.responseInternal = response;\n    }\n}\n/** Content filter results for a prompt sent in the request. Note: This is sent only in the first stream chunk and only if no candidates were generated due to content violations. */ class GenerateContentResponsePromptFeedback {\n}\n/** Usage metadata about the content generation request and response. This message provides a detailed breakdown of token usage and other relevant metrics. This data type is not supported in Gemini API. */ class GenerateContentResponseUsageMetadata {\n}\n/** Response message for PredictionService.GenerateContent. */ class GenerateContentResponse {\n    /**\n     * Returns the concatenation of all text parts from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the text from the first\n     * one will be returned.\n     * If there are non-text parts in the response, the concatenation of all text\n     * parts will be returned, and a warning will be logged.\n     * If there are thought parts in the response, the concatenation of all text\n     * parts excluding the thought parts will be returned.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.generateContent({\n     *   model: 'gemini-2.0-flash',\n     *   contents:\n     *     'Why is the sky blue?',\n     * });\n     *\n     * console.debug(response.text);\n     * ```\n     */ get text() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn(\"there are multiple candidates in the response, returning text from the first one.\");\n        }\n        let text = \"\";\n        let anyTextPartText = false;\n        const nonTextParts = [];\n        for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []){\n            for (const [fieldName, fieldValue] of Object.entries(part)){\n                if (fieldName !== \"text\" && fieldName !== \"thought\" && fieldName !== \"thoughtSignature\" && (fieldValue !== null || fieldValue !== undefined)) {\n                    nonTextParts.push(fieldName);\n                }\n            }\n            if (typeof part.text === \"string\") {\n                if (typeof part.thought === \"boolean\" && part.thought) {\n                    continue;\n                }\n                anyTextPartText = true;\n                text += part.text;\n            }\n        }\n        if (nonTextParts.length > 0) {\n            console.warn(\"there are non-text parts \".concat(nonTextParts, \" in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.\"));\n        }\n        // part.text === '' is different from part.text is null\n        return anyTextPartText ? text : undefined;\n    }\n    /**\n     * Returns the concatenation of all inline data parts from the first candidate\n     * in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the inline data from the\n     * first one will be returned. If there are non-inline data parts in the\n     * response, the concatenation of all inline data parts will be returned, and\n     * a warning will be logged.\n     */ get data() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn(\"there are multiple candidates in the response, returning data from the first one.\");\n        }\n        let data = \"\";\n        const nonDataParts = [];\n        for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []){\n            for (const [fieldName, fieldValue] of Object.entries(part)){\n                if (fieldName !== \"inlineData\" && (fieldValue !== null || fieldValue !== undefined)) {\n                    nonDataParts.push(fieldName);\n                }\n            }\n            if (part.inlineData && typeof part.inlineData.data === \"string\") {\n                data += atob(part.inlineData.data);\n            }\n        }\n        if (nonDataParts.length > 0) {\n            console.warn(\"there are non-data parts \".concat(nonDataParts, \" in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.\"));\n        }\n        return data.length > 0 ? btoa(data) : undefined;\n    }\n    /**\n     * Returns the function calls from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the function calls from\n     * the first one will be returned.\n     * If there are no function calls in the response, undefined will be returned.\n     *\n     * @example\n     * ```ts\n     * const controlLightFunctionDeclaration: FunctionDeclaration = {\n     *   name: 'controlLight',\n     *   parameters: {\n     *   type: Type.OBJECT,\n     *   description: 'Set the brightness and color temperature of a room light.',\n     *   properties: {\n     *     brightness: {\n     *       type: Type.NUMBER,\n     *       description:\n     *         'Light level from 0 to 100. Zero is off and 100 is full brightness.',\n     *     },\n     *     colorTemperature: {\n     *       type: Type.STRING,\n     *       description:\n     *         'Color temperature of the light fixture which can be `daylight`, `cool` or `warm`.',\n     *     },\n     *   },\n     *   required: ['brightness', 'colorTemperature'],\n     *  };\n     *  const response = await ai.models.generateContent({\n     *     model: 'gemini-2.0-flash',\n     *     contents: 'Dim the lights so the room feels cozy and warm.',\n     *     config: {\n     *       tools: [{functionDeclarations: [controlLightFunctionDeclaration]}],\n     *       toolConfig: {\n     *         functionCallingConfig: {\n     *           mode: FunctionCallingConfigMode.ANY,\n     *           allowedFunctionNames: ['controlLight'],\n     *         },\n     *       },\n     *     },\n     *   });\n     *  console.debug(JSON.stringify(response.functionCalls));\n     * ```\n     */ get functionCalls() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn(\"there are multiple candidates in the response, returning function calls from the first one.\");\n        }\n        const functionCalls = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part)=>part.functionCall).map((part)=>part.functionCall).filter((functionCall)=>functionCall !== undefined);\n        if ((functionCalls === null || functionCalls === void 0 ? void 0 : functionCalls.length) === 0) {\n            return undefined;\n        }\n        return functionCalls;\n    }\n    /**\n     * Returns the first executable code from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the executable code from\n     * the first one will be returned.\n     * If there are no executable code in the response, undefined will be\n     * returned.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.generateContent({\n     *   model: 'gemini-2.0-flash',\n     *   contents:\n     *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'\n     *   config: {\n     *     tools: [{codeExecution: {}}],\n     *   },\n     * });\n     *\n     * console.debug(response.executableCode);\n     * ```\n     */ get executableCode() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn(\"there are multiple candidates in the response, returning executable code from the first one.\");\n        }\n        const executableCode = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part)=>part.executableCode).map((part)=>part.executableCode).filter((executableCode)=>executableCode !== undefined);\n        if ((executableCode === null || executableCode === void 0 ? void 0 : executableCode.length) === 0) {\n            return undefined;\n        }\n        return (_j = executableCode === null || executableCode === void 0 ? void 0 : executableCode[0]) === null || _j === void 0 ? void 0 : _j.code;\n    }\n    /**\n     * Returns the first code execution result from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the code execution result from\n     * the first one will be returned.\n     * If there are no code execution result in the response, undefined will be returned.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.generateContent({\n     *   model: 'gemini-2.0-flash',\n     *   contents:\n     *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'\n     *   config: {\n     *     tools: [{codeExecution: {}}],\n     *   },\n     * });\n     *\n     * console.debug(response.codeExecutionResult);\n     * ```\n     */ get codeExecutionResult() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn(\"there are multiple candidates in the response, returning code execution result from the first one.\");\n        }\n        const codeExecutionResult = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part)=>part.codeExecutionResult).map((part)=>part.codeExecutionResult).filter((codeExecutionResult)=>codeExecutionResult !== undefined);\n        if ((codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult.length) === 0) {\n            return undefined;\n        }\n        return (_j = codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult[0]) === null || _j === void 0 ? void 0 : _j.output;\n    }\n}\n/** Response for the embed_content method. */ class EmbedContentResponse {\n}\n/** The output images response. */ class GenerateImagesResponse {\n}\n/** Response for the request to edit an image. */ class EditImageResponse {\n}\nclass UpscaleImageResponse {\n}\n/** The output images response. */ class RecontextImageResponse {\n}\n/** The output images response. */ class SegmentImageResponse {\n}\nclass ListModelsResponse {\n}\nclass DeleteModelResponse {\n}\n/** Response for counting tokens. */ class CountTokensResponse {\n}\n/** Response for computing tokens. */ class ComputeTokensResponse {\n}\n/** Response with generated videos. */ class GenerateVideosResponse {\n}\n/** A video generation operation. */ class GenerateVideosOperation {\n    /**\n     * Instantiates an Operation of the same type as the one being called with the fields set from the API response.\n     * @internal\n     */ _fromAPIResponse(param) {\n        let { apiResponse, _isVertexAI } = param;\n        const operation = new GenerateVideosOperation();\n        let response;\n        const op = apiResponse;\n        if (_isVertexAI) {\n            response = generateVideosOperationFromVertex$1(op);\n        } else {\n            response = generateVideosOperationFromMldev$1(op);\n        }\n        Object.assign(operation, response);\n        return operation;\n    }\n}\n/** Response for the list tuning jobs method. */ class ListTuningJobsResponse {\n}\n/** Empty response for tunings.cancel method. */ class CancelTuningJobResponse {\n}\n/** Empty response for caches.delete method. */ class DeleteCachedContentResponse {\n}\nclass ListCachedContentsResponse {\n}\n/** Config for documents.list return value. */ class ListDocumentsResponse {\n}\n/** Config for file_search_stores.list return value. */ class ListFileSearchStoresResponse {\n}\n/** Response for the resumable upload method. */ class UploadToFileSearchStoreResumableResponse {\n}\n/** Response for ImportFile to import a File API file with a file search store. */ class ImportFileResponse {\n}\n/** Long-running operation for importing a file to a FileSearchStore. */ class ImportFileOperation {\n    /**\n     * Instantiates an Operation of the same type as the one being called with the fields set from the API response.\n     * @internal\n     */ _fromAPIResponse(param) {\n        let { apiResponse, _isVertexAI } = param;\n        const operation = new ImportFileOperation();\n        const op = apiResponse;\n        const response = importFileOperationFromMldev$1(op);\n        Object.assign(operation, response);\n        return operation;\n    }\n}\n/** Response for the list files method. */ class ListFilesResponse {\n}\n/** Response for the create file method. */ class CreateFileResponse {\n}\n/** Response for the delete file method. */ class DeleteFileResponse {\n}\n/** Config for `inlined_responses` parameter. */ class InlinedResponse {\n}\n/** Config for `response` parameter. */ class SingleEmbedContentResponse {\n}\n/** Config for `inlined_embedding_responses` parameter. */ class InlinedEmbedContentResponse {\n}\n/** Config for batches.list return value. */ class ListBatchJobsResponse {\n}\n/** Represents a single response in a replay. */ class ReplayResponse {\n}\n/** A raw reference image.\n\nA raw reference image represents the base image to edit, provided by the user.\nIt can optionally be provided in addition to a mask reference image or\na style reference image. */ class RawReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */ toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: \"REFERENCE_TYPE_RAW\",\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId\n        };\n        return referenceImageAPI;\n    }\n}\n/** A mask reference image.\n\nThis encapsulates either a mask image provided by the user and configs for\nthe user provided mask, or only config parameters for the model to generate\na mask.\n\nA mask image is an image whose non-zero values indicate where to edit the base\nimage. If the user provides a mask image, the mask must be in the same\ndimensions as the raw image. */ class MaskReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */ toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: \"REFERENCE_TYPE_MASK\",\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n            maskImageConfig: this.config\n        };\n        return referenceImageAPI;\n    }\n}\n/** A control reference image.\n\nThe image of the control reference image is either a control image provided\nby the user, or a regular image which the backend will use to generate a\ncontrol image of. In the case of the latter, the\nenable_control_image_computation field in the config should be set to True.\n\nA control image is an image that represents a sketch image of areas for the\nmodel to fill in based on the prompt. */ class ControlReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */ toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: \"REFERENCE_TYPE_CONTROL\",\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n            controlImageConfig: this.config\n        };\n        return referenceImageAPI;\n    }\n}\n/** A style reference image.\n\nThis encapsulates a style reference image provided by the user, and\nadditionally optional config parameters for the style reference image.\n\nA raw reference image can also be provided as a destination for the style to\nbe applied to. */ class StyleReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */ toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: \"REFERENCE_TYPE_STYLE\",\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n            styleImageConfig: this.config\n        };\n        return referenceImageAPI;\n    }\n}\n/** A subject reference image.\n\nThis encapsulates a subject reference image provided by the user, and\nadditionally optional config parameters for the subject reference image.\n\nA raw reference image can also be provided as a destination for the subject to\nbe applied to. */ class SubjectReferenceImage {\n    /* Internal method to convert to ReferenceImageAPIInternal. */ toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: \"REFERENCE_TYPE_SUBJECT\",\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n            subjectImageConfig: this.config\n        };\n        return referenceImageAPI;\n    }\n}\n/** A content reference image.\n\nA content reference image represents a subject to reference (ex. person,\nproduct, animal) provided by the user. It can optionally be provided in\naddition to a style reference image (ex. background, style reference). */ class ContentReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */ toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: \"REFERENCE_TYPE_CONTENT\",\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId\n        };\n        return referenceImageAPI;\n    }\n}\n/** Response message for API call. */ class LiveServerMessage {\n    /**\n     * Returns the concatenation of all text parts from the server content if present.\n     *\n     * @remarks\n     * If there are non-text parts in the response, the concatenation of all text\n     * parts will be returned, and a warning will be logged.\n     */ get text() {\n        var _a, _b, _c;\n        let text = \"\";\n        let anyTextPartFound = false;\n        const nonTextParts = [];\n        for (const part of (_c = (_b = (_a = this.serverContent) === null || _a === void 0 ? void 0 : _a.modelTurn) === null || _b === void 0 ? void 0 : _b.parts) !== null && _c !== void 0 ? _c : []){\n            for (const [fieldName, fieldValue] of Object.entries(part)){\n                if (fieldName !== \"text\" && fieldName !== \"thought\" && fieldValue !== null) {\n                    nonTextParts.push(fieldName);\n                }\n            }\n            if (typeof part.text === \"string\") {\n                if (typeof part.thought === \"boolean\" && part.thought) {\n                    continue;\n                }\n                anyTextPartFound = true;\n                text += part.text;\n            }\n        }\n        if (nonTextParts.length > 0) {\n            console.warn(\"there are non-text parts \".concat(nonTextParts, \" in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.\"));\n        }\n        // part.text === '' is different from part.text is null\n        return anyTextPartFound ? text : undefined;\n    }\n    /**\n     * Returns the concatenation of all inline data parts from the server content if present.\n     *\n     * @remarks\n     * If there are non-inline data parts in the\n     * response, the concatenation of all inline data parts will be returned, and\n     * a warning will be logged.\n     */ get data() {\n        var _a, _b, _c;\n        let data = \"\";\n        const nonDataParts = [];\n        for (const part of (_c = (_b = (_a = this.serverContent) === null || _a === void 0 ? void 0 : _a.modelTurn) === null || _b === void 0 ? void 0 : _b.parts) !== null && _c !== void 0 ? _c : []){\n            for (const [fieldName, fieldValue] of Object.entries(part)){\n                if (fieldName !== \"inlineData\" && fieldValue !== null) {\n                    nonDataParts.push(fieldName);\n                }\n            }\n            if (part.inlineData && typeof part.inlineData.data === \"string\") {\n                data += atob(part.inlineData.data);\n            }\n        }\n        if (nonDataParts.length > 0) {\n            console.warn(\"there are non-data parts \".concat(nonDataParts, \" in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.\"));\n        }\n        return data.length > 0 ? btoa(data) : undefined;\n    }\n}\n/** Client generated response to a `ToolCall` received from the server.\n\nIndividual `FunctionResponse` objects are matched to the respective\n`FunctionCall` objects by the `id` field.\n\nNote that in the unary and server-streaming GenerateContent APIs function\ncalling happens by exchanging the `Content` parts, while in the bidi\nGenerateContent APIs function calling happens over this dedicated set of\nmessages. */ class LiveClientToolResponse {\n}\n/** Parameters for sending tool responses to the live API. */ class LiveSendToolResponseParameters {\n    constructor(){\n        /** Tool responses to send to the session. */ this.functionResponses = [];\n    }\n}\n/** Response message for the LiveMusicClientMessage call. */ class LiveMusicServerMessage {\n    /**\n     * Returns the first audio chunk from the server content, if present.\n     *\n     * @remarks\n     * If there are no audio chunks in the response, undefined will be returned.\n     */ get audioChunk() {\n        if (this.serverContent && this.serverContent.audioChunks && this.serverContent.audioChunks.length > 0) {\n            return this.serverContent.audioChunks[0];\n        }\n        return undefined;\n    }\n}\n/** The response when long-running operation for uploading a file to a FileSearchStore complete. */ class UploadToFileSearchStoreResponse {\n}\n/** Long-running operation for uploading a file to a FileSearchStore. */ class UploadToFileSearchStoreOperation {\n    /**\n     * Instantiates an Operation of the same type as the one being called with the fields set from the API response.\n     * @internal\n     */ _fromAPIResponse(param) {\n        let { apiResponse, _isVertexAI } = param;\n        const operation = new UploadToFileSearchStoreOperation();\n        const op = apiResponse;\n        const response = uploadToFileSearchStoreOperationFromMldev(op);\n        Object.assign(operation, response);\n        return operation;\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function tModel(apiClient, model) {\n    if (!model || typeof model !== \"string\") {\n        throw new Error(\"model is required and must be a string\");\n    }\n    if (model.includes(\"..\") || model.includes(\"?\") || model.includes(\"&\")) {\n        throw new Error(\"invalid model parameter\");\n    }\n    if (apiClient.isVertexAI()) {\n        if (model.startsWith(\"publishers/\") || model.startsWith(\"projects/\") || model.startsWith(\"models/\")) {\n            return model;\n        } else if (model.indexOf(\"/\") >= 0) {\n            const parts = model.split(\"/\", 2);\n            return \"publishers/\".concat(parts[0], \"/models/\").concat(parts[1]);\n        } else {\n            return \"publishers/google/models/\".concat(model);\n        }\n    } else {\n        if (model.startsWith(\"models/\") || model.startsWith(\"tunedModels/\")) {\n            return model;\n        } else {\n            return \"models/\".concat(model);\n        }\n    }\n}\nfunction tCachesModel(apiClient, model) {\n    const transformedModel = tModel(apiClient, model);\n    if (!transformedModel) {\n        return \"\";\n    }\n    if (transformedModel.startsWith(\"publishers/\") && apiClient.isVertexAI()) {\n        // vertex caches only support model name start with projects.\n        return \"projects/\".concat(apiClient.getProject(), \"/locations/\").concat(apiClient.getLocation(), \"/\").concat(transformedModel);\n    } else if (transformedModel.startsWith(\"models/\") && apiClient.isVertexAI()) {\n        return \"projects/\".concat(apiClient.getProject(), \"/locations/\").concat(apiClient.getLocation(), \"/publishers/google/\").concat(transformedModel);\n    } else {\n        return transformedModel;\n    }\n}\nfunction tBlobs(blobs) {\n    if (Array.isArray(blobs)) {\n        return blobs.map((blob)=>tBlob(blob));\n    } else {\n        return [\n            tBlob(blobs)\n        ];\n    }\n}\nfunction tBlob(blob) {\n    if (typeof blob === \"object\" && blob !== null) {\n        return blob;\n    }\n    throw new Error(\"Could not parse input as Blob. Unsupported blob type: \".concat(typeof blob));\n}\nfunction tImageBlob(blob) {\n    const transformedBlob = tBlob(blob);\n    if (transformedBlob.mimeType && transformedBlob.mimeType.startsWith(\"image/\")) {\n        return transformedBlob;\n    }\n    throw new Error(\"Unsupported mime type: \".concat(transformedBlob.mimeType));\n}\nfunction tAudioBlob(blob) {\n    const transformedBlob = tBlob(blob);\n    if (transformedBlob.mimeType && transformedBlob.mimeType.startsWith(\"audio/\")) {\n        return transformedBlob;\n    }\n    throw new Error(\"Unsupported mime type: \".concat(transformedBlob.mimeType));\n}\nfunction tPart(origin) {\n    if (origin === null || origin === undefined) {\n        throw new Error(\"PartUnion is required\");\n    }\n    if (typeof origin === \"object\") {\n        return origin;\n    }\n    if (typeof origin === \"string\") {\n        return {\n            text: origin\n        };\n    }\n    throw new Error(\"Unsupported part type: \".concat(typeof origin));\n}\nfunction tParts(origin) {\n    if (origin === null || origin === undefined || Array.isArray(origin) && origin.length === 0) {\n        throw new Error(\"PartListUnion is required\");\n    }\n    if (Array.isArray(origin)) {\n        return origin.map((item)=>tPart(item));\n    }\n    return [\n        tPart(origin)\n    ];\n}\nfunction _isContent(origin) {\n    return origin !== null && origin !== undefined && typeof origin === \"object\" && \"parts\" in origin && Array.isArray(origin.parts);\n}\nfunction _isFunctionCallPart(origin) {\n    return origin !== null && origin !== undefined && typeof origin === \"object\" && \"functionCall\" in origin;\n}\nfunction _isFunctionResponsePart(origin) {\n    return origin !== null && origin !== undefined && typeof origin === \"object\" && \"functionResponse\" in origin;\n}\nfunction tContent(origin) {\n    if (origin === null || origin === undefined) {\n        throw new Error(\"ContentUnion is required\");\n    }\n    if (_isContent(origin)) {\n        // _isContent is a utility function that checks if the\n        // origin is a Content.\n        return origin;\n    }\n    return {\n        role: \"user\",\n        parts: tParts(origin)\n    };\n}\nfunction tContentsForEmbed(apiClient, origin) {\n    if (!origin) {\n        return [];\n    }\n    if (apiClient.isVertexAI() && Array.isArray(origin)) {\n        return origin.flatMap((item)=>{\n            const content = tContent(item);\n            if (content.parts && content.parts.length > 0 && content.parts[0].text !== undefined) {\n                return [\n                    content.parts[0].text\n                ];\n            }\n            return [];\n        });\n    } else if (apiClient.isVertexAI()) {\n        const content = tContent(origin);\n        if (content.parts && content.parts.length > 0 && content.parts[0].text !== undefined) {\n            return [\n                content.parts[0].text\n            ];\n        }\n        return [];\n    }\n    if (Array.isArray(origin)) {\n        return origin.map((item)=>tContent(item));\n    }\n    return [\n        tContent(origin)\n    ];\n}\nfunction tContents(origin) {\n    if (origin === null || origin === undefined || Array.isArray(origin) && origin.length === 0) {\n        throw new Error(\"contents are required\");\n    }\n    if (!Array.isArray(origin)) {\n        // If it's not an array, it's a single content or a single PartUnion.\n        if (_isFunctionCallPart(origin) || _isFunctionResponsePart(origin)) {\n            throw new Error(\"To specify functionCall or functionResponse parts, please wrap them in a Content object, specifying the role for them\");\n        }\n        return [\n            tContent(origin)\n        ];\n    }\n    const result = [];\n    const accumulatedParts = [];\n    const isContentArray = _isContent(origin[0]);\n    for (const item of origin){\n        const isContent = _isContent(item);\n        if (isContent != isContentArray) {\n            throw new Error(\"Mixing Content and Parts is not supported, please group the parts into a the appropriate Content objects and specify the roles for them\");\n        }\n        if (isContent) {\n            // `isContent` contains the result of _isContent, which is a utility\n            // function that checks if the item is a Content.\n            result.push(item);\n        } else if (_isFunctionCallPart(item) || _isFunctionResponsePart(item)) {\n            throw new Error(\"To specify functionCall or functionResponse parts, please wrap them, and any other parts, in Content objects as appropriate, specifying the role for them\");\n        } else {\n            accumulatedParts.push(item);\n        }\n    }\n    if (!isContentArray) {\n        result.push({\n            role: \"user\",\n            parts: tParts(accumulatedParts)\n        });\n    }\n    return result;\n}\n/*\nTransform the type field from an array of types to an array of anyOf fields.\nExample:\n  {type: ['STRING', 'NUMBER']}\nwill be transformed to\n  {anyOf: [{type: 'STRING'}, {type: 'NUMBER'}]}\n*/ function flattenTypeArrayToAnyOf(typeList, resultingSchema) {\n    if (typeList.includes(\"null\")) {\n        resultingSchema[\"nullable\"] = true;\n    }\n    const listWithoutNull = typeList.filter((type)=>type !== \"null\");\n    if (listWithoutNull.length === 1) {\n        resultingSchema[\"type\"] = Object.values(Type).includes(listWithoutNull[0].toUpperCase()) ? listWithoutNull[0].toUpperCase() : Type.TYPE_UNSPECIFIED;\n    } else {\n        resultingSchema[\"anyOf\"] = [];\n        for (const i of listWithoutNull){\n            resultingSchema[\"anyOf\"].push({\n                \"type\": Object.values(Type).includes(i.toUpperCase()) ? i.toUpperCase() : Type.TYPE_UNSPECIFIED\n            });\n        }\n    }\n}\nfunction processJsonSchema(_jsonSchema) {\n    const genAISchema = {};\n    const schemaFieldNames = [\n        \"items\"\n    ];\n    const listSchemaFieldNames = [\n        \"anyOf\"\n    ];\n    const dictSchemaFieldNames = [\n        \"properties\"\n    ];\n    if (_jsonSchema[\"type\"] && _jsonSchema[\"anyOf\"]) {\n        throw new Error(\"type and anyOf cannot be both populated.\");\n    }\n    /*\n    This is to handle the nullable array or object. The _jsonSchema will\n    be in the format of {anyOf: [{type: 'null'}, {type: 'object'}]}. The\n    logic is to check if anyOf has 2 elements and one of the element is null,\n    if so, the anyOf field is unnecessary, so we need to get rid of the anyOf\n    field and make the schema nullable. Then use the other element as the new\n    _jsonSchema for processing. This is because the backend doesn't have a null\n    type.\n    This has to be checked before we process any other fields.\n    For example:\n      const objectNullable = z.object({\n        nullableArray: z.array(z.string()).nullable(),\n      });\n    Will have the raw _jsonSchema as:\n    {\n      type: 'OBJECT',\n      properties: {\n          nullableArray: {\n             anyOf: [\n                {type: 'null'},\n                {\n                  type: 'array',\n                  items: {type: 'string'},\n                },\n              ],\n          }\n      },\n      required: [ 'nullableArray' ],\n    }\n    Will result in following schema compatible with Gemini API:\n      {\n        type: 'OBJECT',\n        properties: {\n           nullableArray: {\n              nullable: true,\n              type: 'ARRAY',\n              items: {type: 'string'},\n           }\n        },\n        required: [ 'nullableArray' ],\n      }\n    */ const incomingAnyOf = _jsonSchema[\"anyOf\"];\n    if (incomingAnyOf != null && incomingAnyOf.length == 2) {\n        if (incomingAnyOf[0][\"type\"] === \"null\") {\n            genAISchema[\"nullable\"] = true;\n            _jsonSchema = incomingAnyOf[1];\n        } else if (incomingAnyOf[1][\"type\"] === \"null\") {\n            genAISchema[\"nullable\"] = true;\n            _jsonSchema = incomingAnyOf[0];\n        }\n    }\n    if (_jsonSchema[\"type\"] instanceof Array) {\n        flattenTypeArrayToAnyOf(_jsonSchema[\"type\"], genAISchema);\n    }\n    for (const [fieldName, fieldValue] of Object.entries(_jsonSchema)){\n        // Skip if the fieldvalue is undefined or null.\n        if (fieldValue == null) {\n            continue;\n        }\n        if (fieldName == \"type\") {\n            if (fieldValue === \"null\") {\n                throw new Error(\"type: null can not be the only possible type for the field.\");\n            }\n            if (fieldValue instanceof Array) {\n                continue;\n            }\n            genAISchema[\"type\"] = Object.values(Type).includes(fieldValue.toUpperCase()) ? fieldValue.toUpperCase() : Type.TYPE_UNSPECIFIED;\n        } else if (schemaFieldNames.includes(fieldName)) {\n            genAISchema[fieldName] = processJsonSchema(fieldValue);\n        } else if (listSchemaFieldNames.includes(fieldName)) {\n            const listSchemaFieldValue = [];\n            for (const item of fieldValue){\n                if (item[\"type\"] == \"null\") {\n                    genAISchema[\"nullable\"] = true;\n                    continue;\n                }\n                listSchemaFieldValue.push(processJsonSchema(item));\n            }\n            genAISchema[fieldName] = listSchemaFieldValue;\n        } else if (dictSchemaFieldNames.includes(fieldName)) {\n            const dictSchemaFieldValue = {};\n            for (const [key, value] of Object.entries(fieldValue)){\n                dictSchemaFieldValue[key] = processJsonSchema(value);\n            }\n            genAISchema[fieldName] = dictSchemaFieldValue;\n        } else {\n            // additionalProperties is not included in JSONSchema, skipping it.\n            if (fieldName === \"additionalProperties\") {\n                continue;\n            }\n            genAISchema[fieldName] = fieldValue;\n        }\n    }\n    return genAISchema;\n}\n// we take the unknown in the schema field because we want enable user to pass\n// the output of major schema declaration tools without casting. Tools such as\n// zodToJsonSchema, typebox, zodToJsonSchema function can return JsonSchema7Type\n// or object, see details in\n// https://github.com/StefanTerdell/zod-to-json-schema/blob/70525efe555cd226691e093d171370a3b10921d1/src/zodToJsonSchema.ts#L7\n// typebox can return unknown, see details in\n// https://github.com/sinclairzx81/typebox/blob/5a5431439f7d5ca6b494d0d18fbfd7b1a356d67c/src/type/create/type.ts#L35\n// Note: proper json schemas with the $schema field set never arrive to this\n// transformer. Schemas with $schema are routed to the equivalent API json\n// schema field.\nfunction tSchema(schema) {\n    return processJsonSchema(schema);\n}\nfunction tSpeechConfig(speechConfig) {\n    if (typeof speechConfig === \"object\") {\n        return speechConfig;\n    } else if (typeof speechConfig === \"string\") {\n        return {\n            voiceConfig: {\n                prebuiltVoiceConfig: {\n                    voiceName: speechConfig\n                }\n            }\n        };\n    } else {\n        throw new Error(\"Unsupported speechConfig type: \".concat(typeof speechConfig));\n    }\n}\nfunction tLiveSpeechConfig(speechConfig) {\n    if (\"multiSpeakerVoiceConfig\" in speechConfig) {\n        throw new Error(\"multiSpeakerVoiceConfig is not supported in the live API.\");\n    }\n    return speechConfig;\n}\nfunction tTool(tool) {\n    if (tool.functionDeclarations) {\n        for (const functionDeclaration of tool.functionDeclarations){\n            if (functionDeclaration.parameters) {\n                if (!Object.keys(functionDeclaration.parameters).includes(\"$schema\")) {\n                    functionDeclaration.parameters = processJsonSchema(functionDeclaration.parameters);\n                } else {\n                    if (!functionDeclaration.parametersJsonSchema) {\n                        functionDeclaration.parametersJsonSchema = functionDeclaration.parameters;\n                        delete functionDeclaration.parameters;\n                    }\n                }\n            }\n            if (functionDeclaration.response) {\n                if (!Object.keys(functionDeclaration.response).includes(\"$schema\")) {\n                    functionDeclaration.response = processJsonSchema(functionDeclaration.response);\n                } else {\n                    if (!functionDeclaration.responseJsonSchema) {\n                        functionDeclaration.responseJsonSchema = functionDeclaration.response;\n                        delete functionDeclaration.response;\n                    }\n                }\n            }\n        }\n    }\n    return tool;\n}\nfunction tTools(tools) {\n    // Check if the incoming type is defined.\n    if (tools === undefined || tools === null) {\n        throw new Error(\"tools is required\");\n    }\n    if (!Array.isArray(tools)) {\n        throw new Error(\"tools is required and must be an array of Tools\");\n    }\n    const result = [];\n    for (const tool of tools){\n        result.push(tool);\n    }\n    return result;\n}\n/**\n * Prepends resource name with project, location, resource_prefix if needed.\n *\n * @param client The API client.\n * @param resourceName The resource name.\n * @param resourcePrefix The resource prefix.\n * @param splitsAfterPrefix The number of splits after the prefix.\n * @returns The completed resource name.\n *\n * Examples:\n *\n * ```\n * resource_name = '123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = True\n * client.project = 'bar'\n * client.location = 'us-west1'\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * returns: 'projects/bar/locations/us-west1/cachedContents/123'\n * ```\n *\n * ```\n * resource_name = 'projects/foo/locations/us-central1/cachedContents/123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = True\n * client.project = 'bar'\n * client.location = 'us-west1'\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * returns: 'projects/foo/locations/us-central1/cachedContents/123'\n * ```\n *\n * ```\n * resource_name = '123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = False\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * returns 'cachedContents/123'\n * ```\n *\n * ```\n * resource_name = 'some/wrong/cachedContents/resource/name/123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = False\n * # client.vertexai = True\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * -> 'some/wrong/resource/name/123'\n * ```\n */ function resourceName(client, resourceName, resourcePrefix) {\n    let splitsAfterPrefix = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;\n    const shouldAppendPrefix = !resourceName.startsWith(\"\".concat(resourcePrefix, \"/\")) && resourceName.split(\"/\").length === splitsAfterPrefix;\n    if (client.isVertexAI()) {\n        if (resourceName.startsWith(\"projects/\")) {\n            return resourceName;\n        } else if (resourceName.startsWith(\"locations/\")) {\n            return \"projects/\".concat(client.getProject(), \"/\").concat(resourceName);\n        } else if (resourceName.startsWith(\"\".concat(resourcePrefix, \"/\"))) {\n            return \"projects/\".concat(client.getProject(), \"/locations/\").concat(client.getLocation(), \"/\").concat(resourceName);\n        } else if (shouldAppendPrefix) {\n            return \"projects/\".concat(client.getProject(), \"/locations/\").concat(client.getLocation(), \"/\").concat(resourcePrefix, \"/\").concat(resourceName);\n        } else {\n            return resourceName;\n        }\n    }\n    if (shouldAppendPrefix) {\n        return \"\".concat(resourcePrefix, \"/\").concat(resourceName);\n    }\n    return resourceName;\n}\nfunction tCachedContentName(apiClient, name) {\n    if (typeof name !== \"string\") {\n        throw new Error(\"name must be a string\");\n    }\n    return resourceName(apiClient, name, \"cachedContents\");\n}\nfunction tTuningJobStatus(status) {\n    switch(status){\n        case \"STATE_UNSPECIFIED\":\n            return \"JOB_STATE_UNSPECIFIED\";\n        case \"CREATING\":\n            return \"JOB_STATE_RUNNING\";\n        case \"ACTIVE\":\n            return \"JOB_STATE_SUCCEEDED\";\n        case \"FAILED\":\n            return \"JOB_STATE_FAILED\";\n        default:\n            return status;\n    }\n}\nfunction tBytes(fromImageBytes) {\n    return tBytes$1(fromImageBytes);\n}\nfunction _isFile(origin) {\n    return origin !== null && origin !== undefined && typeof origin === \"object\" && \"name\" in origin;\n}\nfunction isGeneratedVideo(origin) {\n    return origin !== null && origin !== undefined && typeof origin === \"object\" && \"video\" in origin;\n}\nfunction isVideo(origin) {\n    return origin !== null && origin !== undefined && typeof origin === \"object\" && \"uri\" in origin;\n}\nfunction tFileName(fromName) {\n    var _a;\n    let name;\n    if (_isFile(fromName)) {\n        name = fromName.name;\n    }\n    if (isVideo(fromName)) {\n        name = fromName.uri;\n        if (name === undefined) {\n            return undefined;\n        }\n    }\n    if (isGeneratedVideo(fromName)) {\n        name = (_a = fromName.video) === null || _a === void 0 ? void 0 : _a.uri;\n        if (name === undefined) {\n            return undefined;\n        }\n    }\n    if (typeof fromName === \"string\") {\n        name = fromName;\n    }\n    if (name === undefined) {\n        throw new Error(\"Could not extract file name from the provided input.\");\n    }\n    if (name.startsWith(\"https://\")) {\n        const suffix = name.split(\"files/\")[1];\n        const match = suffix.match(/[a-z0-9]+/);\n        if (match === null) {\n            throw new Error(\"Could not extract file name from URI \".concat(name));\n        }\n        name = match[0];\n    } else if (name.startsWith(\"files/\")) {\n        name = name.split(\"files/\")[1];\n    }\n    return name;\n}\nfunction tModelsUrl(apiClient, baseModels) {\n    let res;\n    if (apiClient.isVertexAI()) {\n        res = baseModels ? \"publishers/google/models\" : \"models\";\n    } else {\n        res = baseModels ? \"models\" : \"tunedModels\";\n    }\n    return res;\n}\nfunction tExtractModels(response) {\n    for (const key of [\n        \"models\",\n        \"tunedModels\",\n        \"publisherModels\"\n    ]){\n        if (hasField(response, key)) {\n            return response[key];\n        }\n    }\n    return [];\n}\nfunction hasField(data, fieldName) {\n    return data !== null && typeof data === \"object\" && fieldName in data;\n}\nfunction mcpToGeminiTool(mcpTool) {\n    let config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const mcpToolSchema = mcpTool;\n    const functionDeclaration = {\n        name: mcpToolSchema[\"name\"],\n        description: mcpToolSchema[\"description\"],\n        parametersJsonSchema: mcpToolSchema[\"inputSchema\"]\n    };\n    if (mcpToolSchema[\"outputSchema\"]) {\n        functionDeclaration[\"responseJsonSchema\"] = mcpToolSchema[\"outputSchema\"];\n    }\n    if (config.behavior) {\n        functionDeclaration[\"behavior\"] = config.behavior;\n    }\n    const geminiTool = {\n        functionDeclarations: [\n            functionDeclaration\n        ]\n    };\n    return geminiTool;\n}\n/**\n * Converts a list of MCP tools to a single Gemini tool with a list of function\n * declarations.\n */ function mcpToolsToGeminiTool(mcpTools) {\n    let config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const functionDeclarations = [];\n    const toolNames = new Set();\n    for (const mcpTool of mcpTools){\n        const mcpToolName = mcpTool.name;\n        if (toolNames.has(mcpToolName)) {\n            throw new Error(\"Duplicate function name \".concat(mcpToolName, \" found in MCP tools. Please ensure function names are unique.\"));\n        }\n        toolNames.add(mcpToolName);\n        const geminiTool = mcpToGeminiTool(mcpTool, config);\n        if (geminiTool.functionDeclarations) {\n            functionDeclarations.push(...geminiTool.functionDeclarations);\n        }\n    }\n    return {\n        functionDeclarations: functionDeclarations\n    };\n}\n// Transforms a source input into a BatchJobSource object with validation.\nfunction tBatchJobSource(client, src) {\n    let sourceObj;\n    if (typeof src === \"string\") {\n        if (client.isVertexAI()) {\n            if (src.startsWith(\"gs://\")) {\n                sourceObj = {\n                    format: \"jsonl\",\n                    gcsUri: [\n                        src\n                    ]\n                };\n            } else if (src.startsWith(\"bq://\")) {\n                sourceObj = {\n                    format: \"bigquery\",\n                    bigqueryUri: src\n                };\n            } else {\n                throw new Error(\"Unsupported string source for Vertex AI: \".concat(src));\n            }\n        } else {\n            // MLDEV\n            if (src.startsWith(\"files/\")) {\n                sourceObj = {\n                    fileName: src\n                }; // Default to fileName for string input\n            } else {\n                throw new Error(\"Unsupported string source for Gemini API: \".concat(src));\n            }\n        }\n    } else if (Array.isArray(src)) {\n        if (client.isVertexAI()) {\n            throw new Error(\"InlinedRequest[] is not supported in Vertex AI.\");\n        }\n        sourceObj = {\n            inlinedRequests: src\n        };\n    } else {\n        // It's already a BatchJobSource object\n        sourceObj = src;\n    }\n    // Validation logic\n    const vertexSourcesCount = [\n        sourceObj.gcsUri,\n        sourceObj.bigqueryUri\n    ].filter(Boolean).length;\n    const mldevSourcesCount = [\n        sourceObj.inlinedRequests,\n        sourceObj.fileName\n    ].filter(Boolean).length;\n    if (client.isVertexAI()) {\n        if (mldevSourcesCount > 0 || vertexSourcesCount !== 1) {\n            throw new Error(\"Exactly one of `gcsUri` or `bigqueryUri` must be set for Vertex AI.\");\n        }\n    } else {\n        // MLDEV\n        if (vertexSourcesCount > 0 || mldevSourcesCount !== 1) {\n            throw new Error(\"Exactly one of `inlinedRequests`, `fileName`, \" + \"must be set for Gemini API.\");\n        }\n    }\n    return sourceObj;\n}\nfunction tBatchJobDestination(dest) {\n    if (typeof dest !== \"string\") {\n        return dest;\n    }\n    const destString = dest;\n    if (destString.startsWith(\"gs://\")) {\n        return {\n            format: \"jsonl\",\n            gcsUri: destString\n        };\n    } else if (destString.startsWith(\"bq://\")) {\n        return {\n            format: \"bigquery\",\n            bigqueryUri: destString\n        };\n    } else {\n        throw new Error(\"Unsupported destination: \".concat(destString));\n    }\n}\nfunction tRecvBatchJobDestination(dest) {\n    // Ensure dest is a non-null object before proceeding.\n    if (typeof dest !== \"object\" || dest === null) {\n        // If the input is not an object, it cannot be a valid BatchJobDestination\n        // based on the operations performed. Return it cast, or handle as an error.\n        // Casting an empty object might be a safe default.\n        return {};\n    }\n    // Cast to Record<string, unknown> to allow string property access.\n    const obj = dest;\n    // Safely access nested properties.\n    const inlineResponsesVal = obj[\"inlinedResponses\"];\n    if (typeof inlineResponsesVal !== \"object\" || inlineResponsesVal === null) {\n        return dest;\n    }\n    const inlineResponsesObj = inlineResponsesVal;\n    const responsesArray = inlineResponsesObj[\"inlinedResponses\"];\n    if (!Array.isArray(responsesArray) || responsesArray.length === 0) {\n        return dest;\n    }\n    // Check if any response has the 'embedding' property.\n    let hasEmbedding = false;\n    for (const responseItem of responsesArray){\n        if (typeof responseItem !== \"object\" || responseItem === null) {\n            continue;\n        }\n        const responseItemObj = responseItem;\n        const responseVal = responseItemObj[\"response\"];\n        if (typeof responseVal !== \"object\" || responseVal === null) {\n            continue;\n        }\n        const responseObj = responseVal;\n        // Check for the existence of the 'embedding' key.\n        if (responseObj[\"embedding\"] !== undefined) {\n            hasEmbedding = true;\n            break;\n        }\n    }\n    // Perform the transformation if an embedding was found.\n    if (hasEmbedding) {\n        obj[\"inlinedEmbedContentResponses\"] = obj[\"inlinedResponses\"];\n        delete obj[\"inlinedResponses\"];\n    }\n    // Cast the (potentially) modified object to the target type.\n    return dest;\n}\nfunction tBatchJobName(apiClient, name) {\n    const nameString = name;\n    if (!apiClient.isVertexAI()) {\n        const mldevPattern = /batches\\/[^/]+$/;\n        if (mldevPattern.test(nameString)) {\n            return nameString.split(\"/\").pop();\n        } else {\n            throw new Error(\"Invalid batch job name: \".concat(nameString, \".\"));\n        }\n    }\n    const vertexPattern = /^projects\\/[^/]+\\/locations\\/[^/]+\\/batchPredictionJobs\\/[^/]+$/;\n    if (vertexPattern.test(nameString)) {\n        return nameString.split(\"/\").pop();\n    } else if (/^\\d+$/.test(nameString)) {\n        return nameString;\n    } else {\n        throw new Error(\"Invalid batch job name: \".concat(nameString, \".\"));\n    }\n}\nfunction tJobState(state) {\n    const stateString = state;\n    if (stateString === \"BATCH_STATE_UNSPECIFIED\") {\n        return \"JOB_STATE_UNSPECIFIED\";\n    } else if (stateString === \"BATCH_STATE_PENDING\") {\n        return \"JOB_STATE_PENDING\";\n    } else if (stateString === \"BATCH_STATE_RUNNING\") {\n        return \"JOB_STATE_RUNNING\";\n    } else if (stateString === \"BATCH_STATE_SUCCEEDED\") {\n        return \"JOB_STATE_SUCCEEDED\";\n    } else if (stateString === \"BATCH_STATE_FAILED\") {\n        return \"JOB_STATE_FAILED\";\n    } else if (stateString === \"BATCH_STATE_CANCELLED\") {\n        return \"JOB_STATE_CANCELLED\";\n    } else if (stateString === \"BATCH_STATE_EXPIRED\") {\n        return \"JOB_STATE_EXPIRED\";\n    } else {\n        return stateString;\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function batchJobDestinationFromMldev(fromObject) {\n    const toObject = {};\n    const fromFileName = getValueByPath(fromObject, [\n        \"responsesFile\"\n    ]);\n    if (fromFileName != null) {\n        setValueByPath(toObject, [\n            \"fileName\"\n        ], fromFileName);\n    }\n    const fromInlinedResponses = getValueByPath(fromObject, [\n        \"inlinedResponses\",\n        \"inlinedResponses\"\n    ]);\n    if (fromInlinedResponses != null) {\n        let transformedList = fromInlinedResponses;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return inlinedResponseFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"inlinedResponses\"\n        ], transformedList);\n    }\n    const fromInlinedEmbedContentResponses = getValueByPath(fromObject, [\n        \"inlinedEmbedContentResponses\",\n        \"inlinedResponses\"\n    ]);\n    if (fromInlinedEmbedContentResponses != null) {\n        let transformedList = fromInlinedEmbedContentResponses;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"inlinedEmbedContentResponses\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction batchJobDestinationFromVertex(fromObject) {\n    const toObject = {};\n    const fromFormat = getValueByPath(fromObject, [\n        \"predictionsFormat\"\n    ]);\n    if (fromFormat != null) {\n        setValueByPath(toObject, [\n            \"format\"\n        ], fromFormat);\n    }\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsDestination\",\n        \"outputUriPrefix\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"gcsUri\"\n        ], fromGcsUri);\n    }\n    const fromBigqueryUri = getValueByPath(fromObject, [\n        \"bigqueryDestination\",\n        \"outputUri\"\n    ]);\n    if (fromBigqueryUri != null) {\n        setValueByPath(toObject, [\n            \"bigqueryUri\"\n        ], fromBigqueryUri);\n    }\n    return toObject;\n}\nfunction batchJobDestinationToVertex(fromObject) {\n    const toObject = {};\n    const fromFormat = getValueByPath(fromObject, [\n        \"format\"\n    ]);\n    if (fromFormat != null) {\n        setValueByPath(toObject, [\n            \"predictionsFormat\"\n        ], fromFormat);\n    }\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"gcsDestination\",\n            \"outputUriPrefix\"\n        ], fromGcsUri);\n    }\n    const fromBigqueryUri = getValueByPath(fromObject, [\n        \"bigqueryUri\"\n    ]);\n    if (fromBigqueryUri != null) {\n        setValueByPath(toObject, [\n            \"bigqueryDestination\",\n            \"outputUri\"\n        ], fromBigqueryUri);\n    }\n    if (getValueByPath(fromObject, [\n        \"fileName\"\n    ]) !== undefined) {\n        throw new Error(\"fileName parameter is not supported in Vertex AI.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"inlinedResponses\"\n    ]) !== undefined) {\n        throw new Error(\"inlinedResponses parameter is not supported in Vertex AI.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"inlinedEmbedContentResponses\"\n    ]) !== undefined) {\n        throw new Error(\"inlinedEmbedContentResponses parameter is not supported in Vertex AI.\");\n    }\n    return toObject;\n}\nfunction batchJobFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"metadata\",\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromState = getValueByPath(fromObject, [\n        \"metadata\",\n        \"state\"\n    ]);\n    if (fromState != null) {\n        setValueByPath(toObject, [\n            \"state\"\n        ], tJobState(fromState));\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"metadata\",\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"metadata\",\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"metadata\",\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    const fromModel = getValueByPath(fromObject, [\n        \"metadata\",\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], fromModel);\n    }\n    const fromDest = getValueByPath(fromObject, [\n        \"metadata\",\n        \"output\"\n    ]);\n    if (fromDest != null) {\n        setValueByPath(toObject, [\n            \"dest\"\n        ], batchJobDestinationFromMldev(tRecvBatchJobDestination(fromDest)));\n    }\n    return toObject;\n}\nfunction batchJobFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromState = getValueByPath(fromObject, [\n        \"state\"\n    ]);\n    if (fromState != null) {\n        setValueByPath(toObject, [\n            \"state\"\n        ], tJobState(fromState));\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromStartTime = getValueByPath(fromObject, [\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], fromModel);\n    }\n    const fromSrc = getValueByPath(fromObject, [\n        \"inputConfig\"\n    ]);\n    if (fromSrc != null) {\n        setValueByPath(toObject, [\n            \"src\"\n        ], batchJobSourceFromVertex(fromSrc));\n    }\n    const fromDest = getValueByPath(fromObject, [\n        \"outputConfig\"\n    ]);\n    if (fromDest != null) {\n        setValueByPath(toObject, [\n            \"dest\"\n        ], batchJobDestinationFromVertex(tRecvBatchJobDestination(fromDest)));\n    }\n    const fromCompletionStats = getValueByPath(fromObject, [\n        \"completionStats\"\n    ]);\n    if (fromCompletionStats != null) {\n        setValueByPath(toObject, [\n            \"completionStats\"\n        ], fromCompletionStats);\n    }\n    return toObject;\n}\nfunction batchJobSourceFromVertex(fromObject) {\n    const toObject = {};\n    const fromFormat = getValueByPath(fromObject, [\n        \"instancesFormat\"\n    ]);\n    if (fromFormat != null) {\n        setValueByPath(toObject, [\n            \"format\"\n        ], fromFormat);\n    }\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsSource\",\n        \"uris\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"gcsUri\"\n        ], fromGcsUri);\n    }\n    const fromBigqueryUri = getValueByPath(fromObject, [\n        \"bigquerySource\",\n        \"inputUri\"\n    ]);\n    if (fromBigqueryUri != null) {\n        setValueByPath(toObject, [\n            \"bigqueryUri\"\n        ], fromBigqueryUri);\n    }\n    return toObject;\n}\nfunction batchJobSourceToMldev(apiClient, fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"format\"\n    ]) !== undefined) {\n        throw new Error(\"format parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]) !== undefined) {\n        throw new Error(\"gcsUri parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"bigqueryUri\"\n    ]) !== undefined) {\n        throw new Error(\"bigqueryUri parameter is not supported in Gemini API.\");\n    }\n    const fromFileName = getValueByPath(fromObject, [\n        \"fileName\"\n    ]);\n    if (fromFileName != null) {\n        setValueByPath(toObject, [\n            \"fileName\"\n        ], fromFileName);\n    }\n    const fromInlinedRequests = getValueByPath(fromObject, [\n        \"inlinedRequests\"\n    ]);\n    if (fromInlinedRequests != null) {\n        let transformedList = fromInlinedRequests;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return inlinedRequestToMldev(apiClient, item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"requests\",\n            \"requests\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction batchJobSourceToVertex(fromObject) {\n    const toObject = {};\n    const fromFormat = getValueByPath(fromObject, [\n        \"format\"\n    ]);\n    if (fromFormat != null) {\n        setValueByPath(toObject, [\n            \"instancesFormat\"\n        ], fromFormat);\n    }\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"gcsSource\",\n            \"uris\"\n        ], fromGcsUri);\n    }\n    const fromBigqueryUri = getValueByPath(fromObject, [\n        \"bigqueryUri\"\n    ]);\n    if (fromBigqueryUri != null) {\n        setValueByPath(toObject, [\n            \"bigquerySource\",\n            \"inputUri\"\n        ], fromBigqueryUri);\n    }\n    if (getValueByPath(fromObject, [\n        \"fileName\"\n    ]) !== undefined) {\n        throw new Error(\"fileName parameter is not supported in Vertex AI.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"inlinedRequests\"\n    ]) !== undefined) {\n        throw new Error(\"inlinedRequests parameter is not supported in Vertex AI.\");\n    }\n    return toObject;\n}\nfunction blobToMldev$4(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction cancelBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction cancelBatchJobParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction candidateFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromContent = getValueByPath(fromObject, [\n        \"content\"\n    ]);\n    if (fromContent != null) {\n        setValueByPath(toObject, [\n            \"content\"\n        ], fromContent);\n    }\n    const fromCitationMetadata = getValueByPath(fromObject, [\n        \"citationMetadata\"\n    ]);\n    if (fromCitationMetadata != null) {\n        setValueByPath(toObject, [\n            \"citationMetadata\"\n        ], citationMetadataFromMldev$1(fromCitationMetadata));\n    }\n    const fromTokenCount = getValueByPath(fromObject, [\n        \"tokenCount\"\n    ]);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, [\n            \"tokenCount\"\n        ], fromTokenCount);\n    }\n    const fromFinishReason = getValueByPath(fromObject, [\n        \"finishReason\"\n    ]);\n    if (fromFinishReason != null) {\n        setValueByPath(toObject, [\n            \"finishReason\"\n        ], fromFinishReason);\n    }\n    const fromAvgLogprobs = getValueByPath(fromObject, [\n        \"avgLogprobs\"\n    ]);\n    if (fromAvgLogprobs != null) {\n        setValueByPath(toObject, [\n            \"avgLogprobs\"\n        ], fromAvgLogprobs);\n    }\n    const fromGroundingMetadata = getValueByPath(fromObject, [\n        \"groundingMetadata\"\n    ]);\n    if (fromGroundingMetadata != null) {\n        setValueByPath(toObject, [\n            \"groundingMetadata\"\n        ], fromGroundingMetadata);\n    }\n    const fromIndex = getValueByPath(fromObject, [\n        \"index\"\n    ]);\n    if (fromIndex != null) {\n        setValueByPath(toObject, [\n            \"index\"\n        ], fromIndex);\n    }\n    const fromLogprobsResult = getValueByPath(fromObject, [\n        \"logprobsResult\"\n    ]);\n    if (fromLogprobsResult != null) {\n        setValueByPath(toObject, [\n            \"logprobsResult\"\n        ], fromLogprobsResult);\n    }\n    const fromSafetyRatings = getValueByPath(fromObject, [\n        \"safetyRatings\"\n    ]);\n    if (fromSafetyRatings != null) {\n        let transformedList = fromSafetyRatings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"safetyRatings\"\n        ], transformedList);\n    }\n    const fromUrlContextMetadata = getValueByPath(fromObject, [\n        \"urlContextMetadata\"\n    ]);\n    if (fromUrlContextMetadata != null) {\n        setValueByPath(toObject, [\n            \"urlContextMetadata\"\n        ], fromUrlContextMetadata);\n    }\n    return toObject;\n}\nfunction citationMetadataFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromCitations = getValueByPath(fromObject, [\n        \"citationSources\"\n    ]);\n    if (fromCitations != null) {\n        let transformedList = fromCitations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"citations\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction contentToMldev$4(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partToMldev$4(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction createBatchJobConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"batch\",\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    if (getValueByPath(fromObject, [\n        \"dest\"\n    ]) !== undefined) {\n        throw new Error(\"dest parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction createBatchJobConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromDest = getValueByPath(fromObject, [\n        \"dest\"\n    ]);\n    if (parentObject !== undefined && fromDest != null) {\n        setValueByPath(parentObject, [\n            \"outputConfig\"\n        ], batchJobDestinationToVertex(tBatchJobDestination(fromDest)));\n    }\n    return toObject;\n}\nfunction createBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromSrc = getValueByPath(fromObject, [\n        \"src\"\n    ]);\n    if (fromSrc != null) {\n        setValueByPath(toObject, [\n            \"batch\",\n            \"inputConfig\"\n        ], batchJobSourceToMldev(apiClient, tBatchJobSource(apiClient, fromSrc)));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        createBatchJobConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction createBatchJobParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromSrc = getValueByPath(fromObject, [\n        \"src\"\n    ]);\n    if (fromSrc != null) {\n        setValueByPath(toObject, [\n            \"inputConfig\"\n        ], batchJobSourceToVertex(tBatchJobSource(apiClient, fromSrc)));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        createBatchJobConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction createEmbeddingsBatchJobConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"batch\",\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    return toObject;\n}\nfunction createEmbeddingsBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromSrc = getValueByPath(fromObject, [\n        \"src\"\n    ]);\n    if (fromSrc != null) {\n        setValueByPath(toObject, [\n            \"batch\",\n            \"inputConfig\"\n        ], embeddingsBatchJobSourceToMldev(apiClient, fromSrc));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        createEmbeddingsBatchJobConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction deleteBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction deleteBatchJobParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction deleteResourceJobFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    return toObject;\n}\nfunction deleteResourceJobFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    return toObject;\n}\nfunction embedContentBatchToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContentsForEmbed(apiClient, fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"requests[]\",\n            \"request\",\n            \"content\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"_self\"\n        ], embedContentConfigToMldev$1(fromConfig, toObject));\n        moveValueByPath(toObject, {\n            \"requests[].*\": \"requests[].request.*\"\n        });\n    }\n    return toObject;\n}\nfunction embedContentConfigToMldev$1(fromObject, parentObject) {\n    const toObject = {};\n    const fromTaskType = getValueByPath(fromObject, [\n        \"taskType\"\n    ]);\n    if (parentObject !== undefined && fromTaskType != null) {\n        setValueByPath(parentObject, [\n            \"requests[]\",\n            \"taskType\"\n        ], fromTaskType);\n    }\n    const fromTitle = getValueByPath(fromObject, [\n        \"title\"\n    ]);\n    if (parentObject !== undefined && fromTitle != null) {\n        setValueByPath(parentObject, [\n            \"requests[]\",\n            \"title\"\n        ], fromTitle);\n    }\n    const fromOutputDimensionality = getValueByPath(fromObject, [\n        \"outputDimensionality\"\n    ]);\n    if (parentObject !== undefined && fromOutputDimensionality != null) {\n        setValueByPath(parentObject, [\n            \"requests[]\",\n            \"outputDimensionality\"\n        ], fromOutputDimensionality);\n    }\n    if (getValueByPath(fromObject, [\n        \"mimeType\"\n    ]) !== undefined) {\n        throw new Error(\"mimeType parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"autoTruncate\"\n    ]) !== undefined) {\n        throw new Error(\"autoTruncate parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction embeddingsBatchJobSourceToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromFileName = getValueByPath(fromObject, [\n        \"fileName\"\n    ]);\n    if (fromFileName != null) {\n        setValueByPath(toObject, [\n            \"file_name\"\n        ], fromFileName);\n    }\n    const fromInlinedRequests = getValueByPath(fromObject, [\n        \"inlinedRequests\"\n    ]);\n    if (fromInlinedRequests != null) {\n        setValueByPath(toObject, [\n            \"requests\"\n        ], embedContentBatchToMldev(apiClient, fromInlinedRequests));\n    }\n    return toObject;\n}\nfunction fileDataToMldev$4(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction functionCallToMldev$4(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, [\n        \"id\"\n    ]);\n    if (fromId != null) {\n        setValueByPath(toObject, [\n            \"id\"\n        ], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, [\n        \"args\"\n    ]);\n    if (fromArgs != null) {\n        setValueByPath(toObject, [\n            \"args\"\n        ], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    if (getValueByPath(fromObject, [\n        \"partialArgs\"\n    ]) !== undefined) {\n        throw new Error(\"partialArgs parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"willContinue\"\n    ]) !== undefined) {\n        throw new Error(\"willContinue parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction functionCallingConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromAllowedFunctionNames = getValueByPath(fromObject, [\n        \"allowedFunctionNames\"\n    ]);\n    if (fromAllowedFunctionNames != null) {\n        setValueByPath(toObject, [\n            \"allowedFunctionNames\"\n        ], fromAllowedFunctionNames);\n    }\n    if (getValueByPath(fromObject, [\n        \"streamFunctionCallArguments\"\n    ]) !== undefined) {\n        throw new Error(\"streamFunctionCallArguments parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction generateContentConfigToMldev$1(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"systemInstruction\"\n        ], contentToMldev$4(tContent(fromSystemInstruction)));\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, [\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (fromTopP != null) {\n        setValueByPath(toObject, [\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (fromTopK != null) {\n        setValueByPath(toObject, [\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        \"candidateCount\"\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, [\n            \"candidateCount\"\n        ], fromCandidateCount);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, [\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        \"stopSequences\"\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, [\n            \"stopSequences\"\n        ], fromStopSequences);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        \"responseLogprobs\"\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, [\n            \"responseLogprobs\"\n        ], fromResponseLogprobs);\n    }\n    const fromLogprobs = getValueByPath(fromObject, [\n        \"logprobs\"\n    ]);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, [\n            \"logprobs\"\n        ], fromLogprobs);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        \"presencePenalty\"\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, [\n            \"presencePenalty\"\n        ], fromPresencePenalty);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        \"frequencyPenalty\"\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, [\n            \"frequencyPenalty\"\n        ], fromFrequencyPenalty);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (fromSeed != null) {\n        setValueByPath(toObject, [\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        \"responseMimeType\"\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, [\n            \"responseMimeType\"\n        ], fromResponseMimeType);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        \"responseSchema\"\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, [\n            \"responseSchema\"\n        ], tSchema(fromResponseSchema));\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    if (getValueByPath(fromObject, [\n        \"routingConfig\"\n    ]) !== undefined) {\n        throw new Error(\"routingConfig parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"modelSelectionConfig\"\n    ]) !== undefined) {\n        throw new Error(\"modelSelectionConfig parameter is not supported in Gemini API.\");\n    }\n    const fromSafetySettings = getValueByPath(fromObject, [\n        \"safetySettings\"\n    ]);\n    if (parentObject !== undefined && fromSafetySettings != null) {\n        let transformedList = fromSafetySettings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return safetySettingToMldev$1(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"safetySettings\"\n        ], transformedList);\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToMldev$4(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, [\n            \"tools\"\n        ], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, [\n        \"toolConfig\"\n    ]);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, [\n            \"toolConfig\"\n        ], toolConfigToMldev$2(fromToolConfig));\n    }\n    if (getValueByPath(fromObject, [\n        \"labels\"\n    ]) !== undefined) {\n        throw new Error(\"labels parameter is not supported in Gemini API.\");\n    }\n    const fromCachedContent = getValueByPath(fromObject, [\n        \"cachedContent\"\n    ]);\n    if (parentObject !== undefined && fromCachedContent != null) {\n        setValueByPath(parentObject, [\n            \"cachedContent\"\n        ], tCachedContentName(apiClient, fromCachedContent));\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, [\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, [\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, [\n            \"speechConfig\"\n        ], tSpeechConfig(fromSpeechConfig));\n    }\n    if (getValueByPath(fromObject, [\n        \"audioTimestamp\"\n    ]) !== undefined) {\n        throw new Error(\"audioTimestamp parameter is not supported in Gemini API.\");\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        \"thinkingConfig\"\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, [\n            \"thinkingConfig\"\n        ], fromThinkingConfig);\n    }\n    const fromImageConfig = getValueByPath(fromObject, [\n        \"imageConfig\"\n    ]);\n    if (fromImageConfig != null) {\n        setValueByPath(toObject, [\n            \"imageConfig\"\n        ], imageConfigToMldev$1(fromImageConfig));\n    }\n    return toObject;\n}\nfunction generateContentResponseFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromCandidates = getValueByPath(fromObject, [\n        \"candidates\"\n    ]);\n    if (fromCandidates != null) {\n        let transformedList = fromCandidates;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return candidateFromMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"candidates\"\n        ], transformedList);\n    }\n    const fromModelVersion = getValueByPath(fromObject, [\n        \"modelVersion\"\n    ]);\n    if (fromModelVersion != null) {\n        setValueByPath(toObject, [\n            \"modelVersion\"\n        ], fromModelVersion);\n    }\n    const fromPromptFeedback = getValueByPath(fromObject, [\n        \"promptFeedback\"\n    ]);\n    if (fromPromptFeedback != null) {\n        setValueByPath(toObject, [\n            \"promptFeedback\"\n        ], fromPromptFeedback);\n    }\n    const fromResponseId = getValueByPath(fromObject, [\n        \"responseId\"\n    ]);\n    if (fromResponseId != null) {\n        setValueByPath(toObject, [\n            \"responseId\"\n        ], fromResponseId);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        \"usageMetadata\"\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, [\n            \"usageMetadata\"\n        ], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction getBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction getBatchJobParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction googleMapsToMldev$4(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"authConfig\"\n    ]) !== undefined) {\n        throw new Error(\"authConfig parameter is not supported in Gemini API.\");\n    }\n    const fromEnableWidget = getValueByPath(fromObject, [\n        \"enableWidget\"\n    ]);\n    if (fromEnableWidget != null) {\n        setValueByPath(toObject, [\n            \"enableWidget\"\n        ], fromEnableWidget);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$4(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"excludeDomains\"\n    ]) !== undefined) {\n        throw new Error(\"excludeDomains parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"blockingConfidence\"\n    ]) !== undefined) {\n        throw new Error(\"blockingConfidence parameter is not supported in Gemini API.\");\n    }\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        \"timeRangeFilter\"\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, [\n            \"timeRangeFilter\"\n        ], fromTimeRangeFilter);\n    }\n    return toObject;\n}\nfunction imageConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (fromAspectRatio != null) {\n        setValueByPath(toObject, [\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    const fromImageSize = getValueByPath(fromObject, [\n        \"imageSize\"\n    ]);\n    if (fromImageSize != null) {\n        setValueByPath(toObject, [\n            \"imageSize\"\n        ], fromImageSize);\n    }\n    if (getValueByPath(fromObject, [\n        \"outputMimeType\"\n    ]) !== undefined) {\n        throw new Error(\"outputMimeType parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"outputCompressionQuality\"\n    ]) !== undefined) {\n        throw new Error(\"outputCompressionQuality parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction inlinedRequestToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"request\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentToMldev$4(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"request\",\n            \"contents\"\n        ], transformedList);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"request\",\n            \"generationConfig\"\n        ], generateContentConfigToMldev$1(apiClient, fromConfig, getValueByPath(toObject, [\n            \"request\"\n        ], {})));\n    }\n    return toObject;\n}\nfunction inlinedResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], generateContentResponseFromMldev$1(fromResponse));\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    return toObject;\n}\nfunction listBatchJobsConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    if (getValueByPath(fromObject, [\n        \"filter\"\n    ]) !== undefined) {\n        throw new Error(\"filter parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction listBatchJobsConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, [\n        \"filter\"\n    ]);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"filter\"\n        ], fromFilter);\n    }\n    return toObject;\n}\nfunction listBatchJobsParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listBatchJobsConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listBatchJobsParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listBatchJobsConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listBatchJobsResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromBatchJobs = getValueByPath(fromObject, [\n        \"operations\"\n    ]);\n    if (fromBatchJobs != null) {\n        let transformedList = fromBatchJobs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return batchJobFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"batchJobs\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction listBatchJobsResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromBatchJobs = getValueByPath(fromObject, [\n        \"batchPredictionJobs\"\n    ]);\n    if (fromBatchJobs != null) {\n        let transformedList = fromBatchJobs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return batchJobFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"batchJobs\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction partToMldev$4(fromObject) {\n    const toObject = {};\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, [\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataToMldev$4(fromFileData));\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], functionCallToMldev$4(fromFunctionCall));\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobToMldev$4(fromInlineData));\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], fromVideoMetadata);\n    }\n    return toObject;\n}\nfunction safetySettingToMldev$1(fromObject) {\n    const toObject = {};\n    const fromCategory = getValueByPath(fromObject, [\n        \"category\"\n    ]);\n    if (fromCategory != null) {\n        setValueByPath(toObject, [\n            \"category\"\n        ], fromCategory);\n    }\n    if (getValueByPath(fromObject, [\n        \"method\"\n    ]) !== undefined) {\n        throw new Error(\"method parameter is not supported in Gemini API.\");\n    }\n    const fromThreshold = getValueByPath(fromObject, [\n        \"threshold\"\n    ]);\n    if (fromThreshold != null) {\n        setValueByPath(toObject, [\n            \"threshold\"\n        ], fromThreshold);\n    }\n    return toObject;\n}\nfunction toolConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromFunctionCallingConfig = getValueByPath(fromObject, [\n        \"functionCallingConfig\"\n    ]);\n    if (fromFunctionCallingConfig != null) {\n        setValueByPath(toObject, [\n            \"functionCallingConfig\"\n        ], functionCallingConfigToMldev$2(fromFunctionCallingConfig));\n    }\n    const fromRetrievalConfig = getValueByPath(fromObject, [\n        \"retrievalConfig\"\n    ]);\n    if (fromRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"retrievalConfig\"\n        ], fromRetrievalConfig);\n    }\n    return toObject;\n}\nfunction toolToMldev$4(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    if (getValueByPath(fromObject, [\n        \"retrieval\"\n    ]) !== undefined) {\n        throw new Error(\"retrieval parameter is not supported in Gemini API.\");\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], fromGoogleSearchRetrieval);\n    }\n    const fromComputerUse = getValueByPath(fromObject, [\n        \"computerUse\"\n    ]);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, [\n            \"computerUse\"\n        ], fromComputerUse);\n    }\n    const fromFileSearch = getValueByPath(fromObject, [\n        \"fileSearch\"\n    ]);\n    if (fromFileSearch != null) {\n        setValueByPath(toObject, [\n            \"fileSearch\"\n        ], fromFileSearch);\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    if (getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]) !== undefined) {\n        throw new Error(\"enterpriseWebSearch parameter is not supported in Gemini API.\");\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, [\n            \"googleMaps\"\n        ], googleMapsToMldev$4(fromGoogleMaps));\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToMldev$4(fromGoogleSearch));\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], fromUrlContext);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ var PagedItem;\n(function(PagedItem) {\n    PagedItem[\"PAGED_ITEM_BATCH_JOBS\"] = \"batchJobs\";\n    PagedItem[\"PAGED_ITEM_MODELS\"] = \"models\";\n    PagedItem[\"PAGED_ITEM_TUNING_JOBS\"] = \"tuningJobs\";\n    PagedItem[\"PAGED_ITEM_FILES\"] = \"files\";\n    PagedItem[\"PAGED_ITEM_CACHED_CONTENTS\"] = \"cachedContents\";\n    PagedItem[\"PAGED_ITEM_FILE_SEARCH_STORES\"] = \"fileSearchStores\";\n    PagedItem[\"PAGED_ITEM_DOCUMENTS\"] = \"documents\";\n})(PagedItem || (PagedItem = {}));\n/**\n * Pager class for iterating through paginated results.\n */ class Pager {\n    init(name, response, params) {\n        var _a, _b;\n        this.nameInternal = name;\n        this.pageInternal = response[this.nameInternal] || [];\n        this.sdkHttpResponseInternal = response === null || response === void 0 ? void 0 : response.sdkHttpResponse;\n        this.idxInternal = 0;\n        let requestParams = {\n            config: {}\n        };\n        if (!params || Object.keys(params).length === 0) {\n            requestParams = {\n                config: {}\n            };\n        } else if (typeof params === \"object\") {\n            requestParams = Object.assign({}, params);\n        } else {\n            requestParams = params;\n        }\n        if (requestParams[\"config\"]) {\n            requestParams[\"config\"][\"pageToken\"] = response[\"nextPageToken\"];\n        }\n        this.paramsInternal = requestParams;\n        this.pageInternalSize = (_b = (_a = requestParams[\"config\"]) === null || _a === void 0 ? void 0 : _a[\"pageSize\"]) !== null && _b !== void 0 ? _b : this.pageInternal.length;\n    }\n    initNextPage(response) {\n        this.init(this.nameInternal, response, this.paramsInternal);\n    }\n    /**\n     * Returns the current page, which is a list of items.\n     *\n     * @remarks\n     * The first page is retrieved when the pager is created. The returned list of\n     * items could be a subset of the entire list.\n     */ get page() {\n        return this.pageInternal;\n    }\n    /**\n     * Returns the type of paged item (for example, ``batch_jobs``).\n     */ get name() {\n        return this.nameInternal;\n    }\n    /**\n     * Returns the length of the page fetched each time by this pager.\n     *\n     * @remarks\n     * The number of items in the page is less than or equal to the page length.\n     */ get pageSize() {\n        return this.pageInternalSize;\n    }\n    /**\n     * Returns the headers of the API response.\n     */ get sdkHttpResponse() {\n        return this.sdkHttpResponseInternal;\n    }\n    /**\n     * Returns the parameters when making the API request for the next page.\n     *\n     * @remarks\n     * Parameters contain a set of optional configs that can be\n     * used to customize the API request. For example, the `pageToken` parameter\n     * contains the token to request the next page.\n     */ get params() {\n        return this.paramsInternal;\n    }\n    /**\n     * Returns the total number of items in the current page.\n     */ get pageLength() {\n        return this.pageInternal.length;\n    }\n    /**\n     * Returns the item at the given index.\n     */ getItem(index) {\n        return this.pageInternal[index];\n    }\n    /**\n     * Returns an async iterator that support iterating through all items\n     * retrieved from the API.\n     *\n     * @remarks\n     * The iterator will automatically fetch the next page if there are more items\n     * to fetch from the API.\n     *\n     * @example\n     *\n     * ```ts\n     * const pager = await ai.files.list({config: {pageSize: 10}});\n     * for await (const file of pager) {\n     *   console.log(file.name);\n     * }\n     * ```\n     */ [Symbol.asyncIterator]() {\n        return {\n            next: async ()=>{\n                if (this.idxInternal >= this.pageLength) {\n                    if (this.hasNextPage()) {\n                        await this.nextPage();\n                    } else {\n                        return {\n                            value: undefined,\n                            done: true\n                        };\n                    }\n                }\n                const item = this.getItem(this.idxInternal);\n                this.idxInternal += 1;\n                return {\n                    value: item,\n                    done: false\n                };\n            },\n            return: async ()=>{\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n        };\n    }\n    /**\n     * Fetches the next page of items. This makes a new API request.\n     *\n     * @throws {Error} If there are no more pages to fetch.\n     *\n     * @example\n     *\n     * ```ts\n     * const pager = await ai.files.list({config: {pageSize: 10}});\n     * let page = pager.page;\n     * while (true) {\n     *   for (const file of page) {\n     *     console.log(file.name);\n     *   }\n     *   if (!pager.hasNextPage()) {\n     *     break;\n     *   }\n     *   page = await pager.nextPage();\n     * }\n     * ```\n     */ async nextPage() {\n        if (!this.hasNextPage()) {\n            throw new Error(\"No more pages to fetch.\");\n        }\n        const response = await this.requestInternal(this.params);\n        this.initNextPage(response);\n        return this.page;\n    }\n    /**\n     * Returns true if there are more pages to fetch from the API.\n     */ hasNextPage() {\n        var _a;\n        if (((_a = this.params[\"config\"]) === null || _a === void 0 ? void 0 : _a[\"pageToken\"]) !== undefined) {\n            return true;\n        }\n        return false;\n    }\n    constructor(name, request, response, params){\n        this.pageInternal = [];\n        this.paramsInternal = {};\n        this.requestInternal = request;\n        this.init(name, response, params);\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Batches extends BaseModule {\n    // Helper function to handle inlined generate content requests\n    createInlinedGenerateContentRequest(params) {\n        const body = createBatchJobParametersToMldev(this.apiClient, params);\n        const urlParams = body[\"_url\"];\n        const path = formatMap(\"{model}:batchGenerateContent\", urlParams);\n        const batch = body[\"batch\"];\n        const inputConfig = batch[\"inputConfig\"];\n        const requestsWrapper = inputConfig[\"requests\"];\n        const requests = requestsWrapper[\"requests\"];\n        const newRequests = [];\n        for (const request of requests){\n            const requestDict = Object.assign({}, request); // Clone\n            if (requestDict[\"systemInstruction\"]) {\n                const systemInstructionValue = requestDict[\"systemInstruction\"];\n                delete requestDict[\"systemInstruction\"];\n                const requestContent = requestDict[\"request\"];\n                requestContent[\"systemInstruction\"] = systemInstructionValue;\n                requestDict[\"request\"] = requestContent;\n            }\n            newRequests.push(requestDict);\n        }\n        requestsWrapper[\"requests\"] = newRequests;\n        delete body[\"config\"];\n        delete body[\"_url\"];\n        delete body[\"_query\"];\n        return {\n            path,\n            body\n        };\n    }\n    // Helper function to get the first GCS URI\n    getGcsUri(src) {\n        if (typeof src === \"string\") {\n            return src.startsWith(\"gs://\") ? src : undefined;\n        }\n        if (!Array.isArray(src) && src.gcsUri && src.gcsUri.length > 0) {\n            return src.gcsUri[0];\n        }\n        return undefined;\n    }\n    // Helper function to get the BigQuery URI\n    getBigqueryUri(src) {\n        if (typeof src === \"string\") {\n            return src.startsWith(\"bq://\") ? src : undefined;\n        }\n        if (!Array.isArray(src)) {\n            return src.bigqueryUri;\n        }\n        return undefined;\n    }\n    // Function to format the destination configuration for Vertex AI\n    formatDestination(src, config) {\n        const newConfig = config ? Object.assign({}, config) : {};\n        const timestampStr = Date.now().toString();\n        if (!newConfig.displayName) {\n            newConfig.displayName = \"genaiBatchJob_\".concat(timestampStr);\n        }\n        if (newConfig.dest === undefined) {\n            const gcsUri = this.getGcsUri(src);\n            const bigqueryUri = this.getBigqueryUri(src);\n            if (gcsUri) {\n                if (gcsUri.endsWith(\".jsonl\")) {\n                    // For .jsonl files, remove suffix and add /dest\n                    newConfig.dest = \"\".concat(gcsUri.slice(0, -6), \"/dest\");\n                } else {\n                    // Fallback for other GCS URIs\n                    newConfig.dest = \"\".concat(gcsUri, \"_dest_\").concat(timestampStr);\n                }\n            } else if (bigqueryUri) {\n                newConfig.dest = \"\".concat(bigqueryUri, \"_dest_\").concat(timestampStr);\n            } else {\n                throw new Error(\"Unsupported source for Vertex AI: No GCS or BigQuery URI found.\");\n            }\n        }\n        return newConfig;\n    }\n    /**\n     * Internal method to create batch job.\n     *\n     * @param params - The parameters for create batch job request.\n     * @return The created batch job.\n     *\n     */ async createInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = createBatchJobParametersToVertex(this.apiClient, params);\n            path = formatMap(\"batchPredictionJobs\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = batchJobFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = createBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:batchGenerateContent\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = batchJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Internal method to create batch job.\n     *\n     * @param params - The parameters for create batch job request.\n     * @return The created batch job.\n     *\n     */ async createEmbeddingsInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = createEmbeddingsBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:asyncBatchEmbedContent\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = batchJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Gets batch job configurations.\n     *\n     * @param params - The parameters for the get request.\n     * @return The batch job.\n     *\n     * @example\n     * ```ts\n     * await ai.batches.get({name: '...'}); // The server-generated resource name.\n     * ```\n     */ async get(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getBatchJobParametersToVertex(this.apiClient, params);\n            path = formatMap(\"batchPredictionJobs/{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = batchJobFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = getBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap(\"batches/{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = batchJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Cancels a batch job.\n     *\n     * @param params - The parameters for the cancel request.\n     * @return The empty response returned by the API.\n     *\n     * @example\n     * ```ts\n     * await ai.batches.cancel({name: '...'}); // The server-generated resource name.\n     * ```\n     */ async cancel(params) {\n        var _a, _b, _c, _d;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = cancelBatchJobParametersToVertex(this.apiClient, params);\n            path = formatMap(\"batchPredictionJobs/{name}:cancel\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            await this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            });\n        } else {\n            const body = cancelBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap(\"batches/{name}:cancel\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            await this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = listBatchJobsParametersToVertex(params);\n            path = formatMap(\"batchPredictionJobs\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listBatchJobsResponseFromVertex(apiResponse);\n                const typedResp = new ListBatchJobsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = listBatchJobsParametersToMldev(params);\n            path = formatMap(\"batches\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listBatchJobsResponseFromMldev(apiResponse);\n                const typedResp = new ListBatchJobsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Deletes a batch job.\n     *\n     * @param params - The parameters for the delete request.\n     * @return The empty response returned by the API.\n     *\n     * @example\n     * ```ts\n     * await ai.batches.delete({name: '...'}); // The server-generated resource name.\n     * ```\n     */ async delete(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = deleteBatchJobParametersToVertex(this.apiClient, params);\n            path = formatMap(\"batchPredictionJobs/{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = deleteResourceJobFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = deleteBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap(\"batches/{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = deleteResourceJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    constructor(apiClient){\n        var _this;\n        super(), _this = this;\n        this.apiClient = apiClient;\n        /**\n         * Lists batch jobs.\n         *\n         * @param params - The parameters for the list request.\n         * @return - A pager of batch jobs.\n         *\n         * @example\n         * ```ts\n         * const batchJobs = await ai.batches.list({config: {'pageSize': 2}});\n         * for await (const batchJob of batchJobs) {\n         *   console.log(batchJob);\n         * }\n         * ```\n         */ this.list = async function() {\n            let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n            return new Pager(PagedItem.PAGED_ITEM_BATCH_JOBS, (x)=>_this.listInternal(x), await _this.listInternal(params), params);\n        };\n        /**\n         * Create batch job.\n         *\n         * @param params - The parameters for create batch job request.\n         * @return The created batch job.\n         *\n         * @example\n         * ```ts\n         * const response = await ai.batches.create({\n         *   model: 'gemini-2.0-flash',\n         *   src: {gcsUri: 'gs://bucket/path/to/file.jsonl', format: 'jsonl'},\n         *   config: {\n         *     dest: {gcsUri: 'gs://bucket/path/output/directory', format: 'jsonl'},\n         *   }\n         * });\n         * console.log(response);\n         * ```\n         */ this.create = async (params)=>{\n            if (this.apiClient.isVertexAI()) {\n                // Format destination if not provided\n                // Cast params.src as Vertex AI path does not handle InlinedRequest[]\n                params.config = this.formatDestination(params.src, params.config);\n            }\n            return this.createInternal(params);\n        };\n        /**\n         * **Experimental** Creates an embedding batch job.\n         *\n         * @param params - The parameters for create embedding batch job request.\n         * @return The created batch job.\n         *\n         * @example\n         * ```ts\n         * const response = await ai.batches.createEmbeddings({\n         *   model: 'text-embedding-004',\n         *   src: {fileName: 'files/my_embedding_input'},\n         * });\n         * console.log(response);\n         * ```\n         */ this.createEmbeddings = async (params)=>{\n            console.warn(\"batches.createEmbeddings() is experimental and may change without notice.\");\n            if (this.apiClient.isVertexAI()) {\n                throw new Error(\"Vertex AI does not support batches.createEmbeddings.\");\n            }\n            return this.createEmbeddingsInternal(params);\n        };\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function blobToMldev$3(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction contentToMldev$3(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partToMldev$3(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction createCachedContentConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, [\n        \"ttl\"\n    ]);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, [\n            \"ttl\"\n        ], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (parentObject !== undefined && fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentToMldev$3(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"systemInstruction\"\n        ], contentToMldev$3(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = fromTools;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToMldev$3(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"tools\"\n        ], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, [\n        \"toolConfig\"\n    ]);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, [\n            \"toolConfig\"\n        ], toolConfigToMldev$1(fromToolConfig));\n    }\n    if (getValueByPath(fromObject, [\n        \"kmsKeyName\"\n    ]) !== undefined) {\n        throw new Error(\"kmsKeyName parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction createCachedContentConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, [\n        \"ttl\"\n    ]);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, [\n            \"ttl\"\n        ], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (parentObject !== undefined && fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(parentObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"systemInstruction\"\n        ], tContent(fromSystemInstruction));\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = fromTools;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToVertex$2(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"tools\"\n        ], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, [\n        \"toolConfig\"\n    ]);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, [\n            \"toolConfig\"\n        ], fromToolConfig);\n    }\n    const fromKmsKeyName = getValueByPath(fromObject, [\n        \"kmsKeyName\"\n    ]);\n    if (parentObject !== undefined && fromKmsKeyName != null) {\n        setValueByPath(parentObject, [\n            \"encryption_spec\",\n            \"kmsKeyName\"\n        ], fromKmsKeyName);\n    }\n    return toObject;\n}\nfunction createCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], tCachesModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        createCachedContentConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction createCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], tCachesModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        createCachedContentConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction deleteCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction deleteCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction deleteCachedContentResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction deleteCachedContentResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction fileDataToMldev$3(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction functionCallToMldev$3(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, [\n        \"id\"\n    ]);\n    if (fromId != null) {\n        setValueByPath(toObject, [\n            \"id\"\n        ], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, [\n        \"args\"\n    ]);\n    if (fromArgs != null) {\n        setValueByPath(toObject, [\n            \"args\"\n        ], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    if (getValueByPath(fromObject, [\n        \"partialArgs\"\n    ]) !== undefined) {\n        throw new Error(\"partialArgs parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"willContinue\"\n    ]) !== undefined) {\n        throw new Error(\"willContinue parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction functionCallingConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromAllowedFunctionNames = getValueByPath(fromObject, [\n        \"allowedFunctionNames\"\n    ]);\n    if (fromAllowedFunctionNames != null) {\n        setValueByPath(toObject, [\n            \"allowedFunctionNames\"\n        ], fromAllowedFunctionNames);\n    }\n    if (getValueByPath(fromObject, [\n        \"streamFunctionCallArguments\"\n    ]) !== undefined) {\n        throw new Error(\"streamFunctionCallArguments parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction functionDeclarationToVertex$2(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"behavior\"\n    ]) !== undefined) {\n        throw new Error(\"behavior parameter is not supported in Vertex AI.\");\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, [\n        \"parameters\"\n    ]);\n    if (fromParameters != null) {\n        setValueByPath(toObject, [\n            \"parameters\"\n        ], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        \"parametersJsonSchema\"\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"parametersJsonSchema\"\n        ], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction getCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction getCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction googleMapsToMldev$3(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"authConfig\"\n    ]) !== undefined) {\n        throw new Error(\"authConfig parameter is not supported in Gemini API.\");\n    }\n    const fromEnableWidget = getValueByPath(fromObject, [\n        \"enableWidget\"\n    ]);\n    if (fromEnableWidget != null) {\n        setValueByPath(toObject, [\n            \"enableWidget\"\n        ], fromEnableWidget);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$3(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"excludeDomains\"\n    ]) !== undefined) {\n        throw new Error(\"excludeDomains parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"blockingConfidence\"\n    ]) !== undefined) {\n        throw new Error(\"blockingConfidence parameter is not supported in Gemini API.\");\n    }\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        \"timeRangeFilter\"\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, [\n            \"timeRangeFilter\"\n        ], fromTimeRangeFilter);\n    }\n    return toObject;\n}\nfunction listCachedContentsConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    return toObject;\n}\nfunction listCachedContentsConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    return toObject;\n}\nfunction listCachedContentsParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listCachedContentsConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listCachedContentsParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listCachedContentsConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listCachedContentsResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromCachedContents = getValueByPath(fromObject, [\n        \"cachedContents\"\n    ]);\n    if (fromCachedContents != null) {\n        let transformedList = fromCachedContents;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"cachedContents\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction listCachedContentsResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromCachedContents = getValueByPath(fromObject, [\n        \"cachedContents\"\n    ]);\n    if (fromCachedContents != null) {\n        let transformedList = fromCachedContents;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"cachedContents\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction partToMldev$3(fromObject) {\n    const toObject = {};\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, [\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataToMldev$3(fromFileData));\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], functionCallToMldev$3(fromFunctionCall));\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobToMldev$3(fromInlineData));\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], fromVideoMetadata);\n    }\n    return toObject;\n}\nfunction toolConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromFunctionCallingConfig = getValueByPath(fromObject, [\n        \"functionCallingConfig\"\n    ]);\n    if (fromFunctionCallingConfig != null) {\n        setValueByPath(toObject, [\n            \"functionCallingConfig\"\n        ], functionCallingConfigToMldev$1(fromFunctionCallingConfig));\n    }\n    const fromRetrievalConfig = getValueByPath(fromObject, [\n        \"retrievalConfig\"\n    ]);\n    if (fromRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"retrievalConfig\"\n        ], fromRetrievalConfig);\n    }\n    return toObject;\n}\nfunction toolToMldev$3(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    if (getValueByPath(fromObject, [\n        \"retrieval\"\n    ]) !== undefined) {\n        throw new Error(\"retrieval parameter is not supported in Gemini API.\");\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], fromGoogleSearchRetrieval);\n    }\n    const fromComputerUse = getValueByPath(fromObject, [\n        \"computerUse\"\n    ]);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, [\n            \"computerUse\"\n        ], fromComputerUse);\n    }\n    const fromFileSearch = getValueByPath(fromObject, [\n        \"fileSearch\"\n    ]);\n    if (fromFileSearch != null) {\n        setValueByPath(toObject, [\n            \"fileSearch\"\n        ], fromFileSearch);\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    if (getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]) !== undefined) {\n        throw new Error(\"enterpriseWebSearch parameter is not supported in Gemini API.\");\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, [\n            \"googleMaps\"\n        ], googleMapsToMldev$3(fromGoogleMaps));\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToMldev$3(fromGoogleSearch));\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], fromUrlContext);\n    }\n    return toObject;\n}\nfunction toolToVertex$2(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return functionDeclarationToVertex$2(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    const fromRetrieval = getValueByPath(fromObject, [\n        \"retrieval\"\n    ]);\n    if (fromRetrieval != null) {\n        setValueByPath(toObject, [\n            \"retrieval\"\n        ], fromRetrieval);\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], fromGoogleSearchRetrieval);\n    }\n    const fromComputerUse = getValueByPath(fromObject, [\n        \"computerUse\"\n    ]);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, [\n            \"computerUse\"\n        ], fromComputerUse);\n    }\n    if (getValueByPath(fromObject, [\n        \"fileSearch\"\n    ]) !== undefined) {\n        throw new Error(\"fileSearch parameter is not supported in Vertex AI.\");\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    const fromEnterpriseWebSearch = getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]);\n    if (fromEnterpriseWebSearch != null) {\n        setValueByPath(toObject, [\n            \"enterpriseWebSearch\"\n        ], fromEnterpriseWebSearch);\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, [\n            \"googleMaps\"\n        ], fromGoogleMaps);\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], fromGoogleSearch);\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], fromUrlContext);\n    }\n    return toObject;\n}\nfunction updateCachedContentConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, [\n        \"ttl\"\n    ]);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, [\n            \"ttl\"\n        ], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    return toObject;\n}\nfunction updateCachedContentConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, [\n        \"ttl\"\n    ]);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, [\n            \"ttl\"\n        ], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    return toObject;\n}\nfunction updateCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        updateCachedContentConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction updateCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        updateCachedContentConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Caches extends BaseModule {\n    /**\n     * Creates a cached contents resource.\n     *\n     * @remarks\n     * Context caching is only supported for specific models. See [Gemini\n     * Developer API reference](https://ai.google.dev/gemini-api/docs/caching?lang=node/context-cac)\n     * and [Vertex AI reference](https://cloud.google.com/vertex-ai/generative-ai/docs/context-cache/context-cache-overview#supported_models)\n     * for more information.\n     *\n     * @param params - The parameters for the create request.\n     * @return The created cached content.\n     *\n     * @example\n     * ```ts\n     * const contents = ...; // Initialize the content to cache.\n     * const response = await ai.caches.create({\n     *   model: 'gemini-2.0-flash-001',\n     *   config: {\n     *    'contents': contents,\n     *    'displayName': 'test cache',\n     *    'systemInstruction': 'What is the sum of the two pdfs?',\n     *    'ttl': '86400s',\n     *  }\n     * });\n     * ```\n     */ async create(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = createCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"cachedContents\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((resp)=>{\n                return resp;\n            });\n        } else {\n            const body = createCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"cachedContents\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((resp)=>{\n                return resp;\n            });\n        }\n    }\n    /**\n     * Gets cached content configurations.\n     *\n     * @param params - The parameters for the get request.\n     * @return The cached content.\n     *\n     * @example\n     * ```ts\n     * await ai.caches.get({name: '...'}); // The server-generated resource name.\n     * ```\n     */ async get(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((resp)=>{\n                return resp;\n            });\n        } else {\n            const body = getCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((resp)=>{\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes cached content.\n     *\n     * @param params - The parameters for the delete request.\n     * @return The empty response returned by the API.\n     *\n     * @example\n     * ```ts\n     * await ai.caches.delete({name: '...'}); // The server-generated resource name.\n     * ```\n     */ async delete(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = deleteCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = deleteCachedContentResponseFromVertex(apiResponse);\n                const typedResp = new DeleteCachedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = deleteCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = deleteCachedContentResponseFromMldev(apiResponse);\n                const typedResp = new DeleteCachedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Updates cached content configurations.\n     *\n     * @param params - The parameters for the update request.\n     * @return The updated cached content.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.caches.update({\n     *   name: '...',  // The server-generated resource name.\n     *   config: {'ttl': '7600s'}\n     * });\n     * ```\n     */ async update(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = updateCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"PATCH\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((resp)=>{\n                return resp;\n            });\n        } else {\n            const body = updateCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"PATCH\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((resp)=>{\n                return resp;\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = listCachedContentsParametersToVertex(params);\n            path = formatMap(\"cachedContents\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listCachedContentsResponseFromVertex(apiResponse);\n                const typedResp = new ListCachedContentsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = listCachedContentsParametersToMldev(params);\n            path = formatMap(\"cachedContents\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listCachedContentsResponseFromMldev(apiResponse);\n                const typedResp = new ListCachedContentsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    constructor(apiClient){\n        var _this;\n        super(), _this = this;\n        this.apiClient = apiClient;\n        /**\n         * Lists cached contents.\n         *\n         * @param params - The parameters for the list request.\n         * @return - A pager of cached contents.\n         *\n         * @example\n         * ```ts\n         * const cachedContents = await ai.caches.list({config: {'pageSize': 2}});\n         * for await (const cachedContent of cachedContents) {\n         *   console.log(cachedContent);\n         * }\n         * ```\n         */ this.list = async function() {\n            let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n            return new Pager(PagedItem.PAGED_ITEM_CACHED_CONTENTS, (x)=>_this.listInternal(x), await _this.listInternal(params), params);\n        };\n    }\n}\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol, Iterator */ function __values(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function() {\n            if (o && i >= o.length) o = void 0;\n            return {\n                value: o && o[i++],\n                done: !o\n            };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __await(v) {\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i;\n    function awaitReturn(f) {\n        return function(v) {\n            return Promise.resolve(v).then(f, reject);\n        };\n    }\n    function verb(n, f) {\n        if (g[n]) {\n            i[n] = function(v) {\n                return new Promise(function(a, b) {\n                    q.push([\n                        n,\n                        v,\n                        a,\n                        b\n                    ]) > 1 || resume(n, v);\n                });\n            };\n            if (f) i[n] = f(i[n]);\n        }\n    }\n    function resume(n, v) {\n        try {\n            step(g[n](v));\n        } catch (e) {\n            settle(q[0][3], e);\n        }\n    }\n    function step(r) {\n        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n    }\n    function fulfill(value) {\n        resume(\"next\", value);\n    }\n    function reject(value) {\n        resume(\"throw\", value);\n    }\n    function settle(f, v) {\n        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n    }\n}\nfunction __asyncValues(o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i);\n    function verb(n) {\n        i[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n                v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n        };\n    }\n    function settle(resolve, reject, d, v) {\n        Promise.resolve(v).then(function(v) {\n            resolve({\n                value: v,\n                done: d\n            });\n        }, reject);\n    }\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ /**\n * Returns true if the response is valid, false otherwise.\n */ function isValidResponse(response) {\n    var _a;\n    if (response.candidates == undefined || response.candidates.length === 0) {\n        return false;\n    }\n    const content = (_a = response.candidates[0]) === null || _a === void 0 ? void 0 : _a.content;\n    if (content === undefined) {\n        return false;\n    }\n    return isValidContent(content);\n}\nfunction isValidContent(content) {\n    if (content.parts === undefined || content.parts.length === 0) {\n        return false;\n    }\n    for (const part of content.parts){\n        if (part === undefined || Object.keys(part).length === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Validates the history contains the correct roles.\n *\n * @throws Error if the history does not start with a user turn.\n * @throws Error if the history contains an invalid role.\n */ function validateHistory(history) {\n    // Empty history is valid.\n    if (history.length === 0) {\n        return;\n    }\n    for (const content of history){\n        if (content.role !== \"user\" && content.role !== \"model\") {\n            throw new Error(\"Role must be user or model, but got \".concat(content.role, \".\"));\n        }\n    }\n}\n/**\n * Extracts the curated (valid) history from a comprehensive history.\n *\n * @remarks\n * The model may sometimes generate invalid or empty contents(e.g., due to safty\n * filters or recitation). Extracting valid turns from the history\n * ensures that subsequent requests could be accpeted by the model.\n */ function extractCuratedHistory(comprehensiveHistory) {\n    if (comprehensiveHistory === undefined || comprehensiveHistory.length === 0) {\n        return [];\n    }\n    const curatedHistory = [];\n    const length = comprehensiveHistory.length;\n    let i = 0;\n    while(i < length){\n        if (comprehensiveHistory[i].role === \"user\") {\n            curatedHistory.push(comprehensiveHistory[i]);\n            i++;\n        } else {\n            const modelOutput = [];\n            let isValid = true;\n            while(i < length && comprehensiveHistory[i].role === \"model\"){\n                modelOutput.push(comprehensiveHistory[i]);\n                if (isValid && !isValidContent(comprehensiveHistory[i])) {\n                    isValid = false;\n                }\n                i++;\n            }\n            if (isValid) {\n                curatedHistory.push(...modelOutput);\n            } else {\n                // Remove the last user input when model content is invalid.\n                curatedHistory.pop();\n            }\n        }\n    }\n    return curatedHistory;\n}\n/**\n * A utility class to create a chat session.\n */ class Chats {\n    /**\n     * Creates a new chat session.\n     *\n     * @remarks\n     * The config in the params will be used for all requests within the chat\n     * session unless overridden by a per-request `config` in\n     * @see {@link types.SendMessageParameters#config}.\n     *\n     * @param params - Parameters for creating a chat session.\n     * @returns A new chat session.\n     *\n     * @example\n     * ```ts\n     * const chat = ai.chats.create({\n     *   model: 'gemini-2.0-flash'\n     *   config: {\n     *     temperature: 0.5,\n     *     maxOutputTokens: 1024,\n     *   }\n     * });\n     * ```\n     */ create(params) {\n        return new Chat(this.apiClient, this.modelsModule, params.model, params.config, // Deep copy the history to avoid mutating the history outside of the\n        // chat session.\n        structuredClone(params.history));\n    }\n    constructor(modelsModule, apiClient){\n        this.modelsModule = modelsModule;\n        this.apiClient = apiClient;\n    }\n}\n/**\n * Chat session that enables sending messages to the model with previous\n * conversation context.\n *\n * @remarks\n * The session maintains all the turns between user and model.\n */ class Chat {\n    /**\n     * Sends a message to the model and returns the response.\n     *\n     * @remarks\n     * This method will wait for the previous message to be processed before\n     * sending the next message.\n     *\n     * @see {@link Chat#sendMessageStream} for streaming method.\n     * @param params - parameters for sending messages within a chat session.\n     * @returns The model's response.\n     *\n     * @example\n     * ```ts\n     * const chat = ai.chats.create({model: 'gemini-2.0-flash'});\n     * const response = await chat.sendMessage({\n     *   message: 'Why is the sky blue?'\n     * });\n     * console.log(response.text);\n     * ```\n     */ async sendMessage(params) {\n        var _a;\n        await this.sendPromise;\n        const inputContent = tContent(params.message);\n        const responsePromise = this.modelsModule.generateContent({\n            model: this.model,\n            contents: this.getHistory(true).concat(inputContent),\n            config: (_a = params.config) !== null && _a !== void 0 ? _a : this.config\n        });\n        this.sendPromise = (async ()=>{\n            var _a, _b, _c;\n            const response = await responsePromise;\n            const outputContent = (_b = (_a = response.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content;\n            // Because the AFC input contains the entire curated chat history in\n            // addition to the new user input, we need to truncate the AFC history\n            // to deduplicate the existing chat history.\n            const fullAutomaticFunctionCallingHistory = response.automaticFunctionCallingHistory;\n            const index = this.getHistory(true).length;\n            let automaticFunctionCallingHistory = [];\n            if (fullAutomaticFunctionCallingHistory != null) {\n                automaticFunctionCallingHistory = (_c = fullAutomaticFunctionCallingHistory.slice(index)) !== null && _c !== void 0 ? _c : [];\n            }\n            const modelOutput = outputContent ? [\n                outputContent\n            ] : [];\n            this.recordHistory(inputContent, modelOutput, automaticFunctionCallingHistory);\n            return;\n        })();\n        await this.sendPromise.catch(()=>{\n            // Resets sendPromise to avoid subsequent calls failing\n            this.sendPromise = Promise.resolve();\n        });\n        return responsePromise;\n    }\n    /**\n     * Sends a message to the model and returns the response in chunks.\n     *\n     * @remarks\n     * This method will wait for the previous message to be processed before\n     * sending the next message.\n     *\n     * @see {@link Chat#sendMessage} for non-streaming method.\n     * @param params - parameters for sending the message.\n     * @return The model's response.\n     *\n     * @example\n     * ```ts\n     * const chat = ai.chats.create({model: 'gemini-2.0-flash'});\n     * const response = await chat.sendMessageStream({\n     *   message: 'Why is the sky blue?'\n     * });\n     * for await (const chunk of response) {\n     *   console.log(chunk.text);\n     * }\n     * ```\n     */ async sendMessageStream(params) {\n        var _a;\n        await this.sendPromise;\n        const inputContent = tContent(params.message);\n        const streamResponse = this.modelsModule.generateContentStream({\n            model: this.model,\n            contents: this.getHistory(true).concat(inputContent),\n            config: (_a = params.config) !== null && _a !== void 0 ? _a : this.config\n        });\n        // Resolve the internal tracking of send completion promise - `sendPromise`\n        // for both success and failure response. The actual failure is still\n        // propagated by the `await streamResponse`.\n        this.sendPromise = streamResponse.then(()=>undefined).catch(()=>undefined);\n        const response = await streamResponse;\n        const result = this.processStreamResponse(response, inputContent);\n        return result;\n    }\n    /**\n     * Returns the chat history.\n     *\n     * @remarks\n     * The history is a list of contents alternating between user and model.\n     *\n     * There are two types of history:\n     * - The `curated history` contains only the valid turns between user and\n     * model, which will be included in the subsequent requests sent to the model.\n     * - The `comprehensive history` contains all turns, including invalid or\n     *   empty model outputs, providing a complete record of the history.\n     *\n     * The history is updated after receiving the response from the model,\n     * for streaming response, it means receiving the last chunk of the response.\n     *\n     * The `comprehensive history` is returned by default. To get the `curated\n     * history`, set the `curated` parameter to `true`.\n     *\n     * @param curated - whether to return the curated history or the comprehensive\n     *     history.\n     * @return History contents alternating between user and model for the entire\n     *     chat session.\n     */ getHistory() {\n        let curated = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n        const history = curated ? extractCuratedHistory(this.history) : this.history;\n        // Deep copy the history to avoid mutating the history outside of the\n        // chat session.\n        return structuredClone(history);\n    }\n    processStreamResponse(streamResponse, inputContent) {\n        var _a, _b;\n        return __asyncGenerator(this, arguments, function* processStreamResponse_1() {\n            var _c, e_1, _d, _e;\n            const outputContent = [];\n            try {\n                for(var _f = true, streamResponse_1 = __asyncValues(streamResponse), streamResponse_1_1; streamResponse_1_1 = yield __await(streamResponse_1.next()), _c = streamResponse_1_1.done, !_c; _f = true){\n                    _e = streamResponse_1_1.value;\n                    _f = false;\n                    const chunk = _e;\n                    if (isValidResponse(chunk)) {\n                        const content = (_b = (_a = chunk.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content;\n                        if (content !== undefined) {\n                            outputContent.push(content);\n                        }\n                    }\n                    yield yield __await(chunk);\n                }\n            } catch (e_1_1) {\n                e_1 = {\n                    error: e_1_1\n                };\n            } finally{\n                try {\n                    if (!_f && !_c && (_d = streamResponse_1.return)) yield __await(_d.call(streamResponse_1));\n                } finally{\n                    if (e_1) throw e_1.error;\n                }\n            }\n            this.recordHistory(inputContent, outputContent);\n        });\n    }\n    recordHistory(userInput, modelOutput, automaticFunctionCallingHistory) {\n        let outputContents = [];\n        if (modelOutput.length > 0 && modelOutput.every((content)=>content.role !== undefined)) {\n            outputContents = modelOutput;\n        } else {\n            // Appends an empty content when model returns empty response, so that the\n            // history is always alternating between user and model.\n            outputContents.push({\n                role: \"model\",\n                parts: []\n            });\n        }\n        if (automaticFunctionCallingHistory && automaticFunctionCallingHistory.length > 0) {\n            this.history.push(...extractCuratedHistory(automaticFunctionCallingHistory));\n        } else {\n            this.history.push(userInput);\n        }\n        this.history.push(...outputContents);\n    }\n    constructor(apiClient, modelsModule, model, config = {}, history = []){\n        this.apiClient = apiClient;\n        this.modelsModule = modelsModule;\n        this.model = model;\n        this.config = config;\n        this.history = history;\n        // A promise to represent the current state of the message being sent to the\n        // model.\n        this.sendPromise = Promise.resolve();\n        validateHistory(history);\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ /**\n * API errors raised by the GenAI API.\n */ class ApiError extends Error {\n    constructor(options){\n        super(options.message);\n        this.name = \"ApiError\";\n        this.status = options.status;\n        Object.setPrototypeOf(this, ApiError.prototype);\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ // Code generated by the Google Gen AI SDK generator DO NOT EDIT.\nfunction createFileParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromFile = getValueByPath(fromObject, [\n        \"file\"\n    ]);\n    if (fromFile != null) {\n        setValueByPath(toObject, [\n            \"file\"\n        ], fromFile);\n    }\n    return toObject;\n}\nfunction createFileResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction deleteFileParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"file\"\n        ], tFileName(fromName));\n    }\n    return toObject;\n}\nfunction deleteFileResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction getFileParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"file\"\n        ], tFileName(fromName));\n    }\n    return toObject;\n}\nfunction listFilesConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    return toObject;\n}\nfunction listFilesParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listFilesConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listFilesResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromFiles = getValueByPath(fromObject, [\n        \"files\"\n    ]);\n    if (fromFiles != null) {\n        let transformedList = fromFiles;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"files\"\n        ], transformedList);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Files extends BaseModule {\n    /**\n     * Uploads a file asynchronously to the Gemini API.\n     * This method is not available in Vertex AI.\n     * Supported upload sources:\n     * - Node.js: File path (string) or Blob object.\n     * - Browser: Blob object (e.g., File).\n     *\n     * @remarks\n     * The `mimeType` can be specified in the `config` parameter. If omitted:\n     *  - For file path (string) inputs, the `mimeType` will be inferred from the\n     *     file extension.\n     *  - For Blob object inputs, the `mimeType` will be set to the Blob's `type`\n     *     property.\n     * Somex eamples for file extension to mimeType mapping:\n     * .txt -> text/plain\n     * .json -> application/json\n     * .jpg  -> image/jpeg\n     * .png -> image/png\n     * .mp3 -> audio/mpeg\n     * .mp4 -> video/mp4\n     *\n     * This section can contain multiple paragraphs and code examples.\n     *\n     * @param params - Optional parameters specified in the\n     *        `types.UploadFileParameters` interface.\n     *         @see {@link types.UploadFileParameters#config} for the optional\n     *         config in the parameters.\n     * @return A promise that resolves to a `types.File` object.\n     * @throws An error if called on a Vertex AI client.\n     * @throws An error if the `mimeType` is not provided and can not be inferred,\n     * the `mimeType` can be provided in the `params.config` parameter.\n     * @throws An error occurs if a suitable upload location cannot be established.\n     *\n     * @example\n     * The following code uploads a file to Gemini API.\n     *\n     * ```ts\n     * const file = await ai.files.upload({file: 'file.txt', config: {\n     *   mimeType: 'text/plain',\n     * }});\n     * console.log(file.name);\n     * ```\n     */ async upload(params) {\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"Vertex AI does not support uploading files. You can share files through a GCS bucket.\");\n        }\n        return this.apiClient.uploadFile(params.file, params.config).then((resp)=>{\n            return resp;\n        });\n    }\n    /**\n     * Downloads a remotely stored file asynchronously to a location specified in\n     * the `params` object. This method only works on Node environment, to\n     * download files in the browser, use a browser compliant method like an <a>\n     * tag.\n     *\n     * @param params - The parameters for the download request.\n     *\n     * @example\n     * The following code downloads an example file named \"files/mehozpxf877d\" as\n     * \"file.txt\".\n     *\n     * ```ts\n     * await ai.files.download({file: file.name, downloadPath: 'file.txt'});\n     * ```\n     */ async download(params) {\n        await this.apiClient.downloadFile(params);\n    }\n    async listInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = listFilesParametersToMldev(params);\n            path = formatMap(\"files\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listFilesResponseFromMldev(apiResponse);\n                const typedResp = new ListFilesResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    async createInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = createFileParametersToMldev(params);\n            path = formatMap(\"upload/v1beta/files\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = createFileResponseFromMldev(apiResponse);\n                const typedResp = new CreateFileResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Retrieves the file information from the service.\n     *\n     * @param params - The parameters for the get request\n     * @return The Promise that resolves to the types.File object requested.\n     *\n     * @example\n     * ```ts\n     * const config: GetFileParameters = {\n     *   name: fileName,\n     * };\n     * file = await ai.files.get(config);\n     * console.log(file.name);\n     * ```\n     */ async get(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = getFileParametersToMldev(params);\n            path = formatMap(\"files/{file}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((resp)=>{\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes a remotely stored file.\n     *\n     * @param params - The parameters for the delete request.\n     * @return The DeleteFileResponse, the response for the delete method.\n     *\n     * @example\n     * The following code deletes an example file named \"files/mehozpxf877d\".\n     *\n     * ```ts\n     * await ai.files.delete({name: file.name});\n     * ```\n     */ async delete(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = deleteFileParametersToMldev(params);\n            path = formatMap(\"files/{file}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = deleteFileResponseFromMldev(apiResponse);\n                const typedResp = new DeleteFileResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    constructor(apiClient){\n        var _this;\n        super(), _this = this;\n        this.apiClient = apiClient;\n        /**\n         * Lists files.\n         *\n         * @param params - The parameters for the list request.\n         * @return - A pager of files.\n         *\n         * @example\n         * ```ts\n         * const files = await ai.files.list({config: {'pageSize': 2}});\n         * for await (const file of files) {\n         *   console.log(file);\n         * }\n         * ```\n         */ this.list = async function() {\n            let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n            return new Pager(PagedItem.PAGED_ITEM_FILES, (x)=>_this.listInternal(x), await _this.listInternal(params), params);\n        };\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function blobToMldev$2(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction contentToMldev$2(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partToMldev$2(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction fileDataToMldev$2(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction functionCallToMldev$2(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, [\n        \"id\"\n    ]);\n    if (fromId != null) {\n        setValueByPath(toObject, [\n            \"id\"\n        ], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, [\n        \"args\"\n    ]);\n    if (fromArgs != null) {\n        setValueByPath(toObject, [\n            \"args\"\n        ], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    if (getValueByPath(fromObject, [\n        \"partialArgs\"\n    ]) !== undefined) {\n        throw new Error(\"partialArgs parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"willContinue\"\n    ]) !== undefined) {\n        throw new Error(\"willContinue parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction functionDeclarationToVertex$1(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"behavior\"\n    ]) !== undefined) {\n        throw new Error(\"behavior parameter is not supported in Vertex AI.\");\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, [\n        \"parameters\"\n    ]);\n    if (fromParameters != null) {\n        setValueByPath(toObject, [\n            \"parameters\"\n        ], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        \"parametersJsonSchema\"\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"parametersJsonSchema\"\n        ], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction generationConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromModelSelectionConfig = getValueByPath(fromObject, [\n        \"modelSelectionConfig\"\n    ]);\n    if (fromModelSelectionConfig != null) {\n        setValueByPath(toObject, [\n            \"modelConfig\"\n        ], fromModelSelectionConfig);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    const fromAudioTimestamp = getValueByPath(fromObject, [\n        \"audioTimestamp\"\n    ]);\n    if (fromAudioTimestamp != null) {\n        setValueByPath(toObject, [\n            \"audioTimestamp\"\n        ], fromAudioTimestamp);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        \"candidateCount\"\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, [\n            \"candidateCount\"\n        ], fromCandidateCount);\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        \"enableAffectiveDialog\"\n    ]);\n    if (fromEnableAffectiveDialog != null) {\n        setValueByPath(toObject, [\n            \"enableAffectiveDialog\"\n        ], fromEnableAffectiveDialog);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        \"frequencyPenalty\"\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, [\n            \"frequencyPenalty\"\n        ], fromFrequencyPenalty);\n    }\n    const fromLogprobs = getValueByPath(fromObject, [\n        \"logprobs\"\n    ]);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, [\n            \"logprobs\"\n        ], fromLogprobs);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, [\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, [\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        \"presencePenalty\"\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, [\n            \"presencePenalty\"\n        ], fromPresencePenalty);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        \"responseLogprobs\"\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, [\n            \"responseLogprobs\"\n        ], fromResponseLogprobs);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        \"responseMimeType\"\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, [\n            \"responseMimeType\"\n        ], fromResponseMimeType);\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, [\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        \"responseSchema\"\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, [\n            \"responseSchema\"\n        ], fromResponseSchema);\n    }\n    const fromRoutingConfig = getValueByPath(fromObject, [\n        \"routingConfig\"\n    ]);\n    if (fromRoutingConfig != null) {\n        setValueByPath(toObject, [\n            \"routingConfig\"\n        ], fromRoutingConfig);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (fromSeed != null) {\n        setValueByPath(toObject, [\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, [\n            \"speechConfig\"\n        ], speechConfigToVertex$1(fromSpeechConfig));\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        \"stopSequences\"\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, [\n            \"stopSequences\"\n        ], fromStopSequences);\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, [\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        \"thinkingConfig\"\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, [\n            \"thinkingConfig\"\n        ], fromThinkingConfig);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (fromTopK != null) {\n        setValueByPath(toObject, [\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (fromTopP != null) {\n        setValueByPath(toObject, [\n            \"topP\"\n        ], fromTopP);\n    }\n    if (getValueByPath(fromObject, [\n        \"enableEnhancedCivicAnswers\"\n    ]) !== undefined) {\n        throw new Error(\"enableEnhancedCivicAnswers parameter is not supported in Vertex AI.\");\n    }\n    return toObject;\n}\nfunction googleMapsToMldev$2(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"authConfig\"\n    ]) !== undefined) {\n        throw new Error(\"authConfig parameter is not supported in Gemini API.\");\n    }\n    const fromEnableWidget = getValueByPath(fromObject, [\n        \"enableWidget\"\n    ]);\n    if (fromEnableWidget != null) {\n        setValueByPath(toObject, [\n            \"enableWidget\"\n        ], fromEnableWidget);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$2(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"excludeDomains\"\n    ]) !== undefined) {\n        throw new Error(\"excludeDomains parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"blockingConfidence\"\n    ]) !== undefined) {\n        throw new Error(\"blockingConfidence parameter is not supported in Gemini API.\");\n    }\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        \"timeRangeFilter\"\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, [\n            \"timeRangeFilter\"\n        ], fromTimeRangeFilter);\n    }\n    return toObject;\n}\nfunction liveConnectConfigToMldev$1(fromObject, parentObject) {\n    const toObject = {};\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        \"generationConfig\"\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\"\n        ], fromGenerationConfig);\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (parentObject !== undefined && fromResponseModalities != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (parentObject !== undefined && fromTemperature != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (parentObject !== undefined && fromTopP != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (parentObject !== undefined && fromTopK != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (parentObject !== undefined && fromMaxOutputTokens != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (parentObject !== undefined && fromMediaResolution != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (parentObject !== undefined && fromSpeechConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"speechConfig\"\n        ], tLiveSpeechConfig(fromSpeechConfig));\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        \"thinkingConfig\"\n    ]);\n    if (parentObject !== undefined && fromThinkingConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"thinkingConfig\"\n        ], fromThinkingConfig);\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        \"enableAffectiveDialog\"\n    ]);\n    if (parentObject !== undefined && fromEnableAffectiveDialog != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"enableAffectiveDialog\"\n        ], fromEnableAffectiveDialog);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"systemInstruction\"\n        ], contentToMldev$2(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToMldev$2(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"tools\"\n        ], transformedList);\n    }\n    const fromSessionResumption = getValueByPath(fromObject, [\n        \"sessionResumption\"\n    ]);\n    if (parentObject !== undefined && fromSessionResumption != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"sessionResumption\"\n        ], sessionResumptionConfigToMldev$1(fromSessionResumption));\n    }\n    const fromInputAudioTranscription = getValueByPath(fromObject, [\n        \"inputAudioTranscription\"\n    ]);\n    if (parentObject !== undefined && fromInputAudioTranscription != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"inputAudioTranscription\"\n        ], fromInputAudioTranscription);\n    }\n    const fromOutputAudioTranscription = getValueByPath(fromObject, [\n        \"outputAudioTranscription\"\n    ]);\n    if (parentObject !== undefined && fromOutputAudioTranscription != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"outputAudioTranscription\"\n        ], fromOutputAudioTranscription);\n    }\n    const fromRealtimeInputConfig = getValueByPath(fromObject, [\n        \"realtimeInputConfig\"\n    ]);\n    if (parentObject !== undefined && fromRealtimeInputConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"realtimeInputConfig\"\n        ], fromRealtimeInputConfig);\n    }\n    const fromContextWindowCompression = getValueByPath(fromObject, [\n        \"contextWindowCompression\"\n    ]);\n    if (parentObject !== undefined && fromContextWindowCompression != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"contextWindowCompression\"\n        ], fromContextWindowCompression);\n    }\n    const fromProactivity = getValueByPath(fromObject, [\n        \"proactivity\"\n    ]);\n    if (parentObject !== undefined && fromProactivity != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"proactivity\"\n        ], fromProactivity);\n    }\n    return toObject;\n}\nfunction liveConnectConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        \"generationConfig\"\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\"\n        ], generationConfigToVertex$1(fromGenerationConfig));\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (parentObject !== undefined && fromResponseModalities != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (parentObject !== undefined && fromTemperature != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (parentObject !== undefined && fromTopP != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (parentObject !== undefined && fromTopK != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (parentObject !== undefined && fromMaxOutputTokens != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (parentObject !== undefined && fromMediaResolution != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (parentObject !== undefined && fromSpeechConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"speechConfig\"\n        ], speechConfigToVertex$1(tLiveSpeechConfig(fromSpeechConfig)));\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        \"thinkingConfig\"\n    ]);\n    if (parentObject !== undefined && fromThinkingConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"thinkingConfig\"\n        ], fromThinkingConfig);\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        \"enableAffectiveDialog\"\n    ]);\n    if (parentObject !== undefined && fromEnableAffectiveDialog != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"enableAffectiveDialog\"\n        ], fromEnableAffectiveDialog);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"systemInstruction\"\n        ], tContent(fromSystemInstruction));\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToVertex$1(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"tools\"\n        ], transformedList);\n    }\n    const fromSessionResumption = getValueByPath(fromObject, [\n        \"sessionResumption\"\n    ]);\n    if (parentObject !== undefined && fromSessionResumption != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"sessionResumption\"\n        ], fromSessionResumption);\n    }\n    const fromInputAudioTranscription = getValueByPath(fromObject, [\n        \"inputAudioTranscription\"\n    ]);\n    if (parentObject !== undefined && fromInputAudioTranscription != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"inputAudioTranscription\"\n        ], fromInputAudioTranscription);\n    }\n    const fromOutputAudioTranscription = getValueByPath(fromObject, [\n        \"outputAudioTranscription\"\n    ]);\n    if (parentObject !== undefined && fromOutputAudioTranscription != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"outputAudioTranscription\"\n        ], fromOutputAudioTranscription);\n    }\n    const fromRealtimeInputConfig = getValueByPath(fromObject, [\n        \"realtimeInputConfig\"\n    ]);\n    if (parentObject !== undefined && fromRealtimeInputConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"realtimeInputConfig\"\n        ], fromRealtimeInputConfig);\n    }\n    const fromContextWindowCompression = getValueByPath(fromObject, [\n        \"contextWindowCompression\"\n    ]);\n    if (parentObject !== undefined && fromContextWindowCompression != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"contextWindowCompression\"\n        ], fromContextWindowCompression);\n    }\n    const fromProactivity = getValueByPath(fromObject, [\n        \"proactivity\"\n    ]);\n    if (parentObject !== undefined && fromProactivity != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"proactivity\"\n        ], fromProactivity);\n    }\n    return toObject;\n}\nfunction liveConnectParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"setup\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], liveConnectConfigToMldev$1(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction liveConnectParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"setup\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], liveConnectConfigToVertex(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction liveMusicSetConfigParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromMusicGenerationConfig = getValueByPath(fromObject, [\n        \"musicGenerationConfig\"\n    ]);\n    if (fromMusicGenerationConfig != null) {\n        setValueByPath(toObject, [\n            \"musicGenerationConfig\"\n        ], fromMusicGenerationConfig);\n    }\n    return toObject;\n}\nfunction liveMusicSetWeightedPromptsParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromWeightedPrompts = getValueByPath(fromObject, [\n        \"weightedPrompts\"\n    ]);\n    if (fromWeightedPrompts != null) {\n        let transformedList = fromWeightedPrompts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"weightedPrompts\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction liveSendRealtimeInputParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromMedia = getValueByPath(fromObject, [\n        \"media\"\n    ]);\n    if (fromMedia != null) {\n        let transformedList = tBlobs(fromMedia);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return blobToMldev$2(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"mediaChunks\"\n        ], transformedList);\n    }\n    const fromAudio = getValueByPath(fromObject, [\n        \"audio\"\n    ]);\n    if (fromAudio != null) {\n        setValueByPath(toObject, [\n            \"audio\"\n        ], blobToMldev$2(tAudioBlob(fromAudio)));\n    }\n    const fromAudioStreamEnd = getValueByPath(fromObject, [\n        \"audioStreamEnd\"\n    ]);\n    if (fromAudioStreamEnd != null) {\n        setValueByPath(toObject, [\n            \"audioStreamEnd\"\n        ], fromAudioStreamEnd);\n    }\n    const fromVideo = getValueByPath(fromObject, [\n        \"video\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"video\"\n        ], blobToMldev$2(tImageBlob(fromVideo)));\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromActivityStart = getValueByPath(fromObject, [\n        \"activityStart\"\n    ]);\n    if (fromActivityStart != null) {\n        setValueByPath(toObject, [\n            \"activityStart\"\n        ], fromActivityStart);\n    }\n    const fromActivityEnd = getValueByPath(fromObject, [\n        \"activityEnd\"\n    ]);\n    if (fromActivityEnd != null) {\n        setValueByPath(toObject, [\n            \"activityEnd\"\n        ], fromActivityEnd);\n    }\n    return toObject;\n}\nfunction liveSendRealtimeInputParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromMedia = getValueByPath(fromObject, [\n        \"media\"\n    ]);\n    if (fromMedia != null) {\n        let transformedList = tBlobs(fromMedia);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"mediaChunks\"\n        ], transformedList);\n    }\n    const fromAudio = getValueByPath(fromObject, [\n        \"audio\"\n    ]);\n    if (fromAudio != null) {\n        setValueByPath(toObject, [\n            \"audio\"\n        ], tAudioBlob(fromAudio));\n    }\n    const fromAudioStreamEnd = getValueByPath(fromObject, [\n        \"audioStreamEnd\"\n    ]);\n    if (fromAudioStreamEnd != null) {\n        setValueByPath(toObject, [\n            \"audioStreamEnd\"\n        ], fromAudioStreamEnd);\n    }\n    const fromVideo = getValueByPath(fromObject, [\n        \"video\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"video\"\n        ], tImageBlob(fromVideo));\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromActivityStart = getValueByPath(fromObject, [\n        \"activityStart\"\n    ]);\n    if (fromActivityStart != null) {\n        setValueByPath(toObject, [\n            \"activityStart\"\n        ], fromActivityStart);\n    }\n    const fromActivityEnd = getValueByPath(fromObject, [\n        \"activityEnd\"\n    ]);\n    if (fromActivityEnd != null) {\n        setValueByPath(toObject, [\n            \"activityEnd\"\n        ], fromActivityEnd);\n    }\n    return toObject;\n}\nfunction liveServerMessageFromVertex(fromObject) {\n    const toObject = {};\n    const fromSetupComplete = getValueByPath(fromObject, [\n        \"setupComplete\"\n    ]);\n    if (fromSetupComplete != null) {\n        setValueByPath(toObject, [\n            \"setupComplete\"\n        ], fromSetupComplete);\n    }\n    const fromServerContent = getValueByPath(fromObject, [\n        \"serverContent\"\n    ]);\n    if (fromServerContent != null) {\n        setValueByPath(toObject, [\n            \"serverContent\"\n        ], fromServerContent);\n    }\n    const fromToolCall = getValueByPath(fromObject, [\n        \"toolCall\"\n    ]);\n    if (fromToolCall != null) {\n        setValueByPath(toObject, [\n            \"toolCall\"\n        ], fromToolCall);\n    }\n    const fromToolCallCancellation = getValueByPath(fromObject, [\n        \"toolCallCancellation\"\n    ]);\n    if (fromToolCallCancellation != null) {\n        setValueByPath(toObject, [\n            \"toolCallCancellation\"\n        ], fromToolCallCancellation);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        \"usageMetadata\"\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, [\n            \"usageMetadata\"\n        ], usageMetadataFromVertex(fromUsageMetadata));\n    }\n    const fromGoAway = getValueByPath(fromObject, [\n        \"goAway\"\n    ]);\n    if (fromGoAway != null) {\n        setValueByPath(toObject, [\n            \"goAway\"\n        ], fromGoAway);\n    }\n    const fromSessionResumptionUpdate = getValueByPath(fromObject, [\n        \"sessionResumptionUpdate\"\n    ]);\n    if (fromSessionResumptionUpdate != null) {\n        setValueByPath(toObject, [\n            \"sessionResumptionUpdate\"\n        ], fromSessionResumptionUpdate);\n    }\n    return toObject;\n}\nfunction partToMldev$2(fromObject) {\n    const toObject = {};\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, [\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataToMldev$2(fromFileData));\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], functionCallToMldev$2(fromFunctionCall));\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobToMldev$2(fromInlineData));\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], fromVideoMetadata);\n    }\n    return toObject;\n}\nfunction sessionResumptionConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromHandle = getValueByPath(fromObject, [\n        \"handle\"\n    ]);\n    if (fromHandle != null) {\n        setValueByPath(toObject, [\n            \"handle\"\n        ], fromHandle);\n    }\n    if (getValueByPath(fromObject, [\n        \"transparent\"\n    ]) !== undefined) {\n        throw new Error(\"transparent parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction speechConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromLanguageCode = getValueByPath(fromObject, [\n        \"languageCode\"\n    ]);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, [\n            \"languageCode\"\n        ], fromLanguageCode);\n    }\n    const fromVoiceConfig = getValueByPath(fromObject, [\n        \"voiceConfig\"\n    ]);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"voiceConfig\"\n        ], fromVoiceConfig);\n    }\n    if (getValueByPath(fromObject, [\n        \"multiSpeakerVoiceConfig\"\n    ]) !== undefined) {\n        throw new Error(\"multiSpeakerVoiceConfig parameter is not supported in Vertex AI.\");\n    }\n    return toObject;\n}\nfunction toolToMldev$2(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    if (getValueByPath(fromObject, [\n        \"retrieval\"\n    ]) !== undefined) {\n        throw new Error(\"retrieval parameter is not supported in Gemini API.\");\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], fromGoogleSearchRetrieval);\n    }\n    const fromComputerUse = getValueByPath(fromObject, [\n        \"computerUse\"\n    ]);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, [\n            \"computerUse\"\n        ], fromComputerUse);\n    }\n    const fromFileSearch = getValueByPath(fromObject, [\n        \"fileSearch\"\n    ]);\n    if (fromFileSearch != null) {\n        setValueByPath(toObject, [\n            \"fileSearch\"\n        ], fromFileSearch);\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    if (getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]) !== undefined) {\n        throw new Error(\"enterpriseWebSearch parameter is not supported in Gemini API.\");\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, [\n            \"googleMaps\"\n        ], googleMapsToMldev$2(fromGoogleMaps));\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToMldev$2(fromGoogleSearch));\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], fromUrlContext);\n    }\n    return toObject;\n}\nfunction toolToVertex$1(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return functionDeclarationToVertex$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    const fromRetrieval = getValueByPath(fromObject, [\n        \"retrieval\"\n    ]);\n    if (fromRetrieval != null) {\n        setValueByPath(toObject, [\n            \"retrieval\"\n        ], fromRetrieval);\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], fromGoogleSearchRetrieval);\n    }\n    const fromComputerUse = getValueByPath(fromObject, [\n        \"computerUse\"\n    ]);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, [\n            \"computerUse\"\n        ], fromComputerUse);\n    }\n    if (getValueByPath(fromObject, [\n        \"fileSearch\"\n    ]) !== undefined) {\n        throw new Error(\"fileSearch parameter is not supported in Vertex AI.\");\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    const fromEnterpriseWebSearch = getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]);\n    if (fromEnterpriseWebSearch != null) {\n        setValueByPath(toObject, [\n            \"enterpriseWebSearch\"\n        ], fromEnterpriseWebSearch);\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, [\n            \"googleMaps\"\n        ], fromGoogleMaps);\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], fromGoogleSearch);\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], fromUrlContext);\n    }\n    return toObject;\n}\nfunction usageMetadataFromVertex(fromObject) {\n    const toObject = {};\n    const fromPromptTokenCount = getValueByPath(fromObject, [\n        \"promptTokenCount\"\n    ]);\n    if (fromPromptTokenCount != null) {\n        setValueByPath(toObject, [\n            \"promptTokenCount\"\n        ], fromPromptTokenCount);\n    }\n    const fromCachedContentTokenCount = getValueByPath(fromObject, [\n        \"cachedContentTokenCount\"\n    ]);\n    if (fromCachedContentTokenCount != null) {\n        setValueByPath(toObject, [\n            \"cachedContentTokenCount\"\n        ], fromCachedContentTokenCount);\n    }\n    const fromResponseTokenCount = getValueByPath(fromObject, [\n        \"candidatesTokenCount\"\n    ]);\n    if (fromResponseTokenCount != null) {\n        setValueByPath(toObject, [\n            \"responseTokenCount\"\n        ], fromResponseTokenCount);\n    }\n    const fromToolUsePromptTokenCount = getValueByPath(fromObject, [\n        \"toolUsePromptTokenCount\"\n    ]);\n    if (fromToolUsePromptTokenCount != null) {\n        setValueByPath(toObject, [\n            \"toolUsePromptTokenCount\"\n        ], fromToolUsePromptTokenCount);\n    }\n    const fromThoughtsTokenCount = getValueByPath(fromObject, [\n        \"thoughtsTokenCount\"\n    ]);\n    if (fromThoughtsTokenCount != null) {\n        setValueByPath(toObject, [\n            \"thoughtsTokenCount\"\n        ], fromThoughtsTokenCount);\n    }\n    const fromTotalTokenCount = getValueByPath(fromObject, [\n        \"totalTokenCount\"\n    ]);\n    if (fromTotalTokenCount != null) {\n        setValueByPath(toObject, [\n            \"totalTokenCount\"\n        ], fromTotalTokenCount);\n    }\n    const fromPromptTokensDetails = getValueByPath(fromObject, [\n        \"promptTokensDetails\"\n    ]);\n    if (fromPromptTokensDetails != null) {\n        let transformedList = fromPromptTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"promptTokensDetails\"\n        ], transformedList);\n    }\n    const fromCacheTokensDetails = getValueByPath(fromObject, [\n        \"cacheTokensDetails\"\n    ]);\n    if (fromCacheTokensDetails != null) {\n        let transformedList = fromCacheTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"cacheTokensDetails\"\n        ], transformedList);\n    }\n    const fromResponseTokensDetails = getValueByPath(fromObject, [\n        \"candidatesTokensDetails\"\n    ]);\n    if (fromResponseTokensDetails != null) {\n        let transformedList = fromResponseTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"responseTokensDetails\"\n        ], transformedList);\n    }\n    const fromToolUsePromptTokensDetails = getValueByPath(fromObject, [\n        \"toolUsePromptTokensDetails\"\n    ]);\n    if (fromToolUsePromptTokensDetails != null) {\n        let transformedList = fromToolUsePromptTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"toolUsePromptTokensDetails\"\n        ], transformedList);\n    }\n    const fromTrafficType = getValueByPath(fromObject, [\n        \"trafficType\"\n    ]);\n    if (fromTrafficType != null) {\n        setValueByPath(toObject, [\n            \"trafficType\"\n        ], fromTrafficType);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function blobToMldev$1(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction candidateFromMldev(fromObject) {\n    const toObject = {};\n    const fromContent = getValueByPath(fromObject, [\n        \"content\"\n    ]);\n    if (fromContent != null) {\n        setValueByPath(toObject, [\n            \"content\"\n        ], fromContent);\n    }\n    const fromCitationMetadata = getValueByPath(fromObject, [\n        \"citationMetadata\"\n    ]);\n    if (fromCitationMetadata != null) {\n        setValueByPath(toObject, [\n            \"citationMetadata\"\n        ], citationMetadataFromMldev(fromCitationMetadata));\n    }\n    const fromTokenCount = getValueByPath(fromObject, [\n        \"tokenCount\"\n    ]);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, [\n            \"tokenCount\"\n        ], fromTokenCount);\n    }\n    const fromFinishReason = getValueByPath(fromObject, [\n        \"finishReason\"\n    ]);\n    if (fromFinishReason != null) {\n        setValueByPath(toObject, [\n            \"finishReason\"\n        ], fromFinishReason);\n    }\n    const fromAvgLogprobs = getValueByPath(fromObject, [\n        \"avgLogprobs\"\n    ]);\n    if (fromAvgLogprobs != null) {\n        setValueByPath(toObject, [\n            \"avgLogprobs\"\n        ], fromAvgLogprobs);\n    }\n    const fromGroundingMetadata = getValueByPath(fromObject, [\n        \"groundingMetadata\"\n    ]);\n    if (fromGroundingMetadata != null) {\n        setValueByPath(toObject, [\n            \"groundingMetadata\"\n        ], fromGroundingMetadata);\n    }\n    const fromIndex = getValueByPath(fromObject, [\n        \"index\"\n    ]);\n    if (fromIndex != null) {\n        setValueByPath(toObject, [\n            \"index\"\n        ], fromIndex);\n    }\n    const fromLogprobsResult = getValueByPath(fromObject, [\n        \"logprobsResult\"\n    ]);\n    if (fromLogprobsResult != null) {\n        setValueByPath(toObject, [\n            \"logprobsResult\"\n        ], fromLogprobsResult);\n    }\n    const fromSafetyRatings = getValueByPath(fromObject, [\n        \"safetyRatings\"\n    ]);\n    if (fromSafetyRatings != null) {\n        let transformedList = fromSafetyRatings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"safetyRatings\"\n        ], transformedList);\n    }\n    const fromUrlContextMetadata = getValueByPath(fromObject, [\n        \"urlContextMetadata\"\n    ]);\n    if (fromUrlContextMetadata != null) {\n        setValueByPath(toObject, [\n            \"urlContextMetadata\"\n        ], fromUrlContextMetadata);\n    }\n    return toObject;\n}\nfunction citationMetadataFromMldev(fromObject) {\n    const toObject = {};\n    const fromCitations = getValueByPath(fromObject, [\n        \"citationSources\"\n    ]);\n    if (fromCitations != null) {\n        let transformedList = fromCitations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"citations\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction computeTokensParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction computeTokensResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromTokensInfo = getValueByPath(fromObject, [\n        \"tokensInfo\"\n    ]);\n    if (fromTokensInfo != null) {\n        let transformedList = fromTokensInfo;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"tokensInfo\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction contentEmbeddingFromVertex(fromObject) {\n    const toObject = {};\n    const fromValues = getValueByPath(fromObject, [\n        \"values\"\n    ]);\n    if (fromValues != null) {\n        setValueByPath(toObject, [\n            \"values\"\n        ], fromValues);\n    }\n    const fromStatistics = getValueByPath(fromObject, [\n        \"statistics\"\n    ]);\n    if (fromStatistics != null) {\n        setValueByPath(toObject, [\n            \"statistics\"\n        ], contentEmbeddingStatisticsFromVertex(fromStatistics));\n    }\n    return toObject;\n}\nfunction contentEmbeddingStatisticsFromVertex(fromObject) {\n    const toObject = {};\n    const fromTruncated = getValueByPath(fromObject, [\n        \"truncated\"\n    ]);\n    if (fromTruncated != null) {\n        setValueByPath(toObject, [\n            \"truncated\"\n        ], fromTruncated);\n    }\n    const fromTokenCount = getValueByPath(fromObject, [\n        \"token_count\"\n    ]);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, [\n            \"tokenCount\"\n        ], fromTokenCount);\n    }\n    return toObject;\n}\nfunction contentToMldev$1(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partToMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction controlReferenceConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromControlType = getValueByPath(fromObject, [\n        \"controlType\"\n    ]);\n    if (fromControlType != null) {\n        setValueByPath(toObject, [\n            \"controlType\"\n        ], fromControlType);\n    }\n    const fromEnableControlImageComputation = getValueByPath(fromObject, [\n        \"enableControlImageComputation\"\n    ]);\n    if (fromEnableControlImageComputation != null) {\n        setValueByPath(toObject, [\n            \"computeControl\"\n        ], fromEnableControlImageComputation);\n    }\n    return toObject;\n}\nfunction countTokensConfigToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]) !== undefined) {\n        throw new Error(\"systemInstruction parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"tools\"\n    ]) !== undefined) {\n        throw new Error(\"tools parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"generationConfig\"\n    ]) !== undefined) {\n        throw new Error(\"generationConfig parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction countTokensConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"systemInstruction\"\n        ], tContent(fromSystemInstruction));\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = fromTools;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToVertex(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"tools\"\n        ], transformedList);\n    }\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        \"generationConfig\"\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, [\n            \"generationConfig\"\n        ], generationConfigToVertex(fromGenerationConfig));\n    }\n    return toObject;\n}\nfunction countTokensParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentToMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        countTokensConfigToMldev(fromConfig);\n    }\n    return toObject;\n}\nfunction countTokensParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        countTokensConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction countTokensResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromTotalTokens = getValueByPath(fromObject, [\n        \"totalTokens\"\n    ]);\n    if (fromTotalTokens != null) {\n        setValueByPath(toObject, [\n            \"totalTokens\"\n        ], fromTotalTokens);\n    }\n    const fromCachedContentTokenCount = getValueByPath(fromObject, [\n        \"cachedContentTokenCount\"\n    ]);\n    if (fromCachedContentTokenCount != null) {\n        setValueByPath(toObject, [\n            \"cachedContentTokenCount\"\n        ], fromCachedContentTokenCount);\n    }\n    return toObject;\n}\nfunction countTokensResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromTotalTokens = getValueByPath(fromObject, [\n        \"totalTokens\"\n    ]);\n    if (fromTotalTokens != null) {\n        setValueByPath(toObject, [\n            \"totalTokens\"\n        ], fromTotalTokens);\n    }\n    return toObject;\n}\nfunction deleteModelParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tModel(apiClient, fromModel));\n    }\n    return toObject;\n}\nfunction deleteModelParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tModel(apiClient, fromModel));\n    }\n    return toObject;\n}\nfunction deleteModelResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction deleteModelResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction editImageConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromOutputGcsUri = getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"storageUri\"\n        ], fromOutputGcsUri);\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        \"negativePrompt\"\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"negativePrompt\"\n        ], fromNegativePrompt);\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        \"numberOfImages\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfImages);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    const fromGuidanceScale = getValueByPath(fromObject, [\n        \"guidanceScale\"\n    ]);\n    if (parentObject !== undefined && fromGuidanceScale != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"guidanceScale\"\n        ], fromGuidanceScale);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        \"safetyFilterLevel\"\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"safetySetting\"\n        ], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [\n        \"includeSafetyAttributes\"\n    ]);\n    if (parentObject !== undefined && fromIncludeSafetyAttributes != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeSafetyAttributes\"\n        ], fromIncludeSafetyAttributes);\n    }\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        \"includeRaiReason\"\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeRaiReason\"\n        ], fromIncludeRaiReason);\n    }\n    const fromLanguage = getValueByPath(fromObject, [\n        \"language\"\n    ]);\n    if (parentObject !== undefined && fromLanguage != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"language\"\n        ], fromLanguage);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        \"outputMimeType\"\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"mimeType\"\n        ], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        \"outputCompressionQuality\"\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"compressionQuality\"\n        ], fromOutputCompressionQuality);\n    }\n    const fromAddWatermark = getValueByPath(fromObject, [\n        \"addWatermark\"\n    ]);\n    if (parentObject !== undefined && fromAddWatermark != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"addWatermark\"\n        ], fromAddWatermark);\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    const fromEditMode = getValueByPath(fromObject, [\n        \"editMode\"\n    ]);\n    if (parentObject !== undefined && fromEditMode != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"editMode\"\n        ], fromEditMode);\n    }\n    const fromBaseSteps = getValueByPath(fromObject, [\n        \"baseSteps\"\n    ]);\n    if (parentObject !== undefined && fromBaseSteps != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"editConfig\",\n            \"baseSteps\"\n        ], fromBaseSteps);\n    }\n    return toObject;\n}\nfunction editImageParametersInternalToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromReferenceImages = getValueByPath(fromObject, [\n        \"referenceImages\"\n    ]);\n    if (fromReferenceImages != null) {\n        let transformedList = fromReferenceImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return referenceImageAPIInternalToVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"referenceImages\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        editImageConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction editImageResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        \"predictions\"\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedImageFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedImages\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction embedContentConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromTaskType = getValueByPath(fromObject, [\n        \"taskType\"\n    ]);\n    if (parentObject !== undefined && fromTaskType != null) {\n        setValueByPath(parentObject, [\n            \"requests[]\",\n            \"taskType\"\n        ], fromTaskType);\n    }\n    const fromTitle = getValueByPath(fromObject, [\n        \"title\"\n    ]);\n    if (parentObject !== undefined && fromTitle != null) {\n        setValueByPath(parentObject, [\n            \"requests[]\",\n            \"title\"\n        ], fromTitle);\n    }\n    const fromOutputDimensionality = getValueByPath(fromObject, [\n        \"outputDimensionality\"\n    ]);\n    if (parentObject !== undefined && fromOutputDimensionality != null) {\n        setValueByPath(parentObject, [\n            \"requests[]\",\n            \"outputDimensionality\"\n        ], fromOutputDimensionality);\n    }\n    if (getValueByPath(fromObject, [\n        \"mimeType\"\n    ]) !== undefined) {\n        throw new Error(\"mimeType parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"autoTruncate\"\n    ]) !== undefined) {\n        throw new Error(\"autoTruncate parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction embedContentConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromTaskType = getValueByPath(fromObject, [\n        \"taskType\"\n    ]);\n    if (parentObject !== undefined && fromTaskType != null) {\n        setValueByPath(parentObject, [\n            \"instances[]\",\n            \"task_type\"\n        ], fromTaskType);\n    }\n    const fromTitle = getValueByPath(fromObject, [\n        \"title\"\n    ]);\n    if (parentObject !== undefined && fromTitle != null) {\n        setValueByPath(parentObject, [\n            \"instances[]\",\n            \"title\"\n        ], fromTitle);\n    }\n    const fromOutputDimensionality = getValueByPath(fromObject, [\n        \"outputDimensionality\"\n    ]);\n    if (parentObject !== undefined && fromOutputDimensionality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputDimensionality\"\n        ], fromOutputDimensionality);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (parentObject !== undefined && fromMimeType != null) {\n        setValueByPath(parentObject, [\n            \"instances[]\",\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    const fromAutoTruncate = getValueByPath(fromObject, [\n        \"autoTruncate\"\n    ]);\n    if (parentObject !== undefined && fromAutoTruncate != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"autoTruncate\"\n        ], fromAutoTruncate);\n    }\n    return toObject;\n}\nfunction embedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContentsForEmbed(apiClient, fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"requests[]\",\n            \"content\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        embedContentConfigToMldev(fromConfig, toObject);\n    }\n    const fromModelForEmbedContent = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModelForEmbedContent !== undefined) {\n        setValueByPath(toObject, [\n            \"requests[]\",\n            \"model\"\n        ], tModel(apiClient, fromModelForEmbedContent));\n    }\n    return toObject;\n}\nfunction embedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContentsForEmbed(apiClient, fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"instances[]\",\n            \"content\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        embedContentConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction embedContentResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromEmbeddings = getValueByPath(fromObject, [\n        \"embeddings\"\n    ]);\n    if (fromEmbeddings != null) {\n        let transformedList = fromEmbeddings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"embeddings\"\n        ], transformedList);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    return toObject;\n}\nfunction embedContentResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromEmbeddings = getValueByPath(fromObject, [\n        \"predictions[]\",\n        \"embeddings\"\n    ]);\n    if (fromEmbeddings != null) {\n        let transformedList = fromEmbeddings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentEmbeddingFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"embeddings\"\n        ], transformedList);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    return toObject;\n}\nfunction endpointFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"endpoint\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDeployedModelId = getValueByPath(fromObject, [\n        \"deployedModelId\"\n    ]);\n    if (fromDeployedModelId != null) {\n        setValueByPath(toObject, [\n            \"deployedModelId\"\n        ], fromDeployedModelId);\n    }\n    return toObject;\n}\nfunction fileDataToMldev$1(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction functionCallToMldev$1(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, [\n        \"id\"\n    ]);\n    if (fromId != null) {\n        setValueByPath(toObject, [\n            \"id\"\n        ], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, [\n        \"args\"\n    ]);\n    if (fromArgs != null) {\n        setValueByPath(toObject, [\n            \"args\"\n        ], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    if (getValueByPath(fromObject, [\n        \"partialArgs\"\n    ]) !== undefined) {\n        throw new Error(\"partialArgs parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"willContinue\"\n    ]) !== undefined) {\n        throw new Error(\"willContinue parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction functionCallingConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromAllowedFunctionNames = getValueByPath(fromObject, [\n        \"allowedFunctionNames\"\n    ]);\n    if (fromAllowedFunctionNames != null) {\n        setValueByPath(toObject, [\n            \"allowedFunctionNames\"\n        ], fromAllowedFunctionNames);\n    }\n    if (getValueByPath(fromObject, [\n        \"streamFunctionCallArguments\"\n    ]) !== undefined) {\n        throw new Error(\"streamFunctionCallArguments parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction functionDeclarationToVertex(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"behavior\"\n    ]) !== undefined) {\n        throw new Error(\"behavior parameter is not supported in Vertex AI.\");\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, [\n        \"parameters\"\n    ]);\n    if (fromParameters != null) {\n        setValueByPath(toObject, [\n            \"parameters\"\n        ], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        \"parametersJsonSchema\"\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"parametersJsonSchema\"\n        ], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction generateContentConfigToMldev(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"systemInstruction\"\n        ], contentToMldev$1(tContent(fromSystemInstruction)));\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, [\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (fromTopP != null) {\n        setValueByPath(toObject, [\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (fromTopK != null) {\n        setValueByPath(toObject, [\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        \"candidateCount\"\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, [\n            \"candidateCount\"\n        ], fromCandidateCount);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, [\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        \"stopSequences\"\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, [\n            \"stopSequences\"\n        ], fromStopSequences);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        \"responseLogprobs\"\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, [\n            \"responseLogprobs\"\n        ], fromResponseLogprobs);\n    }\n    const fromLogprobs = getValueByPath(fromObject, [\n        \"logprobs\"\n    ]);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, [\n            \"logprobs\"\n        ], fromLogprobs);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        \"presencePenalty\"\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, [\n            \"presencePenalty\"\n        ], fromPresencePenalty);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        \"frequencyPenalty\"\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, [\n            \"frequencyPenalty\"\n        ], fromFrequencyPenalty);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (fromSeed != null) {\n        setValueByPath(toObject, [\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        \"responseMimeType\"\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, [\n            \"responseMimeType\"\n        ], fromResponseMimeType);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        \"responseSchema\"\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, [\n            \"responseSchema\"\n        ], tSchema(fromResponseSchema));\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    if (getValueByPath(fromObject, [\n        \"routingConfig\"\n    ]) !== undefined) {\n        throw new Error(\"routingConfig parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"modelSelectionConfig\"\n    ]) !== undefined) {\n        throw new Error(\"modelSelectionConfig parameter is not supported in Gemini API.\");\n    }\n    const fromSafetySettings = getValueByPath(fromObject, [\n        \"safetySettings\"\n    ]);\n    if (parentObject !== undefined && fromSafetySettings != null) {\n        let transformedList = fromSafetySettings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return safetySettingToMldev(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"safetySettings\"\n        ], transformedList);\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToMldev$1(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, [\n            \"tools\"\n        ], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, [\n        \"toolConfig\"\n    ]);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, [\n            \"toolConfig\"\n        ], toolConfigToMldev(fromToolConfig));\n    }\n    if (getValueByPath(fromObject, [\n        \"labels\"\n    ]) !== undefined) {\n        throw new Error(\"labels parameter is not supported in Gemini API.\");\n    }\n    const fromCachedContent = getValueByPath(fromObject, [\n        \"cachedContent\"\n    ]);\n    if (parentObject !== undefined && fromCachedContent != null) {\n        setValueByPath(parentObject, [\n            \"cachedContent\"\n        ], tCachedContentName(apiClient, fromCachedContent));\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, [\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, [\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, [\n            \"speechConfig\"\n        ], tSpeechConfig(fromSpeechConfig));\n    }\n    if (getValueByPath(fromObject, [\n        \"audioTimestamp\"\n    ]) !== undefined) {\n        throw new Error(\"audioTimestamp parameter is not supported in Gemini API.\");\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        \"thinkingConfig\"\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, [\n            \"thinkingConfig\"\n        ], fromThinkingConfig);\n    }\n    const fromImageConfig = getValueByPath(fromObject, [\n        \"imageConfig\"\n    ]);\n    if (fromImageConfig != null) {\n        setValueByPath(toObject, [\n            \"imageConfig\"\n        ], imageConfigToMldev(fromImageConfig));\n    }\n    return toObject;\n}\nfunction generateContentConfigToVertex(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"systemInstruction\"\n        ], tContent(fromSystemInstruction));\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, [\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (fromTopP != null) {\n        setValueByPath(toObject, [\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (fromTopK != null) {\n        setValueByPath(toObject, [\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        \"candidateCount\"\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, [\n            \"candidateCount\"\n        ], fromCandidateCount);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, [\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        \"stopSequences\"\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, [\n            \"stopSequences\"\n        ], fromStopSequences);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        \"responseLogprobs\"\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, [\n            \"responseLogprobs\"\n        ], fromResponseLogprobs);\n    }\n    const fromLogprobs = getValueByPath(fromObject, [\n        \"logprobs\"\n    ]);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, [\n            \"logprobs\"\n        ], fromLogprobs);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        \"presencePenalty\"\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, [\n            \"presencePenalty\"\n        ], fromPresencePenalty);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        \"frequencyPenalty\"\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, [\n            \"frequencyPenalty\"\n        ], fromFrequencyPenalty);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (fromSeed != null) {\n        setValueByPath(toObject, [\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        \"responseMimeType\"\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, [\n            \"responseMimeType\"\n        ], fromResponseMimeType);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        \"responseSchema\"\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, [\n            \"responseSchema\"\n        ], tSchema(fromResponseSchema));\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    const fromRoutingConfig = getValueByPath(fromObject, [\n        \"routingConfig\"\n    ]);\n    if (fromRoutingConfig != null) {\n        setValueByPath(toObject, [\n            \"routingConfig\"\n        ], fromRoutingConfig);\n    }\n    const fromModelSelectionConfig = getValueByPath(fromObject, [\n        \"modelSelectionConfig\"\n    ]);\n    if (fromModelSelectionConfig != null) {\n        setValueByPath(toObject, [\n            \"modelConfig\"\n        ], fromModelSelectionConfig);\n    }\n    const fromSafetySettings = getValueByPath(fromObject, [\n        \"safetySettings\"\n    ]);\n    if (parentObject !== undefined && fromSafetySettings != null) {\n        let transformedList = fromSafetySettings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(parentObject, [\n            \"safetySettings\"\n        ], transformedList);\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToVertex(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, [\n            \"tools\"\n        ], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, [\n        \"toolConfig\"\n    ]);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, [\n            \"toolConfig\"\n        ], fromToolConfig);\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    const fromCachedContent = getValueByPath(fromObject, [\n        \"cachedContent\"\n    ]);\n    if (parentObject !== undefined && fromCachedContent != null) {\n        setValueByPath(parentObject, [\n            \"cachedContent\"\n        ], tCachedContentName(apiClient, fromCachedContent));\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, [\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, [\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, [\n            \"speechConfig\"\n        ], speechConfigToVertex(tSpeechConfig(fromSpeechConfig)));\n    }\n    const fromAudioTimestamp = getValueByPath(fromObject, [\n        \"audioTimestamp\"\n    ]);\n    if (fromAudioTimestamp != null) {\n        setValueByPath(toObject, [\n            \"audioTimestamp\"\n        ], fromAudioTimestamp);\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        \"thinkingConfig\"\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, [\n            \"thinkingConfig\"\n        ], fromThinkingConfig);\n    }\n    const fromImageConfig = getValueByPath(fromObject, [\n        \"imageConfig\"\n    ]);\n    if (fromImageConfig != null) {\n        setValueByPath(toObject, [\n            \"imageConfig\"\n        ], imageConfigToVertex(fromImageConfig));\n    }\n    return toObject;\n}\nfunction generateContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentToMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"generationConfig\"\n        ], generateContentConfigToMldev(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction generateContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"generationConfig\"\n        ], generateContentConfigToVertex(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction generateContentResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromCandidates = getValueByPath(fromObject, [\n        \"candidates\"\n    ]);\n    if (fromCandidates != null) {\n        let transformedList = fromCandidates;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return candidateFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"candidates\"\n        ], transformedList);\n    }\n    const fromModelVersion = getValueByPath(fromObject, [\n        \"modelVersion\"\n    ]);\n    if (fromModelVersion != null) {\n        setValueByPath(toObject, [\n            \"modelVersion\"\n        ], fromModelVersion);\n    }\n    const fromPromptFeedback = getValueByPath(fromObject, [\n        \"promptFeedback\"\n    ]);\n    if (fromPromptFeedback != null) {\n        setValueByPath(toObject, [\n            \"promptFeedback\"\n        ], fromPromptFeedback);\n    }\n    const fromResponseId = getValueByPath(fromObject, [\n        \"responseId\"\n    ]);\n    if (fromResponseId != null) {\n        setValueByPath(toObject, [\n            \"responseId\"\n        ], fromResponseId);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        \"usageMetadata\"\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, [\n            \"usageMetadata\"\n        ], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction generateContentResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromCandidates = getValueByPath(fromObject, [\n        \"candidates\"\n    ]);\n    if (fromCandidates != null) {\n        let transformedList = fromCandidates;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"candidates\"\n        ], transformedList);\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromModelVersion = getValueByPath(fromObject, [\n        \"modelVersion\"\n    ]);\n    if (fromModelVersion != null) {\n        setValueByPath(toObject, [\n            \"modelVersion\"\n        ], fromModelVersion);\n    }\n    const fromPromptFeedback = getValueByPath(fromObject, [\n        \"promptFeedback\"\n    ]);\n    if (fromPromptFeedback != null) {\n        setValueByPath(toObject, [\n            \"promptFeedback\"\n        ], fromPromptFeedback);\n    }\n    const fromResponseId = getValueByPath(fromObject, [\n        \"responseId\"\n    ]);\n    if (fromResponseId != null) {\n        setValueByPath(toObject, [\n            \"responseId\"\n        ], fromResponseId);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        \"usageMetadata\"\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, [\n            \"usageMetadata\"\n        ], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction generateImagesConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]) !== undefined) {\n        throw new Error(\"outputGcsUri parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"negativePrompt\"\n    ]) !== undefined) {\n        throw new Error(\"negativePrompt parameter is not supported in Gemini API.\");\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        \"numberOfImages\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfImages);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    const fromGuidanceScale = getValueByPath(fromObject, [\n        \"guidanceScale\"\n    ]);\n    if (parentObject !== undefined && fromGuidanceScale != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"guidanceScale\"\n        ], fromGuidanceScale);\n    }\n    if (getValueByPath(fromObject, [\n        \"seed\"\n    ]) !== undefined) {\n        throw new Error(\"seed parameter is not supported in Gemini API.\");\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        \"safetyFilterLevel\"\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"safetySetting\"\n        ], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [\n        \"includeSafetyAttributes\"\n    ]);\n    if (parentObject !== undefined && fromIncludeSafetyAttributes != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeSafetyAttributes\"\n        ], fromIncludeSafetyAttributes);\n    }\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        \"includeRaiReason\"\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeRaiReason\"\n        ], fromIncludeRaiReason);\n    }\n    const fromLanguage = getValueByPath(fromObject, [\n        \"language\"\n    ]);\n    if (parentObject !== undefined && fromLanguage != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"language\"\n        ], fromLanguage);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        \"outputMimeType\"\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"mimeType\"\n        ], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        \"outputCompressionQuality\"\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"compressionQuality\"\n        ], fromOutputCompressionQuality);\n    }\n    if (getValueByPath(fromObject, [\n        \"addWatermark\"\n    ]) !== undefined) {\n        throw new Error(\"addWatermark parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"labels\"\n    ]) !== undefined) {\n        throw new Error(\"labels parameter is not supported in Gemini API.\");\n    }\n    const fromImageSize = getValueByPath(fromObject, [\n        \"imageSize\"\n    ]);\n    if (parentObject !== undefined && fromImageSize != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleImageSize\"\n        ], fromImageSize);\n    }\n    if (getValueByPath(fromObject, [\n        \"enhancePrompt\"\n    ]) !== undefined) {\n        throw new Error(\"enhancePrompt parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction generateImagesConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromOutputGcsUri = getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"storageUri\"\n        ], fromOutputGcsUri);\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        \"negativePrompt\"\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"negativePrompt\"\n        ], fromNegativePrompt);\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        \"numberOfImages\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfImages);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    const fromGuidanceScale = getValueByPath(fromObject, [\n        \"guidanceScale\"\n    ]);\n    if (parentObject !== undefined && fromGuidanceScale != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"guidanceScale\"\n        ], fromGuidanceScale);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        \"safetyFilterLevel\"\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"safetySetting\"\n        ], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [\n        \"includeSafetyAttributes\"\n    ]);\n    if (parentObject !== undefined && fromIncludeSafetyAttributes != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeSafetyAttributes\"\n        ], fromIncludeSafetyAttributes);\n    }\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        \"includeRaiReason\"\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeRaiReason\"\n        ], fromIncludeRaiReason);\n    }\n    const fromLanguage = getValueByPath(fromObject, [\n        \"language\"\n    ]);\n    if (parentObject !== undefined && fromLanguage != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"language\"\n        ], fromLanguage);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        \"outputMimeType\"\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"mimeType\"\n        ], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        \"outputCompressionQuality\"\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"compressionQuality\"\n        ], fromOutputCompressionQuality);\n    }\n    const fromAddWatermark = getValueByPath(fromObject, [\n        \"addWatermark\"\n    ]);\n    if (parentObject !== undefined && fromAddWatermark != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"addWatermark\"\n        ], fromAddWatermark);\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    const fromImageSize = getValueByPath(fromObject, [\n        \"imageSize\"\n    ]);\n    if (parentObject !== undefined && fromImageSize != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleImageSize\"\n        ], fromImageSize);\n    }\n    const fromEnhancePrompt = getValueByPath(fromObject, [\n        \"enhancePrompt\"\n    ]);\n    if (parentObject !== undefined && fromEnhancePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"enhancePrompt\"\n        ], fromEnhancePrompt);\n    }\n    return toObject;\n}\nfunction generateImagesParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        generateImagesConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction generateImagesParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        generateImagesConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction generateImagesResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        \"predictions\"\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedImageFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedImages\"\n        ], transformedList);\n    }\n    const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [\n        \"positivePromptSafetyAttributes\"\n    ]);\n    if (fromPositivePromptSafetyAttributes != null) {\n        setValueByPath(toObject, [\n            \"positivePromptSafetyAttributes\"\n        ], safetyAttributesFromMldev(fromPositivePromptSafetyAttributes));\n    }\n    return toObject;\n}\nfunction generateImagesResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        \"predictions\"\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedImageFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedImages\"\n        ], transformedList);\n    }\n    const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [\n        \"positivePromptSafetyAttributes\"\n    ]);\n    if (fromPositivePromptSafetyAttributes != null) {\n        setValueByPath(toObject, [\n            \"positivePromptSafetyAttributes\"\n        ], safetyAttributesFromVertex(fromPositivePromptSafetyAttributes));\n    }\n    return toObject;\n}\nfunction generateVideosConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromNumberOfVideos = getValueByPath(fromObject, [\n        \"numberOfVideos\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfVideos != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfVideos);\n    }\n    if (getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]) !== undefined) {\n        throw new Error(\"outputGcsUri parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"fps\"\n    ]) !== undefined) {\n        throw new Error(\"fps parameter is not supported in Gemini API.\");\n    }\n    const fromDurationSeconds = getValueByPath(fromObject, [\n        \"durationSeconds\"\n    ]);\n    if (parentObject !== undefined && fromDurationSeconds != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"durationSeconds\"\n        ], fromDurationSeconds);\n    }\n    if (getValueByPath(fromObject, [\n        \"seed\"\n    ]) !== undefined) {\n        throw new Error(\"seed parameter is not supported in Gemini API.\");\n    }\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    const fromResolution = getValueByPath(fromObject, [\n        \"resolution\"\n    ]);\n    if (parentObject !== undefined && fromResolution != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"resolution\"\n        ], fromResolution);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    if (getValueByPath(fromObject, [\n        \"pubsubTopic\"\n    ]) !== undefined) {\n        throw new Error(\"pubsubTopic parameter is not supported in Gemini API.\");\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        \"negativePrompt\"\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"negativePrompt\"\n        ], fromNegativePrompt);\n    }\n    const fromEnhancePrompt = getValueByPath(fromObject, [\n        \"enhancePrompt\"\n    ]);\n    if (parentObject !== undefined && fromEnhancePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"enhancePrompt\"\n        ], fromEnhancePrompt);\n    }\n    if (getValueByPath(fromObject, [\n        \"generateAudio\"\n    ]) !== undefined) {\n        throw new Error(\"generateAudio parameter is not supported in Gemini API.\");\n    }\n    const fromLastFrame = getValueByPath(fromObject, [\n        \"lastFrame\"\n    ]);\n    if (parentObject !== undefined && fromLastFrame != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"lastFrame\"\n        ], imageToMldev(fromLastFrame));\n    }\n    const fromReferenceImages = getValueByPath(fromObject, [\n        \"referenceImages\"\n    ]);\n    if (parentObject !== undefined && fromReferenceImages != null) {\n        let transformedList = fromReferenceImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return videoGenerationReferenceImageToMldev(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"referenceImages\"\n        ], transformedList);\n    }\n    if (getValueByPath(fromObject, [\n        \"mask\"\n    ]) !== undefined) {\n        throw new Error(\"mask parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"compressionQuality\"\n    ]) !== undefined) {\n        throw new Error(\"compressionQuality parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction generateVideosConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromNumberOfVideos = getValueByPath(fromObject, [\n        \"numberOfVideos\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfVideos != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfVideos);\n    }\n    const fromOutputGcsUri = getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"storageUri\"\n        ], fromOutputGcsUri);\n    }\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (parentObject !== undefined && fromFps != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"fps\"\n        ], fromFps);\n    }\n    const fromDurationSeconds = getValueByPath(fromObject, [\n        \"durationSeconds\"\n    ]);\n    if (parentObject !== undefined && fromDurationSeconds != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"durationSeconds\"\n        ], fromDurationSeconds);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    const fromResolution = getValueByPath(fromObject, [\n        \"resolution\"\n    ]);\n    if (parentObject !== undefined && fromResolution != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"resolution\"\n        ], fromResolution);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    const fromPubsubTopic = getValueByPath(fromObject, [\n        \"pubsubTopic\"\n    ]);\n    if (parentObject !== undefined && fromPubsubTopic != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"pubsubTopic\"\n        ], fromPubsubTopic);\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        \"negativePrompt\"\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"negativePrompt\"\n        ], fromNegativePrompt);\n    }\n    const fromEnhancePrompt = getValueByPath(fromObject, [\n        \"enhancePrompt\"\n    ]);\n    if (parentObject !== undefined && fromEnhancePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"enhancePrompt\"\n        ], fromEnhancePrompt);\n    }\n    const fromGenerateAudio = getValueByPath(fromObject, [\n        \"generateAudio\"\n    ]);\n    if (parentObject !== undefined && fromGenerateAudio != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"generateAudio\"\n        ], fromGenerateAudio);\n    }\n    const fromLastFrame = getValueByPath(fromObject, [\n        \"lastFrame\"\n    ]);\n    if (parentObject !== undefined && fromLastFrame != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"lastFrame\"\n        ], imageToVertex(fromLastFrame));\n    }\n    const fromReferenceImages = getValueByPath(fromObject, [\n        \"referenceImages\"\n    ]);\n    if (parentObject !== undefined && fromReferenceImages != null) {\n        let transformedList = fromReferenceImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return videoGenerationReferenceImageToVertex(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"referenceImages\"\n        ], transformedList);\n    }\n    const fromMask = getValueByPath(fromObject, [\n        \"mask\"\n    ]);\n    if (parentObject !== undefined && fromMask != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"mask\"\n        ], videoGenerationMaskToVertex(fromMask));\n    }\n    const fromCompressionQuality = getValueByPath(fromObject, [\n        \"compressionQuality\"\n    ]);\n    if (parentObject !== undefined && fromCompressionQuality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"compressionQuality\"\n        ], fromCompressionQuality);\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\",\n        \"generateVideoResponse\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], generateVideosResponseFromMldev(fromResponse));\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], generateVideosResponseFromVertex(fromResponse));\n    }\n    return toObject;\n}\nfunction generateVideosParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"image\"\n        ], imageToMldev(fromImage));\n    }\n    const fromVideo = getValueByPath(fromObject, [\n        \"video\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"video\"\n        ], videoToMldev(fromVideo));\n    }\n    const fromSource = getValueByPath(fromObject, [\n        \"source\"\n    ]);\n    if (fromSource != null) {\n        generateVideosSourceToMldev(fromSource, toObject);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        generateVideosConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction generateVideosParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"image\"\n        ], imageToVertex(fromImage));\n    }\n    const fromVideo = getValueByPath(fromObject, [\n        \"video\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"video\"\n        ], videoToVertex(fromVideo));\n    }\n    const fromSource = getValueByPath(fromObject, [\n        \"source\"\n    ]);\n    if (fromSource != null) {\n        generateVideosSourceToVertex(fromSource, toObject);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        generateVideosConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, [\n        \"generatedSamples\"\n    ]);\n    if (fromGeneratedVideos != null) {\n        let transformedList = fromGeneratedVideos;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedVideoFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedVideos\"\n        ], transformedList);\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        \"raiMediaFilteredCount\"\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredCount\"\n        ], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        \"raiMediaFilteredReasons\"\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredReasons\"\n        ], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, [\n        \"videos\"\n    ]);\n    if (fromGeneratedVideos != null) {\n        let transformedList = fromGeneratedVideos;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedVideoFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedVideos\"\n        ], transformedList);\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        \"raiMediaFilteredCount\"\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredCount\"\n        ], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        \"raiMediaFilteredReasons\"\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredReasons\"\n        ], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generateVideosSourceToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (parentObject !== undefined && fromPrompt != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (parentObject !== undefined && fromImage != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"image\"\n        ], imageToMldev(fromImage));\n    }\n    const fromVideo = getValueByPath(fromObject, [\n        \"video\"\n    ]);\n    if (parentObject !== undefined && fromVideo != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"video\"\n        ], videoToMldev(fromVideo));\n    }\n    return toObject;\n}\nfunction generateVideosSourceToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (parentObject !== undefined && fromPrompt != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (parentObject !== undefined && fromImage != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"image\"\n        ], imageToVertex(fromImage));\n    }\n    const fromVideo = getValueByPath(fromObject, [\n        \"video\"\n    ]);\n    if (parentObject !== undefined && fromVideo != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"video\"\n        ], videoToVertex(fromVideo));\n    }\n    return toObject;\n}\nfunction generatedImageFromMldev(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"image\"\n        ], imageFromMldev(fromImage));\n    }\n    const fromRaiFilteredReason = getValueByPath(fromObject, [\n        \"raiFilteredReason\"\n    ]);\n    if (fromRaiFilteredReason != null) {\n        setValueByPath(toObject, [\n            \"raiFilteredReason\"\n        ], fromRaiFilteredReason);\n    }\n    const fromSafetyAttributes = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromSafetyAttributes != null) {\n        setValueByPath(toObject, [\n            \"safetyAttributes\"\n        ], safetyAttributesFromMldev(fromSafetyAttributes));\n    }\n    return toObject;\n}\nfunction generatedImageFromVertex(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"image\"\n        ], imageFromVertex(fromImage));\n    }\n    const fromRaiFilteredReason = getValueByPath(fromObject, [\n        \"raiFilteredReason\"\n    ]);\n    if (fromRaiFilteredReason != null) {\n        setValueByPath(toObject, [\n            \"raiFilteredReason\"\n        ], fromRaiFilteredReason);\n    }\n    const fromSafetyAttributes = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromSafetyAttributes != null) {\n        setValueByPath(toObject, [\n            \"safetyAttributes\"\n        ], safetyAttributesFromVertex(fromSafetyAttributes));\n    }\n    const fromEnhancedPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (fromEnhancedPrompt != null) {\n        setValueByPath(toObject, [\n            \"enhancedPrompt\"\n        ], fromEnhancedPrompt);\n    }\n    return toObject;\n}\nfunction generatedImageMaskFromVertex(fromObject) {\n    const toObject = {};\n    const fromMask = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromMask != null) {\n        setValueByPath(toObject, [\n            \"mask\"\n        ], imageFromVertex(fromMask));\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (fromLabels != null) {\n        let transformedList = fromLabels;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"labels\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction generatedVideoFromMldev(fromObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, [\n        \"video\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"video\"\n        ], videoFromMldev(fromVideo));\n    }\n    return toObject;\n}\nfunction generatedVideoFromVertex(fromObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"video\"\n        ], videoFromVertex(fromVideo));\n    }\n    return toObject;\n}\nfunction generationConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromModelSelectionConfig = getValueByPath(fromObject, [\n        \"modelSelectionConfig\"\n    ]);\n    if (fromModelSelectionConfig != null) {\n        setValueByPath(toObject, [\n            \"modelConfig\"\n        ], fromModelSelectionConfig);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    const fromAudioTimestamp = getValueByPath(fromObject, [\n        \"audioTimestamp\"\n    ]);\n    if (fromAudioTimestamp != null) {\n        setValueByPath(toObject, [\n            \"audioTimestamp\"\n        ], fromAudioTimestamp);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        \"candidateCount\"\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, [\n            \"candidateCount\"\n        ], fromCandidateCount);\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        \"enableAffectiveDialog\"\n    ]);\n    if (fromEnableAffectiveDialog != null) {\n        setValueByPath(toObject, [\n            \"enableAffectiveDialog\"\n        ], fromEnableAffectiveDialog);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        \"frequencyPenalty\"\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, [\n            \"frequencyPenalty\"\n        ], fromFrequencyPenalty);\n    }\n    const fromLogprobs = getValueByPath(fromObject, [\n        \"logprobs\"\n    ]);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, [\n            \"logprobs\"\n        ], fromLogprobs);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, [\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, [\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        \"presencePenalty\"\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, [\n            \"presencePenalty\"\n        ], fromPresencePenalty);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        \"responseLogprobs\"\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, [\n            \"responseLogprobs\"\n        ], fromResponseLogprobs);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        \"responseMimeType\"\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, [\n            \"responseMimeType\"\n        ], fromResponseMimeType);\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, [\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        \"responseSchema\"\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, [\n            \"responseSchema\"\n        ], fromResponseSchema);\n    }\n    const fromRoutingConfig = getValueByPath(fromObject, [\n        \"routingConfig\"\n    ]);\n    if (fromRoutingConfig != null) {\n        setValueByPath(toObject, [\n            \"routingConfig\"\n        ], fromRoutingConfig);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (fromSeed != null) {\n        setValueByPath(toObject, [\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, [\n            \"speechConfig\"\n        ], speechConfigToVertex(fromSpeechConfig));\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        \"stopSequences\"\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, [\n            \"stopSequences\"\n        ], fromStopSequences);\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, [\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        \"thinkingConfig\"\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, [\n            \"thinkingConfig\"\n        ], fromThinkingConfig);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (fromTopK != null) {\n        setValueByPath(toObject, [\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (fromTopP != null) {\n        setValueByPath(toObject, [\n            \"topP\"\n        ], fromTopP);\n    }\n    if (getValueByPath(fromObject, [\n        \"enableEnhancedCivicAnswers\"\n    ]) !== undefined) {\n        throw new Error(\"enableEnhancedCivicAnswers parameter is not supported in Vertex AI.\");\n    }\n    return toObject;\n}\nfunction getModelParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tModel(apiClient, fromModel));\n    }\n    return toObject;\n}\nfunction getModelParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tModel(apiClient, fromModel));\n    }\n    return toObject;\n}\nfunction googleMapsToMldev$1(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"authConfig\"\n    ]) !== undefined) {\n        throw new Error(\"authConfig parameter is not supported in Gemini API.\");\n    }\n    const fromEnableWidget = getValueByPath(fromObject, [\n        \"enableWidget\"\n    ]);\n    if (fromEnableWidget != null) {\n        setValueByPath(toObject, [\n            \"enableWidget\"\n        ], fromEnableWidget);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$1(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"excludeDomains\"\n    ]) !== undefined) {\n        throw new Error(\"excludeDomains parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"blockingConfidence\"\n    ]) !== undefined) {\n        throw new Error(\"blockingConfidence parameter is not supported in Gemini API.\");\n    }\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        \"timeRangeFilter\"\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, [\n            \"timeRangeFilter\"\n        ], fromTimeRangeFilter);\n    }\n    return toObject;\n}\nfunction imageConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (fromAspectRatio != null) {\n        setValueByPath(toObject, [\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    const fromImageSize = getValueByPath(fromObject, [\n        \"imageSize\"\n    ]);\n    if (fromImageSize != null) {\n        setValueByPath(toObject, [\n            \"imageSize\"\n        ], fromImageSize);\n    }\n    if (getValueByPath(fromObject, [\n        \"outputMimeType\"\n    ]) !== undefined) {\n        throw new Error(\"outputMimeType parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"outputCompressionQuality\"\n    ]) !== undefined) {\n        throw new Error(\"outputCompressionQuality parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction imageConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (fromAspectRatio != null) {\n        setValueByPath(toObject, [\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    const fromImageSize = getValueByPath(fromObject, [\n        \"imageSize\"\n    ]);\n    if (fromImageSize != null) {\n        setValueByPath(toObject, [\n            \"imageSize\"\n        ], fromImageSize);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        \"outputMimeType\"\n    ]);\n    if (fromOutputMimeType != null) {\n        setValueByPath(toObject, [\n            \"imageOutputOptions\",\n            \"mimeType\"\n        ], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        \"outputCompressionQuality\"\n    ]);\n    if (fromOutputCompressionQuality != null) {\n        setValueByPath(toObject, [\n            \"imageOutputOptions\",\n            \"compressionQuality\"\n        ], fromOutputCompressionQuality);\n    }\n    return toObject;\n}\nfunction imageFromMldev(fromObject) {\n    const toObject = {};\n    const fromImageBytes = getValueByPath(fromObject, [\n        \"bytesBase64Encoded\"\n    ]);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, [\n            \"imageBytes\"\n        ], tBytes(fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction imageFromVertex(fromObject) {\n    const toObject = {};\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"gcsUri\"\n        ], fromGcsUri);\n    }\n    const fromImageBytes = getValueByPath(fromObject, [\n        \"bytesBase64Encoded\"\n    ]);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, [\n            \"imageBytes\"\n        ], tBytes(fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction imageToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]) !== undefined) {\n        throw new Error(\"gcsUri parameter is not supported in Gemini API.\");\n    }\n    const fromImageBytes = getValueByPath(fromObject, [\n        \"imageBytes\"\n    ]);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, [\n            \"bytesBase64Encoded\"\n        ], tBytes(fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction imageToVertex(fromObject) {\n    const toObject = {};\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"gcsUri\"\n        ], fromGcsUri);\n    }\n    const fromImageBytes = getValueByPath(fromObject, [\n        \"imageBytes\"\n    ]);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, [\n            \"bytesBase64Encoded\"\n        ], tBytes(fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction listModelsConfigToMldev(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, [\n        \"filter\"\n    ]);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"filter\"\n        ], fromFilter);\n    }\n    const fromQueryBase = getValueByPath(fromObject, [\n        \"queryBase\"\n    ]);\n    if (parentObject !== undefined && fromQueryBase != null) {\n        setValueByPath(parentObject, [\n            \"_url\",\n            \"models_url\"\n        ], tModelsUrl(apiClient, fromQueryBase));\n    }\n    return toObject;\n}\nfunction listModelsConfigToVertex(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, [\n        \"filter\"\n    ]);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"filter\"\n        ], fromFilter);\n    }\n    const fromQueryBase = getValueByPath(fromObject, [\n        \"queryBase\"\n    ]);\n    if (parentObject !== undefined && fromQueryBase != null) {\n        setValueByPath(parentObject, [\n            \"_url\",\n            \"models_url\"\n        ], tModelsUrl(apiClient, fromQueryBase));\n    }\n    return toObject;\n}\nfunction listModelsParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listModelsConfigToMldev(apiClient, fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listModelsParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listModelsConfigToVertex(apiClient, fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listModelsResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromModels = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromModels != null) {\n        let transformedList = tExtractModels(fromModels);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return modelFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"models\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction listModelsResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromModels = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromModels != null) {\n        let transformedList = tExtractModels(fromModels);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return modelFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"models\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction maskReferenceConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromMaskMode = getValueByPath(fromObject, [\n        \"maskMode\"\n    ]);\n    if (fromMaskMode != null) {\n        setValueByPath(toObject, [\n            \"maskMode\"\n        ], fromMaskMode);\n    }\n    const fromSegmentationClasses = getValueByPath(fromObject, [\n        \"segmentationClasses\"\n    ]);\n    if (fromSegmentationClasses != null) {\n        setValueByPath(toObject, [\n            \"maskClasses\"\n        ], fromSegmentationClasses);\n    }\n    const fromMaskDilation = getValueByPath(fromObject, [\n        \"maskDilation\"\n    ]);\n    if (fromMaskDilation != null) {\n        setValueByPath(toObject, [\n            \"dilation\"\n        ], fromMaskDilation);\n    }\n    return toObject;\n}\nfunction modelFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromVersion = getValueByPath(fromObject, [\n        \"version\"\n    ]);\n    if (fromVersion != null) {\n        setValueByPath(toObject, [\n            \"version\"\n        ], fromVersion);\n    }\n    const fromTunedModelInfo = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromTunedModelInfo != null) {\n        setValueByPath(toObject, [\n            \"tunedModelInfo\"\n        ], tunedModelInfoFromMldev(fromTunedModelInfo));\n    }\n    const fromInputTokenLimit = getValueByPath(fromObject, [\n        \"inputTokenLimit\"\n    ]);\n    if (fromInputTokenLimit != null) {\n        setValueByPath(toObject, [\n            \"inputTokenLimit\"\n        ], fromInputTokenLimit);\n    }\n    const fromOutputTokenLimit = getValueByPath(fromObject, [\n        \"outputTokenLimit\"\n    ]);\n    if (fromOutputTokenLimit != null) {\n        setValueByPath(toObject, [\n            \"outputTokenLimit\"\n        ], fromOutputTokenLimit);\n    }\n    const fromSupportedActions = getValueByPath(fromObject, [\n        \"supportedGenerationMethods\"\n    ]);\n    if (fromSupportedActions != null) {\n        setValueByPath(toObject, [\n            \"supportedActions\"\n        ], fromSupportedActions);\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, [\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromMaxTemperature = getValueByPath(fromObject, [\n        \"maxTemperature\"\n    ]);\n    if (fromMaxTemperature != null) {\n        setValueByPath(toObject, [\n            \"maxTemperature\"\n        ], fromMaxTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (fromTopP != null) {\n        setValueByPath(toObject, [\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (fromTopK != null) {\n        setValueByPath(toObject, [\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromThinking = getValueByPath(fromObject, [\n        \"thinking\"\n    ]);\n    if (fromThinking != null) {\n        setValueByPath(toObject, [\n            \"thinking\"\n        ], fromThinking);\n    }\n    return toObject;\n}\nfunction modelFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromVersion = getValueByPath(fromObject, [\n        \"versionId\"\n    ]);\n    if (fromVersion != null) {\n        setValueByPath(toObject, [\n            \"version\"\n        ], fromVersion);\n    }\n    const fromEndpoints = getValueByPath(fromObject, [\n        \"deployedModels\"\n    ]);\n    if (fromEndpoints != null) {\n        let transformedList = fromEndpoints;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return endpointFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"endpoints\"\n        ], transformedList);\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (fromLabels != null) {\n        setValueByPath(toObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    const fromTunedModelInfo = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromTunedModelInfo != null) {\n        setValueByPath(toObject, [\n            \"tunedModelInfo\"\n        ], tunedModelInfoFromVertex(fromTunedModelInfo));\n    }\n    const fromDefaultCheckpointId = getValueByPath(fromObject, [\n        \"defaultCheckpointId\"\n    ]);\n    if (fromDefaultCheckpointId != null) {\n        setValueByPath(toObject, [\n            \"defaultCheckpointId\"\n        ], fromDefaultCheckpointId);\n    }\n    const fromCheckpoints = getValueByPath(fromObject, [\n        \"checkpoints\"\n    ]);\n    if (fromCheckpoints != null) {\n        let transformedList = fromCheckpoints;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"checkpoints\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction partToMldev$1(fromObject) {\n    const toObject = {};\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, [\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataToMldev$1(fromFileData));\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], functionCallToMldev$1(fromFunctionCall));\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobToMldev$1(fromInlineData));\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], fromVideoMetadata);\n    }\n    return toObject;\n}\nfunction productImageToVertex(fromObject) {\n    const toObject = {};\n    const fromProductImage = getValueByPath(fromObject, [\n        \"productImage\"\n    ]);\n    if (fromProductImage != null) {\n        setValueByPath(toObject, [\n            \"image\"\n        ], imageToVertex(fromProductImage));\n    }\n    return toObject;\n}\nfunction recontextImageConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        \"numberOfImages\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfImages);\n    }\n    const fromBaseSteps = getValueByPath(fromObject, [\n        \"baseSteps\"\n    ]);\n    if (parentObject !== undefined && fromBaseSteps != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"baseSteps\"\n        ], fromBaseSteps);\n    }\n    const fromOutputGcsUri = getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"storageUri\"\n        ], fromOutputGcsUri);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        \"safetyFilterLevel\"\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"safetySetting\"\n        ], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    const fromAddWatermark = getValueByPath(fromObject, [\n        \"addWatermark\"\n    ]);\n    if (parentObject !== undefined && fromAddWatermark != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"addWatermark\"\n        ], fromAddWatermark);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        \"outputMimeType\"\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"mimeType\"\n        ], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        \"outputCompressionQuality\"\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"compressionQuality\"\n        ], fromOutputCompressionQuality);\n    }\n    const fromEnhancePrompt = getValueByPath(fromObject, [\n        \"enhancePrompt\"\n    ]);\n    if (parentObject !== undefined && fromEnhancePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"enhancePrompt\"\n        ], fromEnhancePrompt);\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    return toObject;\n}\nfunction recontextImageParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromSource = getValueByPath(fromObject, [\n        \"source\"\n    ]);\n    if (fromSource != null) {\n        recontextImageSourceToVertex(fromSource, toObject);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        recontextImageConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction recontextImageResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        \"predictions\"\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedImageFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedImages\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction recontextImageSourceToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (parentObject !== undefined && fromPrompt != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromPersonImage = getValueByPath(fromObject, [\n        \"personImage\"\n    ]);\n    if (parentObject !== undefined && fromPersonImage != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"personImage\",\n            \"image\"\n        ], imageToVertex(fromPersonImage));\n    }\n    const fromProductImages = getValueByPath(fromObject, [\n        \"productImages\"\n    ]);\n    if (parentObject !== undefined && fromProductImages != null) {\n        let transformedList = fromProductImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return productImageToVertex(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"productImages\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction referenceImageAPIInternalToVertex(fromObject) {\n    const toObject = {};\n    const fromReferenceImage = getValueByPath(fromObject, [\n        \"referenceImage\"\n    ]);\n    if (fromReferenceImage != null) {\n        setValueByPath(toObject, [\n            \"referenceImage\"\n        ], imageToVertex(fromReferenceImage));\n    }\n    const fromReferenceId = getValueByPath(fromObject, [\n        \"referenceId\"\n    ]);\n    if (fromReferenceId != null) {\n        setValueByPath(toObject, [\n            \"referenceId\"\n        ], fromReferenceId);\n    }\n    const fromReferenceType = getValueByPath(fromObject, [\n        \"referenceType\"\n    ]);\n    if (fromReferenceType != null) {\n        setValueByPath(toObject, [\n            \"referenceType\"\n        ], fromReferenceType);\n    }\n    const fromMaskImageConfig = getValueByPath(fromObject, [\n        \"maskImageConfig\"\n    ]);\n    if (fromMaskImageConfig != null) {\n        setValueByPath(toObject, [\n            \"maskImageConfig\"\n        ], maskReferenceConfigToVertex(fromMaskImageConfig));\n    }\n    const fromControlImageConfig = getValueByPath(fromObject, [\n        \"controlImageConfig\"\n    ]);\n    if (fromControlImageConfig != null) {\n        setValueByPath(toObject, [\n            \"controlImageConfig\"\n        ], controlReferenceConfigToVertex(fromControlImageConfig));\n    }\n    const fromStyleImageConfig = getValueByPath(fromObject, [\n        \"styleImageConfig\"\n    ]);\n    if (fromStyleImageConfig != null) {\n        setValueByPath(toObject, [\n            \"styleImageConfig\"\n        ], fromStyleImageConfig);\n    }\n    const fromSubjectImageConfig = getValueByPath(fromObject, [\n        \"subjectImageConfig\"\n    ]);\n    if (fromSubjectImageConfig != null) {\n        setValueByPath(toObject, [\n            \"subjectImageConfig\"\n        ], fromSubjectImageConfig);\n    }\n    return toObject;\n}\nfunction safetyAttributesFromMldev(fromObject) {\n    const toObject = {};\n    const fromCategories = getValueByPath(fromObject, [\n        \"safetyAttributes\",\n        \"categories\"\n    ]);\n    if (fromCategories != null) {\n        setValueByPath(toObject, [\n            \"categories\"\n        ], fromCategories);\n    }\n    const fromScores = getValueByPath(fromObject, [\n        \"safetyAttributes\",\n        \"scores\"\n    ]);\n    if (fromScores != null) {\n        setValueByPath(toObject, [\n            \"scores\"\n        ], fromScores);\n    }\n    const fromContentType = getValueByPath(fromObject, [\n        \"contentType\"\n    ]);\n    if (fromContentType != null) {\n        setValueByPath(toObject, [\n            \"contentType\"\n        ], fromContentType);\n    }\n    return toObject;\n}\nfunction safetyAttributesFromVertex(fromObject) {\n    const toObject = {};\n    const fromCategories = getValueByPath(fromObject, [\n        \"safetyAttributes\",\n        \"categories\"\n    ]);\n    if (fromCategories != null) {\n        setValueByPath(toObject, [\n            \"categories\"\n        ], fromCategories);\n    }\n    const fromScores = getValueByPath(fromObject, [\n        \"safetyAttributes\",\n        \"scores\"\n    ]);\n    if (fromScores != null) {\n        setValueByPath(toObject, [\n            \"scores\"\n        ], fromScores);\n    }\n    const fromContentType = getValueByPath(fromObject, [\n        \"contentType\"\n    ]);\n    if (fromContentType != null) {\n        setValueByPath(toObject, [\n            \"contentType\"\n        ], fromContentType);\n    }\n    return toObject;\n}\nfunction safetySettingToMldev(fromObject) {\n    const toObject = {};\n    const fromCategory = getValueByPath(fromObject, [\n        \"category\"\n    ]);\n    if (fromCategory != null) {\n        setValueByPath(toObject, [\n            \"category\"\n        ], fromCategory);\n    }\n    if (getValueByPath(fromObject, [\n        \"method\"\n    ]) !== undefined) {\n        throw new Error(\"method parameter is not supported in Gemini API.\");\n    }\n    const fromThreshold = getValueByPath(fromObject, [\n        \"threshold\"\n    ]);\n    if (fromThreshold != null) {\n        setValueByPath(toObject, [\n            \"threshold\"\n        ], fromThreshold);\n    }\n    return toObject;\n}\nfunction scribbleImageToVertex(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"image\"\n        ], imageToVertex(fromImage));\n    }\n    return toObject;\n}\nfunction segmentImageConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (parentObject !== undefined && fromMode != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"mode\"\n        ], fromMode);\n    }\n    const fromMaxPredictions = getValueByPath(fromObject, [\n        \"maxPredictions\"\n    ]);\n    if (parentObject !== undefined && fromMaxPredictions != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"maxPredictions\"\n        ], fromMaxPredictions);\n    }\n    const fromConfidenceThreshold = getValueByPath(fromObject, [\n        \"confidenceThreshold\"\n    ]);\n    if (parentObject !== undefined && fromConfidenceThreshold != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"confidenceThreshold\"\n        ], fromConfidenceThreshold);\n    }\n    const fromMaskDilation = getValueByPath(fromObject, [\n        \"maskDilation\"\n    ]);\n    if (parentObject !== undefined && fromMaskDilation != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"maskDilation\"\n        ], fromMaskDilation);\n    }\n    const fromBinaryColorThreshold = getValueByPath(fromObject, [\n        \"binaryColorThreshold\"\n    ]);\n    if (parentObject !== undefined && fromBinaryColorThreshold != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"binaryColorThreshold\"\n        ], fromBinaryColorThreshold);\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    return toObject;\n}\nfunction segmentImageParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromSource = getValueByPath(fromObject, [\n        \"source\"\n    ]);\n    if (fromSource != null) {\n        segmentImageSourceToVertex(fromSource, toObject);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        segmentImageConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction segmentImageResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromGeneratedMasks = getValueByPath(fromObject, [\n        \"predictions\"\n    ]);\n    if (fromGeneratedMasks != null) {\n        let transformedList = fromGeneratedMasks;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedImageMaskFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedMasks\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction segmentImageSourceToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (parentObject !== undefined && fromPrompt != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (parentObject !== undefined && fromImage != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"image\"\n        ], imageToVertex(fromImage));\n    }\n    const fromScribbleImage = getValueByPath(fromObject, [\n        \"scribbleImage\"\n    ]);\n    if (parentObject !== undefined && fromScribbleImage != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"scribble\"\n        ], scribbleImageToVertex(fromScribbleImage));\n    }\n    return toObject;\n}\nfunction speechConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromLanguageCode = getValueByPath(fromObject, [\n        \"languageCode\"\n    ]);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, [\n            \"languageCode\"\n        ], fromLanguageCode);\n    }\n    const fromVoiceConfig = getValueByPath(fromObject, [\n        \"voiceConfig\"\n    ]);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"voiceConfig\"\n        ], fromVoiceConfig);\n    }\n    if (getValueByPath(fromObject, [\n        \"multiSpeakerVoiceConfig\"\n    ]) !== undefined) {\n        throw new Error(\"multiSpeakerVoiceConfig parameter is not supported in Vertex AI.\");\n    }\n    return toObject;\n}\nfunction toolConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromFunctionCallingConfig = getValueByPath(fromObject, [\n        \"functionCallingConfig\"\n    ]);\n    if (fromFunctionCallingConfig != null) {\n        setValueByPath(toObject, [\n            \"functionCallingConfig\"\n        ], functionCallingConfigToMldev(fromFunctionCallingConfig));\n    }\n    const fromRetrievalConfig = getValueByPath(fromObject, [\n        \"retrievalConfig\"\n    ]);\n    if (fromRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"retrievalConfig\"\n        ], fromRetrievalConfig);\n    }\n    return toObject;\n}\nfunction toolToMldev$1(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    if (getValueByPath(fromObject, [\n        \"retrieval\"\n    ]) !== undefined) {\n        throw new Error(\"retrieval parameter is not supported in Gemini API.\");\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], fromGoogleSearchRetrieval);\n    }\n    const fromComputerUse = getValueByPath(fromObject, [\n        \"computerUse\"\n    ]);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, [\n            \"computerUse\"\n        ], fromComputerUse);\n    }\n    const fromFileSearch = getValueByPath(fromObject, [\n        \"fileSearch\"\n    ]);\n    if (fromFileSearch != null) {\n        setValueByPath(toObject, [\n            \"fileSearch\"\n        ], fromFileSearch);\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    if (getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]) !== undefined) {\n        throw new Error(\"enterpriseWebSearch parameter is not supported in Gemini API.\");\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, [\n            \"googleMaps\"\n        ], googleMapsToMldev$1(fromGoogleMaps));\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToMldev$1(fromGoogleSearch));\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], fromUrlContext);\n    }\n    return toObject;\n}\nfunction toolToVertex(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return functionDeclarationToVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    const fromRetrieval = getValueByPath(fromObject, [\n        \"retrieval\"\n    ]);\n    if (fromRetrieval != null) {\n        setValueByPath(toObject, [\n            \"retrieval\"\n        ], fromRetrieval);\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], fromGoogleSearchRetrieval);\n    }\n    const fromComputerUse = getValueByPath(fromObject, [\n        \"computerUse\"\n    ]);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, [\n            \"computerUse\"\n        ], fromComputerUse);\n    }\n    if (getValueByPath(fromObject, [\n        \"fileSearch\"\n    ]) !== undefined) {\n        throw new Error(\"fileSearch parameter is not supported in Vertex AI.\");\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    const fromEnterpriseWebSearch = getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]);\n    if (fromEnterpriseWebSearch != null) {\n        setValueByPath(toObject, [\n            \"enterpriseWebSearch\"\n        ], fromEnterpriseWebSearch);\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, [\n            \"googleMaps\"\n        ], fromGoogleMaps);\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], fromGoogleSearch);\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], fromUrlContext);\n    }\n    return toObject;\n}\nfunction tunedModelInfoFromMldev(fromObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, [\n        \"baseModel\"\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, [\n            \"baseModel\"\n        ], fromBaseModel);\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    return toObject;\n}\nfunction tunedModelInfoFromVertex(fromObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, [\n        \"labels\",\n        \"google-vertex-llm-tuning-base-model-id\"\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, [\n            \"baseModel\"\n        ], fromBaseModel);\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    return toObject;\n}\nfunction updateModelConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (parentObject !== undefined && fromDescription != null) {\n        setValueByPath(parentObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromDefaultCheckpointId = getValueByPath(fromObject, [\n        \"defaultCheckpointId\"\n    ]);\n    if (parentObject !== undefined && fromDefaultCheckpointId != null) {\n        setValueByPath(parentObject, [\n            \"defaultCheckpointId\"\n        ], fromDefaultCheckpointId);\n    }\n    return toObject;\n}\nfunction updateModelConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (parentObject !== undefined && fromDescription != null) {\n        setValueByPath(parentObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromDefaultCheckpointId = getValueByPath(fromObject, [\n        \"defaultCheckpointId\"\n    ]);\n    if (parentObject !== undefined && fromDefaultCheckpointId != null) {\n        setValueByPath(parentObject, [\n            \"defaultCheckpointId\"\n        ], fromDefaultCheckpointId);\n    }\n    return toObject;\n}\nfunction updateModelParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        updateModelConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction updateModelParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        updateModelConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction upscaleImageAPIConfigInternalToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromOutputGcsUri = getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"storageUri\"\n        ], fromOutputGcsUri);\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        \"safetyFilterLevel\"\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"safetySetting\"\n        ], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        \"includeRaiReason\"\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeRaiReason\"\n        ], fromIncludeRaiReason);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        \"outputMimeType\"\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"mimeType\"\n        ], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        \"outputCompressionQuality\"\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"compressionQuality\"\n        ], fromOutputCompressionQuality);\n    }\n    const fromEnhanceInputImage = getValueByPath(fromObject, [\n        \"enhanceInputImage\"\n    ]);\n    if (parentObject !== undefined && fromEnhanceInputImage != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"upscaleConfig\",\n            \"enhanceInputImage\"\n        ], fromEnhanceInputImage);\n    }\n    const fromImagePreservationFactor = getValueByPath(fromObject, [\n        \"imagePreservationFactor\"\n    ]);\n    if (parentObject !== undefined && fromImagePreservationFactor != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"upscaleConfig\",\n            \"imagePreservationFactor\"\n        ], fromImagePreservationFactor);\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        \"numberOfImages\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfImages);\n    }\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (parentObject !== undefined && fromMode != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"mode\"\n        ], fromMode);\n    }\n    return toObject;\n}\nfunction upscaleImageAPIParametersInternalToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"image\"\n        ], imageToVertex(fromImage));\n    }\n    const fromUpscaleFactor = getValueByPath(fromObject, [\n        \"upscaleFactor\"\n    ]);\n    if (fromUpscaleFactor != null) {\n        setValueByPath(toObject, [\n            \"parameters\",\n            \"upscaleConfig\",\n            \"upscaleFactor\"\n        ], fromUpscaleFactor);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        upscaleImageAPIConfigInternalToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction upscaleImageResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        \"predictions\"\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedImageFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedImages\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction videoFromMldev(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, [\n        \"uri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"uri\"\n        ], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        \"encodedVideo\"\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, [\n            \"videoBytes\"\n        ], tBytes(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"encoding\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction videoFromVertex(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"uri\"\n        ], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        \"bytesBase64Encoded\"\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, [\n            \"videoBytes\"\n        ], tBytes(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction videoGenerationMaskToVertex(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"_self\"\n        ], imageToVertex(fromImage));\n    }\n    const fromMaskMode = getValueByPath(fromObject, [\n        \"maskMode\"\n    ]);\n    if (fromMaskMode != null) {\n        setValueByPath(toObject, [\n            \"maskMode\"\n        ], fromMaskMode);\n    }\n    return toObject;\n}\nfunction videoGenerationReferenceImageToMldev(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"image\"\n        ], imageToMldev(fromImage));\n    }\n    const fromReferenceType = getValueByPath(fromObject, [\n        \"referenceType\"\n    ]);\n    if (fromReferenceType != null) {\n        setValueByPath(toObject, [\n            \"referenceType\"\n        ], fromReferenceType);\n    }\n    return toObject;\n}\nfunction videoGenerationReferenceImageToVertex(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"image\"\n        ], imageToVertex(fromImage));\n    }\n    const fromReferenceType = getValueByPath(fromObject, [\n        \"referenceType\"\n    ]);\n    if (fromReferenceType != null) {\n        setValueByPath(toObject, [\n            \"referenceType\"\n        ], fromReferenceType);\n    }\n    return toObject;\n}\nfunction videoToMldev(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, [\n        \"uri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"uri\"\n        ], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        \"videoBytes\"\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, [\n            \"encodedVideo\"\n        ], tBytes(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"encoding\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction videoToVertex(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, [\n        \"uri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"gcsUri\"\n        ], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        \"videoBytes\"\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, [\n            \"bytesBase64Encoded\"\n        ], tBytes(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ // Code generated by the Google Gen AI SDK generator DO NOT EDIT.\nfunction createFileSearchStoreConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    return toObject;\n}\nfunction createFileSearchStoreParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        createFileSearchStoreConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction deleteFileSearchStoreConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromForce = getValueByPath(fromObject, [\n        \"force\"\n    ]);\n    if (parentObject !== undefined && fromForce != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"force\"\n        ], fromForce);\n    }\n    return toObject;\n}\nfunction deleteFileSearchStoreParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], fromName);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        deleteFileSearchStoreConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction getFileSearchStoreParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction importFileConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromCustomMetadata = getValueByPath(fromObject, [\n        \"customMetadata\"\n    ]);\n    if (parentObject !== undefined && fromCustomMetadata != null) {\n        let transformedList = fromCustomMetadata;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(parentObject, [\n            \"customMetadata\"\n        ], transformedList);\n    }\n    const fromChunkingConfig = getValueByPath(fromObject, [\n        \"chunkingConfig\"\n    ]);\n    if (parentObject !== undefined && fromChunkingConfig != null) {\n        setValueByPath(parentObject, [\n            \"chunkingConfig\"\n        ], fromChunkingConfig);\n    }\n    return toObject;\n}\nfunction importFileOperationFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], importFileResponseFromMldev(fromResponse));\n    }\n    return toObject;\n}\nfunction importFileParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromFileSearchStoreName = getValueByPath(fromObject, [\n        \"fileSearchStoreName\"\n    ]);\n    if (fromFileSearchStoreName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"file_search_store_name\"\n        ], fromFileSearchStoreName);\n    }\n    const fromFileName = getValueByPath(fromObject, [\n        \"fileName\"\n    ]);\n    if (fromFileName != null) {\n        setValueByPath(toObject, [\n            \"fileName\"\n        ], fromFileName);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        importFileConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction importFileResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromParent = getValueByPath(fromObject, [\n        \"parent\"\n    ]);\n    if (fromParent != null) {\n        setValueByPath(toObject, [\n            \"parent\"\n        ], fromParent);\n    }\n    const fromDocumentName = getValueByPath(fromObject, [\n        \"documentName\"\n    ]);\n    if (fromDocumentName != null) {\n        setValueByPath(toObject, [\n            \"documentName\"\n        ], fromDocumentName);\n    }\n    return toObject;\n}\nfunction listFileSearchStoresConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    return toObject;\n}\nfunction listFileSearchStoresParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listFileSearchStoresConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listFileSearchStoresResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromFileSearchStores = getValueByPath(fromObject, [\n        \"fileSearchStores\"\n    ]);\n    if (fromFileSearchStores != null) {\n        let transformedList = fromFileSearchStores;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"fileSearchStores\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction uploadToFileSearchStoreConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (parentObject !== undefined && fromMimeType != null) {\n        setValueByPath(parentObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromCustomMetadata = getValueByPath(fromObject, [\n        \"customMetadata\"\n    ]);\n    if (parentObject !== undefined && fromCustomMetadata != null) {\n        let transformedList = fromCustomMetadata;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(parentObject, [\n            \"customMetadata\"\n        ], transformedList);\n    }\n    const fromChunkingConfig = getValueByPath(fromObject, [\n        \"chunkingConfig\"\n    ]);\n    if (parentObject !== undefined && fromChunkingConfig != null) {\n        setValueByPath(parentObject, [\n            \"chunkingConfig\"\n        ], fromChunkingConfig);\n    }\n    return toObject;\n}\nfunction uploadToFileSearchStoreParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromFileSearchStoreName = getValueByPath(fromObject, [\n        \"fileSearchStoreName\"\n    ]);\n    if (fromFileSearchStoreName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"file_search_store_name\"\n        ], fromFileSearchStoreName);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        uploadToFileSearchStoreConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction uploadToFileSearchStoreResumableResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ const CONTENT_TYPE_HEADER = \"Content-Type\";\nconst SERVER_TIMEOUT_HEADER = \"X-Server-Timeout\";\nconst USER_AGENT_HEADER = \"User-Agent\";\nconst GOOGLE_API_CLIENT_HEADER = \"x-goog-api-client\";\nconst SDK_VERSION = \"1.31.0\"; // x-release-please-version\nconst LIBRARY_LABEL = \"google-genai-sdk/\".concat(SDK_VERSION);\nconst VERTEX_AI_API_DEFAULT_VERSION = \"v1beta1\";\nconst GOOGLE_AI_API_DEFAULT_VERSION = \"v1beta\";\nconst responseLineRE = /^\\s*data: (.*)(?:\\n\\n|\\r\\r|\\r\\n\\r\\n)/;\n/**\n * The ApiClient class is used to send requests to the Gemini API or Vertex AI\n * endpoints.\n */ class ApiClient {\n    /**\n     * Determines the base URL for Vertex AI based on project and location.\n     * Uses the global endpoint if location is 'global' or if project/location\n     * are not specified (implying API key usage).\n     * @private\n     */ baseUrlFromProjectLocation() {\n        if (this.clientOptions.project && this.clientOptions.location && this.clientOptions.location !== \"global\") {\n            // Regional endpoint\n            return \"https://\".concat(this.clientOptions.location, \"-aiplatform.googleapis.com/\");\n        }\n        // Global endpoint (covers 'global' location and API key usage)\n        return \"https://aiplatform.googleapis.com/\";\n    }\n    /**\n     * Normalizes authentication parameters for Vertex AI.\n     * If project and location are provided, API key is cleared.\n     * If project and location are not provided (implying API key usage),\n     * project and location are cleared.\n     * @private\n     */ normalizeAuthParameters() {\n        if (this.clientOptions.project && this.clientOptions.location) {\n            // Using project/location for auth, clear potential API key\n            this.clientOptions.apiKey = undefined;\n            return;\n        }\n        // Using API key for auth (or no auth provided yet), clear project/location\n        this.clientOptions.project = undefined;\n        this.clientOptions.location = undefined;\n    }\n    isVertexAI() {\n        var _a;\n        return (_a = this.clientOptions.vertexai) !== null && _a !== void 0 ? _a : false;\n    }\n    getProject() {\n        return this.clientOptions.project;\n    }\n    getLocation() {\n        return this.clientOptions.location;\n    }\n    getApiVersion() {\n        if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.apiVersion !== undefined) {\n            return this.clientOptions.httpOptions.apiVersion;\n        }\n        throw new Error(\"API version is not set.\");\n    }\n    getBaseUrl() {\n        if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.baseUrl !== undefined) {\n            return this.clientOptions.httpOptions.baseUrl;\n        }\n        throw new Error(\"Base URL is not set.\");\n    }\n    getRequestUrl() {\n        return this.getRequestUrlInternal(this.clientOptions.httpOptions);\n    }\n    getHeaders() {\n        if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.headers !== undefined) {\n            return this.clientOptions.httpOptions.headers;\n        } else {\n            throw new Error(\"Headers are not set.\");\n        }\n    }\n    getRequestUrlInternal(httpOptions) {\n        if (!httpOptions || httpOptions.baseUrl === undefined || httpOptions.apiVersion === undefined) {\n            throw new Error(\"HTTP options are not correctly set.\");\n        }\n        const baseUrl = httpOptions.baseUrl.endsWith(\"/\") ? httpOptions.baseUrl.slice(0, -1) : httpOptions.baseUrl;\n        const urlElement = [\n            baseUrl\n        ];\n        if (httpOptions.apiVersion && httpOptions.apiVersion !== \"\") {\n            urlElement.push(httpOptions.apiVersion);\n        }\n        return urlElement.join(\"/\");\n    }\n    getBaseResourcePath() {\n        return \"projects/\".concat(this.clientOptions.project, \"/locations/\").concat(this.clientOptions.location);\n    }\n    getApiKey() {\n        return this.clientOptions.apiKey;\n    }\n    getWebsocketBaseUrl() {\n        const baseUrl = this.getBaseUrl();\n        const urlParts = new URL(baseUrl);\n        urlParts.protocol = urlParts.protocol == \"http:\" ? \"ws\" : \"wss\";\n        return urlParts.toString();\n    }\n    setBaseUrl(url) {\n        if (this.clientOptions.httpOptions) {\n            this.clientOptions.httpOptions.baseUrl = url;\n        } else {\n            throw new Error(\"HTTP options are not correctly set.\");\n        }\n    }\n    constructUrl(path, httpOptions, prependProjectLocation) {\n        const urlElement = [\n            this.getRequestUrlInternal(httpOptions)\n        ];\n        if (prependProjectLocation) {\n            urlElement.push(this.getBaseResourcePath());\n        }\n        if (path !== \"\") {\n            urlElement.push(path);\n        }\n        const url = new URL(\"\".concat(urlElement.join(\"/\")));\n        return url;\n    }\n    shouldPrependVertexProjectPath(request) {\n        if (this.clientOptions.apiKey) {\n            return false;\n        }\n        if (!this.clientOptions.vertexai) {\n            return false;\n        }\n        if (request.path.startsWith(\"projects/\")) {\n            // Assume the path already starts with\n            // `projects/<project>/location/<location>`.\n            return false;\n        }\n        if (request.httpMethod === \"GET\" && request.path.startsWith(\"publishers/google/models\")) {\n            // These paths are used by Vertex's models.get and models.list\n            // calls. For base models Vertex does not accept a project/location\n            // prefix (for tuned model the prefix is required).\n            return false;\n        }\n        return true;\n    }\n    async request(request) {\n        let patchedHttpOptions = this.clientOptions.httpOptions;\n        if (request.httpOptions) {\n            patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);\n        }\n        const prependProjectLocation = this.shouldPrependVertexProjectPath(request);\n        const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);\n        if (request.queryParams) {\n            for (const [key, value] of Object.entries(request.queryParams)){\n                url.searchParams.append(key, String(value));\n            }\n        }\n        let requestInit = {};\n        if (request.httpMethod === \"GET\") {\n            if (request.body && request.body !== \"{}\") {\n                throw new Error(\"Request body should be empty for GET request, but got non empty request body\");\n            }\n        } else {\n            requestInit.body = request.body;\n        }\n        requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, url.toString(), request.abortSignal);\n        return this.unaryApiCall(url, requestInit, request.httpMethod);\n    }\n    patchHttpOptions(baseHttpOptions, requestHttpOptions) {\n        const patchedHttpOptions = JSON.parse(JSON.stringify(baseHttpOptions));\n        for (const [key, value] of Object.entries(requestHttpOptions)){\n            // Records compile to objects.\n            if (typeof value === \"object\") {\n                // @ts-expect-error TS2345TS7053: Element implicitly has an 'any' type\n                // because expression of type 'string' can't be used to index type\n                // 'HttpOptions'.\n                patchedHttpOptions[key] = Object.assign(Object.assign({}, patchedHttpOptions[key]), value);\n            } else if (value !== undefined) {\n                // @ts-expect-error TS2345TS7053: Element implicitly has an 'any' type\n                // because expression of type 'string' can't be used to index type\n                // 'HttpOptions'.\n                patchedHttpOptions[key] = value;\n            }\n        }\n        return patchedHttpOptions;\n    }\n    async requestStream(request) {\n        let patchedHttpOptions = this.clientOptions.httpOptions;\n        if (request.httpOptions) {\n            patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);\n        }\n        const prependProjectLocation = this.shouldPrependVertexProjectPath(request);\n        const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);\n        if (!url.searchParams.has(\"alt\") || url.searchParams.get(\"alt\") !== \"sse\") {\n            url.searchParams.set(\"alt\", \"sse\");\n        }\n        let requestInit = {};\n        requestInit.body = request.body;\n        requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, url.toString(), request.abortSignal);\n        return this.streamApiCall(url, requestInit, request.httpMethod);\n    }\n    async includeExtraHttpOptionsToRequestInit(requestInit, httpOptions, url, abortSignal) {\n        if (httpOptions && httpOptions.timeout || abortSignal) {\n            const abortController = new AbortController();\n            const signal = abortController.signal;\n            if (httpOptions.timeout && (httpOptions === null || httpOptions === void 0 ? void 0 : httpOptions.timeout) > 0) {\n                const timeoutHandle = setTimeout(()=>abortController.abort(), httpOptions.timeout);\n                if (timeoutHandle && typeof timeoutHandle.unref === \"function\") {\n                    // call unref to prevent nodejs process from hanging, see\n                    // https://nodejs.org/api/timers.html#timeoutunref\n                    timeoutHandle.unref();\n                }\n            }\n            if (abortSignal) {\n                abortSignal.addEventListener(\"abort\", ()=>{\n                    abortController.abort();\n                });\n            }\n            requestInit.signal = signal;\n        }\n        if (httpOptions && httpOptions.extraBody !== null) {\n            includeExtraBodyToRequestInit(requestInit, httpOptions.extraBody);\n        }\n        requestInit.headers = await this.getHeadersInternal(httpOptions, url);\n        return requestInit;\n    }\n    async unaryApiCall(url, requestInit, httpMethod) {\n        return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), {\n            method: httpMethod\n        })).then(async (response)=>{\n            await throwErrorIfNotOK(response);\n            return new HttpResponse(response);\n        }).catch((e)=>{\n            if (e instanceof Error) {\n                throw e;\n            } else {\n                throw new Error(JSON.stringify(e));\n            }\n        });\n    }\n    async streamApiCall(url, requestInit, httpMethod) {\n        return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), {\n            method: httpMethod\n        })).then(async (response)=>{\n            await throwErrorIfNotOK(response);\n            return this.processStreamResponse(response);\n        }).catch((e)=>{\n            if (e instanceof Error) {\n                throw e;\n            } else {\n                throw new Error(JSON.stringify(e));\n            }\n        });\n    }\n    processStreamResponse(response) {\n        var _a;\n        return __asyncGenerator(this, arguments, function* processStreamResponse_1() {\n            const reader = (_a = response === null || response === void 0 ? void 0 : response.body) === null || _a === void 0 ? void 0 : _a.getReader();\n            const decoder = new TextDecoder(\"utf-8\");\n            if (!reader) {\n                throw new Error(\"Response body is empty\");\n            }\n            try {\n                let buffer = \"\";\n                while(true){\n                    const { done, value } = yield __await(reader.read());\n                    if (done) {\n                        if (buffer.trim().length > 0) {\n                            throw new Error(\"Incomplete JSON segment at the end\");\n                        }\n                        break;\n                    }\n                    const chunkString = decoder.decode(value, {\n                        stream: true\n                    });\n                    // Parse and throw an error if the chunk contains an error.\n                    try {\n                        const chunkJson = JSON.parse(chunkString);\n                        if (\"error\" in chunkJson) {\n                            const errorJson = JSON.parse(JSON.stringify(chunkJson[\"error\"]));\n                            const status = errorJson[\"status\"];\n                            const code = errorJson[\"code\"];\n                            const errorMessage = \"got status: \".concat(status, \". \").concat(JSON.stringify(chunkJson));\n                            if (code >= 400 && code < 600) {\n                                const apiError = new ApiError({\n                                    message: errorMessage,\n                                    status: code\n                                });\n                                throw apiError;\n                            }\n                        }\n                    } catch (e) {\n                        const error = e;\n                        if (error.name === \"ApiError\") {\n                            throw e;\n                        }\n                    }\n                    buffer += chunkString;\n                    let match = buffer.match(responseLineRE);\n                    while(match){\n                        const processedChunkString = match[1];\n                        try {\n                            const partialResponse = new Response(processedChunkString, {\n                                headers: response === null || response === void 0 ? void 0 : response.headers,\n                                status: response === null || response === void 0 ? void 0 : response.status,\n                                statusText: response === null || response === void 0 ? void 0 : response.statusText\n                            });\n                            yield yield __await(new HttpResponse(partialResponse));\n                            buffer = buffer.slice(match[0].length);\n                            match = buffer.match(responseLineRE);\n                        } catch (e) {\n                            throw new Error(\"exception parsing stream chunk \".concat(processedChunkString, \". \").concat(e));\n                        }\n                    }\n                }\n            } finally{\n                reader.releaseLock();\n            }\n        });\n    }\n    async apiCall(url, requestInit) {\n        return fetch(url, requestInit).catch((e)=>{\n            throw new Error(\"exception \".concat(e, \" sending request\"));\n        });\n    }\n    getDefaultHeaders() {\n        const headers = {};\n        const versionHeaderValue = LIBRARY_LABEL + \" \" + this.clientOptions.userAgentExtra;\n        headers[USER_AGENT_HEADER] = versionHeaderValue;\n        headers[GOOGLE_API_CLIENT_HEADER] = versionHeaderValue;\n        headers[CONTENT_TYPE_HEADER] = \"application/json\";\n        return headers;\n    }\n    async getHeadersInternal(httpOptions, url) {\n        const headers = new Headers();\n        if (httpOptions && httpOptions.headers) {\n            for (const [key, value] of Object.entries(httpOptions.headers)){\n                headers.append(key, value);\n            }\n            // Append a timeout header if it is set, note that the timeout option is\n            // in milliseconds but the header is in seconds.\n            if (httpOptions.timeout && httpOptions.timeout > 0) {\n                headers.append(SERVER_TIMEOUT_HEADER, String(Math.ceil(httpOptions.timeout / 1000)));\n            }\n        }\n        await this.clientOptions.auth.addAuthHeaders(headers, url);\n        return headers;\n    }\n    getFileName(file) {\n        var _a;\n        let fileName = \"\";\n        if (typeof file === \"string\") {\n            fileName = file.replace(/[/\\\\]+$/, \"\");\n            fileName = (_a = fileName.split(/[/\\\\]/).pop()) !== null && _a !== void 0 ? _a : \"\";\n        }\n        return fileName;\n    }\n    /**\n     * Uploads a file asynchronously using Gemini API only, this is not supported\n     * in Vertex AI.\n     *\n     * @param file The string path to the file to be uploaded or a Blob object.\n     * @param config Optional parameters specified in the `UploadFileConfig`\n     *     interface. @see {@link types.UploadFileConfig}\n     * @return A promise that resolves to a `File` object.\n     * @throws An error if called on a Vertex AI client.\n     * @throws An error if the `mimeType` is not provided and can not be inferred,\n     */ async uploadFile(file, config) {\n        var _a;\n        const fileToUpload = {};\n        if (config != null) {\n            fileToUpload.mimeType = config.mimeType;\n            fileToUpload.name = config.name;\n            fileToUpload.displayName = config.displayName;\n        }\n        if (fileToUpload.name && !fileToUpload.name.startsWith(\"files/\")) {\n            fileToUpload.name = \"files/\".concat(fileToUpload.name);\n        }\n        const uploader = this.clientOptions.uploader;\n        const fileStat = await uploader.stat(file);\n        fileToUpload.sizeBytes = String(fileStat.size);\n        const mimeType = (_a = config === null || config === void 0 ? void 0 : config.mimeType) !== null && _a !== void 0 ? _a : fileStat.type;\n        if (mimeType === undefined || mimeType === \"\") {\n            throw new Error(\"Can not determine mimeType. Please provide mimeType in the config.\");\n        }\n        fileToUpload.mimeType = mimeType;\n        const body = {\n            file: fileToUpload\n        };\n        const fileName = this.getFileName(file);\n        const path = formatMap(\"upload/v1beta/files\", body[\"_url\"]);\n        const uploadUrl = await this.fetchUploadUrl(path, fileToUpload.sizeBytes, fileToUpload.mimeType, fileName, body, config === null || config === void 0 ? void 0 : config.httpOptions);\n        return uploader.upload(file, uploadUrl, this);\n    }\n    /**\n     * Uploads a file to a given file search store asynchronously using Gemini API only, this is not supported\n     * in Vertex AI.\n     *\n     * @param fileSearchStoreName The name of the file search store to upload the file to.\n     * @param file The string path to the file to be uploaded or a Blob object.\n     * @param config Optional parameters specified in the `UploadFileConfig`\n     *     interface. @see {@link UploadFileConfig}\n     * @return A promise that resolves to a `File` object.\n     * @throws An error if called on a Vertex AI client.\n     * @throws An error if the `mimeType` is not provided and can not be inferred,\n     */ async uploadFileToFileSearchStore(fileSearchStoreName, file, config) {\n        var _a;\n        const uploader = this.clientOptions.uploader;\n        const fileStat = await uploader.stat(file);\n        const sizeBytes = String(fileStat.size);\n        const mimeType = (_a = config === null || config === void 0 ? void 0 : config.mimeType) !== null && _a !== void 0 ? _a : fileStat.type;\n        if (mimeType === undefined || mimeType === \"\") {\n            throw new Error(\"Can not determine mimeType. Please provide mimeType in the config.\");\n        }\n        const path = \"upload/v1beta/\".concat(fileSearchStoreName, \":uploadToFileSearchStore\");\n        const fileName = this.getFileName(file);\n        const body = {};\n        if (config != null) {\n            uploadToFileSearchStoreConfigToMldev(config, body);\n        }\n        const uploadUrl = await this.fetchUploadUrl(path, sizeBytes, mimeType, fileName, body, config === null || config === void 0 ? void 0 : config.httpOptions);\n        return uploader.uploadToFileSearchStore(file, uploadUrl, this);\n    }\n    /**\n     * Downloads a file asynchronously to the specified path.\n     *\n     * @params params - The parameters for the download request, see {@link\n     * types.DownloadFileParameters}\n     */ async downloadFile(params) {\n        const downloader = this.clientOptions.downloader;\n        await downloader.download(params, this);\n    }\n    async fetchUploadUrl(path, sizeBytes, mimeType, fileName, body, configHttpOptions) {\n        var _a;\n        let httpOptions = {};\n        if (configHttpOptions) {\n            httpOptions = configHttpOptions;\n        } else {\n            httpOptions = {\n                apiVersion: \"\",\n                headers: Object.assign({\n                    \"Content-Type\": \"application/json\",\n                    \"X-Goog-Upload-Protocol\": \"resumable\",\n                    \"X-Goog-Upload-Command\": \"start\",\n                    \"X-Goog-Upload-Header-Content-Length\": \"\".concat(sizeBytes),\n                    \"X-Goog-Upload-Header-Content-Type\": \"\".concat(mimeType)\n                }, fileName ? {\n                    \"X-Goog-Upload-File-Name\": fileName\n                } : {})\n            };\n        }\n        const httpResponse = await this.request({\n            path,\n            body: JSON.stringify(body),\n            httpMethod: \"POST\",\n            httpOptions\n        });\n        if (!httpResponse || !(httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers)) {\n            throw new Error(\"Server did not return an HttpResponse or the returned HttpResponse did not have headers.\");\n        }\n        const uploadUrl = (_a = httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers) === null || _a === void 0 ? void 0 : _a[\"x-goog-upload-url\"];\n        if (uploadUrl === undefined) {\n            throw new Error(\"Failed to get upload url. Server did not return the x-google-upload-url in the headers\");\n        }\n        return uploadUrl;\n    }\n    constructor(opts){\n        var _a, _b;\n        this.clientOptions = Object.assign(Object.assign({}, opts), {\n            project: opts.project,\n            location: opts.location,\n            apiKey: opts.apiKey,\n            vertexai: opts.vertexai\n        });\n        const initHttpOptions = {};\n        if (this.clientOptions.vertexai) {\n            initHttpOptions.apiVersion = (_a = this.clientOptions.apiVersion) !== null && _a !== void 0 ? _a : VERTEX_AI_API_DEFAULT_VERSION;\n            initHttpOptions.baseUrl = this.baseUrlFromProjectLocation();\n            this.normalizeAuthParameters();\n        } else {\n            // Gemini API\n            initHttpOptions.apiVersion = (_b = this.clientOptions.apiVersion) !== null && _b !== void 0 ? _b : GOOGLE_AI_API_DEFAULT_VERSION;\n            initHttpOptions.baseUrl = \"https://generativelanguage.googleapis.com/\";\n        }\n        initHttpOptions.headers = this.getDefaultHeaders();\n        this.clientOptions.httpOptions = initHttpOptions;\n        if (opts.httpOptions) {\n            this.clientOptions.httpOptions = this.patchHttpOptions(initHttpOptions, opts.httpOptions);\n        }\n    }\n}\nasync function throwErrorIfNotOK(response) {\n    var _a;\n    if (response === undefined) {\n        throw new Error(\"response is undefined\");\n    }\n    if (!response.ok) {\n        const status = response.status;\n        let errorBody;\n        if ((_a = response.headers.get(\"content-type\")) === null || _a === void 0 ? void 0 : _a.includes(\"application/json\")) {\n            errorBody = await response.json();\n        } else {\n            errorBody = {\n                error: {\n                    message: await response.text(),\n                    code: response.status,\n                    status: response.statusText\n                }\n            };\n        }\n        const errorMessage = JSON.stringify(errorBody);\n        if (status >= 400 && status < 600) {\n            const apiError = new ApiError({\n                message: errorMessage,\n                status: status\n            });\n            throw apiError;\n        }\n        throw new Error(errorMessage);\n    }\n}\n/**\n * Recursively updates the `requestInit.body` with values from an `extraBody` object.\n *\n * If `requestInit.body` is a string, it's assumed to be JSON and will be parsed.\n * The `extraBody` is then deeply merged into this parsed object.\n * If `requestInit.body` is a Blob, `extraBody` will be ignored, and a warning logged,\n * as merging structured data into an opaque Blob is not supported.\n *\n * The function does not enforce that updated values from `extraBody` have the\n * same type as existing values in `requestInit.body`. Type mismatches during\n * the merge will result in a warning, but the value from `extraBody` will overwrite\n * the original. `extraBody` users are responsible for ensuring `extraBody` has the correct structure.\n *\n * @param requestInit The RequestInit object whose body will be updated.\n * @param extraBody The object containing updates to be merged into `requestInit.body`.\n */ function includeExtraBodyToRequestInit(requestInit, extraBody) {\n    if (!extraBody || Object.keys(extraBody).length === 0) {\n        return;\n    }\n    if (requestInit.body instanceof Blob) {\n        console.warn(\"includeExtraBodyToRequestInit: extraBody provided but current request body is a Blob. extraBody will be ignored as merging is not supported for Blob bodies.\");\n        return;\n    }\n    let currentBodyObject = {};\n    // If adding new type to HttpRequest.body, please check the code below to\n    // see if we need to update the logic.\n    if (typeof requestInit.body === \"string\" && requestInit.body.length > 0) {\n        try {\n            const parsedBody = JSON.parse(requestInit.body);\n            if (typeof parsedBody === \"object\" && parsedBody !== null && !Array.isArray(parsedBody)) {\n                currentBodyObject = parsedBody;\n            } else {\n                console.warn(\"includeExtraBodyToRequestInit: Original request body is valid JSON but not a non-array object. Skip applying extraBody to the request body.\");\n                return;\n            }\n        /*  eslint-disable-next-line @typescript-eslint/no-unused-vars */ } catch (e) {\n            console.warn(\"includeExtraBodyToRequestInit: Original request body is not valid JSON. Skip applying extraBody to the request body.\");\n            return;\n        }\n    }\n    function deepMerge(target, source) {\n        const output = Object.assign({}, target);\n        for(const key in source){\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n                const sourceValue = source[key];\n                const targetValue = output[key];\n                if (sourceValue && typeof sourceValue === \"object\" && !Array.isArray(sourceValue) && targetValue && typeof targetValue === \"object\" && !Array.isArray(targetValue)) {\n                    output[key] = deepMerge(targetValue, sourceValue);\n                } else {\n                    if (targetValue && sourceValue && typeof targetValue !== typeof sourceValue) {\n                        console.warn('includeExtraBodyToRequestInit:deepMerge: Type mismatch for key \"'.concat(key, '\". Original type: ').concat(typeof targetValue, \", New type: \").concat(typeof sourceValue, \". Overwriting.\"));\n                    }\n                    output[key] = sourceValue;\n                }\n            }\n        }\n        return output;\n    }\n    const mergedBody = deepMerge(currentBodyObject, extraBody);\n    requestInit.body = JSON.stringify(mergedBody);\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ // TODO: b/416041229 - Determine how to retrieve the MCP package version.\nconst MCP_LABEL = \"mcp_used/unknown\";\n// Whether MCP tool usage is detected from mcpToTool. This is used for\n// telemetry.\nlet hasMcpToolUsageFromMcpToTool = false;\n// Checks whether the list of tools contains any MCP tools.\nfunction hasMcpToolUsage(tools) {\n    for (const tool of tools){\n        if (isMcpCallableTool(tool)) {\n            return true;\n        }\n        if (typeof tool === \"object\" && \"inputSchema\" in tool) {\n            return true;\n        }\n    }\n    return hasMcpToolUsageFromMcpToTool;\n}\n// Sets the MCP version label in the Google API client header.\nfunction setMcpUsageHeader(headers) {\n    var _a;\n    const existingHeader = (_a = headers[GOOGLE_API_CLIENT_HEADER]) !== null && _a !== void 0 ? _a : \"\";\n    headers[GOOGLE_API_CLIENT_HEADER] = (existingHeader + \" \".concat(MCP_LABEL)).trimStart();\n}\n// Returns true if the object is a MCP CallableTool, otherwise false.\nfunction isMcpCallableTool(object) {\n    return object !== null && typeof object === \"object\" && object instanceof McpCallableTool;\n}\n// List all tools from the MCP client.\nfunction listAllTools(mcpClient) {\n    let maxTools = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 100;\n    return __asyncGenerator(this, arguments, function* listAllTools_1() {\n        let cursor = undefined;\n        let numTools = 0;\n        while(numTools < maxTools){\n            const t = yield __await(mcpClient.listTools({\n                cursor\n            }));\n            for (const tool of t.tools){\n                yield yield __await(tool);\n                numTools++;\n            }\n            if (!t.nextCursor) {\n                break;\n            }\n            cursor = t.nextCursor;\n        }\n    });\n}\n/**\n * McpCallableTool can be used for model inference and invoking MCP clients with\n * given function call arguments.\n *\n * @experimental Built-in MCP support is an experimental feature, may change in future\n * versions.\n */ class McpCallableTool {\n    /**\n     * Creates a McpCallableTool.\n     */ static create(mcpClients, config) {\n        return new McpCallableTool(mcpClients, config);\n    }\n    /**\n     * Validates the function names are not duplicate and initialize the function\n     * name to MCP client mapping.\n     *\n     * @throws {Error} if the MCP tools from the MCP clients have duplicate tool\n     *     names.\n     */ async initialize() {\n        var _a, e_1, _b, _c;\n        if (this.mcpTools.length > 0) {\n            return;\n        }\n        const functionMap = {};\n        const mcpTools = [];\n        for (const mcpClient of this.mcpClients){\n            try {\n                for(var _d = true, _e = (e_1 = void 0, __asyncValues(listAllTools(mcpClient))), _f; _f = await _e.next(), _a = _f.done, !_a; _d = true){\n                    _c = _f.value;\n                    _d = false;\n                    const mcpTool = _c;\n                    mcpTools.push(mcpTool);\n                    const mcpToolName = mcpTool.name;\n                    if (functionMap[mcpToolName]) {\n                        throw new Error(\"Duplicate function name \".concat(mcpToolName, \" found in MCP tools. Please ensure function names are unique.\"));\n                    }\n                    functionMap[mcpToolName] = mcpClient;\n                }\n            } catch (e_1_1) {\n                e_1 = {\n                    error: e_1_1\n                };\n            } finally{\n                try {\n                    if (!_d && !_a && (_b = _e.return)) await _b.call(_e);\n                } finally{\n                    if (e_1) throw e_1.error;\n                }\n            }\n        }\n        this.mcpTools = mcpTools;\n        this.functionNameToMcpClient = functionMap;\n    }\n    async tool() {\n        await this.initialize();\n        return mcpToolsToGeminiTool(this.mcpTools, this.config);\n    }\n    async callTool(functionCalls) {\n        await this.initialize();\n        const functionCallResponseParts = [];\n        for (const functionCall of functionCalls){\n            if (functionCall.name in this.functionNameToMcpClient) {\n                const mcpClient = this.functionNameToMcpClient[functionCall.name];\n                let requestOptions = undefined;\n                // TODO: b/424238654 - Add support for finer grained timeout control.\n                if (this.config.timeout) {\n                    requestOptions = {\n                        timeout: this.config.timeout\n                    };\n                }\n                const callToolResponse = await mcpClient.callTool({\n                    name: functionCall.name,\n                    arguments: functionCall.args\n                }, // Set the result schema to undefined to allow MCP to rely on the\n                // default schema.\n                undefined, requestOptions);\n                functionCallResponseParts.push({\n                    functionResponse: {\n                        name: functionCall.name,\n                        response: callToolResponse.isError ? {\n                            error: callToolResponse\n                        } : callToolResponse\n                    }\n                });\n            }\n        }\n        return functionCallResponseParts;\n    }\n    constructor(mcpClients = [], config){\n        this.mcpTools = [];\n        this.functionNameToMcpClient = {};\n        this.mcpClients = mcpClients;\n        this.config = config;\n    }\n}\nfunction isMcpClient(client) {\n    return client !== null && typeof client === \"object\" && \"listTools\" in client && typeof client.listTools === \"function\";\n}\n/**\n * Creates a McpCallableTool from MCP clients and an optional config.\n *\n * The callable tool can invoke the MCP clients with given function call\n * arguments. (often for automatic function calling).\n * Use the config to modify tool parameters such as behavior.\n *\n * @experimental Built-in MCP support is an experimental feature, may change in future\n * versions.\n */ function mcpToTool() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    // Set MCP usage for telemetry.\n    hasMcpToolUsageFromMcpToTool = true;\n    if (args.length === 0) {\n        throw new Error(\"No MCP clients provided\");\n    }\n    const maybeConfig = args[args.length - 1];\n    if (isMcpClient(maybeConfig)) {\n        return McpCallableTool.create(args, {});\n    }\n    return McpCallableTool.create(args.slice(0, args.length - 1), maybeConfig);\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ /**\n * Handles incoming messages from the WebSocket.\n *\n * @remarks\n * This function is responsible for parsing incoming messages, transforming them\n * into LiveMusicServerMessage, and then calling the onmessage callback.\n * Note that the first message which is received from the server is a\n * setupComplete message.\n *\n * @param apiClient The ApiClient instance.\n * @param onmessage The user-provided onmessage callback (if any).\n * @param event The MessageEvent from the WebSocket.\n */ async function handleWebSocketMessage$1(apiClient, onmessage, event) {\n    const serverMessage = new LiveMusicServerMessage();\n    let data;\n    if (event.data instanceof Blob) {\n        data = JSON.parse(await event.data.text());\n    } else {\n        data = JSON.parse(event.data);\n    }\n    Object.assign(serverMessage, data);\n    onmessage(serverMessage);\n}\n/**\n   LiveMusic class encapsulates the configuration for live music\n   generation via Lyria Live models.\n\n   @experimental\n  */ class LiveMusic {\n    /**\n       Establishes a connection to the specified model and returns a\n       LiveMusicSession object representing that connection.\n  \n       @experimental\n  \n       @remarks\n  \n       @param params - The parameters for establishing a connection to the model.\n       @return A live session.\n  \n       @example\n       ```ts\n       let model = 'models/lyria-realtime-exp';\n       const session = await ai.live.music.connect({\n         model: model,\n         callbacks: {\n           onmessage: (e: MessageEvent) => {\n             console.log('Received message from the server: %s\\n', debug(e.data));\n           },\n           onerror: (e: ErrorEvent) => {\n             console.log('Error occurred: %s\\n', debug(e.error));\n           },\n           onclose: (e: CloseEvent) => {\n             console.log('Connection closed.');\n           },\n         },\n       });\n       ```\n      */ async connect(params) {\n        var _a, _b;\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"Live music is not supported for Vertex AI.\");\n        }\n        console.warn(\"Live music generation is experimental and may change in future versions.\");\n        const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();\n        const apiVersion = this.apiClient.getApiVersion();\n        const headers = mapToHeaders$1(this.apiClient.getDefaultHeaders());\n        const apiKey = this.apiClient.getApiKey();\n        const url = \"\".concat(websocketBaseUrl, \"/ws/google.ai.generativelanguage.\").concat(apiVersion, \".GenerativeService.BidiGenerateMusic?key=\").concat(apiKey);\n        let onopenResolve = ()=>{};\n        const onopenPromise = new Promise((resolve)=>{\n            onopenResolve = resolve;\n        });\n        const callbacks = params.callbacks;\n        const onopenAwaitedCallback = function() {\n            onopenResolve({});\n        };\n        const apiClient = this.apiClient;\n        const websocketCallbacks = {\n            onopen: onopenAwaitedCallback,\n            onmessage: (event)=>{\n                void handleWebSocketMessage$1(apiClient, callbacks.onmessage, event);\n            },\n            onerror: (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a !== void 0 ? _a : function(e) {},\n            onclose: (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b !== void 0 ? _b : function(e) {}\n        };\n        const conn = this.webSocketFactory.create(url, headersToMap$1(headers), websocketCallbacks);\n        conn.connect();\n        // Wait for the websocket to open before sending requests.\n        await onopenPromise;\n        const model = tModel(this.apiClient, params.model);\n        const setup = {\n            model\n        };\n        const clientMessage = {\n            setup\n        };\n        conn.send(JSON.stringify(clientMessage));\n        return new LiveMusicSession(conn, this.apiClient);\n    }\n    constructor(apiClient, auth, webSocketFactory){\n        this.apiClient = apiClient;\n        this.auth = auth;\n        this.webSocketFactory = webSocketFactory;\n    }\n}\n/**\n   Represents a connection to the API.\n\n   @experimental\n  */ class LiveMusicSession {\n    /**\n      Sets inputs to steer music generation. Updates the session's current\n      weighted prompts.\n  \n      @param params - Contains one property, `weightedPrompts`.\n  \n        - `weightedPrompts` to send to the model; weights are normalized to\n          sum to 1.0.\n  \n      @experimental\n     */ async setWeightedPrompts(params) {\n        if (!params.weightedPrompts || Object.keys(params.weightedPrompts).length === 0) {\n            throw new Error(\"Weighted prompts must be set and contain at least one entry.\");\n        }\n        const clientContent = liveMusicSetWeightedPromptsParametersToMldev(params);\n        this.conn.send(JSON.stringify({\n            clientContent\n        }));\n    }\n    /**\n      Sets a configuration to the model. Updates the session's current\n      music generation config.\n  \n      @param params - Contains one property, `musicGenerationConfig`.\n  \n        - `musicGenerationConfig` to set in the model. Passing an empty or\n      undefined config to the model will reset the config to defaults.\n  \n      @experimental\n     */ async setMusicGenerationConfig(params) {\n        if (!params.musicGenerationConfig) {\n            params.musicGenerationConfig = {};\n        }\n        const setConfigParameters = liveMusicSetConfigParametersToMldev(params);\n        this.conn.send(JSON.stringify(setConfigParameters));\n    }\n    sendPlaybackControl(playbackControl) {\n        const clientMessage = {\n            playbackControl\n        };\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n     * Start the music stream.\n     *\n     * @experimental\n     */ play() {\n        this.sendPlaybackControl(LiveMusicPlaybackControl.PLAY);\n    }\n    /**\n     * Temporarily halt the music stream. Use `play` to resume from the current\n     * position.\n     *\n     * @experimental\n     */ pause() {\n        this.sendPlaybackControl(LiveMusicPlaybackControl.PAUSE);\n    }\n    /**\n     * Stop the music stream and reset the state. Retains the current prompts\n     * and config.\n     *\n     * @experimental\n     */ stop() {\n        this.sendPlaybackControl(LiveMusicPlaybackControl.STOP);\n    }\n    /**\n     * Resets the context of the music generation without stopping it.\n     * Retains the current prompts and config.\n     *\n     * @experimental\n     */ resetContext() {\n        this.sendPlaybackControl(LiveMusicPlaybackControl.RESET_CONTEXT);\n    }\n    /**\n       Terminates the WebSocket connection.\n  \n       @experimental\n     */ close() {\n        this.conn.close();\n    }\n    constructor(conn, apiClient){\n        this.conn = conn;\n        this.apiClient = apiClient;\n    }\n}\n// Converts an headers object to a \"map\" object as expected by the WebSocket\n// constructor. We use this as the Auth interface works with Headers objects\n// while the WebSocket constructor takes a map.\nfunction headersToMap$1(headers) {\n    const headerMap = {};\n    headers.forEach((value, key)=>{\n        headerMap[key] = value;\n    });\n    return headerMap;\n}\n// Converts a \"map\" object to a headers object. We use this as the Auth\n// interface works with Headers objects while the API client default headers\n// returns a map.\nfunction mapToHeaders$1(map) {\n    const headers = new Headers();\n    for (const [key, value] of Object.entries(map)){\n        headers.append(key, value);\n    }\n    return headers;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ const FUNCTION_RESPONSE_REQUIRES_ID = \"FunctionResponse request must have an `id` field from the response of a ToolCall.FunctionalCalls in Google AI.\";\n/**\n * Handles incoming messages from the WebSocket.\n *\n * @remarks\n * This function is responsible for parsing incoming messages, transforming them\n * into LiveServerMessages, and then calling the onmessage callback. Note that\n * the first message which is received from the server is a setupComplete\n * message.\n *\n * @param apiClient The ApiClient instance.\n * @param onmessage The user-provided onmessage callback (if any).\n * @param event The MessageEvent from the WebSocket.\n */ async function handleWebSocketMessage(apiClient, onmessage, event) {\n    const serverMessage = new LiveServerMessage();\n    let jsonData;\n    if (event.data instanceof Blob) {\n        jsonData = await event.data.text();\n    } else if (event.data instanceof ArrayBuffer) {\n        jsonData = new TextDecoder().decode(event.data);\n    } else {\n        jsonData = event.data;\n    }\n    const data = JSON.parse(jsonData);\n    if (apiClient.isVertexAI()) {\n        const resp = liveServerMessageFromVertex(data);\n        Object.assign(serverMessage, resp);\n    } else {\n        const resp = data;\n        Object.assign(serverMessage, resp);\n    }\n    onmessage(serverMessage);\n}\n/**\n   Live class encapsulates the configuration for live interaction with the\n   Generative Language API. It embeds ApiClient for general API settings.\n\n   @experimental\n  */ class Live {\n    /**\n       Establishes a connection to the specified model with the given\n       configuration and returns a Session object representing that connection.\n  \n       @experimental Built-in MCP support is an experimental feature, may change in\n       future versions.\n  \n       @remarks\n  \n       @param params - The parameters for establishing a connection to the model.\n       @return A live session.\n  \n       @example\n       ```ts\n       let model: string;\n       if (GOOGLE_GENAI_USE_VERTEXAI) {\n         model = 'gemini-2.0-flash-live-preview-04-09';\n       } else {\n         model = 'gemini-live-2.5-flash-preview';\n       }\n       const session = await ai.live.connect({\n         model: model,\n         config: {\n           responseModalities: [Modality.AUDIO],\n         },\n         callbacks: {\n           onopen: () => {\n             console.log('Connected to the socket.');\n           },\n           onmessage: (e: MessageEvent) => {\n             console.log('Received message from the server: %s\\n', debug(e.data));\n           },\n           onerror: (e: ErrorEvent) => {\n             console.log('Error occurred: %s\\n', debug(e.error));\n           },\n           onclose: (e: CloseEvent) => {\n             console.log('Connection closed.');\n           },\n         },\n       });\n       ```\n      */ async connect(params) {\n        var _a, _b, _c, _d, _e, _f;\n        // TODO: b/404946746 - Support per request HTTP options.\n        if (params.config && params.config.httpOptions) {\n            throw new Error(\"The Live module does not support httpOptions at request-level in\" + \" LiveConnectConfig yet. Please use the client-level httpOptions\" + \" configuration instead.\");\n        }\n        const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();\n        const apiVersion = this.apiClient.getApiVersion();\n        let url;\n        const clientHeaders = this.apiClient.getHeaders();\n        if (params.config && params.config.tools && hasMcpToolUsage(params.config.tools)) {\n            setMcpUsageHeader(clientHeaders);\n        }\n        const headers = mapToHeaders(clientHeaders);\n        if (this.apiClient.isVertexAI()) {\n            url = \"\".concat(websocketBaseUrl, \"/ws/google.cloud.aiplatform.\").concat(apiVersion, \".LlmBidiService/BidiGenerateContent\");\n            await this.auth.addAuthHeaders(headers, url);\n        } else {\n            const apiKey = this.apiClient.getApiKey();\n            let method = \"BidiGenerateContent\";\n            let keyName = \"key\";\n            if (apiKey === null || apiKey === void 0 ? void 0 : apiKey.startsWith(\"auth_tokens/\")) {\n                console.warn(\"Warning: Ephemeral token support is experimental and may change in future versions.\");\n                if (apiVersion !== \"v1alpha\") {\n                    console.warn(\"Warning: The SDK's ephemeral token support is in v1alpha only. Please use const ai = new GoogleGenAI({apiKey: token.name, httpOptions: { apiVersion: 'v1alpha' }}); before session connection.\");\n                }\n                method = \"BidiGenerateContentConstrained\";\n                keyName = \"access_token\";\n            }\n            url = \"\".concat(websocketBaseUrl, \"/ws/google.ai.generativelanguage.\").concat(apiVersion, \".GenerativeService.\").concat(method, \"?\").concat(keyName, \"=\").concat(apiKey);\n        }\n        let onopenResolve = ()=>{};\n        const onopenPromise = new Promise((resolve)=>{\n            onopenResolve = resolve;\n        });\n        const callbacks = params.callbacks;\n        const onopenAwaitedCallback = function() {\n            var _a;\n            (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onopen) === null || _a === void 0 ? void 0 : _a.call(callbacks);\n            onopenResolve({});\n        };\n        const apiClient = this.apiClient;\n        const websocketCallbacks = {\n            onopen: onopenAwaitedCallback,\n            onmessage: (event)=>{\n                void handleWebSocketMessage(apiClient, callbacks.onmessage, event);\n            },\n            onerror: (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a !== void 0 ? _a : function(e) {},\n            onclose: (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b !== void 0 ? _b : function(e) {}\n        };\n        const conn = this.webSocketFactory.create(url, headersToMap(headers), websocketCallbacks);\n        conn.connect();\n        // Wait for the websocket to open before sending requests.\n        await onopenPromise;\n        let transformedModel = tModel(this.apiClient, params.model);\n        if (this.apiClient.isVertexAI() && transformedModel.startsWith(\"publishers/\")) {\n            const project = this.apiClient.getProject();\n            const location = this.apiClient.getLocation();\n            transformedModel = \"projects/\".concat(project, \"/locations/\").concat(location, \"/\") + transformedModel;\n        }\n        let clientMessage = {};\n        if (this.apiClient.isVertexAI() && ((_c = params.config) === null || _c === void 0 ? void 0 : _c.responseModalities) === undefined) {\n            // Set default to AUDIO to align with MLDev API.\n            if (params.config === undefined) {\n                params.config = {\n                    responseModalities: [\n                        Modality.AUDIO\n                    ]\n                };\n            } else {\n                params.config.responseModalities = [\n                    Modality.AUDIO\n                ];\n            }\n        }\n        if ((_d = params.config) === null || _d === void 0 ? void 0 : _d.generationConfig) {\n            // Raise deprecation warning for generationConfig.\n            console.warn(\"Setting `LiveConnectConfig.generation_config` is deprecated, please set the fields on `LiveConnectConfig` directly. This will become an error in a future version (not before Q3 2025).\");\n        }\n        const inputTools = (_f = (_e = params.config) === null || _e === void 0 ? void 0 : _e.tools) !== null && _f !== void 0 ? _f : [];\n        const convertedTools = [];\n        for (const tool of inputTools){\n            if (this.isCallableTool(tool)) {\n                const callableTool = tool;\n                convertedTools.push(await callableTool.tool());\n            } else {\n                convertedTools.push(tool);\n            }\n        }\n        if (convertedTools.length > 0) {\n            params.config.tools = convertedTools;\n        }\n        const liveConnectParameters = {\n            model: transformedModel,\n            config: params.config,\n            callbacks: params.callbacks\n        };\n        if (this.apiClient.isVertexAI()) {\n            clientMessage = liveConnectParametersToVertex(this.apiClient, liveConnectParameters);\n        } else {\n            clientMessage = liveConnectParametersToMldev(this.apiClient, liveConnectParameters);\n        }\n        delete clientMessage[\"config\"];\n        conn.send(JSON.stringify(clientMessage));\n        return new Session(conn, this.apiClient);\n    }\n    // TODO: b/416041229 - Abstract this method to a common place.\n    isCallableTool(tool) {\n        return \"callTool\" in tool && typeof tool.callTool === \"function\";\n    }\n    constructor(apiClient, auth, webSocketFactory){\n        this.apiClient = apiClient;\n        this.auth = auth;\n        this.webSocketFactory = webSocketFactory;\n        this.music = new LiveMusic(this.apiClient, this.auth, this.webSocketFactory);\n    }\n}\nconst defaultLiveSendClientContentParamerters = {\n    turnComplete: true\n};\n/**\n   Represents a connection to the API.\n\n   @experimental\n  */ class Session {\n    tLiveClientContent(apiClient, params) {\n        if (params.turns !== null && params.turns !== undefined) {\n            let contents = [];\n            try {\n                contents = tContents(params.turns);\n                if (!apiClient.isVertexAI()) {\n                    contents = contents.map((item)=>contentToMldev$1(item));\n                }\n            } catch (_a) {\n                throw new Error('Failed to parse client content \"turns\", type: \\''.concat(typeof params.turns, \"'\"));\n            }\n            return {\n                clientContent: {\n                    turns: contents,\n                    turnComplete: params.turnComplete\n                }\n            };\n        }\n        return {\n            clientContent: {\n                turnComplete: params.turnComplete\n            }\n        };\n    }\n    tLiveClienttToolResponse(apiClient, params) {\n        let functionResponses = [];\n        if (params.functionResponses == null) {\n            throw new Error(\"functionResponses is required.\");\n        }\n        if (!Array.isArray(params.functionResponses)) {\n            functionResponses = [\n                params.functionResponses\n            ];\n        } else {\n            functionResponses = params.functionResponses;\n        }\n        if (functionResponses.length === 0) {\n            throw new Error(\"functionResponses is required.\");\n        }\n        for (const functionResponse of functionResponses){\n            if (typeof functionResponse !== \"object\" || functionResponse === null || !(\"name\" in functionResponse) || !(\"response\" in functionResponse)) {\n                throw new Error(\"Could not parse function response, type '\".concat(typeof functionResponse, \"'.\"));\n            }\n            if (!apiClient.isVertexAI() && !(\"id\" in functionResponse)) {\n                throw new Error(FUNCTION_RESPONSE_REQUIRES_ID);\n            }\n        }\n        const clientMessage = {\n            toolResponse: {\n                functionResponses: functionResponses\n            }\n        };\n        return clientMessage;\n    }\n    /**\n      Send a message over the established connection.\n  \n      @param params - Contains two **optional** properties, `turns` and\n          `turnComplete`.\n  \n        - `turns` will be converted to a `Content[]`\n        - `turnComplete: true` [default] indicates that you are done sending\n          content and expect a response. If `turnComplete: false`, the server\n          will wait for additional messages before starting generation.\n  \n      @experimental\n  \n      @remarks\n      There are two ways to send messages to the live API:\n      `sendClientContent` and `sendRealtimeInput`.\n  \n      `sendClientContent` messages are added to the model context **in order**.\n      Having a conversation using `sendClientContent` messages is roughly\n      equivalent to using the `Chat.sendMessageStream`, except that the state of\n      the `chat` history is stored on the API server instead of locally.\n  \n      Because of `sendClientContent`'s order guarantee, the model cannot respons\n      as quickly to `sendClientContent` messages as to `sendRealtimeInput`\n      messages. This makes the biggest difference when sending objects that have\n      significant preprocessing time (typically images).\n  \n      The `sendClientContent` message sends a `Content[]`\n      which has more options than the `Blob` sent by `sendRealtimeInput`.\n  \n      So the main use-cases for `sendClientContent` over `sendRealtimeInput` are:\n  \n      - Sending anything that can't be represented as a `Blob` (text,\n      `sendClientContent({turns=\"Hello?\"}`)).\n      - Managing turns when not using audio input and voice activity detection.\n        (`sendClientContent({turnComplete:true})` or the short form\n      `sendClientContent()`)\n      - Prefilling a conversation context\n        ```\n        sendClientContent({\n            turns: [\n              Content({role:user, parts:...}),\n              Content({role:user, parts:...}),\n              ...\n            ]\n        })\n        ```\n      @experimental\n     */ sendClientContent(params) {\n        params = Object.assign(Object.assign({}, defaultLiveSendClientContentParamerters), params);\n        const clientMessage = this.tLiveClientContent(this.apiClient, params);\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n      Send a realtime message over the established connection.\n  \n      @param params - Contains one property, `media`.\n  \n        - `media` will be converted to a `Blob`\n  \n      @experimental\n  \n      @remarks\n      Use `sendRealtimeInput` for realtime audio chunks and video frames (images).\n  \n      With `sendRealtimeInput` the api will respond to audio automatically\n      based on voice activity detection (VAD).\n  \n      `sendRealtimeInput` is optimized for responsivness at the expense of\n      deterministic ordering guarantees. Audio and video tokens are to the\n      context when they become available.\n  \n      Note: The Call signature expects a `Blob` object, but only a subset\n      of audio and image mimetypes are allowed.\n     */ sendRealtimeInput(params) {\n        let clientMessage = {};\n        if (this.apiClient.isVertexAI()) {\n            clientMessage = {\n                \"realtimeInput\": liveSendRealtimeInputParametersToVertex(params)\n            };\n        } else {\n            clientMessage = {\n                \"realtimeInput\": liveSendRealtimeInputParametersToMldev(params)\n            };\n        }\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n      Send a function response message over the established connection.\n  \n      @param params - Contains property `functionResponses`.\n  \n        - `functionResponses` will be converted to a `functionResponses[]`\n  \n      @remarks\n      Use `sendFunctionResponse` to reply to `LiveServerToolCall` from the server.\n  \n      Use {@link types.LiveConnectConfig#tools} to configure the callable functions.\n  \n      @experimental\n     */ sendToolResponse(params) {\n        if (params.functionResponses == null) {\n            throw new Error(\"Tool response parameters are required.\");\n        }\n        const clientMessage = this.tLiveClienttToolResponse(this.apiClient, params);\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n       Terminates the WebSocket connection.\n  \n       @experimental\n  \n       @example\n       ```ts\n       let model: string;\n       if (GOOGLE_GENAI_USE_VERTEXAI) {\n         model = 'gemini-2.0-flash-live-preview-04-09';\n       } else {\n         model = 'gemini-live-2.5-flash-preview';\n       }\n       const session = await ai.live.connect({\n         model: model,\n         config: {\n           responseModalities: [Modality.AUDIO],\n         }\n       });\n  \n       session.close();\n       ```\n     */ close() {\n        this.conn.close();\n    }\n    constructor(conn, apiClient){\n        this.conn = conn;\n        this.apiClient = apiClient;\n    }\n}\n// Converts an headers object to a \"map\" object as expected by the WebSocket\n// constructor. We use this as the Auth interface works with Headers objects\n// while the WebSocket constructor takes a map.\nfunction headersToMap(headers) {\n    const headerMap = {};\n    headers.forEach((value, key)=>{\n        headerMap[key] = value;\n    });\n    return headerMap;\n}\n// Converts a \"map\" object to a headers object. We use this as the Auth\n// interface works with Headers objects while the API client default headers\n// returns a map.\nfunction mapToHeaders(map) {\n    const headers = new Headers();\n    for (const [key, value] of Object.entries(map)){\n        headers.append(key, value);\n    }\n    return headers;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ const DEFAULT_MAX_REMOTE_CALLS = 10;\n/** Returns whether automatic function calling is disabled. */ function shouldDisableAfc(config) {\n    var _a, _b, _c;\n    if ((_a = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _a === void 0 ? void 0 : _a.disable) {\n        return true;\n    }\n    let callableToolsPresent = false;\n    for (const tool of (_b = config === null || config === void 0 ? void 0 : config.tools) !== null && _b !== void 0 ? _b : []){\n        if (isCallableTool(tool)) {\n            callableToolsPresent = true;\n            break;\n        }\n    }\n    if (!callableToolsPresent) {\n        return true;\n    }\n    const maxCalls = (_c = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _c === void 0 ? void 0 : _c.maximumRemoteCalls;\n    if (maxCalls && (maxCalls < 0 || !Number.isInteger(maxCalls)) || maxCalls == 0) {\n        console.warn(\"Invalid maximumRemoteCalls value provided for automatic function calling. Disabled automatic function calling. Please provide a valid integer value greater than 0. maximumRemoteCalls provided:\", maxCalls);\n        return true;\n    }\n    return false;\n}\nfunction isCallableTool(tool) {\n    return \"callTool\" in tool && typeof tool.callTool === \"function\";\n}\n// Checks whether the list of tools contains any CallableTools. Will return true\n// if there is at least one CallableTool.\nfunction hasCallableTools(params) {\n    var _a, _b, _c;\n    return (_c = (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools) === null || _b === void 0 ? void 0 : _b.some((tool)=>isCallableTool(tool))) !== null && _c !== void 0 ? _c : false;\n}\n/**\n * Returns the indexes of the tools that are not compatible with AFC.\n */ function findAfcIncompatibleToolIndexes(params) {\n    var _a;\n    // Use number[] for an array of numbers in TypeScript\n    const afcIncompatibleToolIndexes = [];\n    if (!((_a = params === null || params === void 0 ? void 0 : params.config) === null || _a === void 0 ? void 0 : _a.tools)) {\n        return afcIncompatibleToolIndexes;\n    }\n    params.config.tools.forEach((tool, index)=>{\n        if (isCallableTool(tool)) {\n            return;\n        }\n        const geminiTool = tool;\n        if (geminiTool.functionDeclarations && geminiTool.functionDeclarations.length > 0) {\n            afcIncompatibleToolIndexes.push(index);\n        }\n    });\n    return afcIncompatibleToolIndexes;\n}\n/**\n * Returns whether to append automatic function calling history to the\n * response.\n */ function shouldAppendAfcHistory(config) {\n    var _a;\n    return !((_a = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _a === void 0 ? void 0 : _a.ignoreCallHistory);\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Models extends BaseModule {\n    /**\n     * This logic is needed for GenerateContentConfig only.\n     * Previously we made GenerateContentConfig.responseSchema field to accept\n     * unknown. Since v1.9.0, we switch to use backend JSON schema support.\n     * To maintain backward compatibility, we move the data that was treated as\n     * JSON schema from the responseSchema field to the responseJsonSchema field.\n     */ maybeMoveToResponseJsonSchem(params) {\n        if (params.config && params.config.responseSchema) {\n            if (!params.config.responseJsonSchema) {\n                if (Object.keys(params.config.responseSchema).includes(\"$schema\")) {\n                    params.config.responseJsonSchema = params.config.responseSchema;\n                    delete params.config.responseSchema;\n                }\n            }\n        }\n        return;\n    }\n    /**\n     * Transforms the CallableTools in the parameters to be simply Tools, it\n     * copies the params into a new object and replaces the tools, it does not\n     * modify the original params. Also sets the MCP usage header if there are\n     * MCP tools in the parameters.\n     */ async processParamsMaybeAddMcpUsage(params) {\n        var _a, _b, _c;\n        const tools = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools;\n        if (!tools) {\n            return params;\n        }\n        const transformedTools = await Promise.all(tools.map(async (tool)=>{\n            if (isCallableTool(tool)) {\n                const callableTool = tool;\n                return await callableTool.tool();\n            }\n            return tool;\n        }));\n        const newParams = {\n            model: params.model,\n            contents: params.contents,\n            config: Object.assign(Object.assign({}, params.config), {\n                tools: transformedTools\n            })\n        };\n        newParams.config.tools = transformedTools;\n        if (params.config && params.config.tools && hasMcpToolUsage(params.config.tools)) {\n            const headers = (_c = (_b = params.config.httpOptions) === null || _b === void 0 ? void 0 : _b.headers) !== null && _c !== void 0 ? _c : {};\n            let newHeaders = Object.assign({}, headers);\n            if (Object.keys(newHeaders).length === 0) {\n                newHeaders = this.apiClient.getDefaultHeaders();\n            }\n            setMcpUsageHeader(newHeaders);\n            newParams.config.httpOptions = Object.assign(Object.assign({}, params.config.httpOptions), {\n                headers: newHeaders\n            });\n        }\n        return newParams;\n    }\n    async initAfcToolsMap(params) {\n        var _a, _b, _c;\n        const afcTools = new Map();\n        for (const tool of (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools) !== null && _b !== void 0 ? _b : []){\n            if (isCallableTool(tool)) {\n                const callableTool = tool;\n                const toolDeclaration = await callableTool.tool();\n                for (const declaration of (_c = toolDeclaration.functionDeclarations) !== null && _c !== void 0 ? _c : []){\n                    if (!declaration.name) {\n                        throw new Error(\"Function declaration name is required.\");\n                    }\n                    if (afcTools.has(declaration.name)) {\n                        throw new Error(\"Duplicate tool declaration name: \".concat(declaration.name));\n                    }\n                    afcTools.set(declaration.name, callableTool);\n                }\n            }\n        }\n        return afcTools;\n    }\n    async processAfcStream(params) {\n        var _a, _b, _c;\n        const maxRemoteCalls = (_c = (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.automaticFunctionCalling) === null || _b === void 0 ? void 0 : _b.maximumRemoteCalls) !== null && _c !== void 0 ? _c : DEFAULT_MAX_REMOTE_CALLS;\n        let wereFunctionsCalled = false;\n        let remoteCallCount = 0;\n        const afcToolsMap = await this.initAfcToolsMap(params);\n        return function(models, afcTools, params) {\n            var _a, _b;\n            return __asyncGenerator(this, arguments, function*() {\n                var _c, e_1, _d, _e;\n                while(remoteCallCount < maxRemoteCalls){\n                    if (wereFunctionsCalled) {\n                        remoteCallCount++;\n                        wereFunctionsCalled = false;\n                    }\n                    const transformedParams = yield __await(models.processParamsMaybeAddMcpUsage(params));\n                    const response = yield __await(models.generateContentStreamInternal(transformedParams));\n                    const functionResponses = [];\n                    const responseContents = [];\n                    try {\n                        for(var _f = true, response_1 = (e_1 = void 0, __asyncValues(response)), response_1_1; response_1_1 = yield __await(response_1.next()), _c = response_1_1.done, !_c; _f = true){\n                            _e = response_1_1.value;\n                            _f = false;\n                            const chunk = _e;\n                            yield yield __await(chunk);\n                            if (chunk.candidates && ((_a = chunk.candidates[0]) === null || _a === void 0 ? void 0 : _a.content)) {\n                                responseContents.push(chunk.candidates[0].content);\n                                for (const part of (_b = chunk.candidates[0].content.parts) !== null && _b !== void 0 ? _b : []){\n                                    if (remoteCallCount < maxRemoteCalls && part.functionCall) {\n                                        if (!part.functionCall.name) {\n                                            throw new Error(\"Function call name was not returned by the model.\");\n                                        }\n                                        if (!afcTools.has(part.functionCall.name)) {\n                                            throw new Error(\"Automatic function calling was requested, but not all the tools the model used implement the CallableTool interface. Available tools: \".concat(afcTools.keys(), \", mising tool: \").concat(part.functionCall.name));\n                                        } else {\n                                            const responseParts = yield __await(afcTools.get(part.functionCall.name).callTool([\n                                                part.functionCall\n                                            ]));\n                                            functionResponses.push(...responseParts);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    } catch (e_1_1) {\n                        e_1 = {\n                            error: e_1_1\n                        };\n                    } finally{\n                        try {\n                            if (!_f && !_c && (_d = response_1.return)) yield __await(_d.call(response_1));\n                        } finally{\n                            if (e_1) throw e_1.error;\n                        }\n                    }\n                    if (functionResponses.length > 0) {\n                        wereFunctionsCalled = true;\n                        const typedResponseChunk = new GenerateContentResponse();\n                        typedResponseChunk.candidates = [\n                            {\n                                content: {\n                                    role: \"user\",\n                                    parts: functionResponses\n                                }\n                            }\n                        ];\n                        yield yield __await(typedResponseChunk);\n                        const newContents = [];\n                        newContents.push(...responseContents);\n                        newContents.push({\n                            role: \"user\",\n                            parts: functionResponses\n                        });\n                        const updatedContents = tContents(params.contents).concat(newContents);\n                        params.contents = updatedContents;\n                    } else {\n                        break;\n                    }\n                }\n            });\n        }(this, afcToolsMap, params);\n    }\n    async generateContentInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:generateContent\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateContentResponseFromVertex(apiResponse);\n                const typedResp = new GenerateContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = generateContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:generateContent\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateContentResponseFromMldev(apiResponse);\n                const typedResp = new GenerateContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    async generateContentStreamInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:streamGenerateContent?alt=sse\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            const apiClient = this.apiClient;\n            response = apiClient.requestStream({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            });\n            return response.then(function(apiResponse) {\n                return __asyncGenerator(this, arguments, function*() {\n                    var _a, e_2, _b, _c;\n                    try {\n                        for(var _d = true, apiResponse_1 = __asyncValues(apiResponse), apiResponse_1_1; apiResponse_1_1 = yield __await(apiResponse_1.next()), _a = apiResponse_1_1.done, !_a; _d = true){\n                            _c = apiResponse_1_1.value;\n                            _d = false;\n                            const chunk = _c;\n                            const resp = generateContentResponseFromVertex((yield __await(chunk.json())));\n                            resp[\"sdkHttpResponse\"] = {\n                                headers: chunk.headers\n                            };\n                            const typedResp = new GenerateContentResponse();\n                            Object.assign(typedResp, resp);\n                            yield yield __await(typedResp);\n                        }\n                    } catch (e_2_1) {\n                        e_2 = {\n                            error: e_2_1\n                        };\n                    } finally{\n                        try {\n                            if (!_d && !_a && (_b = apiResponse_1.return)) yield __await(_b.call(apiResponse_1));\n                        } finally{\n                            if (e_2) throw e_2.error;\n                        }\n                    }\n                });\n            });\n        } else {\n            const body = generateContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:streamGenerateContent?alt=sse\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            const apiClient = this.apiClient;\n            response = apiClient.requestStream({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            });\n            return response.then(function(apiResponse) {\n                return __asyncGenerator(this, arguments, function*() {\n                    var _a, e_3, _b, _c;\n                    try {\n                        for(var _d = true, apiResponse_2 = __asyncValues(apiResponse), apiResponse_2_1; apiResponse_2_1 = yield __await(apiResponse_2.next()), _a = apiResponse_2_1.done, !_a; _d = true){\n                            _c = apiResponse_2_1.value;\n                            _d = false;\n                            const chunk = _c;\n                            const resp = generateContentResponseFromMldev((yield __await(chunk.json())));\n                            resp[\"sdkHttpResponse\"] = {\n                                headers: chunk.headers\n                            };\n                            const typedResp = new GenerateContentResponse();\n                            Object.assign(typedResp, resp);\n                            yield yield __await(typedResp);\n                        }\n                    } catch (e_3_1) {\n                        e_3 = {\n                            error: e_3_1\n                        };\n                    } finally{\n                        try {\n                            if (!_d && !_a && (_b = apiResponse_2.return)) yield __await(_b.call(apiResponse_2));\n                        } finally{\n                            if (e_3) throw e_3.error;\n                        }\n                    }\n                });\n            });\n        }\n    }\n    /**\n     * Calculates embeddings for the given contents. Only text is supported.\n     *\n     * @param params - The parameters for embedding contents.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.embedContent({\n     *  model: 'text-embedding-004',\n     *  contents: [\n     *    'What is your name?',\n     *    'What is your favorite color?',\n     *  ],\n     *  config: {\n     *    outputDimensionality: 64,\n     *  },\n     * });\n     * console.log(response);\n     * ```\n     */ async embedContent(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = embedContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = embedContentResponseFromVertex(apiResponse);\n                const typedResp = new EmbedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = embedContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:batchEmbedContents\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = embedContentResponseFromMldev(apiResponse);\n                const typedResp = new EmbedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Private method for generating images.\n     */ async generateImagesInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateImagesParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateImagesResponseFromVertex(apiResponse);\n                const typedResp = new GenerateImagesResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = generateImagesParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateImagesResponseFromMldev(apiResponse);\n                const typedResp = new GenerateImagesResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Private method for editing an image.\n     */ async editImageInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = editImageParametersInternalToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = editImageResponseFromVertex(apiResponse);\n                const typedResp = new EditImageResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n    /**\n     * Private method for upscaling an image.\n     */ async upscaleImageInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = upscaleImageAPIParametersInternalToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = upscaleImageResponseFromVertex(apiResponse);\n                const typedResp = new UpscaleImageResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n    /**\n     * Recontextualizes an image.\n     *\n     * There are two types of recontextualization currently supported:\n     * 1) Imagen Product Recontext - Generate images of products in new scenes\n     *    and contexts.\n     * 2) Virtual Try-On: Generate images of persons modeling fashion products.\n     *\n     * @param params - The parameters for recontextualizing an image.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response1 = await ai.models.recontextImage({\n     *  model: 'imagen-product-recontext-preview-06-30',\n     *  source: {\n     *    prompt: 'In a modern kitchen setting.',\n     *    productImages: [productImage],\n     *  },\n     *  config: {\n     *    numberOfImages: 1,\n     *  },\n     * });\n     * console.log(response1?.generatedImages?.[0]?.image?.imageBytes);\n     *\n     * const response2 = await ai.models.recontextImage({\n     *  model: 'virtual-try-on-preview-08-04',\n     *  source: {\n     *    personImage: personImage,\n     *    productImages: [productImage],\n     *  },\n     *  config: {\n     *    numberOfImages: 1,\n     *  },\n     * });\n     * console.log(response2?.generatedImages?.[0]?.image?.imageBytes);\n     * ```\n     */ async recontextImage(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = recontextImageParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = recontextImageResponseFromVertex(apiResponse);\n                const typedResp = new RecontextImageResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n    /**\n     * Segments an image, creating a mask of a specified area.\n     *\n     * @param params - The parameters for segmenting an image.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.segmentImage({\n     *  model: 'image-segmentation-001',\n     *  source: {\n     *    image: image,\n     *  },\n     *  config: {\n     *    mode: 'foreground',\n     *  },\n     * });\n     * console.log(response?.generatedMasks?.[0]?.mask?.imageBytes);\n     * ```\n     */ async segmentImage(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = segmentImageParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = segmentImageResponseFromVertex(apiResponse);\n                const typedResp = new SegmentImageResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n    /**\n     * Fetches information about a model by name.\n     *\n     * @example\n     * ```ts\n     * const modelInfo = await ai.models.get({model: 'gemini-2.0-flash'});\n     * ```\n     */ async get(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getModelParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = modelFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = getModelParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = modelFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = listModelsParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{models_url}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listModelsResponseFromVertex(apiResponse);\n                const typedResp = new ListModelsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = listModelsParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{models_url}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listModelsResponseFromMldev(apiResponse);\n                const typedResp = new ListModelsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Updates a tuned model by its name.\n     *\n     * @param params - The parameters for updating the model.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.update({\n     *   model: 'tuned-model-name',\n     *   config: {\n     *     displayName: 'New display name',\n     *     description: 'New description',\n     *   },\n     * });\n     * ```\n     */ async update(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = updateModelParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"PATCH\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = modelFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = updateModelParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"PATCH\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = modelFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes a tuned model by its name.\n     *\n     * @param params - The parameters for deleting the model.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.delete({model: 'tuned-model-name'});\n     * ```\n     */ async delete(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = deleteModelParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = deleteModelResponseFromVertex(apiResponse);\n                const typedResp = new DeleteModelResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = deleteModelParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = deleteModelResponseFromMldev(apiResponse);\n                const typedResp = new DeleteModelResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Counts the number of tokens in the given contents. Multimodal input is\n     * supported for Gemini models.\n     *\n     * @param params - The parameters for counting tokens.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.countTokens({\n     *  model: 'gemini-2.0-flash',\n     *  contents: 'The quick brown fox jumps over the lazy dog.'\n     * });\n     * console.log(response);\n     * ```\n     */ async countTokens(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = countTokensParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:countTokens\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = countTokensResponseFromVertex(apiResponse);\n                const typedResp = new CountTokensResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = countTokensParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:countTokens\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = countTokensResponseFromMldev(apiResponse);\n                const typedResp = new CountTokensResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Given a list of contents, returns a corresponding TokensInfo containing\n     * the list of tokens and list of token ids.\n     *\n     * This method is not supported by the Gemini Developer API.\n     *\n     * @param params - The parameters for computing tokens.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.computeTokens({\n     *  model: 'gemini-2.0-flash',\n     *  contents: 'What is your name?'\n     * });\n     * console.log(response);\n     * ```\n     */ async computeTokens(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = computeTokensParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:computeTokens\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = computeTokensResponseFromVertex(apiResponse);\n                const typedResp = new ComputeTokensResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n    /**\n     * Private method for generating videos.\n     */ async generateVideosInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateVideosParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predictLongRunning\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateVideosOperationFromVertex(apiResponse);\n                const typedResp = new GenerateVideosOperation();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = generateVideosParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:predictLongRunning\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateVideosOperationFromMldev(apiResponse);\n                const typedResp = new GenerateVideosOperation();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Makes an API request to generate content with a given model.\n         *\n         * For the `model` parameter, supported formats for Vertex AI API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The full resource name starts with 'projects/', for example:\n         *  'projects/my-project-id/locations/us-central1/publishers/google/models/gemini-2.0-flash'\n         * - The partial resource name with 'publishers/', for example:\n         *  'publishers/google/models/gemini-2.0-flash' or\n         *  'publishers/meta/models/llama-3.1-405b-instruct-maas'\n         * - `/` separated publisher and model name, for example:\n         * 'google/gemini-2.0-flash' or 'meta/llama-3.1-405b-instruct-maas'\n         *\n         * For the `model` parameter, supported formats for Gemini API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The model name starts with 'models/', for example:\n         *  'models/gemini-2.0-flash'\n         * - For tuned models, the model name starts with 'tunedModels/',\n         * for example:\n         * 'tunedModels/1234567890123456789'\n         *\n         * Some models support multimodal input and output.\n         *\n         * @param params - The parameters for generating content.\n         * @return The response from generating content.\n         *\n         * @example\n         * ```ts\n         * const response = await ai.models.generateContent({\n         *   model: 'gemini-2.0-flash',\n         *   contents: 'why is the sky blue?',\n         *   config: {\n         *     candidateCount: 2,\n         *   }\n         * });\n         * console.log(response);\n         * ```\n         */ this.generateContent = async (params)=>{\n            var _a, _b, _c, _d, _e;\n            const transformedParams = await this.processParamsMaybeAddMcpUsage(params);\n            this.maybeMoveToResponseJsonSchem(params);\n            if (!hasCallableTools(params) || shouldDisableAfc(params.config)) {\n                return await this.generateContentInternal(transformedParams);\n            }\n            const incompatibleToolIndexes = findAfcIncompatibleToolIndexes(params);\n            if (incompatibleToolIndexes.length > 0) {\n                const formattedIndexes = incompatibleToolIndexes.map((index)=>\"tools[\".concat(index, \"]\")).join(\", \");\n                throw new Error(\"Automatic function calling with CallableTools (or MCP objects) and basic FunctionDeclarations is not yet supported. Incompatible tools found at \".concat(formattedIndexes, \".\"));\n            }\n            let response;\n            let functionResponseContent;\n            const automaticFunctionCallingHistory = tContents(transformedParams.contents);\n            const maxRemoteCalls = (_c = (_b = (_a = transformedParams.config) === null || _a === void 0 ? void 0 : _a.automaticFunctionCalling) === null || _b === void 0 ? void 0 : _b.maximumRemoteCalls) !== null && _c !== void 0 ? _c : DEFAULT_MAX_REMOTE_CALLS;\n            let remoteCalls = 0;\n            while(remoteCalls < maxRemoteCalls){\n                response = await this.generateContentInternal(transformedParams);\n                if (!response.functionCalls || response.functionCalls.length === 0) {\n                    break;\n                }\n                const responseContent = response.candidates[0].content;\n                const functionResponseParts = [];\n                for (const tool of (_e = (_d = params.config) === null || _d === void 0 ? void 0 : _d.tools) !== null && _e !== void 0 ? _e : []){\n                    if (isCallableTool(tool)) {\n                        const callableTool = tool;\n                        const parts = await callableTool.callTool(response.functionCalls);\n                        functionResponseParts.push(...parts);\n                    }\n                }\n                remoteCalls++;\n                functionResponseContent = {\n                    role: \"user\",\n                    parts: functionResponseParts\n                };\n                transformedParams.contents = tContents(transformedParams.contents);\n                transformedParams.contents.push(responseContent);\n                transformedParams.contents.push(functionResponseContent);\n                if (shouldAppendAfcHistory(transformedParams.config)) {\n                    automaticFunctionCallingHistory.push(responseContent);\n                    automaticFunctionCallingHistory.push(functionResponseContent);\n                }\n            }\n            if (shouldAppendAfcHistory(transformedParams.config)) {\n                response.automaticFunctionCallingHistory = automaticFunctionCallingHistory;\n            }\n            return response;\n        };\n        /**\n         * Makes an API request to generate content with a given model and yields the\n         * response in chunks.\n         *\n         * For the `model` parameter, supported formats for Vertex AI API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The full resource name starts with 'projects/', for example:\n         *  'projects/my-project-id/locations/us-central1/publishers/google/models/gemini-2.0-flash'\n         * - The partial resource name with 'publishers/', for example:\n         *  'publishers/google/models/gemini-2.0-flash' or\n         *  'publishers/meta/models/llama-3.1-405b-instruct-maas'\n         * - `/` separated publisher and model name, for example:\n         * 'google/gemini-2.0-flash' or 'meta/llama-3.1-405b-instruct-maas'\n         *\n         * For the `model` parameter, supported formats for Gemini API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The model name starts with 'models/', for example:\n         *  'models/gemini-2.0-flash'\n         * - For tuned models, the model name starts with 'tunedModels/',\n         * for example:\n         *  'tunedModels/1234567890123456789'\n         *\n         * Some models support multimodal input and output.\n         *\n         * @param params - The parameters for generating content with streaming response.\n         * @return The response from generating content.\n         *\n         * @example\n         * ```ts\n         * const response = await ai.models.generateContentStream({\n         *   model: 'gemini-2.0-flash',\n         *   contents: 'why is the sky blue?',\n         *   config: {\n         *     maxOutputTokens: 200,\n         *   }\n         * });\n         * for await (const chunk of response) {\n         *   console.log(chunk);\n         * }\n         * ```\n         */ this.generateContentStream = async (params)=>{\n            var _a, _b, _c, _d, _e;\n            this.maybeMoveToResponseJsonSchem(params);\n            if (shouldDisableAfc(params.config)) {\n                const transformedParams = await this.processParamsMaybeAddMcpUsage(params);\n                return await this.generateContentStreamInternal(transformedParams);\n            }\n            const incompatibleToolIndexes = findAfcIncompatibleToolIndexes(params);\n            if (incompatibleToolIndexes.length > 0) {\n                const formattedIndexes = incompatibleToolIndexes.map((index)=>\"tools[\".concat(index, \"]\")).join(\", \");\n                throw new Error(\"Incompatible tools found at \".concat(formattedIndexes, '. Automatic function calling with CallableTools (or MCP objects) and basic FunctionDeclarations\" is not yet supported.'));\n            }\n            // With tool compatibility confirmed, validate that the configuration are\n            // compatible with each other and raise an error if invalid.\n            const streamFunctionCall = (_c = (_b = (_a = params === null || params === void 0 ? void 0 : params.config) === null || _a === void 0 ? void 0 : _a.toolConfig) === null || _b === void 0 ? void 0 : _b.functionCallingConfig) === null || _c === void 0 ? void 0 : _c.streamFunctionCallArguments;\n            const disableAfc = (_e = (_d = params === null || params === void 0 ? void 0 : params.config) === null || _d === void 0 ? void 0 : _d.automaticFunctionCalling) === null || _e === void 0 ? void 0 : _e.disable;\n            if (streamFunctionCall && !disableAfc) {\n                throw new Error(\"Running in streaming mode with 'streamFunctionCallArguments' enabled, \" + \"this feature is not compatible with automatic function calling (AFC). \" + \"Please set 'config.automaticFunctionCalling.disable' to true to disable AFC \" + \"or leave 'config.toolConfig.functionCallingConfig.streamFunctionCallArguments' \" + \"to be undefined or set to false to disable streaming function call arguments feature.\");\n            }\n            return await this.processAfcStream(params);\n        };\n        /**\n         * Generates an image based on a text description and configuration.\n         *\n         * @param params - The parameters for generating images.\n         * @return The response from the API.\n         *\n         * @example\n         * ```ts\n         * const response = await client.models.generateImages({\n         *  model: 'imagen-3.0-generate-002',\n         *  prompt: 'Robot holding a red skateboard',\n         *  config: {\n         *    numberOfImages: 1,\n         *    includeRaiReason: true,\n         *  },\n         * });\n         * console.log(response?.generatedImages?.[0]?.image?.imageBytes);\n         * ```\n         */ this.generateImages = async (params)=>{\n            return await this.generateImagesInternal(params).then((apiResponse)=>{\n                var _a;\n                let positivePromptSafetyAttributes;\n                const generatedImages = [];\n                if (apiResponse === null || apiResponse === void 0 ? void 0 : apiResponse.generatedImages) {\n                    for (const generatedImage of apiResponse.generatedImages){\n                        if (generatedImage && (generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) && ((_a = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) === null || _a === void 0 ? void 0 : _a.contentType) === \"Positive Prompt\") {\n                            positivePromptSafetyAttributes = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes;\n                        } else {\n                            generatedImages.push(generatedImage);\n                        }\n                    }\n                }\n                let response;\n                if (positivePromptSafetyAttributes) {\n                    response = {\n                        generatedImages: generatedImages,\n                        positivePromptSafetyAttributes: positivePromptSafetyAttributes,\n                        sdkHttpResponse: apiResponse.sdkHttpResponse\n                    };\n                } else {\n                    response = {\n                        generatedImages: generatedImages,\n                        sdkHttpResponse: apiResponse.sdkHttpResponse\n                    };\n                }\n                return response;\n            });\n        };\n        this.list = async (params)=>{\n            var _a;\n            const defaultConfig = {\n                queryBase: true\n            };\n            const actualConfig = Object.assign(Object.assign({}, defaultConfig), params === null || params === void 0 ? void 0 : params.config);\n            const actualParams = {\n                config: actualConfig\n            };\n            if (this.apiClient.isVertexAI()) {\n                if (!actualParams.config.queryBase) {\n                    if ((_a = actualParams.config) === null || _a === void 0 ? void 0 : _a.filter) {\n                        throw new Error(\"Filtering tuned models list for Vertex AI is not currently supported\");\n                    } else {\n                        actualParams.config.filter = \"labels.tune-type:*\";\n                    }\n                }\n            }\n            return new Pager(PagedItem.PAGED_ITEM_MODELS, (x)=>this.listInternal(x), await this.listInternal(actualParams), actualParams);\n        };\n        /**\n         * Edits an image based on a prompt, list of reference images, and configuration.\n         *\n         * @param params - The parameters for editing an image.\n         * @return The response from the API.\n         *\n         * @example\n         * ```ts\n         * const response = await client.models.editImage({\n         *  model: 'imagen-3.0-capability-001',\n         *  prompt: 'Generate an image containing a mug with the product logo [1] visible on the side of the mug.',\n         *  referenceImages: [subjectReferenceImage]\n         *  config: {\n         *    numberOfImages: 1,\n         *    includeRaiReason: true,\n         *  },\n         * });\n         * console.log(response?.generatedImages?.[0]?.image?.imageBytes);\n         * ```\n         */ this.editImage = async (params)=>{\n            const paramsInternal = {\n                model: params.model,\n                prompt: params.prompt,\n                referenceImages: [],\n                config: params.config\n            };\n            if (params.referenceImages) {\n                if (params.referenceImages) {\n                    paramsInternal.referenceImages = params.referenceImages.map((img)=>img.toReferenceImageAPI());\n                }\n            }\n            return await this.editImageInternal(paramsInternal);\n        };\n        /**\n         * Upscales an image based on an image, upscale factor, and configuration.\n         * Only supported in Vertex AI currently.\n         *\n         * @param params - The parameters for upscaling an image.\n         * @return The response from the API.\n         *\n         * @example\n         * ```ts\n         * const response = await client.models.upscaleImage({\n         *  model: 'imagen-3.0-generate-002',\n         *  image: image,\n         *  upscaleFactor: 'x2',\n         *  config: {\n         *    includeRaiReason: true,\n         *  },\n         * });\n         * console.log(response?.generatedImages?.[0]?.image?.imageBytes);\n         * ```\n         */ this.upscaleImage = async (params)=>{\n            let apiConfig = {\n                numberOfImages: 1,\n                mode: \"upscale\"\n            };\n            if (params.config) {\n                apiConfig = Object.assign(Object.assign({}, apiConfig), params.config);\n            }\n            const apiParams = {\n                model: params.model,\n                image: params.image,\n                upscaleFactor: params.upscaleFactor,\n                config: apiConfig\n            };\n            return await this.upscaleImageInternal(apiParams);\n        };\n        /**\n         *  Generates videos based on a text description and configuration.\n         *\n         * @param params - The parameters for generating videos.\n         * @return A Promise<GenerateVideosOperation> which allows you to track the progress and eventually retrieve the generated videos using the operations.get method.\n         *\n         * @example\n         * ```ts\n         * const operation = await ai.models.generateVideos({\n         *  model: 'veo-2.0-generate-001',\n         *  source: {\n         *    prompt: 'A neon hologram of a cat driving at top speed',\n         *  },\n         *  config: {\n         *    numberOfVideos: 1\n         * });\n         *\n         * while (!operation.done) {\n         *   await new Promise(resolve => setTimeout(resolve, 10000));\n         *   operation = await ai.operations.getVideosOperation({operation: operation});\n         * }\n         *\n         * console.log(operation.response?.generatedVideos?.[0]?.video?.uri);\n         * ```\n         */ this.generateVideos = async (params)=>{\n            var _a, _b, _c, _d, _e, _f;\n            if ((params.prompt || params.image || params.video) && params.source) {\n                throw new Error(\"Source and prompt/image/video are mutually exclusive. Please only use source.\");\n            }\n            // Gemini API does not support video bytes.\n            if (!this.apiClient.isVertexAI()) {\n                if (((_a = params.video) === null || _a === void 0 ? void 0 : _a.uri) && ((_b = params.video) === null || _b === void 0 ? void 0 : _b.videoBytes)) {\n                    params.video = {\n                        uri: params.video.uri,\n                        mimeType: params.video.mimeType\n                    };\n                } else if (((_d = (_c = params.source) === null || _c === void 0 ? void 0 : _c.video) === null || _d === void 0 ? void 0 : _d.uri) && ((_f = (_e = params.source) === null || _e === void 0 ? void 0 : _e.video) === null || _f === void 0 ? void 0 : _f.videoBytes)) {\n                    params.source.video = {\n                        uri: params.source.video.uri,\n                        mimeType: params.source.video.mimeType\n                    };\n                }\n            }\n            return await this.generateVideosInternal(params);\n        };\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Operations extends BaseModule {\n    /**\n     * Gets the status of a long-running operation.\n     *\n     * @param parameters The parameters for the get operation request.\n     * @return The updated Operation object, with the latest status or result.\n     */ async getVideosOperation(parameters) {\n        const operation = parameters.operation;\n        const config = parameters.config;\n        if (operation.name === undefined || operation.name === \"\") {\n            throw new Error(\"Operation name is required.\");\n        }\n        if (this.apiClient.isVertexAI()) {\n            const resourceName = operation.name.split(\"/operations/\")[0];\n            let httpOptions = undefined;\n            if (config && \"httpOptions\" in config) {\n                httpOptions = config.httpOptions;\n            }\n            const rawOperation = await this.fetchPredictVideosOperationInternal({\n                operationName: operation.name,\n                resourceName: resourceName,\n                config: {\n                    httpOptions: httpOptions\n                }\n            });\n            return operation._fromAPIResponse({\n                apiResponse: rawOperation,\n                _isVertexAI: true\n            });\n        } else {\n            const rawOperation = await this.getVideosOperationInternal({\n                operationName: operation.name,\n                config: config\n            });\n            return operation._fromAPIResponse({\n                apiResponse: rawOperation,\n                _isVertexAI: false\n            });\n        }\n    }\n    /**\n     * Gets the status of a long-running operation.\n     *\n     * @param parameters The parameters for the get operation request.\n     * @return The updated Operation object, with the latest status or result.\n     */ async get(parameters) {\n        const operation = parameters.operation;\n        const config = parameters.config;\n        if (operation.name === undefined || operation.name === \"\") {\n            throw new Error(\"Operation name is required.\");\n        }\n        if (this.apiClient.isVertexAI()) {\n            const resourceName = operation.name.split(\"/operations/\")[0];\n            let httpOptions = undefined;\n            if (config && \"httpOptions\" in config) {\n                httpOptions = config.httpOptions;\n            }\n            const rawOperation = await this.fetchPredictVideosOperationInternal({\n                operationName: operation.name,\n                resourceName: resourceName,\n                config: {\n                    httpOptions: httpOptions\n                }\n            });\n            return operation._fromAPIResponse({\n                apiResponse: rawOperation,\n                _isVertexAI: true\n            });\n        } else {\n            const rawOperation = await this.getVideosOperationInternal({\n                operationName: operation.name,\n                config: config\n            });\n            return operation._fromAPIResponse({\n                apiResponse: rawOperation,\n                _isVertexAI: false\n            });\n        }\n    }\n    async getVideosOperationInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getOperationParametersToVertex(params);\n            path = formatMap(\"{operationName}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response;\n        } else {\n            const body = getOperationParametersToMldev(params);\n            path = formatMap(\"{operationName}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response;\n        }\n    }\n    async fetchPredictVideosOperationInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = fetchPredictOperationParametersToVertex(params);\n            path = formatMap(\"{resourceName}:fetchPredictOperation\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response;\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function blobToMldev(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction contentToMldev(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partToMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction createAuthTokenConfigToMldev(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    const fromNewSessionExpireTime = getValueByPath(fromObject, [\n        \"newSessionExpireTime\"\n    ]);\n    if (parentObject !== undefined && fromNewSessionExpireTime != null) {\n        setValueByPath(parentObject, [\n            \"newSessionExpireTime\"\n        ], fromNewSessionExpireTime);\n    }\n    const fromUses = getValueByPath(fromObject, [\n        \"uses\"\n    ]);\n    if (parentObject !== undefined && fromUses != null) {\n        setValueByPath(parentObject, [\n            \"uses\"\n        ], fromUses);\n    }\n    const fromLiveConnectConstraints = getValueByPath(fromObject, [\n        \"liveConnectConstraints\"\n    ]);\n    if (parentObject !== undefined && fromLiveConnectConstraints != null) {\n        setValueByPath(parentObject, [\n            \"bidiGenerateContentSetup\"\n        ], liveConnectConstraintsToMldev(apiClient, fromLiveConnectConstraints));\n    }\n    const fromLockAdditionalFields = getValueByPath(fromObject, [\n        \"lockAdditionalFields\"\n    ]);\n    if (parentObject !== undefined && fromLockAdditionalFields != null) {\n        setValueByPath(parentObject, [\n            \"fieldMask\"\n        ], fromLockAdditionalFields);\n    }\n    return toObject;\n}\nfunction createAuthTokenParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], createAuthTokenConfigToMldev(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction fileDataToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction functionCallToMldev(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, [\n        \"id\"\n    ]);\n    if (fromId != null) {\n        setValueByPath(toObject, [\n            \"id\"\n        ], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, [\n        \"args\"\n    ]);\n    if (fromArgs != null) {\n        setValueByPath(toObject, [\n            \"args\"\n        ], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    if (getValueByPath(fromObject, [\n        \"partialArgs\"\n    ]) !== undefined) {\n        throw new Error(\"partialArgs parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"willContinue\"\n    ]) !== undefined) {\n        throw new Error(\"willContinue parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction googleMapsToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"authConfig\"\n    ]) !== undefined) {\n        throw new Error(\"authConfig parameter is not supported in Gemini API.\");\n    }\n    const fromEnableWidget = getValueByPath(fromObject, [\n        \"enableWidget\"\n    ]);\n    if (fromEnableWidget != null) {\n        setValueByPath(toObject, [\n            \"enableWidget\"\n        ], fromEnableWidget);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"excludeDomains\"\n    ]) !== undefined) {\n        throw new Error(\"excludeDomains parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"blockingConfidence\"\n    ]) !== undefined) {\n        throw new Error(\"blockingConfidence parameter is not supported in Gemini API.\");\n    }\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        \"timeRangeFilter\"\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, [\n            \"timeRangeFilter\"\n        ], fromTimeRangeFilter);\n    }\n    return toObject;\n}\nfunction liveConnectConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        \"generationConfig\"\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\"\n        ], fromGenerationConfig);\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (parentObject !== undefined && fromResponseModalities != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (parentObject !== undefined && fromTemperature != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (parentObject !== undefined && fromTopP != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (parentObject !== undefined && fromTopK != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (parentObject !== undefined && fromMaxOutputTokens != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (parentObject !== undefined && fromMediaResolution != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (parentObject !== undefined && fromSpeechConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"speechConfig\"\n        ], tLiveSpeechConfig(fromSpeechConfig));\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        \"thinkingConfig\"\n    ]);\n    if (parentObject !== undefined && fromThinkingConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"thinkingConfig\"\n        ], fromThinkingConfig);\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        \"enableAffectiveDialog\"\n    ]);\n    if (parentObject !== undefined && fromEnableAffectiveDialog != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"enableAffectiveDialog\"\n        ], fromEnableAffectiveDialog);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"systemInstruction\"\n        ], contentToMldev(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToMldev(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"tools\"\n        ], transformedList);\n    }\n    const fromSessionResumption = getValueByPath(fromObject, [\n        \"sessionResumption\"\n    ]);\n    if (parentObject !== undefined && fromSessionResumption != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"sessionResumption\"\n        ], sessionResumptionConfigToMldev(fromSessionResumption));\n    }\n    const fromInputAudioTranscription = getValueByPath(fromObject, [\n        \"inputAudioTranscription\"\n    ]);\n    if (parentObject !== undefined && fromInputAudioTranscription != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"inputAudioTranscription\"\n        ], fromInputAudioTranscription);\n    }\n    const fromOutputAudioTranscription = getValueByPath(fromObject, [\n        \"outputAudioTranscription\"\n    ]);\n    if (parentObject !== undefined && fromOutputAudioTranscription != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"outputAudioTranscription\"\n        ], fromOutputAudioTranscription);\n    }\n    const fromRealtimeInputConfig = getValueByPath(fromObject, [\n        \"realtimeInputConfig\"\n    ]);\n    if (parentObject !== undefined && fromRealtimeInputConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"realtimeInputConfig\"\n        ], fromRealtimeInputConfig);\n    }\n    const fromContextWindowCompression = getValueByPath(fromObject, [\n        \"contextWindowCompression\"\n    ]);\n    if (parentObject !== undefined && fromContextWindowCompression != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"contextWindowCompression\"\n        ], fromContextWindowCompression);\n    }\n    const fromProactivity = getValueByPath(fromObject, [\n        \"proactivity\"\n    ]);\n    if (parentObject !== undefined && fromProactivity != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"proactivity\"\n        ], fromProactivity);\n    }\n    return toObject;\n}\nfunction liveConnectConstraintsToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"setup\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], liveConnectConfigToMldev(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction partToMldev(fromObject) {\n    const toObject = {};\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, [\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataToMldev(fromFileData));\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], functionCallToMldev(fromFunctionCall));\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobToMldev(fromInlineData));\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], fromVideoMetadata);\n    }\n    return toObject;\n}\nfunction sessionResumptionConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromHandle = getValueByPath(fromObject, [\n        \"handle\"\n    ]);\n    if (fromHandle != null) {\n        setValueByPath(toObject, [\n            \"handle\"\n        ], fromHandle);\n    }\n    if (getValueByPath(fromObject, [\n        \"transparent\"\n    ]) !== undefined) {\n        throw new Error(\"transparent parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction toolToMldev(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    if (getValueByPath(fromObject, [\n        \"retrieval\"\n    ]) !== undefined) {\n        throw new Error(\"retrieval parameter is not supported in Gemini API.\");\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], fromGoogleSearchRetrieval);\n    }\n    const fromComputerUse = getValueByPath(fromObject, [\n        \"computerUse\"\n    ]);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, [\n            \"computerUse\"\n        ], fromComputerUse);\n    }\n    const fromFileSearch = getValueByPath(fromObject, [\n        \"fileSearch\"\n    ]);\n    if (fromFileSearch != null) {\n        setValueByPath(toObject, [\n            \"fileSearch\"\n        ], fromFileSearch);\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    if (getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]) !== undefined) {\n        throw new Error(\"enterpriseWebSearch parameter is not supported in Gemini API.\");\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, [\n            \"googleMaps\"\n        ], googleMapsToMldev(fromGoogleMaps));\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToMldev(fromGoogleSearch));\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], fromUrlContext);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ /**\n * Returns a comma-separated list of field masks from a given object.\n *\n * @param setup The object to extract field masks from.\n * @return A comma-separated list of field masks.\n */ function getFieldMasks(setup) {\n    const fields = [];\n    for(const key in setup){\n        if (Object.prototype.hasOwnProperty.call(setup, key)) {\n            const value = setup[key];\n            // 2nd layer, recursively get field masks see TODO(b/418290100)\n            if (typeof value === \"object\" && value != null && Object.keys(value).length > 0) {\n                const field = Object.keys(value).map((kk)=>\"\".concat(key, \".\").concat(kk));\n                fields.push(...field);\n            } else {\n                fields.push(key); // 1st layer\n            }\n        }\n    }\n    return fields.join(\",\");\n}\n/**\n * Converts bidiGenerateContentSetup.\n * @param requestDict - The request dictionary.\n * @param config - The configuration object.\n * @return - The modified request dictionary.\n */ function convertBidiSetupToTokenSetup(requestDict, config) {\n    // Convert bidiGenerateContentSetup from bidiGenerateContentSetup.setup.\n    let setupForMaskGeneration = null;\n    const bidiGenerateContentSetupValue = requestDict[\"bidiGenerateContentSetup\"];\n    if (typeof bidiGenerateContentSetupValue === \"object\" && bidiGenerateContentSetupValue !== null && \"setup\" in bidiGenerateContentSetupValue) {\n        // Now we know bidiGenerateContentSetupValue is an object and has a 'setup'\n        // property.\n        const innerSetup = bidiGenerateContentSetupValue.setup;\n        if (typeof innerSetup === \"object\" && innerSetup !== null) {\n            // Valid inner setup found.\n            requestDict[\"bidiGenerateContentSetup\"] = innerSetup;\n            setupForMaskGeneration = innerSetup;\n        } else {\n            // `bidiGenerateContentSetupValue.setup` is not a valid object; treat as\n            // if bidiGenerateContentSetup is invalid.\n            delete requestDict[\"bidiGenerateContentSetup\"];\n        }\n    } else if (bidiGenerateContentSetupValue !== undefined) {\n        // `bidiGenerateContentSetup` exists but not in the expected\n        // shape {setup: {...}}; treat as invalid.\n        delete requestDict[\"bidiGenerateContentSetup\"];\n    }\n    const preExistingFieldMask = requestDict[\"fieldMask\"];\n    // Handle mask generation setup.\n    if (setupForMaskGeneration) {\n        const generatedMaskFromBidi = getFieldMasks(setupForMaskGeneration);\n        if (Array.isArray(config === null || config === void 0 ? void 0 : config.lockAdditionalFields) && (config === null || config === void 0 ? void 0 : config.lockAdditionalFields.length) === 0) {\n            // Case 1: lockAdditionalFields is an empty array. Lock only fields from\n            // bidi setup.\n            if (generatedMaskFromBidi) {\n                // Only assign if mask is not empty\n                requestDict[\"fieldMask\"] = generatedMaskFromBidi;\n            } else {\n                delete requestDict[\"fieldMask\"]; // If mask is empty, effectively no\n            // specific fields locked by bidi\n            }\n        } else if ((config === null || config === void 0 ? void 0 : config.lockAdditionalFields) && config.lockAdditionalFields.length > 0 && preExistingFieldMask !== null && Array.isArray(preExistingFieldMask) && preExistingFieldMask.length > 0) {\n            // Case 2: Lock fields from bidi setup + additional fields\n            // (preExistingFieldMask).\n            const generationConfigFields = [\n                \"temperature\",\n                \"topK\",\n                \"topP\",\n                \"maxOutputTokens\",\n                \"responseModalities\",\n                \"seed\",\n                \"speechConfig\"\n            ];\n            let mappedFieldsFromPreExisting = [];\n            if (preExistingFieldMask.length > 0) {\n                mappedFieldsFromPreExisting = preExistingFieldMask.map((field)=>{\n                    if (generationConfigFields.includes(field)) {\n                        return \"generationConfig.\".concat(field);\n                    }\n                    return field; // Keep original field name if not in\n                // generationConfigFields\n                });\n            }\n            const finalMaskParts = [];\n            if (generatedMaskFromBidi) {\n                finalMaskParts.push(generatedMaskFromBidi);\n            }\n            if (mappedFieldsFromPreExisting.length > 0) {\n                finalMaskParts.push(...mappedFieldsFromPreExisting);\n            }\n            if (finalMaskParts.length > 0) {\n                requestDict[\"fieldMask\"] = finalMaskParts.join(\",\");\n            } else {\n                // If no fields from bidi and no valid additional fields from\n                // pre-existing mask.\n                delete requestDict[\"fieldMask\"];\n            }\n        } else {\n            // Case 3: \"Lock all fields\" (meaning, don't send a field_mask, let server\n            // defaults apply or all are mutable). This is hit if:\n            //  - `config.lockAdditionalFields` is undefined.\n            //  - `config.lockAdditionalFields` is non-empty, BUT\n            //  `preExistingFieldMask` is null, not a string, or an empty string.\n            delete requestDict[\"fieldMask\"];\n        }\n    } else {\n        // No valid `bidiGenerateContentSetup` was found or extracted.\n        // \"Lock additional null fields if any\".\n        if (preExistingFieldMask !== null && Array.isArray(preExistingFieldMask) && preExistingFieldMask.length > 0) {\n            // If there's a pre-existing field mask, it's a string, and it's not\n            // empty, then we should lock all fields.\n            requestDict[\"fieldMask\"] = preExistingFieldMask.join(\",\");\n        } else {\n            delete requestDict[\"fieldMask\"];\n        }\n    }\n    return requestDict;\n}\nclass Tokens extends BaseModule {\n    /**\n     * Creates an ephemeral auth token resource.\n     *\n     * @experimental\n     *\n     * @remarks\n     * Ephemeral auth tokens is only supported in the Gemini Developer API.\n     * It can be used for the session connection to the Live constrained API.\n     * Support in v1alpha only.\n     *\n     * @param params - The parameters for the create request.\n     * @return The created auth token.\n     *\n     * @example\n     * ```ts\n     * const ai = new GoogleGenAI({\n     *     apiKey: token.name,\n     *     httpOptions: { apiVersion: 'v1alpha' }  // Support in v1alpha only.\n     * });\n     *\n     * // Case 1: If LiveEphemeralParameters is unset, unlock LiveConnectConfig\n     * // when using the token in Live API sessions. Each session connection can\n     * // use a different configuration.\n     * const config: CreateAuthTokenConfig = {\n     *     uses: 3,\n     *     expireTime: '2025-05-01T00:00:00Z',\n     * }\n     * const token = await ai.tokens.create(config);\n     *\n     * // Case 2: If LiveEphemeralParameters is set, lock all fields in\n     * // LiveConnectConfig when using the token in Live API sessions. For\n     * // example, changing `outputAudioTranscription` in the Live API\n     * // connection will be ignored by the API.\n     * const config: CreateAuthTokenConfig =\n     *     uses: 3,\n     *     expireTime: '2025-05-01T00:00:00Z',\n     *     LiveEphemeralParameters: {\n     *        model: 'gemini-2.0-flash-001',\n     *        config: {\n     *           'responseModalities': ['AUDIO'],\n     *           'systemInstruction': 'Always answer in English.',\n     *        }\n     *     }\n     * }\n     * const token = await ai.tokens.create(config);\n     *\n     * // Case 3: If LiveEphemeralParameters is set and lockAdditionalFields is\n     * // set, lock LiveConnectConfig with set and additional fields (e.g.\n     * // responseModalities, systemInstruction, temperature in this example) when\n     * // using the token in Live API sessions.\n     * const config: CreateAuthTokenConfig =\n     *     uses: 3,\n     *     expireTime: '2025-05-01T00:00:00Z',\n     *     LiveEphemeralParameters: {\n     *        model: 'gemini-2.0-flash-001',\n     *        config: {\n     *           'responseModalities': ['AUDIO'],\n     *           'systemInstruction': 'Always answer in English.',\n     *        }\n     *     },\n     *     lockAdditionalFields: ['temperature'],\n     * }\n     * const token = await ai.tokens.create(config);\n     *\n     * // Case 4: If LiveEphemeralParameters is set and lockAdditionalFields is\n     * // empty array, lock LiveConnectConfig with set fields (e.g.\n     * // responseModalities, systemInstruction in this example) when using the\n     * // token in Live API sessions.\n     * const config: CreateAuthTokenConfig =\n     *     uses: 3,\n     *     expireTime: '2025-05-01T00:00:00Z',\n     *     LiveEphemeralParameters: {\n     *        model: 'gemini-2.0-flash-001',\n     *        config: {\n     *           'responseModalities': ['AUDIO'],\n     *           'systemInstruction': 'Always answer in English.',\n     *        }\n     *     },\n     *     lockAdditionalFields: [],\n     * }\n     * const token = await ai.tokens.create(config);\n     * ```\n     */ async create(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"The client.tokens.create method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = createAuthTokenParametersToMldev(this.apiClient, params);\n            path = formatMap(\"auth_tokens\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            const transformedBody = convertBidiSetupToTokenSetup(body, params.config);\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(transformedBody),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((resp)=>{\n                return resp;\n            });\n        }\n    }\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ // Code generated by the Google Gen AI SDK generator DO NOT EDIT.\nfunction deleteDocumentConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromForce = getValueByPath(fromObject, [\n        \"force\"\n    ]);\n    if (parentObject !== undefined && fromForce != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"force\"\n        ], fromForce);\n    }\n    return toObject;\n}\nfunction deleteDocumentParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], fromName);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        deleteDocumentConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction getDocumentParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction listDocumentsConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    return toObject;\n}\nfunction listDocumentsParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromParent = getValueByPath(fromObject, [\n        \"parent\"\n    ]);\n    if (fromParent != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"parent\"\n        ], fromParent);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listDocumentsConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listDocumentsResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromDocuments = getValueByPath(fromObject, [\n        \"documents\"\n    ]);\n    if (fromDocuments != null) {\n        let transformedList = fromDocuments;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"documents\"\n        ], transformedList);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Documents extends BaseModule {\n    /**\n     * Gets a Document.\n     *\n     * @param params - The parameters for getting a document.\n     * @return Document.\n     */ async get(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = getDocumentParametersToMldev(params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((resp)=>{\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes a Document.\n     *\n     * @param params - The parameters for deleting a document.\n     */ async delete(params) {\n        var _a, _b;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = deleteDocumentParametersToMldev(params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            await this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = listDocumentsParametersToMldev(params);\n            path = formatMap(\"{parent}/documents\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = listDocumentsResponseFromMldev(apiResponse);\n                const typedResp = new ListDocumentsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Lists documents.\n         *\n         * @param params - The parameters for the list request.\n         * @return - A pager of documents.\n         *\n         * @example\n         * ```ts\n         * const documents = await ai.documents.list({parent:'rag_store_name', config: {'pageSize': 2}});\n         * for await (const document of documents) {\n         *   console.log(document);\n         * }\n         * ```\n         */ this.list = async (params)=>{\n            return new Pager(PagedItem.PAGED_ITEM_DOCUMENTS, (x)=>this.listInternal({\n                    parent: params.parent,\n                    config: x.config\n                }), await this.listInternal(params), params);\n        };\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class FileSearchStores extends BaseModule {\n    /**\n     * Uploads a file asynchronously to a given File Search Store.\n     * This method is not available in Vertex AI.\n     * Supported upload sources:\n     * - Node.js: File path (string) or Blob object.\n     * - Browser: Blob object (e.g., File).\n     *\n     * @remarks\n     * The `mimeType` can be specified in the `config` parameter. If omitted:\n     *  - For file path (string) inputs, the `mimeType` will be inferred from the\n     *     file extension.\n     *  - For Blob object inputs, the `mimeType` will be set to the Blob's `type`\n     *     property.\n     *\n     * This section can contain multiple paragraphs and code examples.\n     *\n     * @param params - Optional parameters specified in the\n     *        `types.UploadToFileSearchStoreParameters` interface.\n     *         @see {@link types.UploadToFileSearchStoreParameters#config} for the optional\n     *         config in the parameters.\n     * @return A promise that resolves to a long running operation.\n     * @throws An error if called on a Vertex AI client.\n     * @throws An error if the `mimeType` is not provided and can not be inferred,\n     * the `mimeType` can be provided in the `params.config` parameter.\n     * @throws An error occurs if a suitable upload location cannot be established.\n     *\n     * @example\n     * The following code uploads a file to a given file search store.\n     *\n     * ```ts\n     * const operation = await ai.fileSearchStores.upload({fileSearchStoreName: 'fileSearchStores/foo-bar', file: 'file.txt', config: {\n     *   mimeType: 'text/plain',\n     * }});\n     * console.log(operation.name);\n     * ```\n     */ async uploadToFileSearchStore(params) {\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"Vertex AI does not support uploading files to a file search store.\");\n        }\n        return this.apiClient.uploadFileToFileSearchStore(params.fileSearchStoreName, params.file, params.config);\n    }\n    /**\n     * Creates a File Search Store.\n     *\n     * @param params - The parameters for creating a File Search Store.\n     * @return FileSearchStore.\n     */ async create(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = createFileSearchStoreParametersToMldev(params);\n            path = formatMap(\"fileSearchStores\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((resp)=>{\n                return resp;\n            });\n        }\n    }\n    /**\n     * Gets a File Search Store.\n     *\n     * @param params - The parameters for getting a File Search Store.\n     * @return FileSearchStore.\n     */ async get(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = getFileSearchStoreParametersToMldev(params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((resp)=>{\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes a File Search Store.\n     *\n     * @param params - The parameters for deleting a File Search Store.\n     */ async delete(params) {\n        var _a, _b;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = deleteFileSearchStoreParametersToMldev(params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            await this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = listFileSearchStoresParametersToMldev(params);\n            path = formatMap(\"fileSearchStores\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = listFileSearchStoresResponseFromMldev(apiResponse);\n                const typedResp = new ListFileSearchStoresResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    async uploadToFileSearchStoreInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = uploadToFileSearchStoreParametersToMldev(params);\n            path = formatMap(\"upload/v1beta/{file_search_store_name}:uploadToFileSearchStore\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = uploadToFileSearchStoreResumableResponseFromMldev(apiResponse);\n                const typedResp = new UploadToFileSearchStoreResumableResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Imports a File from File Service to a FileSearchStore.\n     *\n     * This is a long-running operation, see aip.dev/151\n     *\n     * @param params - The parameters for importing a file to a file search store.\n     * @return ImportFileOperation.\n     */ async importFile(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = importFileParametersToMldev(params);\n            path = formatMap(\"{file_search_store_name}:importFile\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = importFileOperationFromMldev(apiResponse);\n                const typedResp = new ImportFileOperation();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    constructor(apiClient, documents = new Documents(apiClient)){\n        var _this;\n        super(), _this = this;\n        this.apiClient = apiClient;\n        this.documents = documents;\n        /**\n         * Lists file search stores.\n         *\n         * @param params - The parameters for the list request.\n         * @return - A pager of file search stores.\n         *\n         * @example\n         * ```ts\n         * const fileSearchStores = await ai.fileSearchStores.list({config: {'pageSize': 2}});\n         * for await (const fileSearchStore of fileSearchStores) {\n         *   console.log(fileSearchStore);\n         * }\n         * ```\n         */ this.list = async function() {\n            let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n            return new Pager(PagedItem.PAGED_ITEM_FILE_SEARCH_STORES, (x)=>_this.listInternal(x), await _this.listInternal(params), params);\n        };\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ // Code generated by the Google Gen AI SDK generator DO NOT EDIT.\nfunction cancelTuningJobParametersToMldev(fromObject, _rootObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction cancelTuningJobParametersToVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction cancelTuningJobResponseFromMldev(fromObject, _rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction cancelTuningJobResponseFromVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction createTuningJobConfigToMldev(fromObject, parentObject, _rootObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"validationDataset\"\n    ]) !== undefined) {\n        throw new Error(\"validationDataset parameter is not supported in Gemini API.\");\n    }\n    const fromTunedModelDisplayName = getValueByPath(fromObject, [\n        \"tunedModelDisplayName\"\n    ]);\n    if (parentObject !== undefined && fromTunedModelDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromTunedModelDisplayName);\n    }\n    if (getValueByPath(fromObject, [\n        \"description\"\n    ]) !== undefined) {\n        throw new Error(\"description parameter is not supported in Gemini API.\");\n    }\n    const fromEpochCount = getValueByPath(fromObject, [\n        \"epochCount\"\n    ]);\n    if (parentObject !== undefined && fromEpochCount != null) {\n        setValueByPath(parentObject, [\n            \"tuningTask\",\n            \"hyperparameters\",\n            \"epochCount\"\n        ], fromEpochCount);\n    }\n    const fromLearningRateMultiplier = getValueByPath(fromObject, [\n        \"learningRateMultiplier\"\n    ]);\n    if (fromLearningRateMultiplier != null) {\n        setValueByPath(toObject, [\n            \"tuningTask\",\n            \"hyperparameters\",\n            \"learningRateMultiplier\"\n        ], fromLearningRateMultiplier);\n    }\n    if (getValueByPath(fromObject, [\n        \"exportLastCheckpointOnly\"\n    ]) !== undefined) {\n        throw new Error(\"exportLastCheckpointOnly parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"preTunedModelCheckpointId\"\n    ]) !== undefined) {\n        throw new Error(\"preTunedModelCheckpointId parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"adapterSize\"\n    ]) !== undefined) {\n        throw new Error(\"adapterSize parameter is not supported in Gemini API.\");\n    }\n    const fromBatchSize = getValueByPath(fromObject, [\n        \"batchSize\"\n    ]);\n    if (parentObject !== undefined && fromBatchSize != null) {\n        setValueByPath(parentObject, [\n            \"tuningTask\",\n            \"hyperparameters\",\n            \"batchSize\"\n        ], fromBatchSize);\n    }\n    const fromLearningRate = getValueByPath(fromObject, [\n        \"learningRate\"\n    ]);\n    if (parentObject !== undefined && fromLearningRate != null) {\n        setValueByPath(parentObject, [\n            \"tuningTask\",\n            \"hyperparameters\",\n            \"learningRate\"\n        ], fromLearningRate);\n    }\n    if (getValueByPath(fromObject, [\n        \"labels\"\n    ]) !== undefined) {\n        throw new Error(\"labels parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"beta\"\n    ]) !== undefined) {\n        throw new Error(\"beta parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction createTuningJobConfigToVertex(fromObject, parentObject, rootObject) {\n    const toObject = {};\n    let discriminatorValidationDataset = getValueByPath(rootObject, [\n        \"config\",\n        \"method\"\n    ]);\n    if (discriminatorValidationDataset === undefined) {\n        discriminatorValidationDataset = \"SUPERVISED_FINE_TUNING\";\n    }\n    if (discriminatorValidationDataset === \"SUPERVISED_FINE_TUNING\") {\n        const fromValidationDataset = getValueByPath(fromObject, [\n            \"validationDataset\"\n        ]);\n        if (parentObject !== undefined && fromValidationDataset != null) {\n            setValueByPath(parentObject, [\n                \"supervisedTuningSpec\"\n            ], tuningValidationDatasetToVertex(fromValidationDataset));\n        }\n    } else if (discriminatorValidationDataset === \"PREFERENCE_TUNING\") {\n        const fromValidationDataset = getValueByPath(fromObject, [\n            \"validationDataset\"\n        ]);\n        if (parentObject !== undefined && fromValidationDataset != null) {\n            setValueByPath(parentObject, [\n                \"preferenceOptimizationSpec\"\n            ], tuningValidationDatasetToVertex(fromValidationDataset));\n        }\n    }\n    const fromTunedModelDisplayName = getValueByPath(fromObject, [\n        \"tunedModelDisplayName\"\n    ]);\n    if (parentObject !== undefined && fromTunedModelDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"tunedModelDisplayName\"\n        ], fromTunedModelDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (parentObject !== undefined && fromDescription != null) {\n        setValueByPath(parentObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    let discriminatorEpochCount = getValueByPath(rootObject, [\n        \"config\",\n        \"method\"\n    ]);\n    if (discriminatorEpochCount === undefined) {\n        discriminatorEpochCount = \"SUPERVISED_FINE_TUNING\";\n    }\n    if (discriminatorEpochCount === \"SUPERVISED_FINE_TUNING\") {\n        const fromEpochCount = getValueByPath(fromObject, [\n            \"epochCount\"\n        ]);\n        if (parentObject !== undefined && fromEpochCount != null) {\n            setValueByPath(parentObject, [\n                \"supervisedTuningSpec\",\n                \"hyperParameters\",\n                \"epochCount\"\n            ], fromEpochCount);\n        }\n    } else if (discriminatorEpochCount === \"PREFERENCE_TUNING\") {\n        const fromEpochCount = getValueByPath(fromObject, [\n            \"epochCount\"\n        ]);\n        if (parentObject !== undefined && fromEpochCount != null) {\n            setValueByPath(parentObject, [\n                \"preferenceOptimizationSpec\",\n                \"hyperParameters\",\n                \"epochCount\"\n            ], fromEpochCount);\n        }\n    }\n    let discriminatorLearningRateMultiplier = getValueByPath(rootObject, [\n        \"config\",\n        \"method\"\n    ]);\n    if (discriminatorLearningRateMultiplier === undefined) {\n        discriminatorLearningRateMultiplier = \"SUPERVISED_FINE_TUNING\";\n    }\n    if (discriminatorLearningRateMultiplier === \"SUPERVISED_FINE_TUNING\") {\n        const fromLearningRateMultiplier = getValueByPath(fromObject, [\n            \"learningRateMultiplier\"\n        ]);\n        if (parentObject !== undefined && fromLearningRateMultiplier != null) {\n            setValueByPath(parentObject, [\n                \"supervisedTuningSpec\",\n                \"hyperParameters\",\n                \"learningRateMultiplier\"\n            ], fromLearningRateMultiplier);\n        }\n    } else if (discriminatorLearningRateMultiplier === \"PREFERENCE_TUNING\") {\n        const fromLearningRateMultiplier = getValueByPath(fromObject, [\n            \"learningRateMultiplier\"\n        ]);\n        if (parentObject !== undefined && fromLearningRateMultiplier != null) {\n            setValueByPath(parentObject, [\n                \"preferenceOptimizationSpec\",\n                \"hyperParameters\",\n                \"learningRateMultiplier\"\n            ], fromLearningRateMultiplier);\n        }\n    }\n    let discriminatorExportLastCheckpointOnly = getValueByPath(rootObject, [\n        \"config\",\n        \"method\"\n    ]);\n    if (discriminatorExportLastCheckpointOnly === undefined) {\n        discriminatorExportLastCheckpointOnly = \"SUPERVISED_FINE_TUNING\";\n    }\n    if (discriminatorExportLastCheckpointOnly === \"SUPERVISED_FINE_TUNING\") {\n        const fromExportLastCheckpointOnly = getValueByPath(fromObject, [\n            \"exportLastCheckpointOnly\"\n        ]);\n        if (parentObject !== undefined && fromExportLastCheckpointOnly != null) {\n            setValueByPath(parentObject, [\n                \"supervisedTuningSpec\",\n                \"exportLastCheckpointOnly\"\n            ], fromExportLastCheckpointOnly);\n        }\n    } else if (discriminatorExportLastCheckpointOnly === \"PREFERENCE_TUNING\") {\n        const fromExportLastCheckpointOnly = getValueByPath(fromObject, [\n            \"exportLastCheckpointOnly\"\n        ]);\n        if (parentObject !== undefined && fromExportLastCheckpointOnly != null) {\n            setValueByPath(parentObject, [\n                \"preferenceOptimizationSpec\",\n                \"exportLastCheckpointOnly\"\n            ], fromExportLastCheckpointOnly);\n        }\n    }\n    let discriminatorAdapterSize = getValueByPath(rootObject, [\n        \"config\",\n        \"method\"\n    ]);\n    if (discriminatorAdapterSize === undefined) {\n        discriminatorAdapterSize = \"SUPERVISED_FINE_TUNING\";\n    }\n    if (discriminatorAdapterSize === \"SUPERVISED_FINE_TUNING\") {\n        const fromAdapterSize = getValueByPath(fromObject, [\n            \"adapterSize\"\n        ]);\n        if (parentObject !== undefined && fromAdapterSize != null) {\n            setValueByPath(parentObject, [\n                \"supervisedTuningSpec\",\n                \"hyperParameters\",\n                \"adapterSize\"\n            ], fromAdapterSize);\n        }\n    } else if (discriminatorAdapterSize === \"PREFERENCE_TUNING\") {\n        const fromAdapterSize = getValueByPath(fromObject, [\n            \"adapterSize\"\n        ]);\n        if (parentObject !== undefined && fromAdapterSize != null) {\n            setValueByPath(parentObject, [\n                \"preferenceOptimizationSpec\",\n                \"hyperParameters\",\n                \"adapterSize\"\n            ], fromAdapterSize);\n        }\n    }\n    if (getValueByPath(fromObject, [\n        \"batchSize\"\n    ]) !== undefined) {\n        throw new Error(\"batchSize parameter is not supported in Vertex AI.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"learningRate\"\n    ]) !== undefined) {\n        throw new Error(\"learningRate parameter is not supported in Vertex AI.\");\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    const fromBeta = getValueByPath(fromObject, [\n        \"beta\"\n    ]);\n    if (parentObject !== undefined && fromBeta != null) {\n        setValueByPath(parentObject, [\n            \"preferenceOptimizationSpec\",\n            \"hyperParameters\",\n            \"beta\"\n        ], fromBeta);\n    }\n    return toObject;\n}\nfunction createTuningJobParametersPrivateToMldev(fromObject, rootObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, [\n        \"baseModel\"\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, [\n            \"baseModel\"\n        ], fromBaseModel);\n    }\n    const fromPreTunedModel = getValueByPath(fromObject, [\n        \"preTunedModel\"\n    ]);\n    if (fromPreTunedModel != null) {\n        setValueByPath(toObject, [\n            \"preTunedModel\"\n        ], fromPreTunedModel);\n    }\n    const fromTrainingDataset = getValueByPath(fromObject, [\n        \"trainingDataset\"\n    ]);\n    if (fromTrainingDataset != null) {\n        tuningDatasetToMldev(fromTrainingDataset);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        createTuningJobConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction createTuningJobParametersPrivateToVertex(fromObject, rootObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, [\n        \"baseModel\"\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, [\n            \"baseModel\"\n        ], fromBaseModel);\n    }\n    const fromPreTunedModel = getValueByPath(fromObject, [\n        \"preTunedModel\"\n    ]);\n    if (fromPreTunedModel != null) {\n        setValueByPath(toObject, [\n            \"preTunedModel\"\n        ], fromPreTunedModel);\n    }\n    const fromTrainingDataset = getValueByPath(fromObject, [\n        \"trainingDataset\"\n    ]);\n    if (fromTrainingDataset != null) {\n        tuningDatasetToVertex(fromTrainingDataset, toObject, rootObject);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        createTuningJobConfigToVertex(fromConfig, toObject, rootObject);\n    }\n    return toObject;\n}\nfunction getTuningJobParametersToMldev(fromObject, _rootObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction getTuningJobParametersToVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction listTuningJobsConfigToMldev(fromObject, parentObject, _rootObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, [\n        \"filter\"\n    ]);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"filter\"\n        ], fromFilter);\n    }\n    return toObject;\n}\nfunction listTuningJobsConfigToVertex(fromObject, parentObject, _rootObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, [\n        \"filter\"\n    ]);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"filter\"\n        ], fromFilter);\n    }\n    return toObject;\n}\nfunction listTuningJobsParametersToMldev(fromObject, rootObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listTuningJobsConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listTuningJobsParametersToVertex(fromObject, rootObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listTuningJobsConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listTuningJobsResponseFromMldev(fromObject, rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromTuningJobs = getValueByPath(fromObject, [\n        \"tunedModels\"\n    ]);\n    if (fromTuningJobs != null) {\n        let transformedList = fromTuningJobs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return tuningJobFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"tuningJobs\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction listTuningJobsResponseFromVertex(fromObject, rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromTuningJobs = getValueByPath(fromObject, [\n        \"tuningJobs\"\n    ]);\n    if (fromTuningJobs != null) {\n        let transformedList = fromTuningJobs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return tuningJobFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"tuningJobs\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction tunedModelFromMldev(fromObject, _rootObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], fromModel);\n    }\n    const fromEndpoint = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromEndpoint != null) {\n        setValueByPath(toObject, [\n            \"endpoint\"\n        ], fromEndpoint);\n    }\n    return toObject;\n}\nfunction tuningDatasetToMldev(fromObject, _rootObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]) !== undefined) {\n        throw new Error(\"gcsUri parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"vertexDatasetResource\"\n    ]) !== undefined) {\n        throw new Error(\"vertexDatasetResource parameter is not supported in Gemini API.\");\n    }\n    const fromExamples = getValueByPath(fromObject, [\n        \"examples\"\n    ]);\n    if (fromExamples != null) {\n        let transformedList = fromExamples;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"examples\",\n            \"examples\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction tuningDatasetToVertex(fromObject, parentObject, rootObject) {\n    const toObject = {};\n    let discriminatorGcsUri = getValueByPath(rootObject, [\n        \"config\",\n        \"method\"\n    ]);\n    if (discriminatorGcsUri === undefined) {\n        discriminatorGcsUri = \"SUPERVISED_FINE_TUNING\";\n    }\n    if (discriminatorGcsUri === \"SUPERVISED_FINE_TUNING\") {\n        const fromGcsUri = getValueByPath(fromObject, [\n            \"gcsUri\"\n        ]);\n        if (parentObject !== undefined && fromGcsUri != null) {\n            setValueByPath(parentObject, [\n                \"supervisedTuningSpec\",\n                \"trainingDatasetUri\"\n            ], fromGcsUri);\n        }\n    } else if (discriminatorGcsUri === \"PREFERENCE_TUNING\") {\n        const fromGcsUri = getValueByPath(fromObject, [\n            \"gcsUri\"\n        ]);\n        if (parentObject !== undefined && fromGcsUri != null) {\n            setValueByPath(parentObject, [\n                \"preferenceOptimizationSpec\",\n                \"trainingDatasetUri\"\n            ], fromGcsUri);\n        }\n    }\n    let discriminatorVertexDatasetResource = getValueByPath(rootObject, [\n        \"config\",\n        \"method\"\n    ]);\n    if (discriminatorVertexDatasetResource === undefined) {\n        discriminatorVertexDatasetResource = \"SUPERVISED_FINE_TUNING\";\n    }\n    if (discriminatorVertexDatasetResource === \"SUPERVISED_FINE_TUNING\") {\n        const fromVertexDatasetResource = getValueByPath(fromObject, [\n            \"vertexDatasetResource\"\n        ]);\n        if (parentObject !== undefined && fromVertexDatasetResource != null) {\n            setValueByPath(parentObject, [\n                \"supervisedTuningSpec\",\n                \"trainingDatasetUri\"\n            ], fromVertexDatasetResource);\n        }\n    } else if (discriminatorVertexDatasetResource === \"PREFERENCE_TUNING\") {\n        const fromVertexDatasetResource = getValueByPath(fromObject, [\n            \"vertexDatasetResource\"\n        ]);\n        if (parentObject !== undefined && fromVertexDatasetResource != null) {\n            setValueByPath(parentObject, [\n                \"preferenceOptimizationSpec\",\n                \"trainingDatasetUri\"\n            ], fromVertexDatasetResource);\n        }\n    }\n    if (getValueByPath(fromObject, [\n        \"examples\"\n    ]) !== undefined) {\n        throw new Error(\"examples parameter is not supported in Vertex AI.\");\n    }\n    return toObject;\n}\nfunction tuningJobFromMldev(fromObject, rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromState = getValueByPath(fromObject, [\n        \"state\"\n    ]);\n    if (fromState != null) {\n        setValueByPath(toObject, [\n            \"state\"\n        ], tTuningJobStatus(fromState));\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromStartTime = getValueByPath(fromObject, [\n        \"tuningTask\",\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"tuningTask\",\n        \"completeTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromBaseModel = getValueByPath(fromObject, [\n        \"baseModel\"\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, [\n            \"baseModel\"\n        ], fromBaseModel);\n    }\n    const fromTunedModel = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromTunedModel != null) {\n        setValueByPath(toObject, [\n            \"tunedModel\"\n        ], tunedModelFromMldev(fromTunedModel));\n    }\n    return toObject;\n}\nfunction tuningJobFromVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromState = getValueByPath(fromObject, [\n        \"state\"\n    ]);\n    if (fromState != null) {\n        setValueByPath(toObject, [\n            \"state\"\n        ], tTuningJobStatus(fromState));\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromStartTime = getValueByPath(fromObject, [\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromBaseModel = getValueByPath(fromObject, [\n        \"baseModel\"\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, [\n            \"baseModel\"\n        ], fromBaseModel);\n    }\n    const fromTunedModel = getValueByPath(fromObject, [\n        \"tunedModel\"\n    ]);\n    if (fromTunedModel != null) {\n        setValueByPath(toObject, [\n            \"tunedModel\"\n        ], fromTunedModel);\n    }\n    const fromPreTunedModel = getValueByPath(fromObject, [\n        \"preTunedModel\"\n    ]);\n    if (fromPreTunedModel != null) {\n        setValueByPath(toObject, [\n            \"preTunedModel\"\n        ], fromPreTunedModel);\n    }\n    const fromSupervisedTuningSpec = getValueByPath(fromObject, [\n        \"supervisedTuningSpec\"\n    ]);\n    if (fromSupervisedTuningSpec != null) {\n        setValueByPath(toObject, [\n            \"supervisedTuningSpec\"\n        ], fromSupervisedTuningSpec);\n    }\n    const fromPreferenceOptimizationSpec = getValueByPath(fromObject, [\n        \"preferenceOptimizationSpec\"\n    ]);\n    if (fromPreferenceOptimizationSpec != null) {\n        setValueByPath(toObject, [\n            \"preferenceOptimizationSpec\"\n        ], fromPreferenceOptimizationSpec);\n    }\n    const fromTuningDataStats = getValueByPath(fromObject, [\n        \"tuningDataStats\"\n    ]);\n    if (fromTuningDataStats != null) {\n        setValueByPath(toObject, [\n            \"tuningDataStats\"\n        ], fromTuningDataStats);\n    }\n    const fromEncryptionSpec = getValueByPath(fromObject, [\n        \"encryptionSpec\"\n    ]);\n    if (fromEncryptionSpec != null) {\n        setValueByPath(toObject, [\n            \"encryptionSpec\"\n        ], fromEncryptionSpec);\n    }\n    const fromPartnerModelTuningSpec = getValueByPath(fromObject, [\n        \"partnerModelTuningSpec\"\n    ]);\n    if (fromPartnerModelTuningSpec != null) {\n        setValueByPath(toObject, [\n            \"partnerModelTuningSpec\"\n        ], fromPartnerModelTuningSpec);\n    }\n    const fromCustomBaseModel = getValueByPath(fromObject, [\n        \"customBaseModel\"\n    ]);\n    if (fromCustomBaseModel != null) {\n        setValueByPath(toObject, [\n            \"customBaseModel\"\n        ], fromCustomBaseModel);\n    }\n    const fromExperiment = getValueByPath(fromObject, [\n        \"experiment\"\n    ]);\n    if (fromExperiment != null) {\n        setValueByPath(toObject, [\n            \"experiment\"\n        ], fromExperiment);\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (fromLabels != null) {\n        setValueByPath(toObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    const fromOutputUri = getValueByPath(fromObject, [\n        \"outputUri\"\n    ]);\n    if (fromOutputUri != null) {\n        setValueByPath(toObject, [\n            \"outputUri\"\n        ], fromOutputUri);\n    }\n    const fromPipelineJob = getValueByPath(fromObject, [\n        \"pipelineJob\"\n    ]);\n    if (fromPipelineJob != null) {\n        setValueByPath(toObject, [\n            \"pipelineJob\"\n        ], fromPipelineJob);\n    }\n    const fromServiceAccount = getValueByPath(fromObject, [\n        \"serviceAccount\"\n    ]);\n    if (fromServiceAccount != null) {\n        setValueByPath(toObject, [\n            \"serviceAccount\"\n        ], fromServiceAccount);\n    }\n    const fromTunedModelDisplayName = getValueByPath(fromObject, [\n        \"tunedModelDisplayName\"\n    ]);\n    if (fromTunedModelDisplayName != null) {\n        setValueByPath(toObject, [\n            \"tunedModelDisplayName\"\n        ], fromTunedModelDisplayName);\n    }\n    const fromVeoTuningSpec = getValueByPath(fromObject, [\n        \"veoTuningSpec\"\n    ]);\n    if (fromVeoTuningSpec != null) {\n        setValueByPath(toObject, [\n            \"veoTuningSpec\"\n        ], fromVeoTuningSpec);\n    }\n    return toObject;\n}\nfunction tuningOperationFromMldev(fromObject, _rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    return toObject;\n}\nfunction tuningValidationDatasetToVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"validationDatasetUri\"\n        ], fromGcsUri);\n    }\n    const fromVertexDatasetResource = getValueByPath(fromObject, [\n        \"vertexDatasetResource\"\n    ]);\n    if (fromVertexDatasetResource != null) {\n        setValueByPath(toObject, [\n            \"validationDatasetUri\"\n        ], fromVertexDatasetResource);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Tunings extends BaseModule {\n    async getInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getTuningJobParametersToVertex(params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = tuningJobFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = getTuningJobParametersToMldev(params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = tuningJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = listTuningJobsParametersToVertex(params);\n            path = formatMap(\"tuningJobs\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listTuningJobsResponseFromVertex(apiResponse);\n                const typedResp = new ListTuningJobsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = listTuningJobsParametersToMldev(params);\n            path = formatMap(\"tunedModels\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listTuningJobsResponseFromMldev(apiResponse);\n                const typedResp = new ListTuningJobsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Cancels a tuning job.\n     *\n     * @param params - The parameters for the cancel request.\n     * @return The empty response returned by the API.\n     *\n     * @example\n     * ```ts\n     * await ai.tunings.cancel({name: '...'}); // The server-generated resource name.\n     * ```\n     */ async cancel(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = cancelTuningJobParametersToVertex(params);\n            path = formatMap(\"{name}:cancel\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = cancelTuningJobResponseFromVertex(apiResponse);\n                const typedResp = new CancelTuningJobResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = cancelTuningJobParametersToMldev(params);\n            path = formatMap(\"{name}:cancel\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = cancelTuningJobResponseFromMldev(apiResponse);\n                const typedResp = new CancelTuningJobResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    async tuneInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = createTuningJobParametersPrivateToVertex(params, params);\n            path = formatMap(\"tuningJobs\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = tuningJobFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n    async tuneMldevInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = createTuningJobParametersPrivateToMldev(params);\n            path = formatMap(\"tunedModels\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = tuningOperationFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    constructor(apiClient){\n        var _this;\n        super(), _this = this;\n        this.apiClient = apiClient;\n        /**\n         * Lists tuning jobs.\n         *\n         * @param params - The parameters for the list request.\n         * @return - A pager of tuning jobs.\n         *\n         * @example\n         * ```ts\n         * const tuningJobs = await ai.tunings.list({config: {'pageSize': 2}});\n         * for await (const tuningJob of tuningJobs) {\n         *   console.log(tuningJob);\n         * }\n         * ```\n         */ this.list = async function() {\n            let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n            return new Pager(PagedItem.PAGED_ITEM_TUNING_JOBS, (x)=>_this.listInternal(x), await _this.listInternal(params), params);\n        };\n        /**\n         * Gets a TuningJob.\n         *\n         * @param name - The resource name of the tuning job.\n         * @return - A TuningJob object.\n         *\n         * @experimental - The SDK's tuning implementation is experimental, and may\n         * change in future versions.\n         */ this.get = async (params)=>{\n            return await this.getInternal(params);\n        };\n        /**\n         * Creates a supervised fine-tuning job.\n         *\n         * @param params - The parameters for the tuning job.\n         * @return - A TuningJob operation.\n         *\n         * @experimental - The SDK's tuning implementation is experimental, and may\n         * change in future versions.\n         */ this.tune = async (params)=>{\n            var _a;\n            if (this.apiClient.isVertexAI()) {\n                if (params.baseModel.startsWith(\"projects/\")) {\n                    const preTunedModel = {\n                        tunedModelName: params.baseModel\n                    };\n                    if ((_a = params.config) === null || _a === void 0 ? void 0 : _a.preTunedModelCheckpointId) {\n                        preTunedModel.checkpointId = params.config.preTunedModelCheckpointId;\n                    }\n                    const paramsPrivate = Object.assign(Object.assign({}, params), {\n                        preTunedModel: preTunedModel\n                    });\n                    paramsPrivate.baseModel = undefined;\n                    return await this.tuneInternal(paramsPrivate);\n                } else {\n                    const paramsPrivate = Object.assign({}, params);\n                    return await this.tuneInternal(paramsPrivate);\n                }\n            } else {\n                const paramsPrivate = Object.assign({}, params);\n                const operation = await this.tuneMldevInternal(paramsPrivate);\n                let tunedModelName = \"\";\n                if (operation[\"metadata\"] !== undefined && operation[\"metadata\"][\"tunedModel\"] !== undefined) {\n                    tunedModelName = operation[\"metadata\"][\"tunedModel\"];\n                } else if (operation[\"name\"] !== undefined && operation[\"name\"].includes(\"/operations/\")) {\n                    tunedModelName = operation[\"name\"].split(\"/operations/\")[0];\n                }\n                const tuningJob = {\n                    name: tunedModelName,\n                    state: JobState.JOB_STATE_QUEUED\n                };\n                return tuningJob;\n            }\n        };\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class BrowserDownloader {\n    async download(_params, _apiClient) {\n        throw new Error(\"Download to file is not supported in the browser, please use a browser compliant download like an <a> tag.\");\n    }\n}\nconst MAX_CHUNK_SIZE = 1024 * 1024 * 8; // bytes\nconst MAX_RETRY_COUNT = 3;\nconst INITIAL_RETRY_DELAY_MS = 1000;\nconst DELAY_MULTIPLIER = 2;\nconst X_GOOG_UPLOAD_STATUS_HEADER_FIELD = \"x-goog-upload-status\";\nasync function uploadBlob(file, uploadUrl, apiClient) {\n    var _a;\n    const response = await uploadBlobInternal(file, uploadUrl, apiClient);\n    const responseJson = await (response === null || response === void 0 ? void 0 : response.json());\n    if (((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== \"final\") {\n        throw new Error(\"Failed to upload file: Upload status is not finalized.\");\n    }\n    return responseJson[\"file\"];\n}\nasync function uploadBlobToFileSearchStore(file, uploadUrl, apiClient) {\n    var _a;\n    const response = await uploadBlobInternal(file, uploadUrl, apiClient);\n    const responseJson = await (response === null || response === void 0 ? void 0 : response.json());\n    if (((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== \"final\") {\n        throw new Error(\"Failed to upload file: Upload status is not finalized.\");\n    }\n    const resp = uploadToFileSearchStoreOperationFromMldev(responseJson);\n    const typedResp = new UploadToFileSearchStoreOperation();\n    Object.assign(typedResp, resp);\n    return typedResp;\n}\nasync function uploadBlobInternal(file, uploadUrl, apiClient) {\n    var _a, _b;\n    let fileSize = 0;\n    let offset = 0;\n    let response = new HttpResponse(new Response());\n    let uploadCommand = \"upload\";\n    fileSize = file.size;\n    while(offset < fileSize){\n        const chunkSize = Math.min(MAX_CHUNK_SIZE, fileSize - offset);\n        const chunk = file.slice(offset, offset + chunkSize);\n        if (offset + chunkSize >= fileSize) {\n            uploadCommand += \", finalize\";\n        }\n        let retryCount = 0;\n        let currentDelayMs = INITIAL_RETRY_DELAY_MS;\n        while(retryCount < MAX_RETRY_COUNT){\n            response = await apiClient.request({\n                path: \"\",\n                body: chunk,\n                httpMethod: \"POST\",\n                httpOptions: {\n                    apiVersion: \"\",\n                    baseUrl: uploadUrl,\n                    headers: {\n                        \"X-Goog-Upload-Command\": uploadCommand,\n                        \"X-Goog-Upload-Offset\": String(offset),\n                        \"Content-Length\": String(chunkSize)\n                    }\n                }\n            });\n            if ((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) {\n                break;\n            }\n            retryCount++;\n            await sleep(currentDelayMs);\n            currentDelayMs = currentDelayMs * DELAY_MULTIPLIER;\n        }\n        offset += chunkSize;\n        // The `x-goog-upload-status` header field can be `active`, `final` and\n        //`cancelled` in resposne.\n        if (((_b = response === null || response === void 0 ? void 0 : response.headers) === null || _b === void 0 ? void 0 : _b[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== \"active\") {\n            break;\n        }\n        // TODO(b/401391430) Investigate why the upload status is not finalized\n        // even though all content has been uploaded.\n        if (fileSize <= offset) {\n            throw new Error(\"All content has been uploaded, but the upload status is not finalized.\");\n        }\n    }\n    return response;\n}\nasync function getBlobStat(file) {\n    const fileStat = {\n        size: file.size,\n        type: file.type\n    };\n    return fileStat;\n}\nfunction sleep(ms) {\n    return new Promise((resolvePromise)=>setTimeout(resolvePromise, ms));\n}\nclass BrowserUploader {\n    async upload(file, uploadUrl, apiClient) {\n        if (typeof file === \"string\") {\n            throw new Error(\"File path is not supported in browser uploader.\");\n        }\n        return await uploadBlob(file, uploadUrl, apiClient);\n    }\n    async uploadToFileSearchStore(file, uploadUrl, apiClient) {\n        if (typeof file === \"string\") {\n            throw new Error(\"File path is not supported in browser uploader.\");\n        }\n        return await uploadBlobToFileSearchStore(file, uploadUrl, apiClient);\n    }\n    async stat(file) {\n        if (typeof file === \"string\") {\n            throw new Error(\"File path is not supported in browser uploader.\");\n        } else {\n            return await getBlobStat(file);\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class BrowserWebSocketFactory {\n    create(url, headers, callbacks) {\n        return new BrowserWebSocket(url, headers, callbacks);\n    }\n}\nclass BrowserWebSocket {\n    connect() {\n        this.ws = new WebSocket(this.url);\n        this.ws.onopen = this.callbacks.onopen;\n        this.ws.onerror = this.callbacks.onerror;\n        this.ws.onclose = this.callbacks.onclose;\n        this.ws.onmessage = this.callbacks.onmessage;\n    }\n    send(message) {\n        if (this.ws === undefined) {\n            throw new Error(\"WebSocket is not connected\");\n        }\n        this.ws.send(message);\n    }\n    close() {\n        if (this.ws === undefined) {\n            throw new Error(\"WebSocket is not connected\");\n        }\n        this.ws.close();\n    }\n    constructor(url, headers, callbacks){\n        this.url = url;\n        this.headers = headers;\n        this.callbacks = callbacks;\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ const GOOGLE_API_KEY_HEADER = \"x-goog-api-key\";\n// TODO(b/395122533): We need a secure client side authentication mechanism.\nclass WebAuth {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async addAuthHeaders(headers, url) {\n        if (headers.get(GOOGLE_API_KEY_HEADER) !== null) {\n            return;\n        }\n        if (this.apiKey.startsWith(\"auth_tokens/\")) {\n            throw new Error(\"Ephemeral tokens are only supported by the live API.\");\n        }\n        // Check if API key is empty or null\n        if (!this.apiKey) {\n            throw new Error(\"API key is missing. Please provide a valid API key.\");\n        }\n        headers.append(GOOGLE_API_KEY_HEADER, this.apiKey);\n    }\n    constructor(apiKey){\n        this.apiKey = apiKey;\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ const LANGUAGE_LABEL_PREFIX = \"gl-node/\";\n/**\n * The Google GenAI SDK.\n *\n * @remarks\n * Provides access to the GenAI features through either the {@link\n * https://cloud.google.com/vertex-ai/docs/reference/rest | Gemini API} or\n * the {@link https://cloud.google.com/vertex-ai/docs/reference/rest | Vertex AI\n * API}.\n *\n * The {@link GoogleGenAIOptions.vertexai} value determines which of the API\n * services to use.\n *\n * When using the Gemini API, a {@link GoogleGenAIOptions.apiKey} must also be\n * set. When using Vertex AI, currently only {@link GoogleGenAIOptions.apiKey}\n * is supported via Express mode. {@link GoogleGenAIOptions.project} and {@link\n * GoogleGenAIOptions.location} should not be set.\n *\n * @example\n * Initializing the SDK for using the Gemini API:\n * ```ts\n * import {GoogleGenAI} from '@google/genai';\n * const ai = new GoogleGenAI({apiKey: 'GEMINI_API_KEY'});\n * ```\n *\n * @example\n * Initializing the SDK for using the Vertex AI API:\n * ```ts\n * import {GoogleGenAI} from '@google/genai';\n * const ai = new GoogleGenAI({\n *   vertexai: true,\n *   project: 'PROJECT_ID',\n *   location: 'PROJECT_LOCATION'\n * });\n * ```\n *\n */ class GoogleGenAI {\n    constructor(options){\n        var _a;\n        if (options.apiKey == null) {\n            throw new Error(\"An API Key must be set when running in a browser\");\n        }\n        // Web client only supports API key mode for Vertex AI.\n        if (options.project || options.location) {\n            throw new Error(\"Vertex AI project based authentication is not supported on browser runtimes. Please do not provide a project or location.\");\n        }\n        this.vertexai = (_a = options.vertexai) !== null && _a !== void 0 ? _a : false;\n        this.apiKey = options.apiKey;\n        const baseUrl = getBaseUrl(options.httpOptions, options.vertexai, /*vertexBaseUrlFromEnv*/ undefined, /*geminiBaseUrlFromEnv*/ undefined);\n        if (baseUrl) {\n            if (options.httpOptions) {\n                options.httpOptions.baseUrl = baseUrl;\n            } else {\n                options.httpOptions = {\n                    baseUrl: baseUrl\n                };\n            }\n        }\n        this.apiVersion = options.apiVersion;\n        this.httpOptions = options.httpOptions;\n        const auth = new WebAuth(this.apiKey);\n        this.apiClient = new ApiClient({\n            auth: auth,\n            apiVersion: this.apiVersion,\n            apiKey: this.apiKey,\n            vertexai: this.vertexai,\n            httpOptions: this.httpOptions,\n            userAgentExtra: LANGUAGE_LABEL_PREFIX + \"web\",\n            uploader: new BrowserUploader(),\n            downloader: new BrowserDownloader()\n        });\n        this.models = new Models(this.apiClient);\n        this.live = new Live(this.apiClient, auth, new BrowserWebSocketFactory());\n        this.batches = new Batches(this.apiClient);\n        this.chats = new Chats(this.models, this.apiClient);\n        this.caches = new Caches(this.apiClient);\n        this.files = new Files(this.apiClient);\n        this.operations = new Operations(this.apiClient);\n        this.authTokens = new Tokens(this.apiClient);\n        this.tunings = new Tunings(this.apiClient);\n        this.fileSearchStores = new FileSearchStores(this.apiClient);\n    }\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL2dlbmFpL2Rpc3Qvd2ViL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7O0NBSUMsR0FDRCxJQUFJQSx3QkFBd0JDO0FBQzVCLElBQUlDLHdCQUF3QkQ7QUFDNUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FtQkMsR0FDRCxTQUFTRSxtQkFBbUJDLGFBQWE7SUFDckNKLHdCQUF3QkksY0FBY0MsU0FBUztJQUMvQ0gsd0JBQXdCRSxjQUFjRSxTQUFTO0FBQ25EO0FBQ0E7O0NBRUMsR0FDRCxTQUFTQztJQUNMLE9BQU87UUFDSEYsV0FBV0w7UUFDWE0sV0FBV0o7SUFDZjtBQUNKO0FBQ0E7Ozs7O0NBS0MsR0FDRCxTQUFTTSxXQUFXQyxXQUFXLEVBQUVDLFFBQVEsRUFBRUMsb0JBQW9CLEVBQUVDLG9CQUFvQjtJQUNqRixJQUFJQyxJQUFJQztJQUNSLElBQUksQ0FBRUwsQ0FBQUEsZ0JBQWdCLFFBQVFBLGdCQUFnQixLQUFLLElBQUksS0FBSyxJQUFJQSxZQUFZTSxPQUFPLEdBQUc7UUFDbEYsTUFBTUMsa0JBQWtCVDtRQUN4QixJQUFJRyxVQUFVO1lBQ1YsT0FBTyxDQUFDRyxLQUFLRyxnQkFBZ0JWLFNBQVMsTUFBTSxRQUFRTyxPQUFPLEtBQUssSUFBSUEsS0FBS0Y7UUFDN0UsT0FDSztZQUNELE9BQU8sQ0FBQ0csS0FBS0UsZ0JBQWdCWCxTQUFTLE1BQU0sUUFBUVMsT0FBTyxLQUFLLElBQUlBLEtBQUtGO1FBQzdFO0lBQ0o7SUFDQSxPQUFPSCxZQUFZTSxPQUFPO0FBQzlCO0FBRUE7Ozs7Q0FJQyxHQUNELE1BQU1FO0FBQ047QUFDQSxTQUFTQyxVQUFVQyxjQUFjLEVBQUVDLFFBQVE7SUFDdkMsMkVBQTJFO0lBQzNFLE1BQU1DLFFBQVE7SUFDZCwwRUFBMEU7SUFDMUUsT0FBT0YsZUFBZUcsT0FBTyxDQUFDRCxPQUFPLENBQUNFLE9BQU9DO1FBQ3pDLElBQUlDLE9BQU9DLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNSLFVBQVVJLE1BQU07WUFDckQsTUFBTUssUUFBUVQsUUFBUSxDQUFDSSxJQUFJO1lBQzNCLDZEQUE2RDtZQUM3RCxPQUFPSyxVQUFVNUIsYUFBYTRCLFVBQVUsT0FBT0MsT0FBT0QsU0FBUztRQUNuRSxPQUNLO1lBQ0Qsc0JBQXNCO1lBQ3RCLE1BQU0sSUFBSUUsTUFBTSxRQUFZLE9BQUpQLEtBQUk7UUFDaEM7SUFDSjtBQUNKO0FBQ0EsU0FBU1EsZUFBZUMsSUFBSSxFQUFFQyxJQUFJLEVBQUVMLEtBQUs7SUFDckMsSUFBSyxJQUFJTSxJQUFJLEdBQUdBLElBQUlELEtBQUtFLE1BQU0sR0FBRyxHQUFHRCxJQUFLO1FBQ3RDLE1BQU1YLE1BQU1VLElBQUksQ0FBQ0MsRUFBRTtRQUNuQixJQUFJWCxJQUFJYSxRQUFRLENBQUMsT0FBTztZQUNwQixNQUFNQyxVQUFVZCxJQUFJZSxLQUFLLENBQUMsR0FBRyxDQUFDO1lBQzlCLElBQUksQ0FBRUQsQ0FBQUEsV0FBV0wsSUFBRyxHQUFJO2dCQUNwQixJQUFJTyxNQUFNQyxPQUFPLENBQUNaLFFBQVE7b0JBQ3RCSSxJQUFJLENBQUNLLFFBQVEsR0FBR0UsTUFBTUUsSUFBSSxDQUFDO3dCQUFFTixRQUFRUCxNQUFNTyxNQUFNO29CQUFDLEdBQUcsSUFBTyxFQUFDO2dCQUNqRSxPQUNLO29CQUNELE1BQU0sSUFBSUwsTUFBTSw0Q0FBZ0QsT0FBSlA7Z0JBQ2hFO1lBQ0o7WUFDQSxJQUFJZ0IsTUFBTUMsT0FBTyxDQUFDUixJQUFJLENBQUNLLFFBQVEsR0FBRztnQkFDOUIsTUFBTUssWUFBWVYsSUFBSSxDQUFDSyxRQUFRO2dCQUMvQixJQUFJRSxNQUFNQyxPQUFPLENBQUNaLFFBQVE7b0JBQ3RCLElBQUssSUFBSWUsSUFBSSxHQUFHQSxJQUFJRCxVQUFVUCxNQUFNLEVBQUVRLElBQUs7d0JBQ3ZDLE1BQU1DLFFBQVFGLFNBQVMsQ0FBQ0MsRUFBRTt3QkFDMUJaLGVBQWVhLE9BQU9YLEtBQUtLLEtBQUssQ0FBQ0osSUFBSSxJQUFJTixLQUFLLENBQUNlLEVBQUU7b0JBQ3JEO2dCQUNKLE9BQ0s7b0JBQ0QsS0FBSyxNQUFNRSxLQUFLSCxVQUFXO3dCQUN2QlgsZUFBZWMsR0FBR1osS0FBS0ssS0FBSyxDQUFDSixJQUFJLElBQUlOO29CQUN6QztnQkFDSjtZQUNKO1lBQ0E7UUFDSixPQUNLLElBQUlMLElBQUlhLFFBQVEsQ0FBQyxRQUFRO1lBQzFCLE1BQU1DLFVBQVVkLElBQUllLEtBQUssQ0FBQyxHQUFHLENBQUM7WUFDOUIsSUFBSSxDQUFFRCxDQUFBQSxXQUFXTCxJQUFHLEdBQUk7Z0JBQ3BCQSxJQUFJLENBQUNLLFFBQVEsR0FBRztvQkFBQyxDQUFDO2lCQUFFO1lBQ3hCO1lBQ0EsTUFBTUssWUFBWVYsSUFBSSxDQUFDSyxRQUFRO1lBQy9CTixlQUFlVyxTQUFTLENBQUMsRUFBRSxFQUFFVCxLQUFLSyxLQUFLLENBQUNKLElBQUksSUFBSU47WUFDaEQ7UUFDSjtRQUNBLElBQUksQ0FBQ0ksSUFBSSxDQUFDVCxJQUFJLElBQUksT0FBT1MsSUFBSSxDQUFDVCxJQUFJLEtBQUssVUFBVTtZQUM3Q1MsSUFBSSxDQUFDVCxJQUFJLEdBQUcsQ0FBQztRQUNqQjtRQUNBUyxPQUFPQSxJQUFJLENBQUNULElBQUk7SUFDcEI7SUFDQSxNQUFNdUIsV0FBV2IsSUFBSSxDQUFDQSxLQUFLRSxNQUFNLEdBQUcsRUFBRTtJQUN0QyxNQUFNWSxlQUFlZixJQUFJLENBQUNjLFNBQVM7SUFDbkMsSUFBSUMsaUJBQWlCL0MsV0FBVztRQUM1QixJQUFJLENBQUM0QixTQUNBLE9BQU9BLFVBQVUsWUFBWUosT0FBT1MsSUFBSSxDQUFDTCxPQUFPTyxNQUFNLEtBQUssR0FBSTtZQUNoRTtRQUNKO1FBQ0EsSUFBSVAsVUFBVW1CLGNBQWM7WUFDeEI7UUFDSjtRQUNBLElBQUksT0FBT0EsaUJBQWlCLFlBQ3hCLE9BQU9uQixVQUFVLFlBQ2pCbUIsaUJBQWlCLFFBQ2pCbkIsVUFBVSxNQUFNO1lBQ2hCSixPQUFPd0IsTUFBTSxDQUFDRCxjQUFjbkI7UUFDaEMsT0FDSztZQUNELE1BQU0sSUFBSUUsTUFBTSw4Q0FBdUQsT0FBVGdCO1FBQ2xFO0lBQ0osT0FDSztRQUNELElBQUlBLGFBQWEsV0FDYixPQUFPbEIsVUFBVSxZQUNqQkEsVUFBVSxRQUNWLENBQUNXLE1BQU1DLE9BQU8sQ0FBQ1osUUFBUTtZQUN2QixNQUFNcUIsZ0JBQWdCckI7WUFDdEJKLE9BQU93QixNQUFNLENBQUNoQixNQUFNaUI7UUFDeEIsT0FDSztZQUNEakIsSUFBSSxDQUFDYyxTQUFTLEdBQUdsQjtRQUNyQjtJQUNKO0FBQ0o7QUFDQSxTQUFTc0IsZUFBZWxCLElBQUksRUFBRUMsSUFBSTtRQUFFa0IsZUFBQUEsaUVBQWVuRDtJQUMvQyxJQUFJO1FBQ0EsSUFBSWlDLEtBQUtFLE1BQU0sS0FBSyxLQUFLRixJQUFJLENBQUMsRUFBRSxLQUFLLFNBQVM7WUFDMUMsT0FBT0Q7UUFDWDtRQUNBLElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJRCxLQUFLRSxNQUFNLEVBQUVELElBQUs7WUFDbEMsSUFBSSxPQUFPRixTQUFTLFlBQVlBLFNBQVMsTUFBTTtnQkFDM0MsT0FBT21CO1lBQ1g7WUFDQSxNQUFNNUIsTUFBTVUsSUFBSSxDQUFDQyxFQUFFO1lBQ25CLElBQUlYLElBQUlhLFFBQVEsQ0FBQyxPQUFPO2dCQUNwQixNQUFNQyxVQUFVZCxJQUFJZSxLQUFLLENBQUMsR0FBRyxDQUFDO2dCQUM5QixJQUFJRCxXQUFXTCxNQUFNO29CQUNqQixNQUFNVSxZQUFZVixJQUFJLENBQUNLLFFBQVE7b0JBQy9CLElBQUksQ0FBQ0UsTUFBTUMsT0FBTyxDQUFDRSxZQUFZO3dCQUMzQixPQUFPUztvQkFDWDtvQkFDQSxPQUFPVCxVQUFVVSxHQUFHLENBQUMsQ0FBQ1AsSUFBTUssZUFBZUwsR0FBR1osS0FBS0ssS0FBSyxDQUFDSixJQUFJLElBQUlpQjtnQkFDckUsT0FDSztvQkFDRCxPQUFPQTtnQkFDWDtZQUNKLE9BQ0s7Z0JBQ0RuQixPQUFPQSxJQUFJLENBQUNULElBQUk7WUFDcEI7UUFDSjtRQUNBLE9BQU9TO0lBQ1gsRUFDQSxPQUFPcUIsT0FBTztRQUNWLElBQUlBLGlCQUFpQkMsV0FBVztZQUM1QixPQUFPSDtRQUNYO1FBQ0EsTUFBTUU7SUFDVjtBQUNKO0FBQ0E7Ozs7Ozs7OztDQVNDLEdBQ0QsU0FBU0UsZ0JBQWdCdkIsSUFBSSxFQUFFd0IsS0FBSztJQUNoQyxLQUFLLE1BQU0sQ0FBQ0MsWUFBWUMsU0FBUyxJQUFJbEMsT0FBT21DLE9BQU8sQ0FBQ0gsT0FBUTtRQUN4RCxNQUFNSSxhQUFhSCxXQUFXSSxLQUFLLENBQUM7UUFDcEMsTUFBTUMsV0FBV0osU0FBU0csS0FBSyxDQUFDO1FBQ2hDLHFFQUFxRTtRQUNyRSxNQUFNRSxjQUFjLElBQUlDO1FBQ3hCLElBQUlDLGNBQWMsQ0FBQztRQUNuQixJQUFLLElBQUkvQixJQUFJLEdBQUdBLElBQUkwQixXQUFXekIsTUFBTSxFQUFFRCxJQUFLO1lBQ3hDLElBQUkwQixVQUFVLENBQUMxQixFQUFFLEtBQUssS0FBSztnQkFDdkIrQixjQUFjL0I7Z0JBQ2Q7WUFDSjtRQUNKO1FBQ0EsSUFBSStCLGdCQUFnQixDQUFDLEtBQUtILFNBQVMzQixNQUFNLEdBQUc4QixhQUFhO1lBQ3JELDZEQUE2RDtZQUM3RCwyRUFBMkU7WUFDM0UsK0JBQStCO1lBQy9CLElBQUssSUFBSS9CLElBQUkrQixhQUFhL0IsSUFBSTRCLFNBQVMzQixNQUFNLEVBQUVELElBQUs7Z0JBQ2hELE1BQU1YLE1BQU11QyxRQUFRLENBQUM1QixFQUFFO2dCQUN2QixJQUFJWCxRQUFRLE9BQU8sQ0FBQ0EsSUFBSWEsUUFBUSxDQUFDLFNBQVMsQ0FBQ2IsSUFBSWEsUUFBUSxDQUFDLFFBQVE7b0JBQzVEMkIsWUFBWUcsR0FBRyxDQUFDM0M7Z0JBQ3BCO1lBQ0o7UUFDSjtRQUNBNEMsb0JBQW9CbkMsTUFBTTRCLFlBQVlFLFVBQVUsR0FBR0M7SUFDdkQ7QUFDSjtBQUNBOztDQUVDLEdBQ0QsU0FBU0ksb0JBQW9CbkMsSUFBSSxFQUFFNEIsVUFBVSxFQUFFRSxRQUFRLEVBQUVNLE1BQU0sRUFBRUwsV0FBVztJQUN4RSxJQUFJSyxVQUFVUixXQUFXekIsTUFBTSxFQUFFO1FBQzdCO0lBQ0o7SUFDQSxJQUFJLE9BQU9ILFNBQVMsWUFBWUEsU0FBUyxNQUFNO1FBQzNDO0lBQ0o7SUFDQSxNQUFNVCxNQUFNcUMsVUFBVSxDQUFDUSxPQUFPO0lBQzlCLElBQUk3QyxJQUFJYSxRQUFRLENBQUMsT0FBTztRQUNwQixNQUFNQyxVQUFVZCxJQUFJZSxLQUFLLENBQUMsR0FBRyxDQUFDO1FBQzlCLE1BQU0rQixhQUFhckM7UUFDbkIsSUFBSUssV0FBV2dDLGNBQWM5QixNQUFNQyxPQUFPLENBQUM2QixVQUFVLENBQUNoQyxRQUFRLEdBQUc7WUFDN0QsS0FBSyxNQUFNaUMsUUFBUUQsVUFBVSxDQUFDaEMsUUFBUSxDQUFFO2dCQUNwQzhCLG9CQUFvQkcsTUFBTVYsWUFBWUUsVUFBVU0sU0FBUyxHQUFHTDtZQUNoRTtRQUNKO0lBQ0osT0FDSyxJQUFJeEMsUUFBUSxLQUFLO1FBQ2xCLDZCQUE2QjtRQUM3QixJQUFJLE9BQU9TLFNBQVMsWUFBWUEsU0FBUyxRQUFRLENBQUNPLE1BQU1DLE9BQU8sQ0FBQ1IsT0FBTztZQUNuRSxNQUFNcUMsYUFBYXJDO1lBQ25CLE1BQU11QyxhQUFhL0MsT0FBT1MsSUFBSSxDQUFDb0MsWUFBWUcsTUFBTSxDQUFDLENBQUNDLElBQU0sQ0FBQ0EsRUFBRUMsVUFBVSxDQUFDLFFBQVEsQ0FBQ1gsWUFBWVksR0FBRyxDQUFDRjtZQUNoRyxNQUFNRyxlQUFlLENBQUM7WUFDdEIsS0FBSyxNQUFNSCxLQUFLRixXQUFZO2dCQUN4QkssWUFBWSxDQUFDSCxFQUFFLEdBQUdKLFVBQVUsQ0FBQ0ksRUFBRTtZQUNuQztZQUNBLDRCQUE0QjtZQUM1QixLQUFLLE1BQU0sQ0FBQ0EsR0FBR0ksRUFBRSxJQUFJckQsT0FBT21DLE9BQU8sQ0FBQ2lCLGNBQWU7Z0JBQy9DLE1BQU1FLGNBQWMsRUFBRTtnQkFDdEIsS0FBSyxNQUFNQyxNQUFNakIsU0FBU3hCLEtBQUssQ0FBQzhCLFFBQVM7b0JBQ3JDLElBQUlXLE9BQU8sS0FBSzt3QkFDWkQsWUFBWUUsSUFBSSxDQUFDUDtvQkFDckIsT0FDSzt3QkFDREssWUFBWUUsSUFBSSxDQUFDRDtvQkFDckI7Z0JBQ0o7Z0JBQ0FoRCxlQUFlc0MsWUFBWVMsYUFBYUQ7WUFDNUM7WUFDQSxLQUFLLE1BQU1KLEtBQUtGLFdBQVk7Z0JBQ3hCLE9BQU9GLFVBQVUsQ0FBQ0ksRUFBRTtZQUN4QjtRQUNKO0lBQ0osT0FDSztRQUNELHlCQUF5QjtRQUN6QixNQUFNSixhQUFhckM7UUFDbkIsSUFBSVQsT0FBTzhDLFlBQVk7WUFDbkJGLG9CQUFvQkUsVUFBVSxDQUFDOUMsSUFBSSxFQUFFcUMsWUFBWUUsVUFBVU0sU0FBUyxHQUFHTDtRQUMzRTtJQUNKO0FBQ0o7QUFFQTs7OztDQUlDLEdBQ0QsU0FBU2tCLFNBQVNDLFNBQVM7SUFDdkIsSUFBSSxPQUFPQSxjQUFjLFVBQVU7UUFDL0IsTUFBTSxJQUFJcEQsTUFBTTtJQUNwQjtJQUNBLG1EQUFtRDtJQUNuRCxPQUFPb0Q7QUFDWDtBQUVBOzs7O0NBSUMsR0FDRCxpRUFBaUU7QUFDakUsU0FBU0Msd0NBQXdDQyxVQUFVO0lBQ3ZELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNQyxvQkFBb0JwQyxlQUFla0MsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSUUscUJBQXFCLE1BQU07UUFDM0J2RCxlQUFlc0QsVUFBVTtZQUFDO1NBQWdCLEVBQUVDO0lBQ2hEO0lBQ0EsTUFBTUMsbUJBQW1CckMsZUFBZWtDLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUlHLG9CQUFvQixNQUFNO1FBQzFCeEQsZUFBZXNELFVBQVU7WUFBQztZQUFRO1NBQWUsRUFBRUU7SUFDdkQ7SUFDQSxPQUFPRjtBQUNYO0FBQ0EsU0FBU0csbUNBQW1DSixVQUFVO0lBQ2xELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNSSxXQUFXdkMsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlLLFlBQVksTUFBTTtRQUNsQjFELGVBQWVzRCxVQUFVO1lBQUM7U0FBTyxFQUFFSTtJQUN2QztJQUNBLE1BQU1DLGVBQWV4QyxlQUFla0MsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSU0sZ0JBQWdCLE1BQU07UUFDdEIzRCxlQUFlc0QsVUFBVTtZQUFDO1NBQVcsRUFBRUs7SUFDM0M7SUFDQSxNQUFNQyxXQUFXekMsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlPLFlBQVksTUFBTTtRQUNsQjVELGVBQWVzRCxVQUFVO1lBQUM7U0FBTyxFQUFFTTtJQUN2QztJQUNBLE1BQU1DLFlBQVkxQyxlQUFla0MsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSVEsYUFBYSxNQUFNO1FBQ25CN0QsZUFBZXNELFVBQVU7WUFBQztTQUFRLEVBQUVPO0lBQ3hDO0lBQ0EsTUFBTUMsZUFBZTNDLGVBQWVrQyxZQUFZO1FBQzVDO1FBQ0E7S0FDSDtJQUNELElBQUlTLGdCQUFnQixNQUFNO1FBQ3RCOUQsZUFBZXNELFVBQVU7WUFBQztTQUFXLEVBQUVTLGtDQUFrQ0Q7SUFDN0U7SUFDQSxPQUFPUjtBQUNYO0FBQ0EsU0FBU1Usb0NBQW9DWCxVQUFVO0lBQ25ELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNSSxXQUFXdkMsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlLLFlBQVksTUFBTTtRQUNsQjFELGVBQWVzRCxVQUFVO1lBQUM7U0FBTyxFQUFFSTtJQUN2QztJQUNBLE1BQU1DLGVBQWV4QyxlQUFla0MsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSU0sZ0JBQWdCLE1BQU07UUFDdEIzRCxlQUFlc0QsVUFBVTtZQUFDO1NBQVcsRUFBRUs7SUFDM0M7SUFDQSxNQUFNQyxXQUFXekMsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlPLFlBQVksTUFBTTtRQUNsQjVELGVBQWVzRCxVQUFVO1lBQUM7U0FBTyxFQUFFTTtJQUN2QztJQUNBLE1BQU1DLFlBQVkxQyxlQUFla0MsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSVEsYUFBYSxNQUFNO1FBQ25CN0QsZUFBZXNELFVBQVU7WUFBQztTQUFRLEVBQUVPO0lBQ3hDO0lBQ0EsTUFBTUMsZUFBZTNDLGVBQWVrQyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJUyxnQkFBZ0IsTUFBTTtRQUN0QjlELGVBQWVzRCxVQUFVO1lBQUM7U0FBVyxFQUFFVyxtQ0FBbUNIO0lBQzlFO0lBQ0EsT0FBT1I7QUFDWDtBQUNBLFNBQVNTLGtDQUFrQ1YsVUFBVTtJQUNqRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTVksc0JBQXNCL0MsZUFBZWtDLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUlhLHVCQUF1QixNQUFNO1FBQzdCLElBQUlDLGtCQUFrQkQ7UUFDdEIsSUFBSTFELE1BQU1DLE9BQU8sQ0FBQzBELGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0I5QyxHQUFHLENBQUMsQ0FBQ2tCO2dCQUNuQyxPQUFPNkIsMEJBQTBCN0I7WUFDckM7UUFDSjtRQUNBdkMsZUFBZXNELFVBQVU7WUFBQztTQUFrQixFQUFFYTtJQUNsRDtJQUNBLE1BQU1FLDRCQUE0QmxELGVBQWVrQyxZQUFZO1FBQ3pEO0tBQ0g7SUFDRCxJQUFJZ0IsNkJBQTZCLE1BQU07UUFDbkNyRSxlQUFlc0QsVUFBVTtZQUFDO1NBQXdCLEVBQUVlO0lBQ3hEO0lBQ0EsTUFBTUMsOEJBQThCbkQsZUFBZWtDLFlBQVk7UUFDM0Q7S0FDSDtJQUNELElBQUlpQiwrQkFBK0IsTUFBTTtRQUNyQ3RFLGVBQWVzRCxVQUFVO1lBQUM7U0FBMEIsRUFBRWdCO0lBQzFEO0lBQ0EsT0FBT2hCO0FBQ1g7QUFDQSxTQUFTVyxtQ0FBbUNaLFVBQVU7SUFDbEQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1ZLHNCQUFzQi9DLGVBQWVrQyxZQUFZO1FBQUM7S0FBUztJQUNqRSxJQUFJYSx1QkFBdUIsTUFBTTtRQUM3QixJQUFJQyxrQkFBa0JEO1FBQ3RCLElBQUkxRCxNQUFNQyxPQUFPLENBQUMwRCxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCOUMsR0FBRyxDQUFDLENBQUNrQjtnQkFDbkMsT0FBT2dDLDJCQUEyQmhDO1lBQ3RDO1FBQ0o7UUFDQXZDLGVBQWVzRCxVQUFVO1lBQUM7U0FBa0IsRUFBRWE7SUFDbEQ7SUFDQSxNQUFNRSw0QkFBNEJsRCxlQUFla0MsWUFBWTtRQUN6RDtLQUNIO0lBQ0QsSUFBSWdCLDZCQUE2QixNQUFNO1FBQ25DckUsZUFBZXNELFVBQVU7WUFBQztTQUF3QixFQUFFZTtJQUN4RDtJQUNBLE1BQU1DLDhCQUE4Qm5ELGVBQWVrQyxZQUFZO1FBQzNEO0tBQ0g7SUFDRCxJQUFJaUIsK0JBQStCLE1BQU07UUFDckN0RSxlQUFlc0QsVUFBVTtZQUFDO1NBQTBCLEVBQUVnQjtJQUMxRDtJQUNBLE9BQU9oQjtBQUNYO0FBQ0EsU0FBU2MsMEJBQTBCZixVQUFVO0lBQ3pDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNa0IsWUFBWXJELGVBQWVrQyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJbUIsYUFBYSxNQUFNO1FBQ25CeEUsZUFBZXNELFVBQVU7WUFBQztTQUFRLEVBQUVtQixpQkFBaUJEO0lBQ3pEO0lBQ0EsT0FBT2xCO0FBQ1g7QUFDQSxTQUFTaUIsMkJBQTJCbEIsVUFBVTtJQUMxQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTWtCLFlBQVlyRCxlQUFla0MsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSW1CLGFBQWEsTUFBTTtRQUNuQnhFLGVBQWVzRCxVQUFVO1lBQUM7U0FBUSxFQUFFb0Isa0JBQWtCRjtJQUMxRDtJQUNBLE9BQU9sQjtBQUNYO0FBQ0EsU0FBU3FCLDhCQUE4QnRCLFVBQVU7SUFDN0MsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1DLG9CQUFvQnBDLGVBQWVrQyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJRSxxQkFBcUIsTUFBTTtRQUMzQnZELGVBQWVzRCxVQUFVO1lBQUM7WUFBUTtTQUFnQixFQUFFQztJQUN4RDtJQUNBLE9BQU9EO0FBQ1g7QUFDQSxTQUFTc0IsK0JBQStCdkIsVUFBVTtJQUM5QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTUMsb0JBQW9CcEMsZUFBZWtDLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUlFLHFCQUFxQixNQUFNO1FBQzNCdkQsZUFBZXNELFVBQVU7WUFBQztZQUFRO1NBQWdCLEVBQUVDO0lBQ3hEO0lBQ0EsT0FBT0Q7QUFDWDtBQUNBLFNBQVN1QiwrQkFBK0J4QixVQUFVO0lBQzlDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNSSxXQUFXdkMsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlLLFlBQVksTUFBTTtRQUNsQjFELGVBQWVzRCxVQUFVO1lBQUM7U0FBTyxFQUFFSTtJQUN2QztJQUNBLE1BQU1DLGVBQWV4QyxlQUFla0MsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSU0sZ0JBQWdCLE1BQU07UUFDdEIzRCxlQUFlc0QsVUFBVTtZQUFDO1NBQVcsRUFBRUs7SUFDM0M7SUFDQSxNQUFNQyxXQUFXekMsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlPLFlBQVksTUFBTTtRQUNsQjVELGVBQWVzRCxVQUFVO1lBQUM7U0FBTyxFQUFFTTtJQUN2QztJQUNBLE1BQU1DLFlBQVkxQyxlQUFla0MsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSVEsYUFBYSxNQUFNO1FBQ25CN0QsZUFBZXNELFVBQVU7WUFBQztTQUFRLEVBQUVPO0lBQ3hDO0lBQ0EsTUFBTUMsZUFBZTNDLGVBQWVrQyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJUyxnQkFBZ0IsTUFBTTtRQUN0QjlELGVBQWVzRCxVQUFVO1lBQUM7U0FBVyxFQUFFd0IsOEJBQThCaEI7SUFDekU7SUFDQSxPQUFPUjtBQUNYO0FBQ0EsU0FBU3dCLDhCQUE4QnpCLFVBQVU7SUFDN0MsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU15QixzQkFBc0I1RCxlQUFla0MsWUFBWTtRQUNuRDtLQUNIO0lBQ0QsSUFBSTBCLHVCQUF1QixNQUFNO1FBQzdCL0UsZUFBZXNELFVBQVU7WUFBQztTQUFrQixFQUFFeUI7SUFDbEQ7SUFDQSxNQUFNQyxhQUFhN0QsZUFBZWtDLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUkyQixjQUFjLE1BQU07UUFDcEJoRixlQUFlc0QsVUFBVTtZQUFDO1NBQVMsRUFBRTBCO0lBQ3pDO0lBQ0EsTUFBTUMsbUJBQW1COUQsZUFBZWtDLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUk0QixvQkFBb0IsTUFBTTtRQUMxQmpGLGVBQWVzRCxVQUFVO1lBQUM7U0FBZSxFQUFFMkI7SUFDL0M7SUFDQSxPQUFPM0I7QUFDWDtBQUNBLFNBQVM0QiwwQ0FBMEM3QixVQUFVO0lBQ3pELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNSSxXQUFXdkMsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlLLFlBQVksTUFBTTtRQUNsQjFELGVBQWVzRCxVQUFVO1lBQUM7U0FBTyxFQUFFSTtJQUN2QztJQUNBLE1BQU1DLGVBQWV4QyxlQUFla0MsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSU0sZ0JBQWdCLE1BQU07UUFDdEIzRCxlQUFlc0QsVUFBVTtZQUFDO1NBQVcsRUFBRUs7SUFDM0M7SUFDQSxNQUFNQyxXQUFXekMsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlPLFlBQVksTUFBTTtRQUNsQjVELGVBQWVzRCxVQUFVO1lBQUM7U0FBTyxFQUFFTTtJQUN2QztJQUNBLE1BQU1DLFlBQVkxQyxlQUFla0MsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSVEsYUFBYSxNQUFNO1FBQ25CN0QsZUFBZXNELFVBQVU7WUFBQztTQUFRLEVBQUVPO0lBQ3hDO0lBQ0EsTUFBTUMsZUFBZTNDLGVBQWVrQyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJUyxnQkFBZ0IsTUFBTTtRQUN0QjlELGVBQWVzRCxVQUFVO1lBQUM7U0FBVyxFQUFFNkIseUNBQXlDckI7SUFDcEY7SUFDQSxPQUFPUjtBQUNYO0FBQ0EsU0FBUzZCLHlDQUF5QzlCLFVBQVU7SUFDeEQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU15QixzQkFBc0I1RCxlQUFla0MsWUFBWTtRQUNuRDtLQUNIO0lBQ0QsSUFBSTBCLHVCQUF1QixNQUFNO1FBQzdCL0UsZUFBZXNELFVBQVU7WUFBQztTQUFrQixFQUFFeUI7SUFDbEQ7SUFDQSxNQUFNQyxhQUFhN0QsZUFBZWtDLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUkyQixjQUFjLE1BQU07UUFDcEJoRixlQUFlc0QsVUFBVTtZQUFDO1NBQVMsRUFBRTBCO0lBQ3pDO0lBQ0EsTUFBTUMsbUJBQW1COUQsZUFBZWtDLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUk0QixvQkFBb0IsTUFBTTtRQUMxQmpGLGVBQWVzRCxVQUFVO1lBQUM7U0FBZSxFQUFFMkI7SUFDL0M7SUFDQSxPQUFPM0I7QUFDWDtBQUNBLFNBQVNtQixpQkFBaUJwQixVQUFVO0lBQ2hDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNOEIsVUFBVWpFLGVBQWVrQyxZQUFZO1FBQUM7S0FBTTtJQUNsRCxJQUFJK0IsV0FBVyxNQUFNO1FBQ2pCcEYsZUFBZXNELFVBQVU7WUFBQztTQUFNLEVBQUU4QjtJQUN0QztJQUNBLE1BQU1DLGlCQUFpQmxFLGVBQWVrQyxZQUFZO1FBQUM7S0FBZTtJQUNsRSxJQUFJZ0Msa0JBQWtCLE1BQU07UUFDeEJyRixlQUFlc0QsVUFBVTtZQUFDO1NBQWEsRUFBRUosU0FBU21DO0lBQ3REO0lBQ0EsTUFBTUMsZUFBZW5FLGVBQWVrQyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJaUMsZ0JBQWdCLE1BQU07UUFDdEJ0RixlQUFlc0QsVUFBVTtZQUFDO1NBQVcsRUFBRWdDO0lBQzNDO0lBQ0EsT0FBT2hDO0FBQ1g7QUFDQSxTQUFTb0Isa0JBQWtCckIsVUFBVTtJQUNqQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTThCLFVBQVVqRSxlQUFla0MsWUFBWTtRQUFDO0tBQVM7SUFDckQsSUFBSStCLFdBQVcsTUFBTTtRQUNqQnBGLGVBQWVzRCxVQUFVO1lBQUM7U0FBTSxFQUFFOEI7SUFDdEM7SUFDQSxNQUFNQyxpQkFBaUJsRSxlQUFla0MsWUFBWTtRQUM5QztLQUNIO0lBQ0QsSUFBSWdDLGtCQUFrQixNQUFNO1FBQ3hCckYsZUFBZXNELFVBQVU7WUFBQztTQUFhLEVBQUVKLFNBQVNtQztJQUN0RDtJQUNBLE1BQU1DLGVBQWVuRSxlQUFla0MsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSWlDLGdCQUFnQixNQUFNO1FBQ3RCdEYsZUFBZXNELFVBQVU7WUFBQztTQUFXLEVBQUVnQztJQUMzQztJQUNBLE9BQU9oQztBQUNYO0FBRUE7Ozs7Q0FJQyxHQUNELG1DQUFtQyxHQUNuQyxJQUFJaUM7QUFDSCxVQUFVQSxPQUFPO0lBQ2Q7O0tBRUMsR0FDREEsT0FBTyxDQUFDLHNCQUFzQixHQUFHO0lBQ2pDOztLQUVDLEdBQ0RBLE9BQU8sQ0FBQyxhQUFhLEdBQUc7SUFDeEI7O0tBRUMsR0FDREEsT0FBTyxDQUFDLGlCQUFpQixHQUFHO0lBQzVCOztLQUVDLEdBQ0RBLE9BQU8sQ0FBQyw0QkFBNEIsR0FBRztBQUMzQyxHQUFHQSxXQUFZQSxDQUFBQSxVQUFVLENBQUM7QUFDMUIsd0NBQXdDLEdBQ3hDLElBQUlDO0FBQ0gsVUFBVUEsUUFBUTtJQUNmOztLQUVDLEdBQ0RBLFFBQVEsQ0FBQyx1QkFBdUIsR0FBRztJQUNuQzs7S0FFQyxHQUNEQSxRQUFRLENBQUMsU0FBUyxHQUFHO0FBQ3pCLEdBQUdBLFlBQWFBLENBQUFBLFdBQVcsQ0FBQztBQUM1Qix3RUFBd0UsR0FDeEUsSUFBSUM7QUFDSCxVQUFVQSwwQkFBMEI7SUFDakM7O0tBRUMsR0FDREEsMEJBQTBCLENBQUMseUJBQXlCLEdBQUc7SUFDdkQ7O0tBRUMsR0FDREEsMEJBQTBCLENBQUMsU0FBUyxHQUFHO0lBQ3ZDOztLQUVDLEdBQ0RBLDBCQUEwQixDQUFDLFlBQVksR0FBRztJQUMxQzs7S0FFQyxHQUNEQSwwQkFBMEIsQ0FBQyxZQUFZLEdBQUc7QUFDOUMsR0FBR0EsOEJBQStCQSxDQUFBQSw2QkFBNkIsQ0FBQztBQUNoRSwwQkFBMEIsR0FDMUIsSUFBSUM7QUFDSCxVQUFVQSxJQUFJO0lBQ1g7O0tBRUMsR0FDREEsSUFBSSxDQUFDLG1CQUFtQixHQUFHO0lBQzNCOztLQUVDLEdBQ0RBLElBQUksQ0FBQyxTQUFTLEdBQUc7SUFDakI7O0tBRUMsR0FDREEsSUFBSSxDQUFDLFNBQVMsR0FBRztJQUNqQjs7S0FFQyxHQUNEQSxJQUFJLENBQUMsVUFBVSxHQUFHO0lBQ2xCOztLQUVDLEdBQ0RBLElBQUksQ0FBQyxVQUFVLEdBQUc7SUFDbEI7O0tBRUMsR0FDREEsSUFBSSxDQUFDLFFBQVEsR0FBRztJQUNoQjs7S0FFQyxHQUNEQSxJQUFJLENBQUMsU0FBUyxHQUFHO0lBQ2pCOztLQUVDLEdBQ0RBLElBQUksQ0FBQyxPQUFPLEdBQUc7QUFDbkIsR0FBR0EsUUFBU0EsQ0FBQUEsT0FBTyxDQUFDO0FBQ3BCLCtEQUErRCxHQUMvRCxJQUFJQztBQUNILFVBQVVBLElBQUk7SUFDWDs7S0FFQyxHQUNEQSxJQUFJLENBQUMsbUJBQW1CLEdBQUc7SUFDM0I7O0tBRUMsR0FDREEsSUFBSSxDQUFDLGVBQWUsR0FBRztBQUMzQixHQUFHQSxRQUFTQSxDQUFBQSxPQUFPLENBQUM7QUFDcEIsNkZBQTZGLEdBQzdGLElBQUlDO0FBQ0gsVUFBVUEsT0FBTztJQUNkOztLQUVDLEdBQ0RBLE9BQU8sQ0FBQyx1QkFBdUIsR0FBRztJQUNsQzs7S0FFQyxHQUNEQSxPQUFPLENBQUMsZ0JBQWdCLEdBQUc7SUFDM0I7O0tBRUMsR0FDREEsT0FBTyxDQUFDLGlCQUFpQixHQUFHO0FBQ2hDLEdBQUdBLFdBQVlBLENBQUFBLFVBQVUsQ0FBQztBQUMxQixtRUFBbUUsR0FDbkUsSUFBSUM7QUFDSCxVQUFVQSxRQUFRO0lBQ2ZBLFFBQVEsQ0FBQyx3QkFBd0IsR0FBRztJQUNwQzs7S0FFQyxHQUNEQSxRQUFRLENBQUMsVUFBVSxHQUFHO0lBQ3RCOztLQUVDLEdBQ0RBLFFBQVEsQ0FBQyxlQUFlLEdBQUc7SUFDM0I7O0tBRUMsR0FDREEsUUFBUSxDQUFDLGtCQUFrQixHQUFHO0lBQzlCOztLQUVDLEdBQ0RBLFFBQVEsQ0FBQyw4QkFBOEIsR0FBRztJQUMxQzs7S0FFQyxHQUNEQSxRQUFRLENBQUMsUUFBUSxHQUFHO0lBQ3BCOztLQUVDLEdBQ0RBLFFBQVEsQ0FBQyxZQUFZLEdBQUc7QUFDNUIsR0FBR0EsWUFBYUEsQ0FBQUEsV0FBVyxDQUFDO0FBQzVCLDJFQUEyRSxHQUMzRSxJQUFJQztBQUNILFVBQVVBLG1CQUFtQjtJQUMxQkEsbUJBQW1CLENBQUMsc0JBQXNCLEdBQUc7SUFDN0M7O0tBRUMsR0FDREEsbUJBQW1CLENBQUMsZ0JBQWdCLEdBQUc7SUFDdkM7O0tBRUMsR0FDREEsbUJBQW1CLENBQUMsaUJBQWlCLEdBQUc7SUFDeEM7O0tBRUMsR0FDREEsbUJBQW1CLENBQUMsZUFBZSxHQUFHO0lBQ3RDOztLQUVDLEdBQ0RBLG1CQUFtQixDQUFDLGVBQWUsR0FBRztJQUN0Qzs7S0FFQyxHQUNEQSxtQkFBbUIsQ0FBQyxpQkFBaUIsR0FBRztBQUM1QyxHQUFHQSx1QkFBd0JBLENBQUFBLHNCQUFzQixDQUFDO0FBQ2xELDZJQUE2SSxHQUM3SSxJQUFJQztBQUNILFVBQVVBLG1CQUFtQjtJQUMxQjs7S0FFQyxHQUNEQSxtQkFBbUIsQ0FBQyxvQ0FBb0MsR0FBRztJQUMzRDs7S0FFQyxHQUNEQSxtQkFBbUIsQ0FBQyxzQkFBc0IsR0FBRztJQUM3Qzs7S0FFQyxHQUNEQSxtQkFBbUIsQ0FBQyx5QkFBeUIsR0FBRztJQUNoRDs7S0FFQyxHQUNEQSxtQkFBbUIsQ0FBQyx1QkFBdUIsR0FBRztJQUM5Qzs7S0FFQyxHQUNEQSxtQkFBbUIsQ0FBQyx5QkFBeUIsR0FBRztJQUNoRDs7S0FFQyxHQUNEQSxtQkFBbUIsQ0FBQyw0QkFBNEIsR0FBRztJQUNuRDs7S0FFQyxHQUNEQSxtQkFBbUIsQ0FBQyw0QkFBNEIsR0FBRztBQUN2RCxHQUFHQSx1QkFBd0JBLENBQUFBLHNCQUFzQixDQUFDO0FBQ2xELGlFQUFpRSxHQUNqRSxJQUFJQztBQUNILFVBQVVBLGFBQWE7SUFDcEI7O0tBRUMsR0FDREEsYUFBYSxDQUFDLDZCQUE2QixHQUFHO0lBQzlDOztLQUVDLEdBQ0RBLGFBQWEsQ0FBQyxNQUFNLEdBQUc7SUFDdkI7O0tBRUMsR0FDREEsYUFBYSxDQUFDLE9BQU8sR0FBRztBQUM1QixHQUFHQSxpQkFBa0JBLENBQUFBLGdCQUFnQixDQUFDO0FBQ3RDLG1CQUFtQixHQUNuQixJQUFJQztBQUNILFVBQVVBLFlBQVk7SUFDbkI7O0tBRUMsR0FDREEsWUFBWSxDQUFDLDRCQUE0QixHQUFHO0lBQzVDOztLQUVDLEdBQ0RBLFlBQVksQ0FBQywyQkFBMkIsR0FBRztJQUMzQzs7S0FFQyxHQUNEQSxZQUFZLENBQUMsNEJBQTRCLEdBQUc7SUFDNUM7O0tBRUMsR0FDREEsWUFBWSxDQUFDLGtDQUFrQyxHQUFHO0lBQ2xEOztLQUVDLEdBQ0RBLFlBQVksQ0FBQyxrQ0FBa0MsR0FBRztJQUNsRDs7S0FFQyxHQUNEQSxZQUFZLENBQUMsZ0NBQWdDLEdBQUc7SUFDaEQ7O0tBRUMsR0FDREEsWUFBWSxDQUFDLDJCQUEyQixHQUFHO0lBQzNDOztLQUVDLEdBQ0RBLFlBQVksQ0FBQyx3Q0FBd0MsR0FBRztJQUN4RDs7S0FFQyxHQUNEQSxZQUFZLENBQUMsaUNBQWlDLEdBQUc7SUFDakQ7O0tBRUMsR0FDREEsWUFBWSxDQUFDLHdDQUF3QyxHQUFHO0lBQ3hEOztLQUVDLEdBQ0RBLFlBQVksQ0FBQywwQkFBMEIsR0FBRztBQUM5QyxHQUFHQSxnQkFBaUJBLENBQUFBLGVBQWUsQ0FBQztBQUNwQyxpTEFBaUwsR0FDakwsSUFBSUM7QUFDSCxVQUFVQSxlQUFlO0lBQ3RCOztLQUVDLEdBQ0RBLGVBQWUsQ0FBQyxnQ0FBZ0MsR0FBRztJQUNuRDs7S0FFQyxHQUNEQSxlQUFlLENBQUMsV0FBVyxHQUFHO0lBQzlCOztLQUVDLEdBQ0RBLGVBQWUsQ0FBQyxjQUFjLEdBQUc7QUFDckMsR0FBR0EsbUJBQW9CQSxDQUFBQSxrQkFBa0IsQ0FBQztBQUMxQyw4QkFBOEIsR0FDOUIsSUFBSUM7QUFDSCxVQUFVQSxrQkFBa0I7SUFDekI7O0tBRUMsR0FDREEsa0JBQWtCLENBQUMsbUNBQW1DLEdBQUc7SUFDekQ7O0tBRUMsR0FDREEsa0JBQWtCLENBQUMsc0JBQXNCLEdBQUc7SUFDNUM7O0tBRUMsR0FDREEsa0JBQWtCLENBQUMseUJBQXlCLEdBQUc7SUFDL0M7O0tBRUMsR0FDREEsa0JBQWtCLENBQUMsa0JBQWtCLEdBQUc7SUFDeEM7O0tBRUMsR0FDREEsa0JBQWtCLENBQUMsYUFBYSxHQUFHO0lBQ25DOztLQUVDLEdBQ0RBLGtCQUFrQixDQUFDLE1BQU0sR0FBRztBQUNoQyxHQUFHQSxzQkFBdUJBLENBQUFBLHFCQUFxQixDQUFDO0FBQ2hEOzsyREFFMkQsR0FDM0QsSUFBSUM7QUFDSCxVQUFVQSxZQUFZO0lBQ25COztLQUVDLEdBQ0RBLFlBQVksQ0FBQyw0QkFBNEIsR0FBRztJQUM1Qzs7S0FFQyxHQUNEQSxZQUFZLENBQUMsT0FBTyxHQUFHO0lBQ3ZCOztLQUVDLEdBQ0RBLFlBQVksQ0FBQyxhQUFhLEdBQUc7SUFDN0I7O0tBRUMsR0FDREEsWUFBWSxDQUFDLFNBQVMsR0FBRztJQUN6Qjs7S0FFQyxHQUNEQSxZQUFZLENBQUMsYUFBYSxHQUFHO0lBQzdCOztLQUVDLEdBQ0RBLFlBQVksQ0FBQyxXQUFXLEdBQUc7SUFDM0I7O0tBRUMsR0FDREEsWUFBWSxDQUFDLFFBQVEsR0FBRztJQUN4Qjs7S0FFQyxHQUNEQSxZQUFZLENBQUMsWUFBWSxHQUFHO0lBQzVCOztLQUVDLEdBQ0RBLFlBQVksQ0FBQyxxQkFBcUIsR0FBRztJQUNyQzs7S0FFQyxHQUNEQSxZQUFZLENBQUMsT0FBTyxHQUFHO0lBQ3ZCOztLQUVDLEdBQ0RBLFlBQVksQ0FBQywwQkFBMEIsR0FBRztJQUMxQzs7S0FFQyxHQUNEQSxZQUFZLENBQUMsZUFBZSxHQUFHO0lBQy9COztLQUVDLEdBQ0RBLFlBQVksQ0FBQyx1QkFBdUIsR0FBRztJQUN2Qzs7S0FFQyxHQUNEQSxZQUFZLENBQUMsMkJBQTJCLEdBQUc7SUFDM0M7O0tBRUMsR0FDREEsWUFBWSxDQUFDLFdBQVcsR0FBRztBQUMvQixHQUFHQSxnQkFBaUJBLENBQUFBLGVBQWUsQ0FBQztBQUNwQyx5REFBeUQsR0FDekQsSUFBSUM7QUFDSCxVQUFVQSxlQUFlO0lBQ3RCOztLQUVDLEdBQ0RBLGVBQWUsQ0FBQywrQkFBK0IsR0FBRztJQUNsRDs7S0FFQyxHQUNEQSxlQUFlLENBQUMsYUFBYSxHQUFHO0lBQ2hDOztLQUVDLEdBQ0RBLGVBQWUsQ0FBQyxNQUFNLEdBQUc7SUFDekI7O0tBRUMsR0FDREEsZUFBZSxDQUFDLFNBQVMsR0FBRztJQUM1Qjs7S0FFQyxHQUNEQSxlQUFlLENBQUMsT0FBTyxHQUFHO0FBQzlCLEdBQUdBLG1CQUFvQkEsQ0FBQUEsa0JBQWtCLENBQUM7QUFDMUMsZ0dBQWdHLEdBQ2hHLElBQUlDO0FBQ0gsVUFBVUEsWUFBWTtJQUNuQjs7S0FFQyxHQUNEQSxZQUFZLENBQUMsNEJBQTRCLEdBQUc7SUFDNUM7O0tBRUMsR0FDREEsWUFBWSxDQUFDLDJCQUEyQixHQUFHO0lBQzNDOztLQUVDLEdBQ0RBLFlBQVksQ0FBQyxvQkFBb0IsR0FBRztJQUNwQzs7S0FFQyxHQUNEQSxZQUFZLENBQUMsdUJBQXVCLEdBQUc7SUFDdkM7O0tBRUMsR0FDREEsWUFBWSxDQUFDLHFCQUFxQixHQUFHO0FBQ3pDLEdBQUdBLGdCQUFpQkEsQ0FBQUEsZUFBZSxDQUFDO0FBQ3BDLGlDQUFpQyxHQUNqQyxJQUFJQztBQUNILFVBQVVBLGtCQUFrQjtJQUN6Qjs7S0FFQyxHQUNEQSxrQkFBa0IsQ0FBQyxtQ0FBbUMsR0FBRztJQUN6RDs7S0FFQyxHQUNEQSxrQkFBa0IsQ0FBQywrQkFBK0IsR0FBRztJQUNyRDs7S0FFQyxHQUNEQSxrQkFBa0IsQ0FBQyw2QkFBNkIsR0FBRztJQUNuRDs7S0FFQyxHQUNEQSxrQkFBa0IsQ0FBQywrQkFBK0IsR0FBRztJQUNyRDs7S0FFQyxHQUNEQSxrQkFBa0IsQ0FBQyw4QkFBOEIsR0FBRztBQUN4RCxHQUFHQSxzQkFBdUJBLENBQUFBLHFCQUFxQixDQUFDO0FBQ2hELHdEQUF3RCxHQUN4RCxJQUFJQztBQUNILFVBQVVBLGFBQWE7SUFDcEI7O0tBRUMsR0FDREEsYUFBYSxDQUFDLDZCQUE2QixHQUFHO0lBQzlDOztLQUVDLEdBQ0RBLGFBQWEsQ0FBQyxTQUFTLEdBQUc7SUFDMUI7O0tBRUMsR0FDREEsYUFBYSxDQUFDLFFBQVEsR0FBRztJQUN6Qjs7S0FFQyxHQUNEQSxhQUFhLENBQUMsWUFBWSxHQUFHO0lBQzdCOztLQUVDLEdBQ0RBLGFBQWEsQ0FBQyxxQkFBcUIsR0FBRztJQUN0Qzs7S0FFQyxHQUNEQSxhQUFhLENBQUMsZUFBZSxHQUFHO0lBQ2hDOztLQUVDLEdBQ0RBLGFBQWEsQ0FBQyxjQUFjLEdBQUc7SUFDL0I7O0tBRUMsR0FDREEsYUFBYSxDQUFDLFlBQVksR0FBRztBQUNqQyxHQUFHQSxpQkFBa0JBLENBQUFBLGdCQUFnQixDQUFDO0FBQ3RDLDhGQUE4RixHQUM5RixJQUFJQztBQUNILFVBQVVBLFdBQVc7SUFDbEI7O0tBRUMsR0FDREEsV0FBVyxDQUFDLDJCQUEyQixHQUFHO0lBQzFDOztLQUVDLEdBQ0RBLFdBQVcsQ0FBQyxZQUFZLEdBQUc7SUFDM0I7O0tBRUMsR0FDREEsV0FBVyxDQUFDLHlCQUF5QixHQUFHO0FBQzVDLEdBQUdBLGVBQWdCQSxDQUFBQSxjQUFjLENBQUM7QUFDbEMsK0JBQStCLEdBQy9CLElBQUlDO0FBQ0gsVUFBVUEsUUFBUTtJQUNmOztLQUVDLEdBQ0RBLFFBQVEsQ0FBQyx1QkFBdUIsR0FBRztJQUNuQzs7S0FFQyxHQUNEQSxRQUFRLENBQUMsT0FBTyxHQUFHO0lBQ25COztLQUVDLEdBQ0RBLFFBQVEsQ0FBQyxRQUFRLEdBQUc7SUFDcEI7O0tBRUMsR0FDREEsUUFBUSxDQUFDLFFBQVEsR0FBRztBQUN4QixHQUFHQSxZQUFhQSxDQUFBQSxXQUFXLENBQUM7QUFDNUIsaUNBQWlDLEdBQ2pDLElBQUlDO0FBQ0gsVUFBVUEsZUFBZTtJQUN0Qjs7S0FFQyxHQUNEQSxlQUFlLENBQUMsK0JBQStCLEdBQUc7SUFDbEQ7O0tBRUMsR0FDREEsZUFBZSxDQUFDLHVCQUF1QixHQUFHO0lBQzFDOztLQUVDLEdBQ0RBLGVBQWUsQ0FBQywwQkFBMEIsR0FBRztJQUM3Qzs7S0FFQyxHQUNEQSxlQUFlLENBQUMsd0JBQXdCLEdBQUc7QUFDL0MsR0FBR0EsbUJBQW9CQSxDQUFBQSxrQkFBa0IsQ0FBQztBQUMxQywyREFBMkQsR0FDM0QsSUFBSUM7QUFDSCxVQUFVQSxVQUFVO0lBQ2pCOztLQUVDLEdBQ0RBLFVBQVUsQ0FBQywwQkFBMEIsR0FBRztJQUN4Qzs7S0FFQyxHQUNEQSxVQUFVLENBQUMsbUJBQW1CLEdBQUc7SUFDakM7O0tBRUMsR0FDREEsVUFBVSxDQUFDLDJCQUEyQixHQUFHO0FBQzdDLEdBQUdBLGNBQWVBLENBQUFBLGFBQWEsQ0FBQztBQUNoQyx1RUFBdUUsR0FDdkUsSUFBSUM7QUFDSCxVQUFVQSxXQUFXO0lBQ2xCOztLQUVDLEdBQ0RBLFdBQVcsQ0FBQywyQkFBMkIsR0FBRztJQUMxQzs7S0FFQyxHQUNEQSxXQUFXLENBQUMsbUJBQW1CLEdBQUc7SUFDbEM7O0tBRUMsR0FDREEsV0FBVyxDQUFDLG1CQUFtQixHQUFHO0lBQ2xDOztLQUVDLEdBQ0RBLFdBQVcsQ0FBQyxvQkFBb0IsR0FBRztJQUNuQzs7S0FFQyxHQUNEQSxXQUFXLENBQUMscUJBQXFCLEdBQUc7SUFDcEM7O0tBRUMsR0FDREEsV0FBVyxDQUFDLHVCQUF1QixHQUFHO0lBQ3RDOztLQUVDLEdBQ0RBLFdBQVcsQ0FBQywwQkFBMEIsR0FBRztBQUM3QyxHQUFHQSxlQUFnQkEsQ0FBQUEsY0FBYyxDQUFDO0FBQ2xDLGVBQWUsR0FDZixJQUFJQztBQUNILFVBQVVBLFFBQVE7SUFDZjs7S0FFQyxHQUNEQSxRQUFRLENBQUMsd0JBQXdCLEdBQUc7SUFDcEM7O0tBRUMsR0FDREEsUUFBUSxDQUFDLG1CQUFtQixHQUFHO0lBQy9COztLQUVDLEdBQ0RBLFFBQVEsQ0FBQyxvQkFBb0IsR0FBRztJQUNoQzs7S0FFQyxHQUNEQSxRQUFRLENBQUMsb0JBQW9CLEdBQUc7SUFDaEM7O0tBRUMsR0FDREEsUUFBUSxDQUFDLHNCQUFzQixHQUFHO0lBQ2xDOztLQUVDLEdBQ0RBLFFBQVEsQ0FBQyxtQkFBbUIsR0FBRztJQUMvQjs7S0FFQyxHQUNEQSxRQUFRLENBQUMsdUJBQXVCLEdBQUc7SUFDbkM7O0tBRUMsR0FDREEsUUFBUSxDQUFDLHNCQUFzQixHQUFHO0lBQ2xDOztLQUVDLEdBQ0RBLFFBQVEsQ0FBQyxtQkFBbUIsR0FBRztJQUMvQjs7S0FFQyxHQUNEQSxRQUFRLENBQUMsb0JBQW9CLEdBQUc7SUFDaEM7O0tBRUMsR0FDREEsUUFBUSxDQUFDLHFCQUFxQixHQUFHO0lBQ2pDOztLQUVDLEdBQ0RBLFFBQVEsQ0FBQyxnQ0FBZ0MsR0FBRztBQUNoRCxHQUFHQSxZQUFhQSxDQUFBQSxXQUFXLENBQUM7QUFDNUIsa0ZBQWtGLEdBQ2xGLElBQUlDO0FBQ0gsVUFBVUEsVUFBVTtJQUNqQjs7S0FFQyxHQUNEQSxVQUFVLENBQUMsMEJBQTBCLEdBQUc7SUFDeEM7O0tBRUMsR0FDREEsVUFBVSxDQUFDLGtCQUFrQixHQUFHO0lBQ2hDOztLQUVDLEdBQ0RBLFVBQVUsQ0FBQyxrQkFBa0IsR0FBRztJQUNoQzs7S0FFQyxHQUNEQSxVQUFVLENBQUMsa0JBQWtCLEdBQUc7QUFDcEMsR0FBR0EsY0FBZUEsQ0FBQUEsYUFBYSxDQUFDO0FBQ2hDLG1EQUFtRCxHQUNuRCxJQUFJQztBQUNILFVBQVVBLHdCQUF3QjtJQUMvQjs7S0FFQyxHQUNEQSx3QkFBd0IsQ0FBQywrQkFBK0IsR0FBRztJQUMzRDs7S0FFQyxHQUNEQSx3QkFBd0IsQ0FBQyx1QkFBdUIsR0FBRztJQUNuRDs7S0FFQyxHQUNEQSx3QkFBd0IsQ0FBQywwQkFBMEIsR0FBRztJQUN0RDs7S0FFQyxHQUNEQSx3QkFBd0IsQ0FBQyx3QkFBd0IsR0FBRztBQUN4RCxHQUFHQSw0QkFBNkJBLENBQUFBLDJCQUEyQixDQUFDO0FBQzVELDhDQUE4QyxHQUM5QyxJQUFJQztBQUNILFVBQVVBLDBCQUEwQjtJQUNqQ0EsMEJBQTBCLENBQUMsMkNBQTJDLEdBQUc7SUFDekVBLDBCQUEwQixDQUFDLHFCQUFxQixHQUFHO0lBQ25EQSwwQkFBMEIsQ0FBQyxXQUFXLEdBQUc7SUFDekNBLDBCQUEwQixDQUFDLGtCQUFrQixHQUFHO0FBQ3BELEdBQUdBLDhCQUErQkEsQ0FBQUEsNkJBQTZCLENBQUM7QUFDaEUsMkRBQTJELEdBQzNELElBQUlDO0FBQ0gsVUFBVUEsUUFBUTtJQUNmOztLQUVDLEdBQ0RBLFFBQVEsQ0FBQyxjQUFjLEdBQUc7SUFDMUI7O0tBRUMsR0FDREEsUUFBUSxDQUFDLFdBQVcsR0FBRztJQUN2Qjs7S0FFQyxHQUNEQSxRQUFRLENBQUMsZUFBZSxHQUFHO0FBQy9CLEdBQUdBLFlBQWFBLENBQUFBLFdBQVcsQ0FBQztBQUM1QixrREFBa0QsR0FDbEQsSUFBSUM7QUFDSCxVQUFVQSwwQkFBMEI7SUFDakM7O0tBRUMsR0FDREEsMEJBQTBCLENBQUMsbUJBQW1CLEdBQUc7SUFDakQ7O0tBRUMsR0FDREEsMEJBQTBCLENBQUMsZUFBZSxHQUFHO0FBQ2pELEdBQUdBLDhCQUErQkEsQ0FBQUEsNkJBQTZCLENBQUM7QUFDaEUsb0NBQW9DLEdBQ3BDLElBQUlDO0FBQ0gsVUFBVUEsV0FBVztJQUNsQjs7S0FFQyxHQUNEQSxXQUFXLENBQUMsMEJBQTBCLEdBQUc7SUFDekM7O0tBRUMsR0FDREEsV0FBVyxDQUFDLHNCQUFzQixHQUFHO0FBQ3pDLEdBQUdBLGVBQWdCQSxDQUFBQSxjQUFjLENBQUM7QUFDbEMsaURBQWlELEdBQ2pELElBQUlDO0FBQ0gsVUFBVUEseUJBQXlCO0lBQ2hDOztLQUVDLEdBQ0RBLHlCQUF5QixDQUFDLG1CQUFtQixHQUFHO0lBQ2hEOztLQUVDLEdBQ0RBLHlCQUF5QixDQUFDLE9BQU8sR0FBRztJQUNwQzs7S0FFQyxHQUNEQSx5QkFBeUIsQ0FBQyxNQUFNLEdBQUc7SUFDbkM7O0tBRUMsR0FDREEseUJBQXlCLENBQUMsT0FBTyxHQUFHO0lBQ3BDOztLQUVDLEdBQ0RBLHlCQUF5QixDQUFDLFlBQVksR0FBRztBQUM3QyxHQUFHQSw2QkFBOEJBLENBQUFBLDRCQUE0QixDQUFDO0FBQzlELDBFQUEwRSxHQUMxRSxJQUFJQztBQUNILFVBQVVBLGlCQUFpQjtJQUN4QkEsaUJBQWlCLENBQUMsc0JBQXNCLEdBQUc7SUFDM0NBLGlCQUFpQixDQUFDLHlCQUF5QixHQUFHO0lBQzlDQSxpQkFBaUIsQ0FBQyxrQkFBa0IsR0FBRztJQUN2Q0EsaUJBQWlCLENBQUMsYUFBYSxHQUFHO0FBQ3RDLEdBQUdBLHFCQUFzQkEsQ0FBQUEsb0JBQW9CLENBQUM7QUFDOUMsaURBQWlELEdBQ2pELElBQUlDO0FBQ0gsVUFBVUEsZ0JBQWdCO0lBQ3ZCOztLQUVDLEdBQ0RBLGdCQUFnQixDQUFDLGFBQWEsR0FBRztJQUNqQzs7S0FFQyxHQUNEQSxnQkFBZ0IsQ0FBQyxjQUFjLEdBQUc7SUFDbEM7O0tBRUMsR0FDREEsZ0JBQWdCLENBQUMsWUFBWSxHQUFHO0FBQ3BDLEdBQUdBLG9CQUFxQkEsQ0FBQUEsbUJBQW1CLENBQUM7QUFDNUMsZ0VBQWdFLEdBQ2hFLElBQUlDO0FBQ0gsVUFBVUEsbUJBQW1CO0lBQzFCOztLQUVDLEdBQ0RBLG1CQUFtQixDQUFDLE9BQU8sR0FBRztJQUM5Qjs7S0FFQyxHQUNEQSxtQkFBbUIsQ0FBQyxLQUFLLEdBQUc7SUFDNUI7O0tBRUMsR0FDREEsbUJBQW1CLENBQUMsS0FBSyxHQUFHO0lBQzVCOztLQUVDLEdBQ0RBLG1CQUFtQixDQUFDLEtBQUssR0FBRztJQUM1Qjs7S0FFQyxHQUNEQSxtQkFBbUIsQ0FBQyxLQUFLLEdBQUc7SUFDNUI7O0tBRUMsR0FDREEsbUJBQW1CLENBQUMsS0FBSyxHQUFHO0lBQzVCOztLQUVDLEdBQ0RBLG1CQUFtQixDQUFDLEtBQUssR0FBRztJQUM1Qjs7S0FFQyxHQUNEQSxtQkFBbUIsQ0FBQyxLQUFLLEdBQUc7QUFDaEMsR0FBR0EsdUJBQXdCQSxDQUFBQSxzQkFBc0IsQ0FBQztBQUNsRCwrREFBK0QsR0FDL0QsSUFBSUM7QUFDSCxVQUFVQSxpQkFBaUI7SUFDeEJBLGlCQUFpQixDQUFDLG9CQUFvQixHQUFHO0lBQ3pDQSxpQkFBaUIsQ0FBQywwQkFBMEIsR0FBRztJQUMvQ0EsaUJBQWlCLENBQUMsdUJBQXVCLEdBQUc7SUFDNUNBLGlCQUFpQixDQUFDLHVCQUF1QixHQUFHO0lBQzVDQSxpQkFBaUIsQ0FBQyxxQkFBcUIsR0FBRztBQUM5QyxHQUFHQSxxQkFBc0JBLENBQUFBLG9CQUFvQixDQUFDO0FBQzlDLHFFQUFxRSxHQUNyRSxJQUFJQztBQUNILFVBQVVBLG9CQUFvQjtJQUMzQkEsb0JBQW9CLENBQUMsdUJBQXVCLEdBQUc7SUFDL0NBLG9CQUFvQixDQUFDLHFCQUFxQixHQUFHO0lBQzdDQSxvQkFBb0IsQ0FBQyx3QkFBd0IsR0FBRztJQUNoREEsb0JBQW9CLENBQUMseUJBQXlCLEdBQUc7QUFDckQsR0FBR0Esd0JBQXlCQSxDQUFBQSx1QkFBdUIsQ0FBQztBQUNwRCxxRUFBcUUsR0FDckUsSUFBSUM7QUFDSCxVQUFVQSxvQkFBb0I7SUFDM0JBLG9CQUFvQixDQUFDLHVCQUF1QixHQUFHO0lBQy9DQSxvQkFBb0IsQ0FBQyxzQkFBc0IsR0FBRztJQUM5Q0Esb0JBQW9CLENBQUMsc0JBQXNCLEdBQUc7SUFDOUNBLG9CQUFvQixDQUFDLHVCQUF1QixHQUFHO0FBQ25ELEdBQUdBLHdCQUF5QkEsQ0FBQUEsdUJBQXVCLENBQUM7QUFDcEQsd0NBQXdDLEdBQ3hDLElBQUlDO0FBQ0gsVUFBVUEsUUFBUTtJQUNmQSxRQUFRLENBQUMsb0JBQW9CLEdBQUc7SUFDaENBLFFBQVEsQ0FBQyw0QkFBNEIsR0FBRztJQUN4Q0EsUUFBUSxDQUFDLDhCQUE4QixHQUFHO0lBQzFDQSxRQUFRLENBQUMscUJBQXFCLEdBQUc7SUFDakNBLFFBQVEsQ0FBQywrQkFBK0IsR0FBRztJQUMzQ0EsUUFBUSxDQUFDLGtCQUFrQixHQUFHO0lBQzlCQSxRQUFRLENBQUMsbUJBQW1CLEdBQUc7SUFDL0JBLFFBQVEsQ0FBQywwQkFBMEIsR0FBRztBQUMxQyxHQUFHQSxZQUFhQSxDQUFBQSxXQUFXLENBQUM7QUFDNUIsZ0RBQWdELEdBQ2hELElBQUlDO0FBQ0gsVUFBVUEsV0FBVztJQUNsQkEsV0FBVyxDQUFDLGFBQWEsR0FBRztJQUM1QkEsV0FBVyxDQUFDLGFBQWEsR0FBRztJQUM1QkEsV0FBVyxDQUFDLFNBQVMsR0FBRztJQUN4QkEsV0FBVyxDQUFDLFdBQVcsR0FBRztJQUMxQkEsV0FBVyxDQUFDLGNBQWMsR0FBRztBQUNqQyxHQUFHQSxlQUFnQkEsQ0FBQUEsY0FBYyxDQUFDO0FBQ2xDLHVFQUF1RSxHQUN2RSxJQUFJQztBQUNILFVBQVVBLDRCQUE0QjtJQUNuQzs7O0tBR0MsR0FDREEsNEJBQTRCLENBQUMsUUFBUSxHQUFHO0lBQ3hDOzs7O0tBSUMsR0FDREEsNEJBQTRCLENBQUMsUUFBUSxHQUFHO0FBQzVDLEdBQUdBLGdDQUFpQ0EsQ0FBQUEsK0JBQStCLENBQUM7QUFDcEUsdURBQXVELEdBQ3ZELElBQUlDO0FBQ0gsVUFBVUEsdUJBQXVCO0lBQzlCOzs7OztLQUtDLEdBQ0RBLHVCQUF1QixDQUFDLFNBQVMsR0FBRztJQUNwQzs7O0tBR0MsR0FDREEsdUJBQXVCLENBQUMsU0FBUyxHQUFHO0lBQ3BDOzs7S0FHQyxHQUNEQSx1QkFBdUIsQ0FBQyxnQkFBZ0IsR0FBRztJQUMzQzs7OztLQUlDLEdBQ0RBLHVCQUF1QixDQUFDLFdBQVcsR0FBRztBQUMxQyxHQUFHQSwyQkFBNEJBLENBQUFBLDBCQUEwQixDQUFDO0FBQzFELHdFQUF3RSxHQUN4RSxJQUFJQztBQUNILFVBQVVBLHVCQUF1QjtJQUM5Qjs7O0tBR0MsR0FDREEsdUJBQXVCLENBQUMsWUFBWSxHQUFHO0lBQ3ZDOzs7S0FHQyxHQUNEQSx1QkFBdUIsQ0FBQyxXQUFXLEdBQUc7QUFDMUMsR0FBR0EsMkJBQTRCQSxDQUFBQSwwQkFBMEIsQ0FBQztBQUMxRCx5Q0FBeUMsR0FDekMsSUFBSUM7QUFDSCxVQUFVQSxZQUFZO0lBQ25COztLQUVDLEdBQ0RBLFlBQVksQ0FBQyx5QkFBeUIsR0FBRztJQUN6Qzs7S0FFQyxHQUNEQSxZQUFZLENBQUMsb0JBQW9CLEdBQUc7QUFDeEMsR0FBR0EsZ0JBQWlCQSxDQUFBQSxlQUFlLENBQUM7QUFDcEMsMkNBQTJDLEdBQzNDLElBQUlDO0FBQ0gsVUFBVUEsYUFBYTtJQUNwQkEsYUFBYSxDQUFDLG9CQUFvQixHQUFHO0lBQ3JDQSxhQUFhLENBQUMsZ0JBQWdCLEdBQUc7SUFDakNBLGFBQWEsQ0FBQyxlQUFlLEdBQUc7SUFDaENBLGFBQWEsQ0FBQyxlQUFlLEdBQUc7QUFDcEMsR0FBR0EsaUJBQWtCQSxDQUFBQSxnQkFBZ0IsQ0FBQztBQUN0Qyx1Q0FBdUMsR0FDdkMsSUFBSUM7QUFDSCxVQUFVQSxTQUFTO0lBQ2hCQSxTQUFTLENBQUMsb0JBQW9CLEdBQUc7SUFDakNBLFNBQVMsQ0FBQyxhQUFhLEdBQUc7SUFDMUJBLFNBQVMsQ0FBQyxTQUFTLEdBQUc7SUFDdEJBLFNBQVMsQ0FBQyxTQUFTLEdBQUc7QUFDMUIsR0FBR0EsYUFBY0EsQ0FBQUEsWUFBWSxDQUFDO0FBQzlCLHdCQUF3QixHQUN4QixJQUFJQztBQUNILFVBQVVBLFVBQVU7SUFDakJBLFVBQVUsQ0FBQyxxQkFBcUIsR0FBRztJQUNuQ0EsVUFBVSxDQUFDLFdBQVcsR0FBRztJQUN6QkEsVUFBVSxDQUFDLFlBQVksR0FBRztBQUM5QixHQUFHQSxjQUFlQSxDQUFBQSxhQUFhLENBQUM7QUFDaEMseUNBQXlDLEdBQ3pDLElBQUlDO0FBQ0gsVUFBVUEsa0JBQWtCO0lBQ3pCOztLQUVDLEdBQ0RBLGtCQUFrQixDQUFDLG1DQUFtQyxHQUFHO0lBQ3pEOztLQUVDLEdBQ0RBLGtCQUFrQixDQUFDLDBCQUEwQixHQUFHO0lBQ2hEOztLQUVDLEdBQ0RBLGtCQUFrQixDQUFDLG9CQUFvQixHQUFHO0lBQzFDOztLQUVDLEdBQ0RBLGtCQUFrQixDQUFDLGtCQUFrQixHQUFHO0FBQzVDLEdBQUdBLHNCQUF1QkEsQ0FBQUEscUJBQXFCLENBQUM7QUFDaEQsK0JBQStCLEdBQy9CLElBQUlDO0FBQ0gsVUFBVUEsYUFBYTtJQUNwQjs7S0FFQyxHQUNEQSxhQUFhLENBQUMsdUJBQXVCLEdBQUc7SUFDeEM7O0tBRUMsR0FDREEsYUFBYSxDQUFDLE9BQU8sR0FBRztJQUN4Qjs7S0FFQyxHQUNEQSxhQUFhLENBQUMsUUFBUSxHQUFHO0lBQ3pCOztLQUVDLEdBQ0RBLGFBQWEsQ0FBQyxRQUFRLEdBQUc7SUFDekI7O0tBRUMsR0FDREEsYUFBYSxDQUFDLFFBQVEsR0FBRztJQUN6Qjs7S0FFQyxHQUNEQSxhQUFhLENBQUMsV0FBVyxHQUFHO0FBQ2hDLEdBQUdBLGlCQUFrQkEsQ0FBQUEsZ0JBQWdCLENBQUM7QUFDdEMsaUNBQWlDLEdBQ2pDLElBQUlDO0FBQ0gsVUFBVUEsZ0JBQWdCO0lBQ3ZCOztLQUVDLEdBQ0RBLGdCQUFnQixDQUFDLGdDQUFnQyxHQUFHO0lBQ3BEOztLQUVDLEdBQ0RBLGdCQUFnQixDQUFDLHlCQUF5QixHQUFHO0lBQzdDOztLQUVDLEdBQ0RBLGdCQUFnQixDQUFDLHdCQUF3QixHQUFHO0FBQ2hELEdBQUdBLG9CQUFxQkEsQ0FBQUEsbUJBQW1CLENBQUM7QUFDNUMsK0JBQStCLEdBQy9CLElBQUlDO0FBQ0gsVUFBVUEsY0FBYztJQUNyQjs7S0FFQyxHQUNEQSxjQUFjLENBQUMsOEJBQThCLEdBQUc7SUFDaEQ7O0tBRUMsR0FDREEsY0FBYyxDQUFDLHVCQUF1QixHQUFHO0lBQ3pDOztLQUVDLEdBQ0RBLGNBQWMsQ0FBQyxzQkFBc0IsR0FBRztBQUM1QyxHQUFHQSxrQkFBbUJBLENBQUFBLGlCQUFpQixDQUFDO0FBQ3hDLGtEQUFrRCxHQUNsRCxJQUFJQztBQUNILFVBQVVBLGdCQUFnQjtJQUN2Qjs7S0FFQyxHQUNEQSxnQkFBZ0IsQ0FBQyxnQ0FBZ0MsR0FBRztJQUNwRDs7S0FFQyxHQUNEQSxnQkFBZ0IsQ0FBQywrQkFBK0IsR0FBRztJQUNuRDs7S0FFQyxHQUNEQSxnQkFBZ0IsQ0FBQyxrQkFBa0IsR0FBRztBQUMxQyxHQUFHQSxvQkFBcUJBLENBQUFBLG1CQUFtQixDQUFDO0FBQzVDLDhEQUE4RCxHQUM5RCxJQUFJQztBQUNILFVBQVVBLFlBQVk7SUFDbkI7O0tBRUMsR0FDREEsWUFBWSxDQUFDLDRCQUE0QixHQUFHO0lBQzVDOztLQUVDLEdBQ0RBLFlBQVksQ0FBQyw4QkFBOEIsR0FBRztJQUM5Qzs7S0FFQyxHQUNEQSxZQUFZLENBQUMsMEJBQTBCLEdBQUc7QUFDOUMsR0FBR0EsZ0JBQWlCQSxDQUFBQSxlQUFlLENBQUM7QUFDcEMsa0NBQWtDLEdBQ2xDLElBQUlDO0FBQ0gsVUFBVUEsS0FBSztJQUNaOztLQUVDLEdBQ0RBLEtBQUssQ0FBQyxvQkFBb0IsR0FBRztJQUM3Qjs7S0FFQyxHQUNEQSxLQUFLLENBQUMsa0JBQWtCLEdBQUc7SUFDM0I7O0tBRUMsR0FDREEsS0FBSyxDQUFDLDRCQUE0QixHQUFHO0lBQ3JDOztLQUVDLEdBQ0RBLEtBQUssQ0FBQyxrQkFBa0IsR0FBRztJQUMzQjs7S0FFQyxHQUNEQSxLQUFLLENBQUMsdUJBQXVCLEdBQUc7SUFDaEM7O0tBRUMsR0FDREEsS0FBSyxDQUFDLHVCQUF1QixHQUFHO0lBQ2hDOztLQUVDLEdBQ0RBLEtBQUssQ0FBQyxrQkFBa0IsR0FBRztJQUMzQjs7S0FFQyxHQUNEQSxLQUFLLENBQUMsNEJBQTRCLEdBQUc7SUFDckM7O0tBRUMsR0FDREEsS0FBSyxDQUFDLGtCQUFrQixHQUFHO0lBQzNCOztLQUVDLEdBQ0RBLEtBQUssQ0FBQyx1QkFBdUIsR0FBRztJQUNoQzs7S0FFQyxHQUNEQSxLQUFLLENBQUMsdUJBQXVCLEdBQUc7SUFDaEM7O0tBRUMsR0FDREEsS0FBSyxDQUFDLHVCQUF1QixHQUFHO0lBQ2hDOztLQUVDLEdBQ0RBLEtBQUssQ0FBQyx1QkFBdUIsR0FBRztBQUNwQyxHQUFHQSxTQUFVQSxDQUFBQSxRQUFRLENBQUM7QUFDdEIsa0NBQWtDLEdBQ2xDLElBQUlDO0FBQ0gsVUFBVUEsbUJBQW1CO0lBQzFCOztLQUVDLEdBQ0RBLG1CQUFtQixDQUFDLG9DQUFvQyxHQUFHO0lBQzNEOzs7S0FHQyxHQUNEQSxtQkFBbUIsQ0FBQyxVQUFVLEdBQUc7SUFDakM7OztLQUdDLEdBQ0RBLG1CQUFtQixDQUFDLFlBQVksR0FBRztJQUNuQzs7O0tBR0MsR0FDREEsbUJBQW1CLENBQUMsZUFBZSxHQUFHO0FBQzFDLEdBQUdBLHVCQUF3QkEsQ0FBQUEsc0JBQXNCLENBQUM7QUFDbEQsa0VBQWtFLEdBQ2xFLElBQUlDO0FBQ0gsVUFBVUEsd0JBQXdCO0lBQy9COztLQUVDLEdBQ0RBLHdCQUF3QixDQUFDLCtCQUErQixHQUFHO0lBQzNEOztLQUVDLEdBQ0RBLHdCQUF3QixDQUFDLE9BQU8sR0FBRztJQUNuQzs7S0FFQyxHQUNEQSx3QkFBd0IsQ0FBQyxRQUFRLEdBQUc7SUFDcEM7OztLQUdDLEdBQ0RBLHdCQUF3QixDQUFDLE9BQU8sR0FBRztJQUNuQzs7O0tBR0MsR0FDREEsd0JBQXdCLENBQUMsZ0JBQWdCLEdBQUc7QUFDaEQsR0FBR0EsNEJBQTZCQSxDQUFBQSwyQkFBMkIsQ0FBQztBQUM1RDs7O09BR08sR0FDUCxNQUFNQztBQUNOO0FBQ0EsMENBQTBDLEdBQzFDLE1BQU1DO0FBQ047QUFDQTs7Ozs7Ozs7T0FRTyxHQUNQLE1BQU1DO0FBQ047QUFDQTs7Q0FFQyxHQUNELFNBQVNDLHFDQUFxQ2hKLElBQUksRUFBRWlKLFFBQVE7SUFDeEQsT0FBTztRQUNIQyxZQUFZO1lBQ1JsSixNQUFNQTtZQUNOaUosVUFBVUE7UUFDZDtJQUNKO0FBQ0o7QUFDQTs7Q0FFQyxHQUNELFNBQVNFLGtDQUFrQ0MsR0FBRyxFQUFFSCxRQUFRO0lBQ3BELE9BQU87UUFDSEksVUFBVTtZQUNOQyxTQUFTRjtZQUNUSCxVQUFVQTtRQUNkO0lBQ0o7QUFDSjtBQUNBLHlCQUF5QixHQUN6QixNQUFNTTtBQUNOO0FBQ0E7O0NBRUMsR0FDRCxTQUFTQyxrQkFBa0JKLEdBQUcsRUFBRUgsUUFBUSxFQUFFUSxlQUFlO0lBQ3JELE9BQU9qSyxPQUFPd0IsTUFBTSxDQUFDO1FBQUVxSSxVQUFVO1lBQ3pCQyxTQUFTRjtZQUNUSCxVQUFVQTtRQUNkO0lBQUUsR0FBSVEsbUJBQW1CO1FBQUVBLGlCQUFpQjtZQUFFQyxPQUFPRDtRQUFnQjtJQUFFO0FBQy9FO0FBQ0E7O0NBRUMsR0FDRCxTQUFTRSxtQkFBbUJDLElBQUk7SUFDNUIsT0FBTztRQUNIQSxNQUFNQTtJQUNWO0FBQ0o7QUFDQTs7Q0FFQyxHQUNELFNBQVNDLDJCQUEyQkMsSUFBSSxFQUFFQyxJQUFJO0lBQzFDLE9BQU87UUFDSEMsY0FBYztZQUNWRixNQUFNQTtZQUNOQyxNQUFNQTtRQUNWO0lBQ0o7QUFDSjtBQUNBOztDQUVDLEdBQ0QsU0FBU0UsK0JBQStCQyxFQUFFLEVBQUVKLElBQUksRUFBRUssUUFBUTtRQUFFQyxRQUFBQSxpRUFBUSxFQUFFO0lBQ2xFLE9BQU87UUFDSEMsa0JBQWtCN0ssT0FBT3dCLE1BQU0sQ0FBQztZQUFFa0osSUFBSUE7WUFBSUosTUFBTUE7WUFBTUssVUFBVUE7UUFBUyxHQUFJQyxNQUFNakssTUFBTSxHQUFHLEtBQUs7WUFBRWlLO1FBQU07SUFDN0c7QUFDSjtBQUNBOztDQUVDLEdBQ0QsU0FBU0UscUJBQXFCdEssSUFBSSxFQUFFaUosUUFBUSxFQUFFUSxlQUFlO0lBQ3pELE9BQU9qSyxPQUFPd0IsTUFBTSxDQUFDO1FBQUVrSSxZQUFZO1lBQzNCbEosTUFBTUE7WUFDTmlKLFVBQVVBO1FBQ2Q7SUFBRSxHQUFJUSxtQkFBbUI7UUFBRUEsaUJBQWlCO1lBQUVDLE9BQU9EO1FBQWdCO0lBQUU7QUFDL0U7QUFDQTs7Q0FFQyxHQUNELFNBQVNjLGtDQUFrQ0MsT0FBTyxFQUFFQyxNQUFNO0lBQ3RELE9BQU87UUFDSEMscUJBQXFCO1lBQ2pCRixTQUFTQTtZQUNUQyxRQUFRQTtRQUNaO0lBQ0o7QUFDSjtBQUNBOztDQUVDLEdBQ0QsU0FBU0UsNkJBQTZCQyxJQUFJLEVBQUVDLFFBQVE7SUFDaEQsT0FBTztRQUNIQyxnQkFBZ0I7WUFDWkYsTUFBTUE7WUFDTkMsVUFBVUE7UUFDZDtJQUNKO0FBQ0o7QUFDQSxTQUFTRSxRQUFRQyxHQUFHO0lBQ2hCLElBQUksT0FBT0EsUUFBUSxZQUFZQSxRQUFRLE1BQU07UUFDekMsT0FBUSxjQUFjQSxPQUNsQixVQUFVQSxPQUNWLGtCQUFrQkEsT0FDbEIsc0JBQXNCQSxPQUN0QixnQkFBZ0JBLE9BQ2hCLG1CQUFtQkEsT0FDbkIseUJBQXlCQSxPQUN6QixvQkFBb0JBO0lBQzVCO0lBQ0EsT0FBTztBQUNYO0FBQ0EsU0FBU0MsU0FBU0MsWUFBWTtJQUMxQixNQUFNZCxRQUFRLEVBQUU7SUFDaEIsSUFBSSxPQUFPYyxpQkFBaUIsVUFBVTtRQUNsQ2QsTUFBTXBILElBQUksQ0FBQzJHLG1CQUFtQnVCO0lBQ2xDLE9BQ0ssSUFBSUgsUUFBUUcsZUFBZTtRQUM1QmQsTUFBTXBILElBQUksQ0FBQ2tJO0lBQ2YsT0FDSyxJQUFJM0ssTUFBTUMsT0FBTyxDQUFDMEssZUFBZTtRQUNsQyxJQUFJQSxhQUFhL0ssTUFBTSxLQUFLLEdBQUc7WUFDM0IsTUFBTSxJQUFJTCxNQUFNO1FBQ3BCO1FBQ0EsS0FBSyxNQUFNcUwsUUFBUUQsYUFBYztZQUM3QixJQUFJLE9BQU9DLFNBQVMsVUFBVTtnQkFDMUJmLE1BQU1wSCxJQUFJLENBQUMyRyxtQkFBbUJ3QjtZQUNsQyxPQUNLLElBQUlKLFFBQVFJLE9BQU87Z0JBQ3BCZixNQUFNcEgsSUFBSSxDQUFDbUk7WUFDZixPQUNLO2dCQUNELE1BQU0sSUFBSXJMLE1BQU07WUFDcEI7UUFDSjtJQUNKLE9BQ0s7UUFDRCxNQUFNLElBQUlBLE1BQU07SUFDcEI7SUFDQSxPQUFPc0s7QUFDWDtBQUNBOztDQUVDLEdBQ0QsU0FBU2dCLGtCQUFrQkYsWUFBWTtJQUNuQyxPQUFPO1FBQ0hHLE1BQU07UUFDTmpCLE9BQU9hLFNBQVNDO0lBQ3BCO0FBQ0o7QUFDQTs7Q0FFQyxHQUNELFNBQVNJLG1CQUFtQkosWUFBWTtJQUNwQyxPQUFPO1FBQ0hHLE1BQU07UUFDTmpCLE9BQU9hLFNBQVNDO0lBQ3BCO0FBQ0o7QUFDQSwyQ0FBMkMsR0FDM0MsTUFBTUs7SUFXRkMsT0FBTztRQUNILE9BQU8sSUFBSSxDQUFDQyxnQkFBZ0IsQ0FBQ0QsSUFBSTtJQUNyQztJQVpBRSxZQUFZdkIsUUFBUSxDQUFFO1FBQ2xCLHVCQUF1QjtRQUN2QixNQUFNd0IsVUFBVSxDQUFDO1FBQ2pCLEtBQUssTUFBTUMsUUFBUXpCLFNBQVN3QixPQUFPLENBQUNoSyxPQUFPLEdBQUk7WUFDM0NnSyxPQUFPLENBQUNDLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBR0EsSUFBSSxDQUFDLEVBQUU7UUFDOUI7UUFDQSxJQUFJLENBQUNELE9BQU8sR0FBR0E7UUFDZiw4QkFBOEI7UUFDOUIsSUFBSSxDQUFDRixnQkFBZ0IsR0FBR3RCO0lBQzVCO0FBSUo7QUFDQSxtTEFBbUwsR0FDbkwsTUFBTTBCO0FBQ047QUFDQSwyTUFBMk0sR0FDM00sTUFBTUM7QUFDTjtBQUNBLDREQUE0RCxHQUM1RCxNQUFNQztJQUNGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FxQkMsR0FDRCxJQUFJbkMsT0FBTztRQUNQLElBQUloTCxJQUFJQyxJQUFJbU4sSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUM7UUFDaEMsSUFBSSxDQUFDLENBQUNKLEtBQUssQ0FBQ0QsS0FBSyxDQUFDbk4sS0FBSyxDQUFDRCxLQUFLLElBQUksQ0FBQzBOLFVBQVUsTUFBTSxRQUFRMU4sT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxFQUFFLENBQUMsRUFBRSxNQUFNLFFBQVFDLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzBOLE9BQU8sTUFBTSxRQUFRUCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUc1QixLQUFLLE1BQU0sUUFBUTZCLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzlMLE1BQU0sTUFBTSxHQUFHO1lBQzdPLE9BQU9uQztRQUNYO1FBQ0EsSUFBSSxJQUFJLENBQUNzTyxVQUFVLElBQUksSUFBSSxDQUFDQSxVQUFVLENBQUNuTSxNQUFNLEdBQUcsR0FBRztZQUMvQ3FNLFFBQVFDLElBQUksQ0FBQztRQUNqQjtRQUNBLElBQUk3QyxPQUFPO1FBQ1gsSUFBSThDLGtCQUFrQjtRQUN0QixNQUFNQyxlQUFlLEVBQUU7UUFDdkIsS0FBSyxNQUFNeEIsUUFBUSxDQUFDa0IsS0FBSyxDQUFDRCxLQUFLLENBQUNELEtBQUssQ0FBQ0QsS0FBSyxJQUFJLENBQUNJLFVBQVUsTUFBTSxRQUFRSixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEVBQUUsQ0FBQyxFQUFFLE1BQU0sUUFBUUMsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSSxPQUFPLE1BQU0sUUFBUUgsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHaEMsS0FBSyxNQUFNLFFBQVFpQyxPQUFPLEtBQUssSUFBSUEsS0FBSyxFQUFFLENBQUU7WUFDek8sS0FBSyxNQUFNLENBQUNPLFdBQVdDLFdBQVcsSUFBSXJOLE9BQU9tQyxPQUFPLENBQUN3SixNQUFPO2dCQUN4RCxJQUFJeUIsY0FBYyxVQUNkQSxjQUFjLGFBQ2RBLGNBQWMsc0JBQ2JDLENBQUFBLGVBQWUsUUFBUUEsZUFBZTdPLFNBQVEsR0FBSTtvQkFDbkQyTyxhQUFhM0osSUFBSSxDQUFDNEo7Z0JBQ3RCO1lBQ0o7WUFDQSxJQUFJLE9BQU96QixLQUFLdkIsSUFBSSxLQUFLLFVBQVU7Z0JBQy9CLElBQUksT0FBT3VCLEtBQUsyQixPQUFPLEtBQUssYUFBYTNCLEtBQUsyQixPQUFPLEVBQUU7b0JBQ25EO2dCQUNKO2dCQUNBSixrQkFBa0I7Z0JBQ2xCOUMsUUFBUXVCLEtBQUt2QixJQUFJO1lBQ3JCO1FBQ0o7UUFDQSxJQUFJK0MsYUFBYXhNLE1BQU0sR0FBRyxHQUFHO1lBQ3pCcU0sUUFBUUMsSUFBSSxDQUFDLDRCQUF5QyxPQUFiRSxjQUFhO1FBQzFEO1FBQ0EsdURBQXVEO1FBQ3ZELE9BQU9ELGtCQUFrQjlDLE9BQU81TDtJQUNwQztJQUNBOzs7Ozs7Ozs7S0FTQyxHQUNELElBQUlnQyxPQUFPO1FBQ1AsSUFBSXBCLElBQUlDLElBQUltTixJQUFJQyxJQUFJQyxJQUFJQyxJQUFJQyxJQUFJQztRQUNoQyxJQUFJLENBQUMsQ0FBQ0osS0FBSyxDQUFDRCxLQUFLLENBQUNuTixLQUFLLENBQUNELEtBQUssSUFBSSxDQUFDME4sVUFBVSxNQUFNLFFBQVExTixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEVBQUUsQ0FBQyxFQUFFLE1BQU0sUUFBUUMsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHME4sT0FBTyxNQUFNLFFBQVFQLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzVCLEtBQUssTUFBTSxRQUFRNkIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHOUwsTUFBTSxNQUFNLEdBQUc7WUFDN08sT0FBT25DO1FBQ1g7UUFDQSxJQUFJLElBQUksQ0FBQ3NPLFVBQVUsSUFBSSxJQUFJLENBQUNBLFVBQVUsQ0FBQ25NLE1BQU0sR0FBRyxHQUFHO1lBQy9DcU0sUUFBUUMsSUFBSSxDQUFDO1FBQ2pCO1FBQ0EsSUFBSXpNLE9BQU87UUFDWCxNQUFNK00sZUFBZSxFQUFFO1FBQ3ZCLEtBQUssTUFBTTVCLFFBQVEsQ0FBQ2tCLEtBQUssQ0FBQ0QsS0FBSyxDQUFDRCxLQUFLLENBQUNELEtBQUssSUFBSSxDQUFDSSxVQUFVLE1BQU0sUUFBUUosT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxFQUFFLENBQUMsRUFBRSxNQUFNLFFBQVFDLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0ksT0FBTyxNQUFNLFFBQVFILE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2hDLEtBQUssTUFBTSxRQUFRaUMsT0FBTyxLQUFLLElBQUlBLEtBQUssRUFBRSxDQUFFO1lBQ3pPLEtBQUssTUFBTSxDQUFDTyxXQUFXQyxXQUFXLElBQUlyTixPQUFPbUMsT0FBTyxDQUFDd0osTUFBTztnQkFDeEQsSUFBSXlCLGNBQWMsZ0JBQ2JDLENBQUFBLGVBQWUsUUFBUUEsZUFBZTdPLFNBQVEsR0FBSTtvQkFDbkQrTyxhQUFhL0osSUFBSSxDQUFDNEo7Z0JBQ3RCO1lBQ0o7WUFDQSxJQUFJekIsS0FBS2pDLFVBQVUsSUFBSSxPQUFPaUMsS0FBS2pDLFVBQVUsQ0FBQ2xKLElBQUksS0FBSyxVQUFVO2dCQUM3REEsUUFBUWdOLEtBQUs3QixLQUFLakMsVUFBVSxDQUFDbEosSUFBSTtZQUNyQztRQUNKO1FBQ0EsSUFBSStNLGFBQWE1TSxNQUFNLEdBQUcsR0FBRztZQUN6QnFNLFFBQVFDLElBQUksQ0FBQyw0QkFBeUMsT0FBYk0sY0FBYTtRQUMxRDtRQUNBLE9BQU8vTSxLQUFLRyxNQUFNLEdBQUcsSUFBSThNLEtBQUtqTixRQUFRaEM7SUFDMUM7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0E0Q0MsR0FDRCxJQUFJa1AsZ0JBQWdCO1FBQ2hCLElBQUl0TyxJQUFJQyxJQUFJbU4sSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUM7UUFDaEMsSUFBSSxDQUFDLENBQUNKLEtBQUssQ0FBQ0QsS0FBSyxDQUFDbk4sS0FBSyxDQUFDRCxLQUFLLElBQUksQ0FBQzBOLFVBQVUsTUFBTSxRQUFRMU4sT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxFQUFFLENBQUMsRUFBRSxNQUFNLFFBQVFDLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzBOLE9BQU8sTUFBTSxRQUFRUCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUc1QixLQUFLLE1BQU0sUUFBUTZCLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzlMLE1BQU0sTUFBTSxHQUFHO1lBQzdPLE9BQU9uQztRQUNYO1FBQ0EsSUFBSSxJQUFJLENBQUNzTyxVQUFVLElBQUksSUFBSSxDQUFDQSxVQUFVLENBQUNuTSxNQUFNLEdBQUcsR0FBRztZQUMvQ3FNLFFBQVFDLElBQUksQ0FBQztRQUNqQjtRQUNBLE1BQU1TLGdCQUFnQixDQUFDYixLQUFLLENBQUNELEtBQUssQ0FBQ0QsS0FBSyxDQUFDRCxLQUFLLElBQUksQ0FBQ0ksVUFBVSxNQUFNLFFBQVFKLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsRUFBRSxDQUFDLEVBQUUsTUFBTSxRQUFRQyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdJLE9BQU8sTUFBTSxRQUFRSCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdoQyxLQUFLLE1BQU0sUUFBUWlDLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzdKLE1BQU0sQ0FBQyxDQUFDMkksT0FBU0EsS0FBS25CLFlBQVksRUFBRTVJLEdBQUcsQ0FBQyxDQUFDK0osT0FBU0EsS0FBS25CLFlBQVksRUFBRXhILE1BQU0sQ0FBQyxDQUFDd0gsZUFBaUJBLGlCQUFpQmhNO1FBQ2xXLElBQUksQ0FBQ2tQLGtCQUFrQixRQUFRQSxrQkFBa0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsY0FBYy9NLE1BQU0sTUFBTSxHQUFHO1lBQzVGLE9BQU9uQztRQUNYO1FBQ0EsT0FBT2tQO0lBQ1g7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQXNCQyxHQUNELElBQUlwQyxpQkFBaUI7UUFDakIsSUFBSWxNLElBQUlDLElBQUltTixJQUFJQyxJQUFJQyxJQUFJQyxJQUFJQyxJQUFJQyxJQUFJYztRQUNwQyxJQUFJLENBQUMsQ0FBQ2xCLEtBQUssQ0FBQ0QsS0FBSyxDQUFDbk4sS0FBSyxDQUFDRCxLQUFLLElBQUksQ0FBQzBOLFVBQVUsTUFBTSxRQUFRMU4sT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxFQUFFLENBQUMsRUFBRSxNQUFNLFFBQVFDLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzBOLE9BQU8sTUFBTSxRQUFRUCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUc1QixLQUFLLE1BQU0sUUFBUTZCLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzlMLE1BQU0sTUFBTSxHQUFHO1lBQzdPLE9BQU9uQztRQUNYO1FBQ0EsSUFBSSxJQUFJLENBQUNzTyxVQUFVLElBQUksSUFBSSxDQUFDQSxVQUFVLENBQUNuTSxNQUFNLEdBQUcsR0FBRztZQUMvQ3FNLFFBQVFDLElBQUksQ0FBQztRQUNqQjtRQUNBLE1BQU0zQixpQkFBaUIsQ0FBQ3VCLEtBQUssQ0FBQ0QsS0FBSyxDQUFDRCxLQUFLLENBQUNELEtBQUssSUFBSSxDQUFDSSxVQUFVLE1BQU0sUUFBUUosT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxFQUFFLENBQUMsRUFBRSxNQUFNLFFBQVFDLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0ksT0FBTyxNQUFNLFFBQVFILE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2hDLEtBQUssTUFBTSxRQUFRaUMsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHN0osTUFBTSxDQUFDLENBQUMySSxPQUFTQSxLQUFLTCxjQUFjLEVBQUUxSixHQUFHLENBQUMsQ0FBQytKLE9BQVNBLEtBQUtMLGNBQWMsRUFBRXRJLE1BQU0sQ0FBQyxDQUFDc0ksaUJBQW1CQSxtQkFBbUI5TTtRQUMzVyxJQUFJLENBQUM4TSxtQkFBbUIsUUFBUUEsbUJBQW1CLEtBQUssSUFBSSxLQUFLLElBQUlBLGVBQWUzSyxNQUFNLE1BQU0sR0FBRztZQUMvRixPQUFPbkM7UUFDWDtRQUNBLE9BQU8sQ0FBQ21QLEtBQUtyQyxtQkFBbUIsUUFBUUEsbUJBQW1CLEtBQUssSUFBSSxLQUFLLElBQUlBLGNBQWMsQ0FBQyxFQUFFLE1BQU0sUUFBUXFDLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3ZDLElBQUk7SUFDaEo7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBcUJDLEdBQ0QsSUFBSUYsc0JBQXNCO1FBQ3RCLElBQUk5TCxJQUFJQyxJQUFJbU4sSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSWM7UUFDcEMsSUFBSSxDQUFDLENBQUNsQixLQUFLLENBQUNELEtBQUssQ0FBQ25OLEtBQUssQ0FBQ0QsS0FBSyxJQUFJLENBQUMwTixVQUFVLE1BQU0sUUFBUTFOLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsRUFBRSxDQUFDLEVBQUUsTUFBTSxRQUFRQyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUcwTixPQUFPLE1BQU0sUUFBUVAsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHNUIsS0FBSyxNQUFNLFFBQVE2QixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUc5TCxNQUFNLE1BQU0sR0FBRztZQUM3TyxPQUFPbkM7UUFDWDtRQUNBLElBQUksSUFBSSxDQUFDc08sVUFBVSxJQUFJLElBQUksQ0FBQ0EsVUFBVSxDQUFDbk0sTUFBTSxHQUFHLEdBQUc7WUFDL0NxTSxRQUFRQyxJQUFJLENBQUM7UUFDakI7UUFDQSxNQUFNL0Isc0JBQXNCLENBQUMyQixLQUFLLENBQUNELEtBQUssQ0FBQ0QsS0FBSyxDQUFDRCxLQUFLLElBQUksQ0FBQ0ksVUFBVSxNQUFNLFFBQVFKLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsRUFBRSxDQUFDLEVBQUUsTUFBTSxRQUFRQyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdJLE9BQU8sTUFBTSxRQUFRSCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdoQyxLQUFLLE1BQU0sUUFBUWlDLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzdKLE1BQU0sQ0FBQyxDQUFDMkksT0FBU0EsS0FBS1QsbUJBQW1CLEVBQUV0SixHQUFHLENBQUMsQ0FBQytKLE9BQVNBLEtBQUtULG1CQUFtQixFQUFFbEksTUFBTSxDQUFDLENBQUNrSSxzQkFBd0JBLHdCQUF3QjFNO1FBQ3BZLElBQUksQ0FBQzBNLHdCQUF3QixRQUFRQSx3QkFBd0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsb0JBQW9CdkssTUFBTSxNQUFNLEdBQUc7WUFDOUcsT0FBT25DO1FBQ1g7UUFDQSxPQUFPLENBQUNtUCxLQUFLekMsd0JBQXdCLFFBQVFBLHdCQUF3QixLQUFLLElBQUksS0FBSyxJQUFJQSxtQkFBbUIsQ0FBQyxFQUFFLE1BQU0sUUFBUXlDLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzFDLE1BQU07SUFDaks7QUFDSjtBQUNBLDJDQUEyQyxHQUMzQyxNQUFNMkM7QUFDTjtBQUNBLGdDQUFnQyxHQUNoQyxNQUFNQztBQUNOO0FBQ0EsK0NBQStDLEdBQy9DLE1BQU1DO0FBQ047QUFDQSxNQUFNQztBQUNOO0FBQ0EsZ0NBQWdDLEdBQ2hDLE1BQU1DO0FBQ047QUFDQSxnQ0FBZ0MsR0FDaEMsTUFBTUM7QUFDTjtBQUNBLE1BQU1DO0FBQ047QUFDQSxNQUFNQztBQUNOO0FBQ0Esa0NBQWtDLEdBQ2xDLE1BQU1DO0FBQ047QUFDQSxtQ0FBbUMsR0FDbkMsTUFBTUM7QUFDTjtBQUNBLG9DQUFvQyxHQUNwQyxNQUFNQztBQUNOO0FBQ0Esa0NBQWtDLEdBQ2xDLE1BQU1DO0lBQ0Y7OztLQUdDLEdBQ0RDLGlCQUFpQixLQUE2QixFQUFFO1lBQS9CLEVBQUVDLFdBQVcsRUFBRUMsV0FBVyxFQUFHLEdBQTdCO1FBQ2IsTUFBTUMsWUFBWSxJQUFJSjtRQUN0QixJQUFJNUQ7UUFDSixNQUFNaUUsS0FBS0g7UUFDWCxJQUFJQyxhQUFhO1lBQ2IvRCxXQUFXcEcsb0NBQW9DcUs7UUFDbkQsT0FDSztZQUNEakUsV0FBVzNHLG1DQUFtQzRLO1FBQ2xEO1FBQ0E1TyxPQUFPd0IsTUFBTSxDQUFDbU4sV0FBV2hFO1FBQ3pCLE9BQU9nRTtJQUNYO0FBQ0o7QUFDQSw4Q0FBOEMsR0FDOUMsTUFBTUU7QUFDTjtBQUNBLDhDQUE4QyxHQUM5QyxNQUFNQztBQUNOO0FBQ0EsNkNBQTZDLEdBQzdDLE1BQU1DO0FBQ047QUFDQSxNQUFNQztBQUNOO0FBQ0EsNENBQTRDLEdBQzVDLE1BQU1DO0FBQ047QUFDQSxxREFBcUQsR0FDckQsTUFBTUM7QUFDTjtBQUNBLDhDQUE4QyxHQUM5QyxNQUFNQztBQUNOO0FBQ0EsZ0ZBQWdGLEdBQ2hGLE1BQU1DO0FBQ047QUFDQSxzRUFBc0UsR0FDdEUsTUFBTUM7SUFDRjs7O0tBR0MsR0FDRGIsaUJBQWlCLEtBQTZCLEVBQUU7WUFBL0IsRUFBRUMsV0FBVyxFQUFFQyxXQUFXLEVBQUcsR0FBN0I7UUFDYixNQUFNQyxZQUFZLElBQUlVO1FBQ3RCLE1BQU1ULEtBQUtIO1FBQ1gsTUFBTTlELFdBQVd2RiwrQkFBK0J3SjtRQUNoRDVPLE9BQU93QixNQUFNLENBQUNtTixXQUFXaEU7UUFDekIsT0FBT2dFO0lBQ1g7QUFDSjtBQUNBLHdDQUF3QyxHQUN4QyxNQUFNVztBQUNOO0FBQ0EseUNBQXlDLEdBQ3pDLE1BQU1DO0FBQ047QUFDQSx5Q0FBeUMsR0FDekMsTUFBTUM7QUFDTjtBQUNBLDhDQUE4QyxHQUM5QyxNQUFNQztBQUNOO0FBQ0EscUNBQXFDLEdBQ3JDLE1BQU1DO0FBQ047QUFDQSx3REFBd0QsR0FDeEQsTUFBTUM7QUFDTjtBQUNBLDBDQUEwQyxHQUMxQyxNQUFNQztBQUNOO0FBQ0EsOENBQThDLEdBQzlDLE1BQU1DO0FBQ047QUFDQTs7Ozt5QkFJeUIsR0FDekIsTUFBTUM7SUFDRiw2REFBNkQsR0FDN0RDLHNCQUFzQjtRQUNsQixNQUFNQyxvQkFBb0I7WUFDdEJDLGVBQWU7WUFDZkMsZ0JBQWdCLElBQUksQ0FBQ0EsY0FBYztZQUNuQ0MsYUFBYSxJQUFJLENBQUNBLFdBQVc7UUFDakM7UUFDQSxPQUFPSDtJQUNYO0FBQ0o7QUFDQTs7Ozs7Ozs7NkJBUTZCLEdBQzdCLE1BQU1JO0lBQ0YsNkRBQTZELEdBQzdETCxzQkFBc0I7UUFDbEIsTUFBTUMsb0JBQW9CO1lBQ3RCQyxlQUFlO1lBQ2ZDLGdCQUFnQixJQUFJLENBQUNBLGNBQWM7WUFDbkNDLGFBQWEsSUFBSSxDQUFDQSxXQUFXO1lBQzdCRSxpQkFBaUIsSUFBSSxDQUFDQyxNQUFNO1FBQ2hDO1FBQ0EsT0FBT047SUFDWDtBQUNKO0FBQ0E7Ozs7Ozs7O3NDQVFzQyxHQUN0QyxNQUFNTztJQUNGLDZEQUE2RCxHQUM3RFIsc0JBQXNCO1FBQ2xCLE1BQU1DLG9CQUFvQjtZQUN0QkMsZUFBZTtZQUNmQyxnQkFBZ0IsSUFBSSxDQUFDQSxjQUFjO1lBQ25DQyxhQUFhLElBQUksQ0FBQ0EsV0FBVztZQUM3Qkssb0JBQW9CLElBQUksQ0FBQ0YsTUFBTTtRQUNuQztRQUNBLE9BQU9OO0lBQ1g7QUFDSjtBQUNBOzs7Ozs7ZUFNZSxHQUNmLE1BQU1TO0lBQ0YsNkRBQTZELEdBQzdEVixzQkFBc0I7UUFDbEIsTUFBTUMsb0JBQW9CO1lBQ3RCQyxlQUFlO1lBQ2ZDLGdCQUFnQixJQUFJLENBQUNBLGNBQWM7WUFDbkNDLGFBQWEsSUFBSSxDQUFDQSxXQUFXO1lBQzdCTyxrQkFBa0IsSUFBSSxDQUFDSixNQUFNO1FBQ2pDO1FBQ0EsT0FBT047SUFDWDtBQUNKO0FBQ0E7Ozs7OztlQU1lLEdBQ2YsTUFBTVc7SUFDRiw0REFBNEQsR0FDNURaLHNCQUFzQjtRQUNsQixNQUFNQyxvQkFBb0I7WUFDdEJDLGVBQWU7WUFDZkMsZ0JBQWdCLElBQUksQ0FBQ0EsY0FBYztZQUNuQ0MsYUFBYSxJQUFJLENBQUNBLFdBQVc7WUFDN0JTLG9CQUFvQixJQUFJLENBQUNOLE1BQU07UUFDbkM7UUFDQSxPQUFPTjtJQUNYO0FBQ0o7QUFDQTs7Ozt1RUFJdUUsR0FDdkUsTUFBTWE7SUFDRiw2REFBNkQsR0FDN0RkLHNCQUFzQjtRQUNsQixNQUFNQyxvQkFBb0I7WUFDdEJDLGVBQWU7WUFDZkMsZ0JBQWdCLElBQUksQ0FBQ0EsY0FBYztZQUNuQ0MsYUFBYSxJQUFJLENBQUNBLFdBQVc7UUFDakM7UUFDQSxPQUFPSDtJQUNYO0FBQ0o7QUFDQSxtQ0FBbUMsR0FDbkMsTUFBTWM7SUFDRjs7Ozs7O0tBTUMsR0FDRCxJQUFJMUcsT0FBTztRQUNQLElBQUloTCxJQUFJQyxJQUFJbU47UUFDWixJQUFJcEMsT0FBTztRQUNYLElBQUkyRyxtQkFBbUI7UUFDdkIsTUFBTTVELGVBQWUsRUFBRTtRQUN2QixLQUFLLE1BQU14QixRQUFRLENBQUNhLEtBQUssQ0FBQ25OLEtBQUssQ0FBQ0QsS0FBSyxJQUFJLENBQUM0UixhQUFhLE1BQU0sUUFBUTVSLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzZSLFNBQVMsTUFBTSxRQUFRNVIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHdUwsS0FBSyxNQUFNLFFBQVE0QixPQUFPLEtBQUssSUFBSUEsS0FBSyxFQUFFLENBQUU7WUFDNUwsS0FBSyxNQUFNLENBQUNZLFdBQVdDLFdBQVcsSUFBSXJOLE9BQU9tQyxPQUFPLENBQUN3SixNQUFPO2dCQUN4RCxJQUFJeUIsY0FBYyxVQUNkQSxjQUFjLGFBQ2RDLGVBQWUsTUFBTTtvQkFDckJGLGFBQWEzSixJQUFJLENBQUM0SjtnQkFDdEI7WUFDSjtZQUNBLElBQUksT0FBT3pCLEtBQUt2QixJQUFJLEtBQUssVUFBVTtnQkFDL0IsSUFBSSxPQUFPdUIsS0FBSzJCLE9BQU8sS0FBSyxhQUFhM0IsS0FBSzJCLE9BQU8sRUFBRTtvQkFDbkQ7Z0JBQ0o7Z0JBQ0F5RCxtQkFBbUI7Z0JBQ25CM0csUUFBUXVCLEtBQUt2QixJQUFJO1lBQ3JCO1FBQ0o7UUFDQSxJQUFJK0MsYUFBYXhNLE1BQU0sR0FBRyxHQUFHO1lBQ3pCcU0sUUFBUUMsSUFBSSxDQUFDLDRCQUF5QyxPQUFiRSxjQUFhO1FBQzFEO1FBQ0EsdURBQXVEO1FBQ3ZELE9BQU80RCxtQkFBbUIzRyxPQUFPNUw7SUFDckM7SUFDQTs7Ozs7OztLQU9DLEdBQ0QsSUFBSWdDLE9BQU87UUFDUCxJQUFJcEIsSUFBSUMsSUFBSW1OO1FBQ1osSUFBSWhNLE9BQU87UUFDWCxNQUFNK00sZUFBZSxFQUFFO1FBQ3ZCLEtBQUssTUFBTTVCLFFBQVEsQ0FBQ2EsS0FBSyxDQUFDbk4sS0FBSyxDQUFDRCxLQUFLLElBQUksQ0FBQzRSLGFBQWEsTUFBTSxRQUFRNVIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHNlIsU0FBUyxNQUFNLFFBQVE1UixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUd1TCxLQUFLLE1BQU0sUUFBUTRCLE9BQU8sS0FBSyxJQUFJQSxLQUFLLEVBQUUsQ0FBRTtZQUM1TCxLQUFLLE1BQU0sQ0FBQ1ksV0FBV0MsV0FBVyxJQUFJck4sT0FBT21DLE9BQU8sQ0FBQ3dKLE1BQU87Z0JBQ3hELElBQUl5QixjQUFjLGdCQUFnQkMsZUFBZSxNQUFNO29CQUNuREUsYUFBYS9KLElBQUksQ0FBQzRKO2dCQUN0QjtZQUNKO1lBQ0EsSUFBSXpCLEtBQUtqQyxVQUFVLElBQUksT0FBT2lDLEtBQUtqQyxVQUFVLENBQUNsSixJQUFJLEtBQUssVUFBVTtnQkFDN0RBLFFBQVFnTixLQUFLN0IsS0FBS2pDLFVBQVUsQ0FBQ2xKLElBQUk7WUFDckM7UUFDSjtRQUNBLElBQUkrTSxhQUFhNU0sTUFBTSxHQUFHLEdBQUc7WUFDekJxTSxRQUFRQyxJQUFJLENBQUMsNEJBQXlDLE9BQWJNLGNBQWE7UUFDMUQ7UUFDQSxPQUFPL00sS0FBS0csTUFBTSxHQUFHLElBQUk4TSxLQUFLak4sUUFBUWhDO0lBQzFDO0FBQ0o7QUFDQTs7Ozs7Ozs7VUFRVSxHQUNWLE1BQU0wUztBQUNOO0FBQ0EsMkRBQTJELEdBQzNELE1BQU1DO0lBQ0ZqRixhQUFjO1FBQ1YsMkNBQTJDLEdBQzNDLElBQUksQ0FBQ2tGLGlCQUFpQixHQUFHLEVBQUU7SUFDL0I7QUFDSjtBQUNBLDBEQUEwRCxHQUMxRCxNQUFNQztJQUNGOzs7OztLQUtDLEdBQ0QsSUFBSUMsYUFBYTtRQUNiLElBQUksSUFBSSxDQUFDTixhQUFhLElBQ2xCLElBQUksQ0FBQ0EsYUFBYSxDQUFDTyxXQUFXLElBQzlCLElBQUksQ0FBQ1AsYUFBYSxDQUFDTyxXQUFXLENBQUM1USxNQUFNLEdBQUcsR0FBRztZQUMzQyxPQUFPLElBQUksQ0FBQ3FRLGFBQWEsQ0FBQ08sV0FBVyxDQUFDLEVBQUU7UUFDNUM7UUFDQSxPQUFPL1M7SUFDWDtBQUNKO0FBQ0EsaUdBQWlHLEdBQ2pHLE1BQU1nVDtBQUNOO0FBQ0Esc0VBQXNFLEdBQ3RFLE1BQU1DO0lBQ0Y7OztLQUdDLEdBQ0RqRCxpQkFBaUIsS0FBNkIsRUFBRTtZQUEvQixFQUFFQyxXQUFXLEVBQUVDLFdBQVcsRUFBRyxHQUE3QjtRQUNiLE1BQU1DLFlBQVksSUFBSThDO1FBQ3RCLE1BQU03QyxLQUFLSDtRQUNYLE1BQU05RCxXQUFXbEYsMENBQTBDbUo7UUFDM0Q1TyxPQUFPd0IsTUFBTSxDQUFDbU4sV0FBV2hFO1FBQ3pCLE9BQU9nRTtJQUNYO0FBQ0o7QUFFQTs7OztDQUlDLEdBQ0QsU0FBUytDLE9BQU9DLFNBQVMsRUFBRUMsS0FBSztJQUM1QixJQUFJLENBQUNBLFNBQVMsT0FBT0EsVUFBVSxVQUFVO1FBQ3JDLE1BQU0sSUFBSXRSLE1BQU07SUFDcEI7SUFDQSxJQUFJc1IsTUFBTUMsUUFBUSxDQUFDLFNBQVNELE1BQU1DLFFBQVEsQ0FBQyxRQUFRRCxNQUFNQyxRQUFRLENBQUMsTUFBTTtRQUNwRSxNQUFNLElBQUl2UixNQUFNO0lBQ3BCO0lBQ0EsSUFBSXFSLFVBQVVHLFVBQVUsSUFBSTtRQUN4QixJQUFJRixNQUFNMU8sVUFBVSxDQUFDLGtCQUNqQjBPLE1BQU0xTyxVQUFVLENBQUMsZ0JBQ2pCME8sTUFBTTFPLFVBQVUsQ0FBQyxZQUFZO1lBQzdCLE9BQU8wTztRQUNYLE9BQ0ssSUFBSUEsTUFBTUcsT0FBTyxDQUFDLFFBQVEsR0FBRztZQUM5QixNQUFNbkgsUUFBUWdILE1BQU12UCxLQUFLLENBQUMsS0FBSztZQUMvQixPQUFPLGNBQWlDdUksT0FBbkJBLEtBQUssQ0FBQyxFQUFFLEVBQUMsWUFBbUIsT0FBVEEsS0FBSyxDQUFDLEVBQUU7UUFDcEQsT0FDSztZQUNELE9BQU8sNEJBQWtDLE9BQU5nSDtRQUN2QztJQUNKLE9BQ0s7UUFDRCxJQUFJQSxNQUFNMU8sVUFBVSxDQUFDLGNBQWMwTyxNQUFNMU8sVUFBVSxDQUFDLGlCQUFpQjtZQUNqRSxPQUFPME87UUFDWCxPQUNLO1lBQ0QsT0FBTyxVQUFnQixPQUFOQTtRQUNyQjtJQUNKO0FBQ0o7QUFDQSxTQUFTSSxhQUFhTCxTQUFTLEVBQUVDLEtBQUs7SUFDbEMsTUFBTUssbUJBQW1CUCxPQUFPQyxXQUFXQztJQUMzQyxJQUFJLENBQUNLLGtCQUFrQjtRQUNuQixPQUFPO0lBQ1g7SUFDQSxJQUFJQSxpQkFBaUIvTyxVQUFVLENBQUMsa0JBQWtCeU8sVUFBVUcsVUFBVSxJQUFJO1FBQ3RFLDZEQUE2RDtRQUM3RCxPQUFPLFlBQWdESCxPQUFwQ0EsVUFBVU8sVUFBVSxJQUFHLGVBQXdDRCxPQUEzQk4sVUFBVVEsV0FBVyxJQUFHLEtBQW9CLE9BQWpCRjtJQUN0RixPQUNLLElBQUlBLGlCQUFpQi9PLFVBQVUsQ0FBQyxjQUFjeU8sVUFBVUcsVUFBVSxJQUFJO1FBQ3ZFLE9BQU8sWUFBZ0RILE9BQXBDQSxVQUFVTyxVQUFVLElBQUcsZUFBMERELE9BQTdDTixVQUFVUSxXQUFXLElBQUcsdUJBQXNDLE9BQWpCRjtJQUN4RyxPQUNLO1FBQ0QsT0FBT0E7SUFDWDtBQUNKO0FBQ0EsU0FBU0csT0FBT0MsS0FBSztJQUNqQixJQUFJdFIsTUFBTUMsT0FBTyxDQUFDcVIsUUFBUTtRQUN0QixPQUFPQSxNQUFNelEsR0FBRyxDQUFDLENBQUMwUSxPQUFTQyxNQUFNRDtJQUNyQyxPQUNLO1FBQ0QsT0FBTztZQUFDQyxNQUFNRjtTQUFPO0lBQ3pCO0FBQ0o7QUFDQSxTQUFTRSxNQUFNRCxJQUFJO0lBQ2YsSUFBSSxPQUFPQSxTQUFTLFlBQVlBLFNBQVMsTUFBTTtRQUMzQyxPQUFPQTtJQUNYO0lBQ0EsTUFBTSxJQUFJaFMsTUFBTSx5REFBcUUsT0FBWixPQUFPZ1M7QUFDcEY7QUFDQSxTQUFTRSxXQUFXRixJQUFJO0lBQ3BCLE1BQU1HLGtCQUFrQkYsTUFBTUQ7SUFDOUIsSUFBSUcsZ0JBQWdCaEosUUFBUSxJQUN4QmdKLGdCQUFnQmhKLFFBQVEsQ0FBQ3ZHLFVBQVUsQ0FBQyxXQUFXO1FBQy9DLE9BQU91UDtJQUNYO0lBQ0EsTUFBTSxJQUFJblMsTUFBTSwwQkFBbUQsT0FBekJtUyxnQkFBZ0JoSixRQUFRO0FBQ3RFO0FBQ0EsU0FBU2lKLFdBQVdKLElBQUk7SUFDcEIsTUFBTUcsa0JBQWtCRixNQUFNRDtJQUM5QixJQUFJRyxnQkFBZ0JoSixRQUFRLElBQ3hCZ0osZ0JBQWdCaEosUUFBUSxDQUFDdkcsVUFBVSxDQUFDLFdBQVc7UUFDL0MsT0FBT3VQO0lBQ1g7SUFDQSxNQUFNLElBQUluUyxNQUFNLDBCQUFtRCxPQUF6Qm1TLGdCQUFnQmhKLFFBQVE7QUFDdEU7QUFDQSxTQUFTa0osTUFBTUMsTUFBTTtJQUNqQixJQUFJQSxXQUFXLFFBQVFBLFdBQVdwVSxXQUFXO1FBQ3pDLE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxJQUFJLE9BQU9zUyxXQUFXLFVBQVU7UUFDNUIsT0FBT0E7SUFDWDtJQUNBLElBQUksT0FBT0EsV0FBVyxVQUFVO1FBQzVCLE9BQU87WUFBRXhJLE1BQU13STtRQUFPO0lBQzFCO0lBQ0EsTUFBTSxJQUFJdFMsTUFBTSwwQkFBd0MsT0FBZCxPQUFPc1M7QUFDckQ7QUFDQSxTQUFTQyxPQUFPRCxNQUFNO0lBQ2xCLElBQUlBLFdBQVcsUUFDWEEsV0FBV3BVLGFBQ1Z1QyxNQUFNQyxPQUFPLENBQUM0UixXQUFXQSxPQUFPalMsTUFBTSxLQUFLLEdBQUk7UUFDaEQsTUFBTSxJQUFJTCxNQUFNO0lBQ3BCO0lBQ0EsSUFBSVMsTUFBTUMsT0FBTyxDQUFDNFIsU0FBUztRQUN2QixPQUFPQSxPQUFPaFIsR0FBRyxDQUFDLENBQUNrQixPQUFTNlAsTUFBTTdQO0lBQ3RDO0lBQ0EsT0FBTztRQUFDNlAsTUFBTUM7S0FBUTtBQUMxQjtBQUNBLFNBQVNFLFdBQVdGLE1BQU07SUFDdEIsT0FBUUEsV0FBVyxRQUNmQSxXQUFXcFUsYUFDWCxPQUFPb1UsV0FBVyxZQUNsQixXQUFXQSxVQUNYN1IsTUFBTUMsT0FBTyxDQUFDNFIsT0FBT2hJLEtBQUs7QUFDbEM7QUFDQSxTQUFTbUksb0JBQW9CSCxNQUFNO0lBQy9CLE9BQVFBLFdBQVcsUUFDZkEsV0FBV3BVLGFBQ1gsT0FBT29VLFdBQVcsWUFDbEIsa0JBQWtCQTtBQUMxQjtBQUNBLFNBQVNJLHdCQUF3QkosTUFBTTtJQUNuQyxPQUFRQSxXQUFXLFFBQ2ZBLFdBQVdwVSxhQUNYLE9BQU9vVSxXQUFXLFlBQ2xCLHNCQUFzQkE7QUFDOUI7QUFDQSxTQUFTSyxTQUFTTCxNQUFNO0lBQ3BCLElBQUlBLFdBQVcsUUFBUUEsV0FBV3BVLFdBQVc7UUFDekMsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLElBQUl3UyxXQUFXRixTQUFTO1FBQ3BCLHNEQUFzRDtRQUN0RCx1QkFBdUI7UUFDdkIsT0FBT0E7SUFDWDtJQUNBLE9BQU87UUFDSC9HLE1BQU07UUFDTmpCLE9BQU9pSSxPQUFPRDtJQUNsQjtBQUNKO0FBQ0EsU0FBU00sa0JBQWtCdkIsU0FBUyxFQUFFaUIsTUFBTTtJQUN4QyxJQUFJLENBQUNBLFFBQVE7UUFDVCxPQUFPLEVBQUU7SUFDYjtJQUNBLElBQUlqQixVQUFVRyxVQUFVLE1BQU0vUSxNQUFNQyxPQUFPLENBQUM0UixTQUFTO1FBQ2pELE9BQU9BLE9BQU9PLE9BQU8sQ0FBQyxDQUFDclE7WUFDbkIsTUFBTWlLLFVBQVVrRyxTQUFTblE7WUFDekIsSUFBSWlLLFFBQVFuQyxLQUFLLElBQ2JtQyxRQUFRbkMsS0FBSyxDQUFDakssTUFBTSxHQUFHLEtBQ3ZCb00sUUFBUW5DLEtBQUssQ0FBQyxFQUFFLENBQUNSLElBQUksS0FBSzVMLFdBQVc7Z0JBQ3JDLE9BQU87b0JBQUN1TyxRQUFRbkMsS0FBSyxDQUFDLEVBQUUsQ0FBQ1IsSUFBSTtpQkFBQztZQUNsQztZQUNBLE9BQU8sRUFBRTtRQUNiO0lBQ0osT0FDSyxJQUFJdUgsVUFBVUcsVUFBVSxJQUFJO1FBQzdCLE1BQU0vRSxVQUFVa0csU0FBU0w7UUFDekIsSUFBSTdGLFFBQVFuQyxLQUFLLElBQ2JtQyxRQUFRbkMsS0FBSyxDQUFDakssTUFBTSxHQUFHLEtBQ3ZCb00sUUFBUW5DLEtBQUssQ0FBQyxFQUFFLENBQUNSLElBQUksS0FBSzVMLFdBQVc7WUFDckMsT0FBTztnQkFBQ3VPLFFBQVFuQyxLQUFLLENBQUMsRUFBRSxDQUFDUixJQUFJO2FBQUM7UUFDbEM7UUFDQSxPQUFPLEVBQUU7SUFDYjtJQUNBLElBQUlySixNQUFNQyxPQUFPLENBQUM0UixTQUFTO1FBQ3ZCLE9BQU9BLE9BQU9oUixHQUFHLENBQUMsQ0FBQ2tCLE9BQVNtUSxTQUFTblE7SUFDekM7SUFDQSxPQUFPO1FBQUNtUSxTQUFTTDtLQUFRO0FBQzdCO0FBQ0EsU0FBU1EsVUFBVVIsTUFBTTtJQUNyQixJQUFJQSxXQUFXLFFBQ1hBLFdBQVdwVSxhQUNWdUMsTUFBTUMsT0FBTyxDQUFDNFIsV0FBV0EsT0FBT2pTLE1BQU0sS0FBSyxHQUFJO1FBQ2hELE1BQU0sSUFBSUwsTUFBTTtJQUNwQjtJQUNBLElBQUksQ0FBQ1MsTUFBTUMsT0FBTyxDQUFDNFIsU0FBUztRQUN4QixxRUFBcUU7UUFDckUsSUFBSUcsb0JBQW9CSCxXQUFXSSx3QkFBd0JKLFNBQVM7WUFDaEUsTUFBTSxJQUFJdFMsTUFBTTtRQUNwQjtRQUNBLE9BQU87WUFBQzJTLFNBQVNMO1NBQVE7SUFDN0I7SUFDQSxNQUFNUyxTQUFTLEVBQUU7SUFDakIsTUFBTUMsbUJBQW1CLEVBQUU7SUFDM0IsTUFBTUMsaUJBQWlCVCxXQUFXRixNQUFNLENBQUMsRUFBRTtJQUMzQyxLQUFLLE1BQU05UCxRQUFROFAsT0FBUTtRQUN2QixNQUFNWSxZQUFZVixXQUFXaFE7UUFDN0IsSUFBSTBRLGFBQWFELGdCQUFnQjtZQUM3QixNQUFNLElBQUlqVCxNQUFNO1FBQ3BCO1FBQ0EsSUFBSWtULFdBQVc7WUFDWCxvRUFBb0U7WUFDcEUsaURBQWlEO1lBQ2pESCxPQUFPN1AsSUFBSSxDQUFDVjtRQUNoQixPQUNLLElBQUlpUSxvQkFBb0JqUSxTQUFTa1Esd0JBQXdCbFEsT0FBTztZQUNqRSxNQUFNLElBQUl4QyxNQUFNO1FBQ3BCLE9BQ0s7WUFDRGdULGlCQUFpQjlQLElBQUksQ0FBQ1Y7UUFDMUI7SUFDSjtJQUNBLElBQUksQ0FBQ3lRLGdCQUFnQjtRQUNqQkYsT0FBTzdQLElBQUksQ0FBQztZQUFFcUksTUFBTTtZQUFRakIsT0FBT2lJLE9BQU9TO1FBQWtCO0lBQ2hFO0lBQ0EsT0FBT0Q7QUFDWDtBQUNBOzs7Ozs7QUFNQSxHQUNBLFNBQVNJLHdCQUF3QkMsUUFBUSxFQUFFQyxlQUFlO0lBQ3RELElBQUlELFNBQVM3QixRQUFRLENBQUMsU0FBUztRQUMzQjhCLGVBQWUsQ0FBQyxXQUFXLEdBQUc7SUFDbEM7SUFDQSxNQUFNQyxrQkFBa0JGLFNBQVMxUSxNQUFNLENBQUMsQ0FBQzZRLE9BQVNBLFNBQVM7SUFDM0QsSUFBSUQsZ0JBQWdCalQsTUFBTSxLQUFLLEdBQUc7UUFDOUJnVCxlQUFlLENBQUMsT0FBTyxHQUFHM1QsT0FBTzhULE1BQU0sQ0FBQzdOLE1BQU00TCxRQUFRLENBQUMrQixlQUFlLENBQUMsRUFBRSxDQUFDRyxXQUFXLE1BQy9FSCxlQUFlLENBQUMsRUFBRSxDQUFDRyxXQUFXLEtBQzlCOU4sS0FBSytOLGdCQUFnQjtJQUMvQixPQUNLO1FBQ0RMLGVBQWUsQ0FBQyxRQUFRLEdBQUcsRUFBRTtRQUM3QixLQUFLLE1BQU1qVCxLQUFLa1QsZ0JBQWlCO1lBQzdCRCxlQUFlLENBQUMsUUFBUSxDQUFDblEsSUFBSSxDQUFDO2dCQUMxQixRQUFReEQsT0FBTzhULE1BQU0sQ0FBQzdOLE1BQU00TCxRQUFRLENBQUNuUixFQUFFcVQsV0FBVyxNQUM1Q3JULEVBQUVxVCxXQUFXLEtBQ2I5TixLQUFLK04sZ0JBQWdCO1lBQy9CO1FBQ0o7SUFDSjtBQUNKO0FBQ0EsU0FBU0Msa0JBQWtCQyxXQUFXO0lBQ2xDLE1BQU1DLGNBQWMsQ0FBQztJQUNyQixNQUFNQyxtQkFBbUI7UUFBQztLQUFRO0lBQ2xDLE1BQU1DLHVCQUF1QjtRQUFDO0tBQVE7SUFDdEMsTUFBTUMsdUJBQXVCO1FBQUM7S0FBYTtJQUMzQyxJQUFJSixXQUFXLENBQUMsT0FBTyxJQUFJQSxXQUFXLENBQUMsUUFBUSxFQUFFO1FBQzdDLE1BQU0sSUFBSTVULE1BQU07SUFDcEI7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUF5Q0EsR0FDQSxNQUFNaVUsZ0JBQWdCTCxXQUFXLENBQUMsUUFBUTtJQUMxQyxJQUFJSyxpQkFBaUIsUUFBUUEsY0FBYzVULE1BQU0sSUFBSSxHQUFHO1FBQ3BELElBQUk0VCxhQUFhLENBQUMsRUFBRSxDQUFDLE9BQU8sS0FBSyxRQUFRO1lBQ3JDSixXQUFXLENBQUMsV0FBVyxHQUFHO1lBQzFCRCxjQUFjSyxhQUFhLENBQUMsRUFBRTtRQUNsQyxPQUNLLElBQUlBLGFBQWEsQ0FBQyxFQUFFLENBQUMsT0FBTyxLQUFLLFFBQVE7WUFDMUNKLFdBQVcsQ0FBQyxXQUFXLEdBQUc7WUFDMUJELGNBQWNLLGFBQWEsQ0FBQyxFQUFFO1FBQ2xDO0lBQ0o7SUFDQSxJQUFJTCxXQUFXLENBQUMsT0FBTyxZQUFZblQsT0FBTztRQUN0QzBTLHdCQUF3QlMsV0FBVyxDQUFDLE9BQU8sRUFBRUM7SUFDakQ7SUFDQSxLQUFLLE1BQU0sQ0FBQy9HLFdBQVdDLFdBQVcsSUFBSXJOLE9BQU9tQyxPQUFPLENBQUMrUixhQUFjO1FBQy9ELCtDQUErQztRQUMvQyxJQUFJN0csY0FBYyxNQUFNO1lBQ3BCO1FBQ0o7UUFDQSxJQUFJRCxhQUFhLFFBQVE7WUFDckIsSUFBSUMsZUFBZSxRQUFRO2dCQUN2QixNQUFNLElBQUkvTSxNQUFNO1lBQ3BCO1lBQ0EsSUFBSStNLHNCQUFzQnRNLE9BQU87Z0JBRzdCO1lBQ0o7WUFDQW9ULFdBQVcsQ0FBQyxPQUFPLEdBQUduVSxPQUFPOFQsTUFBTSxDQUFDN04sTUFBTTRMLFFBQVEsQ0FBQ3hFLFdBQVcwRyxXQUFXLE1BQ25FMUcsV0FBVzBHLFdBQVcsS0FDdEI5TixLQUFLK04sZ0JBQWdCO1FBQy9CLE9BQ0ssSUFBSUksaUJBQWlCdkMsUUFBUSxDQUFDekUsWUFBWTtZQUMzQytHLFdBQVcsQ0FBQy9HLFVBQVUsR0FDbEI2RyxrQkFBa0I1RztRQUMxQixPQUNLLElBQUlnSCxxQkFBcUJ4QyxRQUFRLENBQUN6RSxZQUFZO1lBQy9DLE1BQU1vSCx1QkFBdUIsRUFBRTtZQUMvQixLQUFLLE1BQU0xUixRQUFRdUssV0FBWTtnQkFDM0IsSUFBSXZLLElBQUksQ0FBQyxPQUFPLElBQUksUUFBUTtvQkFDeEJxUixXQUFXLENBQUMsV0FBVyxHQUFHO29CQUMxQjtnQkFDSjtnQkFDQUsscUJBQXFCaFIsSUFBSSxDQUFDeVEsa0JBQWtCblI7WUFDaEQ7WUFDQXFSLFdBQVcsQ0FBQy9HLFVBQVUsR0FDbEJvSDtRQUNSLE9BQ0ssSUFBSUYscUJBQXFCekMsUUFBUSxDQUFDekUsWUFBWTtZQUMvQyxNQUFNcUgsdUJBQXVCLENBQUM7WUFDOUIsS0FBSyxNQUFNLENBQUMxVSxLQUFLSyxNQUFNLElBQUlKLE9BQU9tQyxPQUFPLENBQUNrTCxZQUFhO2dCQUNuRG9ILG9CQUFvQixDQUFDMVUsSUFBSSxHQUFHa1Usa0JBQWtCN1Q7WUFDbEQ7WUFDQStULFdBQVcsQ0FBQy9HLFVBQVUsR0FDbEJxSDtRQUNSLE9BQ0s7WUFDRCxtRUFBbUU7WUFDbkUsSUFBSXJILGNBQWMsd0JBQXdCO2dCQUN0QztZQUNKO1lBQ0ErRyxXQUFXLENBQUMvRyxVQUFVLEdBQUdDO1FBQzdCO0lBQ0o7SUFDQSxPQUFPOEc7QUFDWDtBQUNBLDhFQUE4RTtBQUM5RSw4RUFBOEU7QUFDOUUsZ0ZBQWdGO0FBQ2hGLDRCQUE0QjtBQUM1Qiw4SEFBOEg7QUFDOUgsNkNBQTZDO0FBQzdDLG9IQUFvSDtBQUNwSCw0RUFBNEU7QUFDNUUsMEVBQTBFO0FBQzFFLGdCQUFnQjtBQUNoQixTQUFTTyxRQUFRQyxNQUFNO0lBQ25CLE9BQU9WLGtCQUFrQlU7QUFDN0I7QUFDQSxTQUFTQyxjQUFjQyxZQUFZO0lBQy9CLElBQUksT0FBT0EsaUJBQWlCLFVBQVU7UUFDbEMsT0FBT0E7SUFDWCxPQUNLLElBQUksT0FBT0EsaUJBQWlCLFVBQVU7UUFDdkMsT0FBTztZQUNIQyxhQUFhO2dCQUNUQyxxQkFBcUI7b0JBQ2pCQyxXQUFXSDtnQkFDZjtZQUNKO1FBQ0o7SUFDSixPQUNLO1FBQ0QsTUFBTSxJQUFJdlUsTUFBTSxrQ0FBc0QsT0FBcEIsT0FBT3VVO0lBQzdEO0FBQ0o7QUFDQSxTQUFTSSxrQkFBa0JKLFlBQVk7SUFDbkMsSUFBSSw2QkFBNkJBLGNBQWM7UUFDM0MsTUFBTSxJQUFJdlUsTUFBTTtJQUNwQjtJQUNBLE9BQU91VTtBQUNYO0FBQ0EsU0FBU0ssTUFBTUMsSUFBSTtJQUNmLElBQUlBLEtBQUtDLG9CQUFvQixFQUFFO1FBQzNCLEtBQUssTUFBTUMsdUJBQXVCRixLQUFLQyxvQkFBb0IsQ0FBRTtZQUN6RCxJQUFJQyxvQkFBb0JDLFVBQVUsRUFBRTtnQkFDaEMsSUFBSSxDQUFDdFYsT0FBT1MsSUFBSSxDQUFDNFUsb0JBQW9CQyxVQUFVLEVBQUV6RCxRQUFRLENBQUMsWUFBWTtvQkFDbEV3RCxvQkFBb0JDLFVBQVUsR0FBR3JCLGtCQUFrQm9CLG9CQUFvQkMsVUFBVTtnQkFDckYsT0FDSztvQkFDRCxJQUFJLENBQUNELG9CQUFvQkUsb0JBQW9CLEVBQUU7d0JBQzNDRixvQkFBb0JFLG9CQUFvQixHQUNwQ0Ysb0JBQW9CQyxVQUFVO3dCQUNsQyxPQUFPRCxvQkFBb0JDLFVBQVU7b0JBQ3pDO2dCQUNKO1lBQ0o7WUFDQSxJQUFJRCxvQkFBb0IxSyxRQUFRLEVBQUU7Z0JBQzlCLElBQUksQ0FBQzNLLE9BQU9TLElBQUksQ0FBQzRVLG9CQUFvQjFLLFFBQVEsRUFBRWtILFFBQVEsQ0FBQyxZQUFZO29CQUNoRXdELG9CQUFvQjFLLFFBQVEsR0FBR3NKLGtCQUFrQm9CLG9CQUFvQjFLLFFBQVE7Z0JBQ2pGLE9BQ0s7b0JBQ0QsSUFBSSxDQUFDMEssb0JBQW9CRyxrQkFBa0IsRUFBRTt3QkFDekNILG9CQUFvQkcsa0JBQWtCLEdBQ2xDSCxvQkFBb0IxSyxRQUFRO3dCQUNoQyxPQUFPMEssb0JBQW9CMUssUUFBUTtvQkFDdkM7Z0JBQ0o7WUFDSjtRQUNKO0lBQ0o7SUFDQSxPQUFPd0s7QUFDWDtBQUNBLFNBQVNNLE9BQU9DLEtBQUs7SUFDakIseUNBQXlDO0lBQ3pDLElBQUlBLFVBQVVsWCxhQUFha1gsVUFBVSxNQUFNO1FBQ3ZDLE1BQU0sSUFBSXBWLE1BQU07SUFDcEI7SUFDQSxJQUFJLENBQUNTLE1BQU1DLE9BQU8sQ0FBQzBVLFFBQVE7UUFDdkIsTUFBTSxJQUFJcFYsTUFBTTtJQUNwQjtJQUNBLE1BQU0rUyxTQUFTLEVBQUU7SUFDakIsS0FBSyxNQUFNOEIsUUFBUU8sTUFBTztRQUN0QnJDLE9BQU83UCxJQUFJLENBQUMyUjtJQUNoQjtJQUNBLE9BQU85QjtBQUNYO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW1EQyxHQUNELFNBQVNzQyxhQUFhQyxNQUFNLEVBQUVELFlBQVksRUFBRUUsY0FBYztRQUFFQyxvQkFBQUEsaUVBQW9CO0lBQzVFLE1BQU1DLHFCQUFxQixDQUFDSixhQUFhelMsVUFBVSxDQUFDLEdBQWtCLE9BQWYyUyxnQkFBZSxTQUNsRUYsYUFBYXRULEtBQUssQ0FBQyxLQUFLMUIsTUFBTSxLQUFLbVY7SUFDdkMsSUFBSUYsT0FBTzlELFVBQVUsSUFBSTtRQUNyQixJQUFJNkQsYUFBYXpTLFVBQVUsQ0FBQyxjQUFjO1lBQ3RDLE9BQU95UztRQUNYLE9BQ0ssSUFBSUEsYUFBYXpTLFVBQVUsQ0FBQyxlQUFlO1lBQzVDLE9BQU8sWUFBbUN5UyxPQUF2QkMsT0FBTzFELFVBQVUsSUFBRyxLQUFnQixPQUFieUQ7UUFDOUMsT0FDSyxJQUFJQSxhQUFhelMsVUFBVSxDQUFDLEdBQWtCLE9BQWYyUyxnQkFBZSxPQUFLO1lBQ3BELE9BQU8sWUFBNkNELE9BQWpDQSxPQUFPMUQsVUFBVSxJQUFHLGVBQXFDeUQsT0FBeEJDLE9BQU96RCxXQUFXLElBQUcsS0FBZ0IsT0FBYndEO1FBQ2hGLE9BQ0ssSUFBSUksb0JBQW9CO1lBQ3pCLE9BQU8sWUFBNkNILE9BQWpDQSxPQUFPMUQsVUFBVSxJQUFHLGVBQXFDMkQsT0FBeEJELE9BQU96RCxXQUFXLElBQUcsS0FBcUJ3RCxPQUFsQkUsZ0JBQWUsS0FBZ0IsT0FBYkY7UUFDbEcsT0FDSztZQUNELE9BQU9BO1FBQ1g7SUFDSjtJQUNBLElBQUlJLG9CQUFvQjtRQUNwQixPQUFPLEdBQXFCSixPQUFsQkUsZ0JBQWUsS0FBZ0IsT0FBYkY7SUFDaEM7SUFDQSxPQUFPQTtBQUNYO0FBQ0EsU0FBU0ssbUJBQW1CckUsU0FBUyxFQUFFckgsSUFBSTtJQUN2QyxJQUFJLE9BQU9BLFNBQVMsVUFBVTtRQUMxQixNQUFNLElBQUloSyxNQUFNO0lBQ3BCO0lBQ0EsT0FBT3FWLGFBQWFoRSxXQUFXckgsTUFBTTtBQUN6QztBQUNBLFNBQVMyTCxpQkFBaUJDLE1BQU07SUFDNUIsT0FBUUE7UUFDSixLQUFLO1lBQ0QsT0FBTztRQUNYLEtBQUs7WUFDRCxPQUFPO1FBQ1gsS0FBSztZQUNELE9BQU87UUFDWCxLQUFLO1lBQ0QsT0FBTztRQUNYO1lBQ0ksT0FBT0E7SUFDZjtBQUNKO0FBQ0EsU0FBU0MsT0FBT0MsY0FBYztJQUMxQixPQUFPM1MsU0FBUzJTO0FBQ3BCO0FBQ0EsU0FBU0MsUUFBUXpELE1BQU07SUFDbkIsT0FBUUEsV0FBVyxRQUNmQSxXQUFXcFUsYUFDWCxPQUFPb1UsV0FBVyxZQUNsQixVQUFVQTtBQUNsQjtBQUNBLFNBQVMwRCxpQkFBaUIxRCxNQUFNO0lBQzVCLE9BQVFBLFdBQVcsUUFDZkEsV0FBV3BVLGFBQ1gsT0FBT29VLFdBQVcsWUFDbEIsV0FBV0E7QUFDbkI7QUFDQSxTQUFTMkQsUUFBUTNELE1BQU07SUFDbkIsT0FBUUEsV0FBVyxRQUNmQSxXQUFXcFUsYUFDWCxPQUFPb1UsV0FBVyxZQUNsQixTQUFTQTtBQUNqQjtBQUNBLFNBQVM0RCxVQUFVdlMsUUFBUTtJQUN2QixJQUFJN0U7SUFDSixJQUFJa0w7SUFDSixJQUFJK0wsUUFBUXBTLFdBQVc7UUFDbkJxRyxPQUFPckcsU0FBU3FHLElBQUk7SUFDeEI7SUFDQSxJQUFJaU0sUUFBUXRTLFdBQVc7UUFDbkJxRyxPQUFPckcsU0FBUzJGLEdBQUc7UUFDbkIsSUFBSVUsU0FBUzlMLFdBQVc7WUFDcEIsT0FBT0E7UUFDWDtJQUNKO0lBQ0EsSUFBSThYLGlCQUFpQnJTLFdBQVc7UUFDNUJxRyxPQUFPLENBQUNsTCxLQUFLNkUsU0FBU3dTLEtBQUssTUFBTSxRQUFRclgsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHd0ssR0FBRztRQUN4RSxJQUFJVSxTQUFTOUwsV0FBVztZQUNwQixPQUFPQTtRQUNYO0lBQ0o7SUFDQSxJQUFJLE9BQU95RixhQUFhLFVBQVU7UUFDOUJxRyxPQUFPckc7SUFDWDtJQUNBLElBQUlxRyxTQUFTOUwsV0FBVztRQUNwQixNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsSUFBSWdLLEtBQUtwSCxVQUFVLENBQUMsYUFBYTtRQUM3QixNQUFNd1QsU0FBU3BNLEtBQUtqSSxLQUFLLENBQUMsU0FBUyxDQUFDLEVBQUU7UUFDdEMsTUFBTXZDLFFBQVE0VyxPQUFPNVcsS0FBSyxDQUFDO1FBQzNCLElBQUlBLFVBQVUsTUFBTTtZQUNoQixNQUFNLElBQUlRLE1BQU0sd0NBQTZDLE9BQUxnSztRQUM1RDtRQUNBQSxPQUFPeEssS0FBSyxDQUFDLEVBQUU7SUFDbkIsT0FDSyxJQUFJd0ssS0FBS3BILFVBQVUsQ0FBQyxXQUFXO1FBQ2hDb0gsT0FBT0EsS0FBS2pJLEtBQUssQ0FBQyxTQUFTLENBQUMsRUFBRTtJQUNsQztJQUNBLE9BQU9pSTtBQUNYO0FBQ0EsU0FBU3FNLFdBQVdoRixTQUFTLEVBQUVpRixVQUFVO0lBQ3JDLElBQUlDO0lBQ0osSUFBSWxGLFVBQVVHLFVBQVUsSUFBSTtRQUN4QitFLE1BQU1ELGFBQWEsNkJBQTZCO0lBQ3BELE9BQ0s7UUFDREMsTUFBTUQsYUFBYSxXQUFXO0lBQ2xDO0lBQ0EsT0FBT0M7QUFDWDtBQUNBLFNBQVNDLGVBQWVuTSxRQUFRO0lBQzVCLEtBQUssTUFBTTVLLE9BQU87UUFBQztRQUFVO1FBQWU7S0FBa0IsQ0FBRTtRQUM1RCxJQUFJZ1gsU0FBU3BNLFVBQVU1SyxNQUFNO1lBQ3pCLE9BQU80SyxRQUFRLENBQUM1SyxJQUFJO1FBQ3hCO0lBQ0o7SUFDQSxPQUFPLEVBQUU7QUFDYjtBQUNBLFNBQVNnWCxTQUFTdlcsSUFBSSxFQUFFNE0sU0FBUztJQUM3QixPQUFPNU0sU0FBUyxRQUFRLE9BQU9BLFNBQVMsWUFBWTRNLGFBQWE1TTtBQUNyRTtBQUNBLFNBQVN3VyxnQkFBZ0JDLE9BQU87UUFBRTNHLFNBQUFBLGlFQUFTLENBQUM7SUFDeEMsTUFBTTRHLGdCQUFnQkQ7SUFDdEIsTUFBTTVCLHNCQUFzQjtRQUN4Qi9LLE1BQU00TSxhQUFhLENBQUMsT0FBTztRQUMzQkMsYUFBYUQsYUFBYSxDQUFDLGNBQWM7UUFDekMzQixzQkFBc0IyQixhQUFhLENBQUMsY0FBYztJQUN0RDtJQUNBLElBQUlBLGFBQWEsQ0FBQyxlQUFlLEVBQUU7UUFDL0I3QixtQkFBbUIsQ0FBQyxxQkFBcUIsR0FBRzZCLGFBQWEsQ0FBQyxlQUFlO0lBQzdFO0lBQ0EsSUFBSTVHLE9BQU84RyxRQUFRLEVBQUU7UUFDakIvQixtQkFBbUIsQ0FBQyxXQUFXLEdBQUcvRSxPQUFPOEcsUUFBUTtJQUNyRDtJQUNBLE1BQU1DLGFBQWE7UUFDZmpDLHNCQUFzQjtZQUNsQkM7U0FDSDtJQUNMO0lBQ0EsT0FBT2dDO0FBQ1g7QUFDQTs7O0NBR0MsR0FDRCxTQUFTQyxxQkFBcUJDLFFBQVE7UUFBRWpILFNBQUFBLGlFQUFTLENBQUM7SUFDOUMsTUFBTThFLHVCQUF1QixFQUFFO0lBQy9CLE1BQU1vQyxZQUFZLElBQUloVjtJQUN0QixLQUFLLE1BQU15VSxXQUFXTSxTQUFVO1FBQzVCLE1BQU1FLGNBQWNSLFFBQVEzTSxJQUFJO1FBQ2hDLElBQUlrTixVQUFVclUsR0FBRyxDQUFDc1UsY0FBYztZQUM1QixNQUFNLElBQUluWCxNQUFNLDJCQUF1QyxPQUFabVgsYUFBWTtRQUMzRDtRQUNBRCxVQUFVOVUsR0FBRyxDQUFDK1U7UUFDZCxNQUFNSixhQUFhTCxnQkFBZ0JDLFNBQVMzRztRQUM1QyxJQUFJK0csV0FBV2pDLG9CQUFvQixFQUFFO1lBQ2pDQSxxQkFBcUI1UixJQUFJLElBQUk2VCxXQUFXakMsb0JBQW9CO1FBQ2hFO0lBQ0o7SUFDQSxPQUFPO1FBQUVBLHNCQUFzQkE7SUFBcUI7QUFDeEQ7QUFDQSwwRUFBMEU7QUFDMUUsU0FBU3NDLGdCQUFnQjlCLE1BQU0sRUFBRStCLEdBQUc7SUFDaEMsSUFBSUM7SUFDSixJQUFJLE9BQU9ELFFBQVEsVUFBVTtRQUN6QixJQUFJL0IsT0FBTzlELFVBQVUsSUFBSTtZQUNyQixJQUFJNkYsSUFBSXpVLFVBQVUsQ0FBQyxVQUFVO2dCQUN6QjBVLFlBQVk7b0JBQUVDLFFBQVE7b0JBQVNDLFFBQVE7d0JBQUNIO3FCQUFJO2dCQUFDO1lBQ2pELE9BQ0ssSUFBSUEsSUFBSXpVLFVBQVUsQ0FBQyxVQUFVO2dCQUM5QjBVLFlBQVk7b0JBQUVDLFFBQVE7b0JBQVlFLGFBQWFKO2dCQUFJO1lBQ3ZELE9BQ0s7Z0JBQ0QsTUFBTSxJQUFJclgsTUFBTSw0Q0FBZ0QsT0FBSnFYO1lBQ2hFO1FBQ0osT0FDSztZQUNELFFBQVE7WUFDUixJQUFJQSxJQUFJelUsVUFBVSxDQUFDLFdBQVc7Z0JBQzFCMFUsWUFBWTtvQkFBRUksVUFBVUw7Z0JBQUksR0FBRyx1Q0FBdUM7WUFDMUUsT0FDSztnQkFDRCxNQUFNLElBQUlyWCxNQUFNLDZDQUFpRCxPQUFKcVg7WUFDakU7UUFDSjtJQUNKLE9BQ0ssSUFBSTVXLE1BQU1DLE9BQU8sQ0FBQzJXLE1BQU07UUFDekIsSUFBSS9CLE9BQU85RCxVQUFVLElBQUk7WUFDckIsTUFBTSxJQUFJeFIsTUFBTTtRQUNwQjtRQUNBc1gsWUFBWTtZQUFFSyxpQkFBaUJOO1FBQUk7SUFDdkMsT0FDSztRQUNELHVDQUF1QztRQUN2Q0MsWUFBWUQ7SUFDaEI7SUFDQSxtQkFBbUI7SUFDbkIsTUFBTU8scUJBQXFCO1FBQUNOLFVBQVVFLE1BQU07UUFBRUYsVUFBVUcsV0FBVztLQUFDLENBQUMvVSxNQUFNLENBQUNtVixTQUFTeFgsTUFBTTtJQUMzRixNQUFNeVgsb0JBQW9CO1FBQ3RCUixVQUFVSyxlQUFlO1FBQ3pCTCxVQUFVSSxRQUFRO0tBQ3JCLENBQUNoVixNQUFNLENBQUNtVixTQUFTeFgsTUFBTTtJQUN4QixJQUFJaVYsT0FBTzlELFVBQVUsSUFBSTtRQUNyQixJQUFJc0csb0JBQW9CLEtBQUtGLHVCQUF1QixHQUFHO1lBQ25ELE1BQU0sSUFBSTVYLE1BQU07UUFDcEI7SUFDSixPQUNLO1FBQ0QsUUFBUTtRQUNSLElBQUk0WCxxQkFBcUIsS0FBS0Usc0JBQXNCLEdBQUc7WUFDbkQsTUFBTSxJQUFJOVgsTUFBTSxtREFDWjtRQUNSO0lBQ0o7SUFDQSxPQUFPc1g7QUFDWDtBQUNBLFNBQVNTLHFCQUFxQkMsSUFBSTtJQUM5QixJQUFJLE9BQU9BLFNBQVMsVUFBVTtRQUMxQixPQUFPQTtJQUNYO0lBQ0EsTUFBTUMsYUFBYUQ7SUFDbkIsSUFBSUMsV0FBV3JWLFVBQVUsQ0FBQyxVQUFVO1FBQ2hDLE9BQU87WUFDSDJVLFFBQVE7WUFDUkMsUUFBUVM7UUFDWjtJQUNKLE9BQ0ssSUFBSUEsV0FBV3JWLFVBQVUsQ0FBQyxVQUFVO1FBQ3JDLE9BQU87WUFDSDJVLFFBQVE7WUFDUkUsYUFBYVE7UUFDakI7SUFDSixPQUNLO1FBQ0QsTUFBTSxJQUFJalksTUFBTSw0QkFBdUMsT0FBWGlZO0lBQ2hEO0FBQ0o7QUFDQSxTQUFTQyx5QkFBeUJGLElBQUk7SUFDbEMsc0RBQXNEO0lBQ3RELElBQUksT0FBT0EsU0FBUyxZQUFZQSxTQUFTLE1BQU07UUFDM0MsMEVBQTBFO1FBQzFFLDRFQUE0RTtRQUM1RSxtREFBbUQ7UUFDbkQsT0FBTyxDQUFDO0lBQ1o7SUFDQSxtRUFBbUU7SUFDbkUsTUFBTTlNLE1BQU04TTtJQUNaLG1DQUFtQztJQUNuQyxNQUFNRyxxQkFBcUJqTixHQUFHLENBQUMsbUJBQW1CO0lBQ2xELElBQUksT0FBT2lOLHVCQUF1QixZQUFZQSx1QkFBdUIsTUFBTTtRQUN2RSxPQUFPSDtJQUNYO0lBQ0EsTUFBTUkscUJBQXFCRDtJQUMzQixNQUFNRSxpQkFBaUJELGtCQUFrQixDQUFDLG1CQUFtQjtJQUM3RCxJQUFJLENBQUMzWCxNQUFNQyxPQUFPLENBQUMyWCxtQkFBbUJBLGVBQWVoWSxNQUFNLEtBQUssR0FBRztRQUMvRCxPQUFPMlg7SUFDWDtJQUNBLHNEQUFzRDtJQUN0RCxJQUFJTSxlQUFlO0lBQ25CLEtBQUssTUFBTUMsZ0JBQWdCRixlQUFnQjtRQUN2QyxJQUFJLE9BQU9FLGlCQUFpQixZQUFZQSxpQkFBaUIsTUFBTTtZQUMzRDtRQUNKO1FBQ0EsTUFBTUMsa0JBQWtCRDtRQUN4QixNQUFNRSxjQUFjRCxlQUFlLENBQUMsV0FBVztRQUMvQyxJQUFJLE9BQU9DLGdCQUFnQixZQUFZQSxnQkFBZ0IsTUFBTTtZQUN6RDtRQUNKO1FBQ0EsTUFBTUMsY0FBY0Q7UUFDcEIsa0RBQWtEO1FBQ2xELElBQUlDLFdBQVcsQ0FBQyxZQUFZLEtBQUt4YSxXQUFXO1lBQ3hDb2EsZUFBZTtZQUNmO1FBQ0o7SUFDSjtJQUNBLHdEQUF3RDtJQUN4RCxJQUFJQSxjQUFjO1FBQ2RwTixHQUFHLENBQUMsK0JBQStCLEdBQUdBLEdBQUcsQ0FBQyxtQkFBbUI7UUFDN0QsT0FBT0EsR0FBRyxDQUFDLG1CQUFtQjtJQUNsQztJQUNBLDZEQUE2RDtJQUM3RCxPQUFPOE07QUFDWDtBQUNBLFNBQVNXLGNBQWN0SCxTQUFTLEVBQUVySCxJQUFJO0lBQ2xDLE1BQU00TyxhQUFhNU87SUFDbkIsSUFBSSxDQUFDcUgsVUFBVUcsVUFBVSxJQUFJO1FBQ3pCLE1BQU1xSCxlQUFlO1FBQ3JCLElBQUlBLGFBQWFDLElBQUksQ0FBQ0YsYUFBYTtZQUMvQixPQUFPQSxXQUFXN1csS0FBSyxDQUFDLEtBQUtnWCxHQUFHO1FBQ3BDLE9BQ0s7WUFDRCxNQUFNLElBQUkvWSxNQUFNLDJCQUFzQyxPQUFYNFksWUFBVztRQUMxRDtJQUNKO0lBQ0EsTUFBTUksZ0JBQWdCO0lBQ3RCLElBQUlBLGNBQWNGLElBQUksQ0FBQ0YsYUFBYTtRQUNoQyxPQUFPQSxXQUFXN1csS0FBSyxDQUFDLEtBQUtnWCxHQUFHO0lBQ3BDLE9BQ0ssSUFBSSxRQUFRRCxJQUFJLENBQUNGLGFBQWE7UUFDL0IsT0FBT0E7SUFDWCxPQUNLO1FBQ0QsTUFBTSxJQUFJNVksTUFBTSwyQkFBc0MsT0FBWDRZLFlBQVc7SUFDMUQ7QUFDSjtBQUNBLFNBQVNLLFVBQVVDLEtBQUs7SUFDcEIsTUFBTUMsY0FBY0Q7SUFDcEIsSUFBSUMsZ0JBQWdCLDJCQUEyQjtRQUMzQyxPQUFPO0lBQ1gsT0FDSyxJQUFJQSxnQkFBZ0IsdUJBQXVCO1FBQzVDLE9BQU87SUFDWCxPQUNLLElBQUlBLGdCQUFnQix1QkFBdUI7UUFDNUMsT0FBTztJQUNYLE9BQ0ssSUFBSUEsZ0JBQWdCLHlCQUF5QjtRQUM5QyxPQUFPO0lBQ1gsT0FDSyxJQUFJQSxnQkFBZ0Isc0JBQXNCO1FBQzNDLE9BQU87SUFDWCxPQUNLLElBQUlBLGdCQUFnQix5QkFBeUI7UUFDOUMsT0FBTztJQUNYLE9BQ0ssSUFBSUEsZ0JBQWdCLHVCQUF1QjtRQUM1QyxPQUFPO0lBQ1gsT0FDSztRQUNELE9BQU9BO0lBQ1g7QUFDSjtBQUVBOzs7O0NBSUMsR0FDRCxTQUFTQyw2QkFBNkI5VixVQUFVO0lBQzVDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNOFYsZUFBZWpZLGVBQWVrQyxZQUFZO1FBQUM7S0FBZ0I7SUFDakUsSUFBSStWLGdCQUFnQixNQUFNO1FBQ3RCcFosZUFBZXNELFVBQVU7WUFBQztTQUFXLEVBQUU4VjtJQUMzQztJQUNBLE1BQU1DLHVCQUF1QmxZLGVBQWVrQyxZQUFZO1FBQ3BEO1FBQ0E7S0FDSDtJQUNELElBQUlnVyx3QkFBd0IsTUFBTTtRQUM5QixJQUFJbFYsa0JBQWtCa1Y7UUFDdEIsSUFBSTdZLE1BQU1DLE9BQU8sQ0FBQzBELGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0I5QyxHQUFHLENBQUMsQ0FBQ2tCO2dCQUNuQyxPQUFPK1cseUJBQXlCL1c7WUFDcEM7UUFDSjtRQUNBdkMsZUFBZXNELFVBQVU7WUFBQztTQUFtQixFQUFFYTtJQUNuRDtJQUNBLE1BQU1vVixtQ0FBbUNwWSxlQUFla0MsWUFBWTtRQUNoRTtRQUNBO0tBQ0g7SUFDRCxJQUFJa1csb0NBQW9DLE1BQU07UUFDMUMsSUFBSXBWLGtCQUFrQm9WO1FBQ3RCLElBQUkvWSxNQUFNQyxPQUFPLENBQUMwRCxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCOUMsR0FBRyxDQUFDLENBQUNrQjtnQkFDbkMsT0FBT0E7WUFDWDtRQUNKO1FBQ0F2QyxlQUFlc0QsVUFBVTtZQUFDO1NBQStCLEVBQUVhO0lBQy9EO0lBQ0EsT0FBT2I7QUFDWDtBQUNBLFNBQVNrVyw4QkFBOEJuVyxVQUFVO0lBQzdDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNbVcsYUFBYXRZLGVBQWVrQyxZQUFZO1FBQUM7S0FBb0I7SUFDbkUsSUFBSW9XLGNBQWMsTUFBTTtRQUNwQnpaLGVBQWVzRCxVQUFVO1lBQUM7U0FBUyxFQUFFbVc7SUFDekM7SUFDQSxNQUFNQyxhQUFhdlksZUFBZWtDLFlBQVk7UUFDMUM7UUFDQTtLQUNIO0lBQ0QsSUFBSXFXLGNBQWMsTUFBTTtRQUNwQjFaLGVBQWVzRCxVQUFVO1lBQUM7U0FBUyxFQUFFb1c7SUFDekM7SUFDQSxNQUFNQyxrQkFBa0J4WSxlQUFla0MsWUFBWTtRQUMvQztRQUNBO0tBQ0g7SUFDRCxJQUFJc1csbUJBQW1CLE1BQU07UUFDekIzWixlQUFlc0QsVUFBVTtZQUFDO1NBQWMsRUFBRXFXO0lBQzlDO0lBQ0EsT0FBT3JXO0FBQ1g7QUFDQSxTQUFTc1csNEJBQTRCdlcsVUFBVTtJQUMzQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTW1XLGFBQWF0WSxlQUFla0MsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSW9XLGNBQWMsTUFBTTtRQUNwQnpaLGVBQWVzRCxVQUFVO1lBQUM7U0FBb0IsRUFBRW1XO0lBQ3BEO0lBQ0EsTUFBTUMsYUFBYXZZLGVBQWVrQyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJcVcsY0FBYyxNQUFNO1FBQ3BCMVosZUFBZXNELFVBQVU7WUFBQztZQUFrQjtTQUFrQixFQUFFb1c7SUFDcEU7SUFDQSxNQUFNQyxrQkFBa0J4WSxlQUFla0MsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSXNXLG1CQUFtQixNQUFNO1FBQ3pCM1osZUFBZXNELFVBQVU7WUFBQztZQUF1QjtTQUFZLEVBQUVxVztJQUNuRTtJQUNBLElBQUl4WSxlQUFla0MsWUFBWTtRQUFDO0tBQVcsTUFBTXBGLFdBQVc7UUFDeEQsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLElBQUlvQixlQUFla0MsWUFBWTtRQUFDO0tBQW1CLE1BQU1wRixXQUFXO1FBQ2hFLE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxJQUFJb0IsZUFBZWtDLFlBQVk7UUFBQztLQUErQixNQUMzRHBGLFdBQVc7UUFDWCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsT0FBT3VEO0FBQ1g7QUFDQSxTQUFTdVcsa0JBQWtCeFcsVUFBVTtJQUNqQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTUksV0FBV3ZDLGVBQWVrQyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJSyxZQUFZLE1BQU07UUFDbEIxRCxlQUFlc0QsVUFBVTtZQUFDO1NBQU8sRUFBRUk7SUFDdkM7SUFDQSxNQUFNb1csa0JBQWtCM1ksZUFBZWtDLFlBQVk7UUFDL0M7UUFDQTtLQUNIO0lBQ0QsSUFBSXlXLG1CQUFtQixNQUFNO1FBQ3pCOVosZUFBZXNELFVBQVU7WUFBQztTQUFjLEVBQUV3VztJQUM5QztJQUNBLE1BQU1DLFlBQVk1WSxlQUFla0MsWUFBWTtRQUFDO1FBQVk7S0FBUTtJQUNsRSxJQUFJMFcsYUFBYSxNQUFNO1FBQ25CL1osZUFBZXNELFVBQVU7WUFBQztTQUFRLEVBQUUwVixVQUFVZTtJQUNsRDtJQUNBLE1BQU1DLGlCQUFpQjdZLGVBQWVrQyxZQUFZO1FBQzlDO1FBQ0E7S0FDSDtJQUNELElBQUkyVyxrQkFBa0IsTUFBTTtRQUN4QmhhLGVBQWVzRCxVQUFVO1lBQUM7U0FBYSxFQUFFMFc7SUFDN0M7SUFDQSxNQUFNQyxjQUFjOVksZUFBZWtDLFlBQVk7UUFDM0M7UUFDQTtLQUNIO0lBQ0QsSUFBSTRXLGVBQWUsTUFBTTtRQUNyQmphLGVBQWVzRCxVQUFVO1lBQUM7U0FBVSxFQUFFMlc7SUFDMUM7SUFDQSxNQUFNQyxpQkFBaUIvWSxlQUFla0MsWUFBWTtRQUM5QztRQUNBO0tBQ0g7SUFDRCxJQUFJNlcsa0JBQWtCLE1BQU07UUFDeEJsYSxlQUFlc0QsVUFBVTtZQUFDO1NBQWEsRUFBRTRXO0lBQzdDO0lBQ0EsTUFBTUMsWUFBWWhaLGVBQWVrQyxZQUFZO1FBQUM7UUFBWTtLQUFRO0lBQ2xFLElBQUk4VyxhQUFhLE1BQU07UUFDbkJuYSxlQUFlc0QsVUFBVTtZQUFDO1NBQVEsRUFBRTZXO0lBQ3hDO0lBQ0EsTUFBTUMsV0FBV2paLGVBQWVrQyxZQUFZO1FBQUM7UUFBWTtLQUFTO0lBQ2xFLElBQUkrVyxZQUFZLE1BQU07UUFDbEJwYSxlQUFlc0QsVUFBVTtZQUFDO1NBQU8sRUFBRTZWLDZCQUE2QmxCLHlCQUF5Qm1DO0lBQzdGO0lBQ0EsT0FBTzlXO0FBQ1g7QUFDQSxTQUFTK1csbUJBQW1CaFgsVUFBVTtJQUNsQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTUksV0FBV3ZDLGVBQWVrQyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJSyxZQUFZLE1BQU07UUFDbEIxRCxlQUFlc0QsVUFBVTtZQUFDO1NBQU8sRUFBRUk7SUFDdkM7SUFDQSxNQUFNb1csa0JBQWtCM1ksZUFBZWtDLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUl5VyxtQkFBbUIsTUFBTTtRQUN6QjlaLGVBQWVzRCxVQUFVO1lBQUM7U0FBYyxFQUFFd1c7SUFDOUM7SUFDQSxNQUFNQyxZQUFZNVksZUFBZWtDLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUkwVyxhQUFhLE1BQU07UUFDbkIvWixlQUFlc0QsVUFBVTtZQUFDO1NBQVEsRUFBRTBWLFVBQVVlO0lBQ2xEO0lBQ0EsTUFBTWxXLFlBQVkxQyxlQUFla0MsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSVEsYUFBYSxNQUFNO1FBQ25CN0QsZUFBZXNELFVBQVU7WUFBQztTQUFRLEVBQUVPO0lBQ3hDO0lBQ0EsTUFBTW1XLGlCQUFpQjdZLGVBQWVrQyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJMlcsa0JBQWtCLE1BQU07UUFDeEJoYSxlQUFlc0QsVUFBVTtZQUFDO1NBQWEsRUFBRTBXO0lBQzdDO0lBQ0EsTUFBTU0sZ0JBQWdCblosZUFBZWtDLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUlpWCxpQkFBaUIsTUFBTTtRQUN2QnRhLGVBQWVzRCxVQUFVO1lBQUM7U0FBWSxFQUFFZ1g7SUFDNUM7SUFDQSxNQUFNTCxjQUFjOVksZUFBZWtDLFlBQVk7UUFBQztLQUFVO0lBQzFELElBQUk0VyxlQUFlLE1BQU07UUFDckJqYSxlQUFlc0QsVUFBVTtZQUFDO1NBQVUsRUFBRTJXO0lBQzFDO0lBQ0EsTUFBTUMsaUJBQWlCL1ksZUFBZWtDLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUk2VyxrQkFBa0IsTUFBTTtRQUN4QmxhLGVBQWVzRCxVQUFVO1lBQUM7U0FBYSxFQUFFNFc7SUFDN0M7SUFDQSxNQUFNQyxZQUFZaFosZUFBZWtDLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUk4VyxhQUFhLE1BQU07UUFDbkJuYSxlQUFlc0QsVUFBVTtZQUFDO1NBQVEsRUFBRTZXO0lBQ3hDO0lBQ0EsTUFBTUksVUFBVXBaLGVBQWVrQyxZQUFZO1FBQUM7S0FBYztJQUMxRCxJQUFJa1gsV0FBVyxNQUFNO1FBQ2pCdmEsZUFBZXNELFVBQVU7WUFBQztTQUFNLEVBQUVrWCx5QkFBeUJEO0lBQy9EO0lBQ0EsTUFBTUgsV0FBV2paLGVBQWVrQyxZQUFZO1FBQUM7S0FBZTtJQUM1RCxJQUFJK1csWUFBWSxNQUFNO1FBQ2xCcGEsZUFBZXNELFVBQVU7WUFBQztTQUFPLEVBQUVrVyw4QkFBOEJ2Qix5QkFBeUJtQztJQUM5RjtJQUNBLE1BQU1LLHNCQUFzQnRaLGVBQWVrQyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJb1gsdUJBQXVCLE1BQU07UUFDN0J6YSxlQUFlc0QsVUFBVTtZQUFDO1NBQWtCLEVBQUVtWDtJQUNsRDtJQUNBLE9BQU9uWDtBQUNYO0FBQ0EsU0FBU2tYLHlCQUF5Qm5YLFVBQVU7SUFDeEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1tVyxhQUFhdFksZUFBZWtDLFlBQVk7UUFBQztLQUFrQjtJQUNqRSxJQUFJb1csY0FBYyxNQUFNO1FBQ3BCelosZUFBZXNELFVBQVU7WUFBQztTQUFTLEVBQUVtVztJQUN6QztJQUNBLE1BQU1DLGFBQWF2WSxlQUFla0MsWUFBWTtRQUFDO1FBQWE7S0FBTztJQUNuRSxJQUFJcVcsY0FBYyxNQUFNO1FBQ3BCMVosZUFBZXNELFVBQVU7WUFBQztTQUFTLEVBQUVvVztJQUN6QztJQUNBLE1BQU1DLGtCQUFrQnhZLGVBQWVrQyxZQUFZO1FBQy9DO1FBQ0E7S0FDSDtJQUNELElBQUlzVyxtQkFBbUIsTUFBTTtRQUN6QjNaLGVBQWVzRCxVQUFVO1lBQUM7U0FBYyxFQUFFcVc7SUFDOUM7SUFDQSxPQUFPclc7QUFDWDtBQUNBLFNBQVNvWCxzQkFBc0J0SixTQUFTLEVBQUUvTixVQUFVO0lBQ2hELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixJQUFJbkMsZUFBZWtDLFlBQVk7UUFBQztLQUFTLE1BQU1wRixXQUFXO1FBQ3RELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxJQUFJb0IsZUFBZWtDLFlBQVk7UUFBQztLQUFTLE1BQU1wRixXQUFXO1FBQ3RELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxJQUFJb0IsZUFBZWtDLFlBQVk7UUFBQztLQUFjLE1BQU1wRixXQUFXO1FBQzNELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxNQUFNcVosZUFBZWpZLGVBQWVrQyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJK1YsZ0JBQWdCLE1BQU07UUFDdEJwWixlQUFlc0QsVUFBVTtZQUFDO1NBQVcsRUFBRThWO0lBQzNDO0lBQ0EsTUFBTXVCLHNCQUFzQnhaLGVBQWVrQyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJc1gsdUJBQXVCLE1BQU07UUFDN0IsSUFBSXhXLGtCQUFrQndXO1FBQ3RCLElBQUluYSxNQUFNQyxPQUFPLENBQUMwRCxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCOUMsR0FBRyxDQUFDLENBQUNrQjtnQkFDbkMsT0FBT3FZLHNCQUFzQnhKLFdBQVc3TztZQUM1QztRQUNKO1FBQ0F2QyxlQUFlc0QsVUFBVTtZQUFDO1lBQVk7U0FBVyxFQUFFYTtJQUN2RDtJQUNBLE9BQU9iO0FBQ1g7QUFDQSxTQUFTdVgsdUJBQXVCeFgsVUFBVTtJQUN0QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTW1XLGFBQWF0WSxlQUFla0MsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSW9XLGNBQWMsTUFBTTtRQUNwQnpaLGVBQWVzRCxVQUFVO1lBQUM7U0FBa0IsRUFBRW1XO0lBQ2xEO0lBQ0EsTUFBTUMsYUFBYXZZLGVBQWVrQyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJcVcsY0FBYyxNQUFNO1FBQ3BCMVosZUFBZXNELFVBQVU7WUFBQztZQUFhO1NBQU8sRUFBRW9XO0lBQ3BEO0lBQ0EsTUFBTUMsa0JBQWtCeFksZUFBZWtDLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUlzVyxtQkFBbUIsTUFBTTtRQUN6QjNaLGVBQWVzRCxVQUFVO1lBQUM7WUFBa0I7U0FBVyxFQUFFcVc7SUFDN0Q7SUFDQSxJQUFJeFksZUFBZWtDLFlBQVk7UUFBQztLQUFXLE1BQU1wRixXQUFXO1FBQ3hELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxJQUFJb0IsZUFBZWtDLFlBQVk7UUFBQztLQUFrQixNQUFNcEYsV0FBVztRQUMvRCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsT0FBT3VEO0FBQ1g7QUFDQSxTQUFTd1gsY0FBY3pYLFVBQVU7SUFDN0IsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU15WCxXQUFXNVosZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUkwWCxZQUFZLE1BQU07UUFDbEIvYSxlQUFlc0QsVUFBVTtZQUFDO1NBQU8sRUFBRXlYO0lBQ3ZDO0lBQ0EsSUFBSTVaLGVBQWVrQyxZQUFZO1FBQUM7S0FBYyxNQUFNcEYsV0FBVztRQUMzRCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTXVGLGVBQWVuRSxlQUFla0MsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSWlDLGdCQUFnQixNQUFNO1FBQ3RCdEYsZUFBZXNELFVBQVU7WUFBQztTQUFXLEVBQUVnQztJQUMzQztJQUNBLE9BQU9oQztBQUNYO0FBQ0EsU0FBUzBYLGdDQUFnQzVKLFNBQVMsRUFBRS9OLFVBQVU7SUFDMUQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1JLFdBQVd2QyxlQUFla0MsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSUssWUFBWSxNQUFNO1FBQ2xCMUQsZUFBZXNELFVBQVU7WUFBQztZQUFRO1NBQU8sRUFBRW9WLGNBQWN0SCxXQUFXMU47SUFDeEU7SUFDQSxPQUFPSjtBQUNYO0FBQ0EsU0FBUzJYLGlDQUFpQzdKLFNBQVMsRUFBRS9OLFVBQVU7SUFDM0QsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1JLFdBQVd2QyxlQUFla0MsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSUssWUFBWSxNQUFNO1FBQ2xCMUQsZUFBZXNELFVBQVU7WUFBQztZQUFRO1NBQU8sRUFBRW9WLGNBQWN0SCxXQUFXMU47SUFDeEU7SUFDQSxPQUFPSjtBQUNYO0FBQ0EsU0FBUzRYLHFCQUFxQjdYLFVBQVU7SUFDcEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU02WCxjQUFjaGEsZUFBZWtDLFlBQVk7UUFBQztLQUFVO0lBQzFELElBQUk4WCxlQUFlLE1BQU07UUFDckJuYixlQUFlc0QsVUFBVTtZQUFDO1NBQVUsRUFBRTZYO0lBQzFDO0lBQ0EsTUFBTUMsdUJBQXVCamEsZUFBZWtDLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUkrWCx3QkFBd0IsTUFBTTtRQUM5QnBiLGVBQWVzRCxVQUFVO1lBQUM7U0FBbUIsRUFBRStYLDRCQUE0QkQ7SUFDL0U7SUFDQSxNQUFNRSxpQkFBaUJuYSxlQUFla0MsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSWlZLGtCQUFrQixNQUFNO1FBQ3hCdGIsZUFBZXNELFVBQVU7WUFBQztTQUFhLEVBQUVnWTtJQUM3QztJQUNBLE1BQU1DLG1CQUFtQnBhLGVBQWVrQyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJa1ksb0JBQW9CLE1BQU07UUFDMUJ2YixlQUFlc0QsVUFBVTtZQUFDO1NBQWUsRUFBRWlZO0lBQy9DO0lBQ0EsTUFBTUMsa0JBQWtCcmEsZUFBZWtDLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUltWSxtQkFBbUIsTUFBTTtRQUN6QnhiLGVBQWVzRCxVQUFVO1lBQUM7U0FBYyxFQUFFa1k7SUFDOUM7SUFDQSxNQUFNQyx3QkFBd0J0YSxlQUFla0MsWUFBWTtRQUNyRDtLQUNIO0lBQ0QsSUFBSW9ZLHlCQUF5QixNQUFNO1FBQy9CemIsZUFBZXNELFVBQVU7WUFBQztTQUFvQixFQUFFbVk7SUFDcEQ7SUFDQSxNQUFNQyxZQUFZdmEsZUFBZWtDLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUlxWSxhQUFhLE1BQU07UUFDbkIxYixlQUFlc0QsVUFBVTtZQUFDO1NBQVEsRUFBRW9ZO0lBQ3hDO0lBQ0EsTUFBTUMscUJBQXFCeGEsZUFBZWtDLFlBQVk7UUFDbEQ7S0FDSDtJQUNELElBQUlzWSxzQkFBc0IsTUFBTTtRQUM1QjNiLGVBQWVzRCxVQUFVO1lBQUM7U0FBaUIsRUFBRXFZO0lBQ2pEO0lBQ0EsTUFBTUMsb0JBQW9CemEsZUFBZWtDLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUl1WSxxQkFBcUIsTUFBTTtRQUMzQixJQUFJelgsa0JBQWtCeVg7UUFDdEIsSUFBSXBiLE1BQU1DLE9BQU8sQ0FBQzBELGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0I5QyxHQUFHLENBQUMsQ0FBQ2tCO2dCQUNuQyxPQUFPQTtZQUNYO1FBQ0o7UUFDQXZDLGVBQWVzRCxVQUFVO1lBQUM7U0FBZ0IsRUFBRWE7SUFDaEQ7SUFDQSxNQUFNMFgseUJBQXlCMWEsZUFBZWtDLFlBQVk7UUFDdEQ7S0FDSDtJQUNELElBQUl3WSwwQkFBMEIsTUFBTTtRQUNoQzdiLGVBQWVzRCxVQUFVO1lBQUM7U0FBcUIsRUFBRXVZO0lBQ3JEO0lBQ0EsT0FBT3ZZO0FBQ1g7QUFDQSxTQUFTK1gsNEJBQTRCaFksVUFBVTtJQUMzQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXdZLGdCQUFnQjNhLGVBQWVrQyxZQUFZO1FBQUM7S0FBa0I7SUFDcEUsSUFBSXlZLGlCQUFpQixNQUFNO1FBQ3ZCLElBQUkzWCxrQkFBa0IyWDtRQUN0QixJQUFJdGIsTUFBTUMsT0FBTyxDQUFDMEQsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQjlDLEdBQUcsQ0FBQyxDQUFDa0I7Z0JBQ25DLE9BQU9BO1lBQ1g7UUFDSjtRQUNBdkMsZUFBZXNELFVBQVU7WUFBQztTQUFZLEVBQUVhO0lBQzVDO0lBQ0EsT0FBT2I7QUFDWDtBQUNBLFNBQVN5WSxpQkFBaUIxWSxVQUFVO0lBQ2hDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNMFksWUFBWTdhLGVBQWVrQyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJMlksYUFBYSxNQUFNO1FBQ25CLElBQUk3WCxrQkFBa0I2WDtRQUN0QixJQUFJeGIsTUFBTUMsT0FBTyxDQUFDMEQsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQjlDLEdBQUcsQ0FBQyxDQUFDa0I7Z0JBQ25DLE9BQU8wWixjQUFjMVo7WUFDekI7UUFDSjtRQUNBdkMsZUFBZXNELFVBQVU7WUFBQztTQUFRLEVBQUVhO0lBQ3hDO0lBQ0EsTUFBTStYLFdBQVcvYSxlQUFla0MsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSTZZLFlBQVksTUFBTTtRQUNsQmxjLGVBQWVzRCxVQUFVO1lBQUM7U0FBTyxFQUFFNFk7SUFDdkM7SUFDQSxPQUFPNVk7QUFDWDtBQUNBLFNBQVM2WSw0QkFBNEI5WSxVQUFVLEVBQUUrWSxZQUFZO0lBQ3pELE1BQU05WSxXQUFXLENBQUM7SUFDbEIsTUFBTXdXLGtCQUFrQjNZLGVBQWVrQyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJK1ksaUJBQWlCbmUsYUFBYTZiLG1CQUFtQixNQUFNO1FBQ3ZEOVosZUFBZW9jLGNBQWM7WUFBQztZQUFTO1NBQWMsRUFBRXRDO0lBQzNEO0lBQ0EsSUFBSTNZLGVBQWVrQyxZQUFZO1FBQUM7S0FBTyxNQUFNcEYsV0FBVztRQUNwRCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsT0FBT3VEO0FBQ1g7QUFDQSxTQUFTK1ksNkJBQTZCaFosVUFBVSxFQUFFK1ksWUFBWTtJQUMxRCxNQUFNOVksV0FBVyxDQUFDO0lBQ2xCLE1BQU13VyxrQkFBa0IzWSxlQUFla0MsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSStZLGlCQUFpQm5lLGFBQWE2YixtQkFBbUIsTUFBTTtRQUN2RDlaLGVBQWVvYyxjQUFjO1lBQUM7U0FBYyxFQUFFdEM7SUFDbEQ7SUFDQSxNQUFNTSxXQUFXalosZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUkrWSxpQkFBaUJuZSxhQUFhbWMsWUFBWSxNQUFNO1FBQ2hEcGEsZUFBZW9jLGNBQWM7WUFBQztTQUFlLEVBQUV4Qyw0QkFBNEI5QixxQkFBcUJzQztJQUNwRztJQUNBLE9BQU85VztBQUNYO0FBQ0EsU0FBU2daLGdDQUFnQ2xMLFNBQVMsRUFBRS9OLFVBQVU7SUFDMUQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU02VyxZQUFZaFosZUFBZWtDLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUk4VyxhQUFhLE1BQU07UUFDbkJuYSxlQUFlc0QsVUFBVTtZQUFDO1lBQVE7U0FBUSxFQUFFNk4sT0FBT0MsV0FBVytJO0lBQ2xFO0lBQ0EsTUFBTUksVUFBVXBaLGVBQWVrQyxZQUFZO1FBQUM7S0FBTTtJQUNsRCxJQUFJa1gsV0FBVyxNQUFNO1FBQ2pCdmEsZUFBZXNELFVBQVU7WUFBQztZQUFTO1NBQWMsRUFBRW9YLHNCQUFzQnRKLFdBQVcrRixnQkFBZ0IvRixXQUFXbUo7SUFDbkg7SUFDQSxNQUFNZ0MsYUFBYXBiLGVBQWVrQyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJa1osY0FBYyxNQUFNO1FBQ3BCSiw0QkFBNEJJLFlBQVlqWjtJQUM1QztJQUNBLE9BQU9BO0FBQ1g7QUFDQSxTQUFTa1osaUNBQWlDcEwsU0FBUyxFQUFFL04sVUFBVTtJQUMzRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTTZXLFlBQVloWixlQUFla0MsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSThXLGFBQWEsTUFBTTtRQUNuQm5hLGVBQWVzRCxVQUFVO1lBQUM7U0FBUSxFQUFFNk4sT0FBT0MsV0FBVytJO0lBQzFEO0lBQ0EsTUFBTUksVUFBVXBaLGVBQWVrQyxZQUFZO1FBQUM7S0FBTTtJQUNsRCxJQUFJa1gsV0FBVyxNQUFNO1FBQ2pCdmEsZUFBZXNELFVBQVU7WUFBQztTQUFjLEVBQUV1WCx1QkFBdUIxRCxnQkFBZ0IvRixXQUFXbUo7SUFDaEc7SUFDQSxNQUFNZ0MsYUFBYXBiLGVBQWVrQyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJa1osY0FBYyxNQUFNO1FBQ3BCRiw2QkFBNkJFLFlBQVlqWjtJQUM3QztJQUNBLE9BQU9BO0FBQ1g7QUFDQSxTQUFTbVosc0NBQXNDcFosVUFBVSxFQUFFK1ksWUFBWTtJQUNuRSxNQUFNOVksV0FBVyxDQUFDO0lBQ2xCLE1BQU13VyxrQkFBa0IzWSxlQUFla0MsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSStZLGlCQUFpQm5lLGFBQWE2YixtQkFBbUIsTUFBTTtRQUN2RDlaLGVBQWVvYyxjQUFjO1lBQUM7WUFBUztTQUFjLEVBQUV0QztJQUMzRDtJQUNBLE9BQU94VztBQUNYO0FBQ0EsU0FBU29aLDBDQUEwQ3RMLFNBQVMsRUFBRS9OLFVBQVU7SUFDcEUsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU02VyxZQUFZaFosZUFBZWtDLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUk4VyxhQUFhLE1BQU07UUFDbkJuYSxlQUFlc0QsVUFBVTtZQUFDO1lBQVE7U0FBUSxFQUFFNk4sT0FBT0MsV0FBVytJO0lBQ2xFO0lBQ0EsTUFBTUksVUFBVXBaLGVBQWVrQyxZQUFZO1FBQUM7S0FBTTtJQUNsRCxJQUFJa1gsV0FBVyxNQUFNO1FBQ2pCdmEsZUFBZXNELFVBQVU7WUFBQztZQUFTO1NBQWMsRUFBRXFaLGdDQUFnQ3ZMLFdBQVdtSjtJQUNsRztJQUNBLE1BQU1nQyxhQUFhcGIsZUFBZWtDLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlrWixjQUFjLE1BQU07UUFDcEJFLHNDQUFzQ0YsWUFBWWpaO0lBQ3REO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLFNBQVNzWixnQ0FBZ0N4TCxTQUFTLEVBQUUvTixVQUFVO0lBQzFELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNSSxXQUFXdkMsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlLLFlBQVksTUFBTTtRQUNsQjFELGVBQWVzRCxVQUFVO1lBQUM7WUFBUTtTQUFPLEVBQUVvVixjQUFjdEgsV0FBVzFOO0lBQ3hFO0lBQ0EsT0FBT0o7QUFDWDtBQUNBLFNBQVN1WixpQ0FBaUN6TCxTQUFTLEVBQUUvTixVQUFVO0lBQzNELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNSSxXQUFXdkMsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlLLFlBQVksTUFBTTtRQUNsQjFELGVBQWVzRCxVQUFVO1lBQUM7WUFBUTtTQUFPLEVBQUVvVixjQUFjdEgsV0FBVzFOO0lBQ3hFO0lBQ0EsT0FBT0o7QUFDWDtBQUNBLFNBQVN3WiwyQkFBMkJ6WixVQUFVO0lBQzFDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNeUIsc0JBQXNCNUQsZUFBZWtDLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUkwQix1QkFBdUIsTUFBTTtRQUM3Qi9FLGVBQWVzRCxVQUFVO1lBQUM7U0FBa0IsRUFBRXlCO0lBQ2xEO0lBQ0EsTUFBTXJCLFdBQVd2QyxlQUFla0MsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSUssWUFBWSxNQUFNO1FBQ2xCMUQsZUFBZXNELFVBQVU7WUFBQztTQUFPLEVBQUVJO0lBQ3ZDO0lBQ0EsTUFBTUUsV0FBV3pDLGVBQWVrQyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJTyxZQUFZLE1BQU07UUFDbEI1RCxlQUFlc0QsVUFBVTtZQUFDO1NBQU8sRUFBRU07SUFDdkM7SUFDQSxNQUFNQyxZQUFZMUMsZUFBZWtDLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUlRLGFBQWEsTUFBTTtRQUNuQjdELGVBQWVzRCxVQUFVO1lBQUM7U0FBUSxFQUFFTztJQUN4QztJQUNBLE9BQU9QO0FBQ1g7QUFDQSxTQUFTeVosNEJBQTRCMVosVUFBVTtJQUMzQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXlCLHNCQUFzQjVELGVBQWVrQyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJMEIsdUJBQXVCLE1BQU07UUFDN0IvRSxlQUFlc0QsVUFBVTtZQUFDO1NBQWtCLEVBQUV5QjtJQUNsRDtJQUNBLE1BQU1yQixXQUFXdkMsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlLLFlBQVksTUFBTTtRQUNsQjFELGVBQWVzRCxVQUFVO1lBQUM7U0FBTyxFQUFFSTtJQUN2QztJQUNBLE1BQU1FLFdBQVd6QyxlQUFla0MsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSU8sWUFBWSxNQUFNO1FBQ2xCNUQsZUFBZXNELFVBQVU7WUFBQztTQUFPLEVBQUVNO0lBQ3ZDO0lBQ0EsTUFBTUMsWUFBWTFDLGVBQWVrQyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJUSxhQUFhLE1BQU07UUFDbkI3RCxlQUFlc0QsVUFBVTtZQUFDO1NBQVEsRUFBRU87SUFDeEM7SUFDQSxPQUFPUDtBQUNYO0FBQ0EsU0FBUzBaLHlCQUF5QjVMLFNBQVMsRUFBRS9OLFVBQVU7SUFDbkQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU0yWixlQUFlOWIsZUFBZWtDLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUk0WixnQkFBZ0IsTUFBTTtRQUN0QixJQUFJOVksa0JBQWtCd08sa0JBQWtCdkIsV0FBVzZMO1FBQ25ELElBQUl6YyxNQUFNQyxPQUFPLENBQUMwRCxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCOUMsR0FBRyxDQUFDLENBQUNrQjtnQkFDbkMsT0FBT0E7WUFDWDtRQUNKO1FBQ0F2QyxlQUFlc0QsVUFBVTtZQUFDO1lBQWM7WUFBVztTQUFVLEVBQUVhO0lBQ25FO0lBQ0EsTUFBTW9ZLGFBQWFwYixlQUFla0MsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSWtaLGNBQWMsTUFBTTtRQUNwQnZjLGVBQWVzRCxVQUFVO1lBQUM7U0FBUSxFQUFFNFosNEJBQTRCWCxZQUFZalo7UUFDNUU5QixnQkFBZ0I4QixVQUFVO1lBQUUsZ0JBQWdCO1FBQXVCO0lBQ3ZFO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLFNBQVM0Wiw0QkFBNEI3WixVQUFVLEVBQUUrWSxZQUFZO0lBQ3pELE1BQU05WSxXQUFXLENBQUM7SUFDbEIsTUFBTTZaLGVBQWVoYyxlQUFla0MsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSStZLGlCQUFpQm5lLGFBQWFrZixnQkFBZ0IsTUFBTTtRQUNwRG5kLGVBQWVvYyxjQUFjO1lBQUM7WUFBYztTQUFXLEVBQUVlO0lBQzdEO0lBQ0EsTUFBTUMsWUFBWWpjLGVBQWVrQyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJK1ksaUJBQWlCbmUsYUFBYW1mLGFBQWEsTUFBTTtRQUNqRHBkLGVBQWVvYyxjQUFjO1lBQUM7WUFBYztTQUFRLEVBQUVnQjtJQUMxRDtJQUNBLE1BQU1DLDJCQUEyQmxjLGVBQWVrQyxZQUFZO1FBQ3hEO0tBQ0g7SUFDRCxJQUFJK1ksaUJBQWlCbmUsYUFBYW9mLDRCQUE0QixNQUFNO1FBQ2hFcmQsZUFBZW9jLGNBQWM7WUFBQztZQUFjO1NBQXVCLEVBQUVpQjtJQUN6RTtJQUNBLElBQUlsYyxlQUFla0MsWUFBWTtRQUFDO0tBQVcsTUFBTXBGLFdBQVc7UUFDeEQsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLElBQUlvQixlQUFla0MsWUFBWTtRQUFDO0tBQWUsTUFBTXBGLFdBQVc7UUFDNUQsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE9BQU91RDtBQUNYO0FBQ0EsU0FBU3FaLGdDQUFnQ3ZMLFNBQVMsRUFBRS9OLFVBQVU7SUFDMUQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU04VixlQUFlalksZUFBZWtDLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUkrVixnQkFBZ0IsTUFBTTtRQUN0QnBaLGVBQWVzRCxVQUFVO1lBQUM7U0FBWSxFQUFFOFY7SUFDNUM7SUFDQSxNQUFNdUIsc0JBQXNCeFosZUFBZWtDLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUlzWCx1QkFBdUIsTUFBTTtRQUM3QjNhLGVBQWVzRCxVQUFVO1lBQUM7U0FBVyxFQUFFMFoseUJBQXlCNUwsV0FBV3VKO0lBQy9FO0lBQ0EsT0FBT3JYO0FBQ1g7QUFDQSxTQUFTZ2Esa0JBQWtCamEsVUFBVTtJQUNqQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsSUFBSW5DLGVBQWVrQyxZQUFZO1FBQUM7S0FBYyxNQUFNcEYsV0FBVztRQUMzRCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTXdkLGNBQWNwYyxlQUFla0MsWUFBWTtRQUFDO0tBQVU7SUFDMUQsSUFBSWthLGVBQWUsTUFBTTtRQUNyQnZkLGVBQWVzRCxVQUFVO1lBQUM7U0FBVSxFQUFFaWE7SUFDMUM7SUFDQSxNQUFNalksZUFBZW5FLGVBQWVrQyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJaUMsZ0JBQWdCLE1BQU07UUFDdEJ0RixlQUFlc0QsVUFBVTtZQUFDO1NBQVcsRUFBRWdDO0lBQzNDO0lBQ0EsT0FBT2hDO0FBQ1g7QUFDQSxTQUFTa2Esc0JBQXNCbmEsVUFBVTtJQUNyQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTW1hLFNBQVN0YyxlQUFla0MsWUFBWTtRQUFDO0tBQUs7SUFDaEQsSUFBSW9hLFVBQVUsTUFBTTtRQUNoQnpkLGVBQWVzRCxVQUFVO1lBQUM7U0FBSyxFQUFFbWE7SUFDckM7SUFDQSxNQUFNQyxXQUFXdmMsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlxYSxZQUFZLE1BQU07UUFDbEIxZCxlQUFlc0QsVUFBVTtZQUFDO1NBQU8sRUFBRW9hO0lBQ3ZDO0lBQ0EsTUFBTWhhLFdBQVd2QyxlQUFla0MsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSUssWUFBWSxNQUFNO1FBQ2xCMUQsZUFBZXNELFVBQVU7WUFBQztTQUFPLEVBQUVJO0lBQ3ZDO0lBQ0EsSUFBSXZDLGVBQWVrQyxZQUFZO1FBQUM7S0FBYyxNQUFNcEYsV0FBVztRQUMzRCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsSUFBSW9CLGVBQWVrQyxZQUFZO1FBQUM7S0FBZSxNQUFNcEYsV0FBVztRQUM1RCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsT0FBT3VEO0FBQ1g7QUFDQSxTQUFTcWEsK0JBQStCdGEsVUFBVTtJQUM5QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXNhLFdBQVd6YyxlQUFla0MsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSXVhLFlBQVksTUFBTTtRQUNsQjVkLGVBQWVzRCxVQUFVO1lBQUM7U0FBTyxFQUFFc2E7SUFDdkM7SUFDQSxNQUFNQywyQkFBMkIxYyxlQUFla0MsWUFBWTtRQUN4RDtLQUNIO0lBQ0QsSUFBSXdhLDRCQUE0QixNQUFNO1FBQ2xDN2QsZUFBZXNELFVBQVU7WUFBQztTQUF1QixFQUFFdWE7SUFDdkQ7SUFDQSxJQUFJMWMsZUFBZWtDLFlBQVk7UUFBQztLQUE4QixNQUMxRHBGLFdBQVc7UUFDWCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsT0FBT3VEO0FBQ1g7QUFDQSxTQUFTd2EsK0JBQStCMU0sU0FBUyxFQUFFL04sVUFBVSxFQUFFK1ksWUFBWTtJQUN2RSxNQUFNOVksV0FBVyxDQUFDO0lBQ2xCLE1BQU15YSx3QkFBd0I1YyxlQUFla0MsWUFBWTtRQUNyRDtLQUNIO0lBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWE4Zix5QkFBeUIsTUFBTTtRQUM3RC9kLGVBQWVvYyxjQUFjO1lBQUM7U0FBb0IsRUFBRUwsaUJBQWlCckosU0FBU3FMO0lBQ2xGO0lBQ0EsTUFBTUMsa0JBQWtCN2MsZUFBZWtDLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUkyYSxtQkFBbUIsTUFBTTtRQUN6QmhlLGVBQWVzRCxVQUFVO1lBQUM7U0FBYyxFQUFFMGE7SUFDOUM7SUFDQSxNQUFNQyxXQUFXOWMsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUk0YSxZQUFZLE1BQU07UUFDbEJqZSxlQUFlc0QsVUFBVTtZQUFDO1NBQU8sRUFBRTJhO0lBQ3ZDO0lBQ0EsTUFBTUMsV0FBVy9jLGVBQWVrQyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJNmEsWUFBWSxNQUFNO1FBQ2xCbGUsZUFBZXNELFVBQVU7WUFBQztTQUFPLEVBQUU0YTtJQUN2QztJQUNBLE1BQU1DLHFCQUFxQmhkLGVBQWVrQyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJOGEsc0JBQXNCLE1BQU07UUFDNUJuZSxlQUFlc0QsVUFBVTtZQUFDO1NBQWlCLEVBQUU2YTtJQUNqRDtJQUNBLE1BQU1DLHNCQUFzQmpkLGVBQWVrQyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJK2EsdUJBQXVCLE1BQU07UUFDN0JwZSxlQUFlc0QsVUFBVTtZQUFDO1NBQWtCLEVBQUU4YTtJQUNsRDtJQUNBLE1BQU1DLG9CQUFvQmxkLGVBQWVrQyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJZ2IscUJBQXFCLE1BQU07UUFDM0JyZSxlQUFlc0QsVUFBVTtZQUFDO1NBQWdCLEVBQUUrYTtJQUNoRDtJQUNBLE1BQU1DLHVCQUF1Qm5kLGVBQWVrQyxZQUFZO1FBQ3BEO0tBQ0g7SUFDRCxJQUFJaWIsd0JBQXdCLE1BQU07UUFDOUJ0ZSxlQUFlc0QsVUFBVTtZQUFDO1NBQW1CLEVBQUVnYjtJQUNuRDtJQUNBLE1BQU1DLGVBQWVwZCxlQUFla0MsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSWtiLGdCQUFnQixNQUFNO1FBQ3RCdmUsZUFBZXNELFVBQVU7WUFBQztTQUFXLEVBQUVpYjtJQUMzQztJQUNBLE1BQU1DLHNCQUFzQnJkLGVBQWVrQyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJbWIsdUJBQXVCLE1BQU07UUFDN0J4ZSxlQUFlc0QsVUFBVTtZQUFDO1NBQWtCLEVBQUVrYjtJQUNsRDtJQUNBLE1BQU1DLHVCQUF1QnRkLGVBQWVrQyxZQUFZO1FBQ3BEO0tBQ0g7SUFDRCxJQUFJb2Isd0JBQXdCLE1BQU07UUFDOUJ6ZSxlQUFlc0QsVUFBVTtZQUFDO1NBQW1CLEVBQUVtYjtJQUNuRDtJQUNBLE1BQU1DLFdBQVd2ZCxlQUFla0MsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSXFiLFlBQVksTUFBTTtRQUNsQjFlLGVBQWVzRCxVQUFVO1lBQUM7U0FBTyxFQUFFb2I7SUFDdkM7SUFDQSxNQUFNQyx1QkFBdUJ4ZCxlQUFla0MsWUFBWTtRQUNwRDtLQUNIO0lBQ0QsSUFBSXNiLHdCQUF3QixNQUFNO1FBQzlCM2UsZUFBZXNELFVBQVU7WUFBQztTQUFtQixFQUFFcWI7SUFDbkQ7SUFDQSxNQUFNQyxxQkFBcUJ6ZCxlQUFla0MsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSXViLHNCQUFzQixNQUFNO1FBQzVCNWUsZUFBZXNELFVBQVU7WUFBQztTQUFpQixFQUFFNlEsUUFBUXlLO0lBQ3pEO0lBQ0EsTUFBTUMseUJBQXlCMWQsZUFBZWtDLFlBQVk7UUFDdEQ7S0FDSDtJQUNELElBQUl3YiwwQkFBMEIsTUFBTTtRQUNoQzdlLGVBQWVzRCxVQUFVO1lBQUM7U0FBcUIsRUFBRXViO0lBQ3JEO0lBQ0EsSUFBSTFkLGVBQWVrQyxZQUFZO1FBQUM7S0FBZ0IsTUFBTXBGLFdBQVc7UUFDN0QsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLElBQUlvQixlQUFla0MsWUFBWTtRQUFDO0tBQXVCLE1BQU1wRixXQUFXO1FBQ3BFLE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxNQUFNK2UscUJBQXFCM2QsZUFBZWtDLFlBQVk7UUFDbEQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhNmdCLHNCQUFzQixNQUFNO1FBQzFELElBQUkzYSxrQkFBa0IyYTtRQUN0QixJQUFJdGUsTUFBTUMsT0FBTyxDQUFDMEQsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQjlDLEdBQUcsQ0FBQyxDQUFDa0I7Z0JBQ25DLE9BQU93Yyx1QkFBdUJ4YztZQUNsQztRQUNKO1FBQ0F2QyxlQUFlb2MsY0FBYztZQUFDO1NBQWlCLEVBQUVqWTtJQUNyRDtJQUNBLE1BQU02YSxZQUFZN2QsZUFBZWtDLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUkrWSxpQkFBaUJuZSxhQUFhK2dCLGFBQWEsTUFBTTtRQUNqRCxJQUFJN2Esa0JBQWtCK1EsT0FBTzhKO1FBQzdCLElBQUl4ZSxNQUFNQyxPQUFPLENBQUMwRCxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCOUMsR0FBRyxDQUFDLENBQUNrQjtnQkFDbkMsT0FBTzBjLGNBQWN0SyxNQUFNcFM7WUFDL0I7UUFDSjtRQUNBdkMsZUFBZW9jLGNBQWM7WUFBQztTQUFRLEVBQUVqWTtJQUM1QztJQUNBLE1BQU0rYSxpQkFBaUIvZCxlQUFla0MsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSStZLGlCQUFpQm5lLGFBQWFpaEIsa0JBQWtCLE1BQU07UUFDdERsZixlQUFlb2MsY0FBYztZQUFDO1NBQWEsRUFBRStDLG9CQUFvQkQ7SUFDckU7SUFDQSxJQUFJL2QsZUFBZWtDLFlBQVk7UUFBQztLQUFTLE1BQU1wRixXQUFXO1FBQ3RELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxNQUFNcWYsb0JBQW9CamUsZUFBZWtDLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhbWhCLHFCQUFxQixNQUFNO1FBQ3pEcGYsZUFBZW9jLGNBQWM7WUFBQztTQUFnQixFQUFFM0csbUJBQW1CckUsV0FBV2dPO0lBQ2xGO0lBQ0EsTUFBTUMseUJBQXlCbGUsZUFBZWtDLFlBQVk7UUFDdEQ7S0FDSDtJQUNELElBQUlnYywwQkFBMEIsTUFBTTtRQUNoQ3JmLGVBQWVzRCxVQUFVO1lBQUM7U0FBcUIsRUFBRStiO0lBQ3JEO0lBQ0EsTUFBTUMsc0JBQXNCbmUsZUFBZWtDLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUlpYyx1QkFBdUIsTUFBTTtRQUM3QnRmLGVBQWVzRCxVQUFVO1lBQUM7U0FBa0IsRUFBRWdjO0lBQ2xEO0lBQ0EsTUFBTUMsbUJBQW1CcGUsZUFBZWtDLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUlrYyxvQkFBb0IsTUFBTTtRQUMxQnZmLGVBQWVzRCxVQUFVO1lBQUM7U0FBZSxFQUFFK1EsY0FBY2tMO0lBQzdEO0lBQ0EsSUFBSXBlLGVBQWVrQyxZQUFZO1FBQUM7S0FBaUIsTUFBTXBGLFdBQVc7UUFDOUQsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE1BQU15ZixxQkFBcUJyZSxlQUFla0MsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSW1jLHNCQUFzQixNQUFNO1FBQzVCeGYsZUFBZXNELFVBQVU7WUFBQztTQUFpQixFQUFFa2M7SUFDakQ7SUFDQSxNQUFNQyxrQkFBa0J0ZSxlQUFla0MsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSW9jLG1CQUFtQixNQUFNO1FBQ3pCemYsZUFBZXNELFVBQVU7WUFBQztTQUFjLEVBQUVvYyxxQkFBcUJEO0lBQ25FO0lBQ0EsT0FBT25jO0FBQ1g7QUFDQSxTQUFTcWMsbUNBQW1DdGMsVUFBVTtJQUNsRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXlCLHNCQUFzQjVELGVBQWVrQyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJMEIsdUJBQXVCLE1BQU07UUFDN0IvRSxlQUFlc0QsVUFBVTtZQUFDO1NBQWtCLEVBQUV5QjtJQUNsRDtJQUNBLE1BQU02YSxpQkFBaUJ6ZSxlQUFla0MsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSXVjLGtCQUFrQixNQUFNO1FBQ3hCLElBQUl6YixrQkFBa0J5YjtRQUN0QixJQUFJcGYsTUFBTUMsT0FBTyxDQUFDMEQsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQjlDLEdBQUcsQ0FBQyxDQUFDa0I7Z0JBQ25DLE9BQU8yWSxxQkFBcUIzWTtZQUNoQztRQUNKO1FBQ0F2QyxlQUFlc0QsVUFBVTtZQUFDO1NBQWEsRUFBRWE7SUFDN0M7SUFDQSxNQUFNMGIsbUJBQW1CMWUsZUFBZWtDLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUl3YyxvQkFBb0IsTUFBTTtRQUMxQjdmLGVBQWVzRCxVQUFVO1lBQUM7U0FBZSxFQUFFdWM7SUFDL0M7SUFDQSxNQUFNQyxxQkFBcUIzZSxlQUFla0MsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSXljLHNCQUFzQixNQUFNO1FBQzVCOWYsZUFBZXNELFVBQVU7WUFBQztTQUFpQixFQUFFd2M7SUFDakQ7SUFDQSxNQUFNQyxpQkFBaUI1ZSxlQUFla0MsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSTBjLGtCQUFrQixNQUFNO1FBQ3hCL2YsZUFBZXNELFVBQVU7WUFBQztTQUFhLEVBQUV5YztJQUM3QztJQUNBLE1BQU1DLG9CQUFvQjdlLGVBQWVrQyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJMmMscUJBQXFCLE1BQU07UUFDM0JoZ0IsZUFBZXNELFVBQVU7WUFBQztTQUFnQixFQUFFMGM7SUFDaEQ7SUFDQSxPQUFPMWM7QUFDWDtBQUNBLFNBQVMyYyw2QkFBNkI3TyxTQUFTLEVBQUUvTixVQUFVO0lBQ3ZELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNSSxXQUFXdkMsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlLLFlBQVksTUFBTTtRQUNsQjFELGVBQWVzRCxVQUFVO1lBQUM7WUFBUTtTQUFPLEVBQUVvVixjQUFjdEgsV0FBVzFOO0lBQ3hFO0lBQ0EsT0FBT0o7QUFDWDtBQUNBLFNBQVM0Yyw4QkFBOEI5TyxTQUFTLEVBQUUvTixVQUFVO0lBQ3hELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNSSxXQUFXdkMsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlLLFlBQVksTUFBTTtRQUNsQjFELGVBQWVzRCxVQUFVO1lBQUM7WUFBUTtTQUFPLEVBQUVvVixjQUFjdEgsV0FBVzFOO0lBQ3hFO0lBQ0EsT0FBT0o7QUFDWDtBQUNBLFNBQVM2YyxvQkFBb0I5YyxVQUFVO0lBQ25DLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixJQUFJbkMsZUFBZWtDLFlBQVk7UUFBQztLQUFhLE1BQU1wRixXQUFXO1FBQzFELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxNQUFNcWdCLG1CQUFtQmpmLGVBQWVrQyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJK2Msb0JBQW9CLE1BQU07UUFDMUJwZ0IsZUFBZXNELFVBQVU7WUFBQztTQUFlLEVBQUU4YztJQUMvQztJQUNBLE9BQU85YztBQUNYO0FBQ0EsU0FBUytjLHNCQUFzQmhkLFVBQVU7SUFDckMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLElBQUluQyxlQUFla0MsWUFBWTtRQUFDO0tBQWlCLE1BQU1wRixXQUFXO1FBQzlELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxJQUFJb0IsZUFBZWtDLFlBQVk7UUFBQztLQUFxQixNQUFNcEYsV0FBVztRQUNsRSxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTXVnQixzQkFBc0JuZixlQUFla0MsWUFBWTtRQUNuRDtLQUNIO0lBQ0QsSUFBSWlkLHVCQUF1QixNQUFNO1FBQzdCdGdCLGVBQWVzRCxVQUFVO1lBQUM7U0FBa0IsRUFBRWdkO0lBQ2xEO0lBQ0EsT0FBT2hkO0FBQ1g7QUFDQSxTQUFTb2MscUJBQXFCcmMsVUFBVTtJQUNwQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTWlkLGtCQUFrQnBmLGVBQWVrQyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJa2QsbUJBQW1CLE1BQU07UUFDekJ2Z0IsZUFBZXNELFVBQVU7WUFBQztTQUFjLEVBQUVpZDtJQUM5QztJQUNBLE1BQU1DLGdCQUFnQnJmLGVBQWVrQyxZQUFZO1FBQUM7S0FBWTtJQUM5RCxJQUFJbWQsaUJBQWlCLE1BQU07UUFDdkJ4Z0IsZUFBZXNELFVBQVU7WUFBQztTQUFZLEVBQUVrZDtJQUM1QztJQUNBLElBQUlyZixlQUFla0MsWUFBWTtRQUFDO0tBQWlCLE1BQU1wRixXQUFXO1FBQzlELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxJQUFJb0IsZUFBZWtDLFlBQVk7UUFBQztLQUEyQixNQUN2RHBGLFdBQVc7UUFDWCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsT0FBT3VEO0FBQ1g7QUFDQSxTQUFTc1gsc0JBQXNCeEosU0FBUyxFQUFFL04sVUFBVTtJQUNoRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTTZXLFlBQVloWixlQUFla0MsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSThXLGFBQWEsTUFBTTtRQUNuQm5hLGVBQWVzRCxVQUFVO1lBQUM7WUFBVztTQUFRLEVBQUU2TixPQUFPQyxXQUFXK0k7SUFDckU7SUFDQSxNQUFNOEMsZUFBZTliLGVBQWVrQyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJNFosZ0JBQWdCLE1BQU07UUFDdEIsSUFBSTlZLGtCQUFrQjBPLFVBQVVvSztRQUNoQyxJQUFJemMsTUFBTUMsT0FBTyxDQUFDMEQsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQjlDLEdBQUcsQ0FBQyxDQUFDa0I7Z0JBQ25DLE9BQU93WixpQkFBaUJ4WjtZQUM1QjtRQUNKO1FBQ0F2QyxlQUFlc0QsVUFBVTtZQUFDO1lBQVc7U0FBVyxFQUFFYTtJQUN0RDtJQUNBLE1BQU1SLGVBQWV4QyxlQUFla0MsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSU0sZ0JBQWdCLE1BQU07UUFDdEIzRCxlQUFlc0QsVUFBVTtZQUFDO1NBQVcsRUFBRUs7SUFDM0M7SUFDQSxNQUFNNFksYUFBYXBiLGVBQWVrQyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJa1osY0FBYyxNQUFNO1FBQ3BCdmMsZUFBZXNELFVBQVU7WUFBQztZQUFXO1NBQW1CLEVBQUV3YSwrQkFBK0IxTSxXQUFXbUwsWUFBWXBiLGVBQWVtQyxVQUFVO1lBQUM7U0FBVSxFQUFFLENBQUM7SUFDM0o7SUFDQSxPQUFPQTtBQUNYO0FBQ0EsU0FBU2dXLHlCQUF5QmpXLFVBQVU7SUFDeEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1RLGVBQWUzQyxlQUFla0MsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSVMsZ0JBQWdCLE1BQU07UUFDdEI5RCxlQUFlc0QsVUFBVTtZQUFDO1NBQVcsRUFBRXFjLG1DQUFtQzdiO0lBQzlFO0lBQ0EsTUFBTUQsWUFBWTFDLGVBQWVrQyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJUSxhQUFhLE1BQU07UUFDbkI3RCxlQUFlc0QsVUFBVTtZQUFDO1NBQVEsRUFBRU87SUFDeEM7SUFDQSxPQUFPUDtBQUNYO0FBQ0EsU0FBU21kLDJCQUEyQnBkLFVBQVUsRUFBRStZLFlBQVk7SUFDeEQsTUFBTTlZLFdBQVcsQ0FBQztJQUNsQixNQUFNb2QsZUFBZXZmLGVBQWVrQyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJK1ksaUJBQWlCbmUsYUFBYXlpQixnQkFBZ0IsTUFBTTtRQUNwRDFnQixlQUFlb2MsY0FBYztZQUFDO1lBQVU7U0FBVyxFQUFFc0U7SUFDekQ7SUFDQSxNQUFNQyxnQkFBZ0J4ZixlQUFla0MsWUFBWTtRQUFDO0tBQVk7SUFDOUQsSUFBSStZLGlCQUFpQm5lLGFBQWEwaUIsaUJBQWlCLE1BQU07UUFDckQzZ0IsZUFBZW9jLGNBQWM7WUFBQztZQUFVO1NBQVksRUFBRXVFO0lBQzFEO0lBQ0EsSUFBSXhmLGVBQWVrQyxZQUFZO1FBQUM7S0FBUyxNQUFNcEYsV0FBVztRQUN0RCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsT0FBT3VEO0FBQ1g7QUFDQSxTQUFTc2QsNEJBQTRCdmQsVUFBVSxFQUFFK1ksWUFBWTtJQUN6RCxNQUFNOVksV0FBVyxDQUFDO0lBQ2xCLE1BQU1vZCxlQUFldmYsZUFBZWtDLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUkrWSxpQkFBaUJuZSxhQUFheWlCLGdCQUFnQixNQUFNO1FBQ3BEMWdCLGVBQWVvYyxjQUFjO1lBQUM7WUFBVTtTQUFXLEVBQUVzRTtJQUN6RDtJQUNBLE1BQU1DLGdCQUFnQnhmLGVBQWVrQyxZQUFZO1FBQUM7S0FBWTtJQUM5RCxJQUFJK1ksaUJBQWlCbmUsYUFBYTBpQixpQkFBaUIsTUFBTTtRQUNyRDNnQixlQUFlb2MsY0FBYztZQUFDO1lBQVU7U0FBWSxFQUFFdUU7SUFDMUQ7SUFDQSxNQUFNRSxhQUFhMWYsZUFBZWtDLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUkrWSxpQkFBaUJuZSxhQUFhNGlCLGNBQWMsTUFBTTtRQUNsRDdnQixlQUFlb2MsY0FBYztZQUFDO1lBQVU7U0FBUyxFQUFFeUU7SUFDdkQ7SUFDQSxPQUFPdmQ7QUFDWDtBQUNBLFNBQVN3ZCwrQkFBK0J6ZCxVQUFVO0lBQzlDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNaVosYUFBYXBiLGVBQWVrQyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJa1osY0FBYyxNQUFNO1FBQ3BCa0UsMkJBQTJCbEUsWUFBWWpaO0lBQzNDO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLFNBQVN5ZCxnQ0FBZ0MxZCxVQUFVO0lBQy9DLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNaVosYUFBYXBiLGVBQWVrQyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJa1osY0FBYyxNQUFNO1FBQ3BCcUUsNEJBQTRCckUsWUFBWWpaO0lBQzVDO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLFNBQVMwZCwrQkFBK0IzZCxVQUFVO0lBQzlDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNeUIsc0JBQXNCNUQsZUFBZWtDLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUkwQix1QkFBdUIsTUFBTTtRQUM3Qi9FLGVBQWVzRCxVQUFVO1lBQUM7U0FBa0IsRUFBRXlCO0lBQ2xEO0lBQ0EsTUFBTWtjLG9CQUFvQjlmLGVBQWVrQyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJNGQscUJBQXFCLE1BQU07UUFDM0JqaEIsZUFBZXNELFVBQVU7WUFBQztTQUFnQixFQUFFMmQ7SUFDaEQ7SUFDQSxNQUFNQyxnQkFBZ0IvZixlQUFla0MsWUFBWTtRQUFDO0tBQWE7SUFDL0QsSUFBSTZkLGlCQUFpQixNQUFNO1FBQ3ZCLElBQUkvYyxrQkFBa0IrYztRQUN0QixJQUFJMWdCLE1BQU1DLE9BQU8sQ0FBQzBELGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0I5QyxHQUFHLENBQUMsQ0FBQ2tCO2dCQUNuQyxPQUFPc1gsa0JBQWtCdFg7WUFDN0I7UUFDSjtRQUNBdkMsZUFBZXNELFVBQVU7WUFBQztTQUFZLEVBQUVhO0lBQzVDO0lBQ0EsT0FBT2I7QUFDWDtBQUNBLFNBQVM2ZCxnQ0FBZ0M5ZCxVQUFVO0lBQy9DLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNeUIsc0JBQXNCNUQsZUFBZWtDLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUkwQix1QkFBdUIsTUFBTTtRQUM3Qi9FLGVBQWVzRCxVQUFVO1lBQUM7U0FBa0IsRUFBRXlCO0lBQ2xEO0lBQ0EsTUFBTWtjLG9CQUFvQjlmLGVBQWVrQyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJNGQscUJBQXFCLE1BQU07UUFDM0JqaEIsZUFBZXNELFVBQVU7WUFBQztTQUFnQixFQUFFMmQ7SUFDaEQ7SUFDQSxNQUFNQyxnQkFBZ0IvZixlQUFla0MsWUFBWTtRQUM3QztLQUNIO0lBQ0QsSUFBSTZkLGlCQUFpQixNQUFNO1FBQ3ZCLElBQUkvYyxrQkFBa0IrYztRQUN0QixJQUFJMWdCLE1BQU1DLE9BQU8sQ0FBQzBELGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0I5QyxHQUFHLENBQUMsQ0FBQ2tCO2dCQUNuQyxPQUFPOFgsbUJBQW1COVg7WUFDOUI7UUFDSjtRQUNBdkMsZUFBZXNELFVBQVU7WUFBQztTQUFZLEVBQUVhO0lBQzVDO0lBQ0EsT0FBT2I7QUFDWDtBQUNBLFNBQVMyWSxjQUFjNVksVUFBVTtJQUM3QixNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTWdjLHNCQUFzQm5lLGVBQWVrQyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJaWMsdUJBQXVCLE1BQU07UUFDN0J0ZixlQUFlc0QsVUFBVTtZQUFDO1NBQWtCLEVBQUVnYztJQUNsRDtJQUNBLE1BQU04QiwwQkFBMEJqZ0IsZUFBZWtDLFlBQVk7UUFDdkQ7S0FDSDtJQUNELElBQUkrZCwyQkFBMkIsTUFBTTtRQUNqQ3BoQixlQUFlc0QsVUFBVTtZQUFDO1NBQXNCLEVBQUU4ZDtJQUN0RDtJQUNBLE1BQU1DLHFCQUFxQmxnQixlQUFla0MsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSWdlLHNCQUFzQixNQUFNO1FBQzVCcmhCLGVBQWVzRCxVQUFVO1lBQUM7U0FBaUIsRUFBRStkO0lBQ2pEO0lBQ0EsTUFBTUMsZUFBZW5nQixlQUFla0MsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSWllLGdCQUFnQixNQUFNO1FBQ3RCdGhCLGVBQWVzRCxVQUFVO1lBQUM7U0FBVyxFQUFFZ2Esa0JBQWtCZ0U7SUFDN0Q7SUFDQSxNQUFNQyxtQkFBbUJwZ0IsZUFBZWtDLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUlrZSxvQkFBb0IsTUFBTTtRQUMxQnZoQixlQUFlc0QsVUFBVTtZQUFDO1NBQWUsRUFBRWthLHNCQUFzQitEO0lBQ3JFO0lBQ0EsTUFBTUMsdUJBQXVCcmdCLGVBQWVrQyxZQUFZO1FBQ3BEO0tBQ0g7SUFDRCxJQUFJbWUsd0JBQXdCLE1BQU07UUFDOUJ4aEIsZUFBZXNELFVBQVU7WUFBQztTQUFtQixFQUFFa2U7SUFDbkQ7SUFDQSxNQUFNQyxpQkFBaUJ0Z0IsZUFBZWtDLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUlvZSxrQkFBa0IsTUFBTTtRQUN4QnpoQixlQUFlc0QsVUFBVTtZQUFDO1NBQWEsRUFBRXdYLGNBQWMyRztJQUMzRDtJQUNBLE1BQU1DLFdBQVd2Z0IsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlxZSxZQUFZLE1BQU07UUFDbEIxaEIsZUFBZXNELFVBQVU7WUFBQztTQUFPLEVBQUVvZTtJQUN2QztJQUNBLE1BQU1DLGNBQWN4Z0IsZUFBZWtDLFlBQVk7UUFBQztLQUFVO0lBQzFELElBQUlzZSxlQUFlLE1BQU07UUFDckIzaEIsZUFBZXNELFVBQVU7WUFBQztTQUFVLEVBQUVxZTtJQUMxQztJQUNBLE1BQU1DLHVCQUF1QnpnQixlQUFla0MsWUFBWTtRQUNwRDtLQUNIO0lBQ0QsSUFBSXVlLHdCQUF3QixNQUFNO1FBQzlCNWhCLGVBQWVzRCxVQUFVO1lBQUM7U0FBbUIsRUFBRXNlO0lBQ25EO0lBQ0EsTUFBTUMsb0JBQW9CMWdCLGVBQWVrQyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJd2UscUJBQXFCLE1BQU07UUFDM0I3aEIsZUFBZXNELFVBQVU7WUFBQztTQUFnQixFQUFFdWU7SUFDaEQ7SUFDQSxPQUFPdmU7QUFDWDtBQUNBLFNBQVN5Yix1QkFBdUIxYixVQUFVO0lBQ3RDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNd2UsZUFBZTNnQixlQUFla0MsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSXllLGdCQUFnQixNQUFNO1FBQ3RCOWhCLGVBQWVzRCxVQUFVO1lBQUM7U0FBVyxFQUFFd2U7SUFDM0M7SUFDQSxJQUFJM2dCLGVBQWVrQyxZQUFZO1FBQUM7S0FBUyxNQUFNcEYsV0FBVztRQUN0RCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTWdpQixnQkFBZ0I1Z0IsZUFBZWtDLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUkwZSxpQkFBaUIsTUFBTTtRQUN2Qi9oQixlQUFlc0QsVUFBVTtZQUFDO1NBQVksRUFBRXllO0lBQzVDO0lBQ0EsT0FBT3plO0FBQ1g7QUFDQSxTQUFTNmIsb0JBQW9COWIsVUFBVTtJQUNuQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTTBlLDRCQUE0QjdnQixlQUFla0MsWUFBWTtRQUN6RDtLQUNIO0lBQ0QsSUFBSTJlLDZCQUE2QixNQUFNO1FBQ25DaGlCLGVBQWVzRCxVQUFVO1lBQUM7U0FBd0IsRUFBRXFhLCtCQUErQnFFO0lBQ3ZGO0lBQ0EsTUFBTUMsc0JBQXNCOWdCLGVBQWVrQyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJNGUsdUJBQXVCLE1BQU07UUFDN0JqaUIsZUFBZXNELFVBQVU7WUFBQztTQUFrQixFQUFFMmU7SUFDbEQ7SUFDQSxPQUFPM2U7QUFDWDtBQUNBLFNBQVMyYixjQUFjNWIsVUFBVTtJQUM3QixNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTTRlLDJCQUEyQi9nQixlQUFla0MsWUFBWTtRQUN4RDtLQUNIO0lBQ0QsSUFBSTZlLDRCQUE0QixNQUFNO1FBQ2xDLElBQUkvZCxrQkFBa0IrZDtRQUN0QixJQUFJMWhCLE1BQU1DLE9BQU8sQ0FBQzBELGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0I5QyxHQUFHLENBQUMsQ0FBQ2tCO2dCQUNuQyxPQUFPQTtZQUNYO1FBQ0o7UUFDQXZDLGVBQWVzRCxVQUFVO1lBQUM7U0FBdUIsRUFBRWE7SUFDdkQ7SUFDQSxJQUFJaEQsZUFBZWtDLFlBQVk7UUFBQztLQUFZLE1BQU1wRixXQUFXO1FBQ3pELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxNQUFNb2lCLDRCQUE0QmhoQixlQUFla0MsWUFBWTtRQUN6RDtLQUNIO0lBQ0QsSUFBSThlLDZCQUE2QixNQUFNO1FBQ25DbmlCLGVBQWVzRCxVQUFVO1lBQUM7U0FBd0IsRUFBRTZlO0lBQ3hEO0lBQ0EsTUFBTUMsa0JBQWtCamhCLGVBQWVrQyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJK2UsbUJBQW1CLE1BQU07UUFDekJwaUIsZUFBZXNELFVBQVU7WUFBQztTQUFjLEVBQUU4ZTtJQUM5QztJQUNBLE1BQU1DLGlCQUFpQmxoQixlQUFla0MsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSWdmLGtCQUFrQixNQUFNO1FBQ3hCcmlCLGVBQWVzRCxVQUFVO1lBQUM7U0FBYSxFQUFFK2U7SUFDN0M7SUFDQSxNQUFNQyxvQkFBb0JuaEIsZUFBZWtDLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUlpZixxQkFBcUIsTUFBTTtRQUMzQnRpQixlQUFlc0QsVUFBVTtZQUFDO1NBQWdCLEVBQUVnZjtJQUNoRDtJQUNBLElBQUluaEIsZUFBZWtDLFlBQVk7UUFBQztLQUFzQixNQUFNcEYsV0FBVztRQUNuRSxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTXdpQixpQkFBaUJwaEIsZUFBZWtDLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUlrZixrQkFBa0IsTUFBTTtRQUN4QnZpQixlQUFlc0QsVUFBVTtZQUFDO1NBQWEsRUFBRTZjLG9CQUFvQm9DO0lBQ2pFO0lBQ0EsTUFBTUMsbUJBQW1CcmhCLGVBQWVrQyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJbWYsb0JBQW9CLE1BQU07UUFDMUJ4aUIsZUFBZXNELFVBQVU7WUFBQztTQUFlLEVBQUUrYyxzQkFBc0JtQztJQUNyRTtJQUNBLE1BQU1DLGlCQUFpQnRoQixlQUFla0MsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSW9mLGtCQUFrQixNQUFNO1FBQ3hCemlCLGVBQWVzRCxVQUFVO1lBQUM7U0FBYSxFQUFFbWY7SUFDN0M7SUFDQSxPQUFPbmY7QUFDWDtBQUVBOzs7O0NBSUMsR0FDRCxJQUFJb2Y7QUFDSCxVQUFVQSxTQUFTO0lBQ2hCQSxTQUFTLENBQUMsd0JBQXdCLEdBQUc7SUFDckNBLFNBQVMsQ0FBQyxvQkFBb0IsR0FBRztJQUNqQ0EsU0FBUyxDQUFDLHlCQUF5QixHQUFHO0lBQ3RDQSxTQUFTLENBQUMsbUJBQW1CLEdBQUc7SUFDaENBLFNBQVMsQ0FBQyw2QkFBNkIsR0FBRztJQUMxQ0EsU0FBUyxDQUFDLGdDQUFnQyxHQUFHO0lBQzdDQSxTQUFTLENBQUMsdUJBQXVCLEdBQUc7QUFDeEMsR0FBR0EsYUFBY0EsQ0FBQUEsWUFBWSxDQUFDO0FBQzlCOztDQUVDLEdBQ0QsTUFBTUM7SUFPRkMsS0FBSzdZLElBQUksRUFBRUssUUFBUSxFQUFFeVksTUFBTSxFQUFFO1FBQ3pCLElBQUloa0IsSUFBSUM7UUFDUixJQUFJLENBQUNna0IsWUFBWSxHQUFHL1k7UUFDcEIsSUFBSSxDQUFDZ1osWUFBWSxHQUFHM1ksUUFBUSxDQUFDLElBQUksQ0FBQzBZLFlBQVksQ0FBQyxJQUFJLEVBQUU7UUFDckQsSUFBSSxDQUFDRSx1QkFBdUIsR0FBRzVZLGFBQWEsUUFBUUEsYUFBYSxLQUFLLElBQUksS0FBSyxJQUFJQSxTQUFTNlksZUFBZTtRQUMzRyxJQUFJLENBQUNDLFdBQVcsR0FBRztRQUNuQixJQUFJQyxnQkFBZ0I7WUFBRXBULFFBQVEsQ0FBQztRQUFFO1FBQ2pDLElBQUksQ0FBQzhTLFVBQVVwakIsT0FBT1MsSUFBSSxDQUFDMmlCLFFBQVF6aUIsTUFBTSxLQUFLLEdBQUc7WUFDN0MraUIsZ0JBQWdCO2dCQUFFcFQsUUFBUSxDQUFDO1lBQUU7UUFDakMsT0FDSyxJQUFJLE9BQU84UyxXQUFXLFVBQVU7WUFDakNNLGdCQUFnQjFqQixPQUFPd0IsTUFBTSxDQUFDLENBQUMsR0FBRzRoQjtRQUN0QyxPQUNLO1lBQ0RNLGdCQUFnQk47UUFDcEI7UUFDQSxJQUFJTSxhQUFhLENBQUMsU0FBUyxFQUFFO1lBQ3pCQSxhQUFhLENBQUMsU0FBUyxDQUFDLFlBQVksR0FBRy9ZLFFBQVEsQ0FBQyxnQkFBZ0I7UUFDcEU7UUFDQSxJQUFJLENBQUNnWixjQUFjLEdBQUdEO1FBQ3RCLElBQUksQ0FBQ0UsZ0JBQWdCLEdBQ2pCLENBQUN2a0IsS0FBSyxDQUFDRCxLQUFLc2tCLGFBQWEsQ0FBQyxTQUFTLE1BQU0sUUFBUXRrQixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEVBQUUsQ0FBQyxXQUFXLE1BQU0sUUFBUUMsT0FBTyxLQUFLLElBQUlBLEtBQUssSUFBSSxDQUFDaWtCLFlBQVksQ0FBQzNpQixNQUFNO0lBQzNKO0lBQ0FrakIsYUFBYWxaLFFBQVEsRUFBRTtRQUNuQixJQUFJLENBQUN3WSxJQUFJLENBQUMsSUFBSSxDQUFDRSxZQUFZLEVBQUUxWSxVQUFVLElBQUksQ0FBQ2daLGNBQWM7SUFDOUQ7SUFDQTs7Ozs7O0tBTUMsR0FDRCxJQUFJRyxPQUFPO1FBQ1AsT0FBTyxJQUFJLENBQUNSLFlBQVk7SUFDNUI7SUFDQTs7S0FFQyxHQUNELElBQUloWixPQUFPO1FBQ1AsT0FBTyxJQUFJLENBQUMrWSxZQUFZO0lBQzVCO0lBQ0E7Ozs7O0tBS0MsR0FDRCxJQUFJVSxXQUFXO1FBQ1gsT0FBTyxJQUFJLENBQUNILGdCQUFnQjtJQUNoQztJQUNBOztLQUVDLEdBQ0QsSUFBSUosa0JBQWtCO1FBQ2xCLE9BQU8sSUFBSSxDQUFDRCx1QkFBdUI7SUFDdkM7SUFDQTs7Ozs7OztLQU9DLEdBQ0QsSUFBSUgsU0FBUztRQUNULE9BQU8sSUFBSSxDQUFDTyxjQUFjO0lBQzlCO0lBQ0E7O0tBRUMsR0FDRCxJQUFJSyxhQUFhO1FBQ2IsT0FBTyxJQUFJLENBQUNWLFlBQVksQ0FBQzNpQixNQUFNO0lBQ25DO0lBQ0E7O0tBRUMsR0FDRHNqQixRQUFRQyxLQUFLLEVBQUU7UUFDWCxPQUFPLElBQUksQ0FBQ1osWUFBWSxDQUFDWSxNQUFNO0lBQ25DO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7S0FnQkMsR0FDRCxDQUFDQyxPQUFPQyxhQUFhLENBQUMsR0FBRztRQUNyQixPQUFPO1lBQ0hDLE1BQU07Z0JBQ0YsSUFBSSxJQUFJLENBQUNaLFdBQVcsSUFBSSxJQUFJLENBQUNPLFVBQVUsRUFBRTtvQkFDckMsSUFBSSxJQUFJLENBQUNNLFdBQVcsSUFBSTt3QkFDcEIsTUFBTSxJQUFJLENBQUNDLFFBQVE7b0JBQ3ZCLE9BQ0s7d0JBQ0QsT0FBTzs0QkFBRW5rQixPQUFPNUI7NEJBQVdnbUIsTUFBTTt3QkFBSztvQkFDMUM7Z0JBQ0o7Z0JBQ0EsTUFBTTFoQixPQUFPLElBQUksQ0FBQ21oQixPQUFPLENBQUMsSUFBSSxDQUFDUixXQUFXO2dCQUMxQyxJQUFJLENBQUNBLFdBQVcsSUFBSTtnQkFDcEIsT0FBTztvQkFBRXJqQixPQUFPMEM7b0JBQU0waEIsTUFBTTtnQkFBTTtZQUN0QztZQUNBQyxRQUFRO2dCQUNKLE9BQU87b0JBQUVya0IsT0FBTzVCO29CQUFXZ21CLE1BQU07Z0JBQUs7WUFDMUM7UUFDSjtJQUNKO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBb0JDLEdBQ0QsTUFBTUQsV0FBVztRQUNiLElBQUksQ0FBQyxJQUFJLENBQUNELFdBQVcsSUFBSTtZQUNyQixNQUFNLElBQUloa0IsTUFBTTtRQUNwQjtRQUNBLE1BQU1xSyxXQUFXLE1BQU0sSUFBSSxDQUFDK1osZUFBZSxDQUFDLElBQUksQ0FBQ3RCLE1BQU07UUFDdkQsSUFBSSxDQUFDUyxZQUFZLENBQUNsWjtRQUNsQixPQUFPLElBQUksQ0FBQ21aLElBQUk7SUFDcEI7SUFDQTs7S0FFQyxHQUNEUSxjQUFjO1FBQ1YsSUFBSWxsQjtRQUNKLElBQUksQ0FBQyxDQUFDQSxLQUFLLElBQUksQ0FBQ2drQixNQUFNLENBQUMsU0FBUyxNQUFNLFFBQVFoa0IsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxFQUFFLENBQUMsWUFBWSxNQUFNWixXQUFXO1lBQ25HLE9BQU87UUFDWDtRQUNBLE9BQU87SUFDWDtJQWpLQTBOLFlBQVk1QixJQUFJLEVBQUVxYSxPQUFPLEVBQUVoYSxRQUFRLEVBQUV5WSxNQUFNLENBQUU7UUFDekMsSUFBSSxDQUFDRSxZQUFZLEdBQUcsRUFBRTtRQUN0QixJQUFJLENBQUNLLGNBQWMsR0FBRyxDQUFDO1FBQ3ZCLElBQUksQ0FBQ2UsZUFBZSxHQUFHQztRQUN2QixJQUFJLENBQUN4QixJQUFJLENBQUM3WSxNQUFNSyxVQUFVeVk7SUFDOUI7QUE2Sko7QUFFQTs7OztDQUlDLEdBQ0QsTUFBTXdCLGdCQUFnQnBsQjtJQXNFbEIsOERBQThEO0lBQzlEcWxCLG9DQUFvQ3pCLE1BQU0sRUFBRTtRQUN4QyxNQUFNMEIsT0FBT2pJLGdDQUFnQyxJQUFJLENBQUNsTCxTQUFTLEVBQzNEeVI7UUFDQSxNQUFNMkIsWUFBWUQsSUFBSSxDQUFDLE9BQU87UUFDOUIsTUFBTUUsT0FBT3ZsQixVQUFVLGdDQUFnQ3NsQjtRQUN2RCxNQUFNRSxRQUFRSCxJQUFJLENBQUMsUUFBUTtRQUMzQixNQUFNSSxjQUFjRCxLQUFLLENBQUMsY0FBYztRQUN4QyxNQUFNRSxrQkFBa0JELFdBQVcsQ0FBQyxXQUFXO1FBQy9DLE1BQU1FLFdBQVdELGVBQWUsQ0FBQyxXQUFXO1FBQzVDLE1BQU1FLGNBQWMsRUFBRTtRQUN0QixLQUFLLE1BQU1WLFdBQVdTLFNBQVU7WUFDNUIsTUFBTUUsY0FBY3RsQixPQUFPd0IsTUFBTSxDQUFDLENBQUMsR0FBR21qQixVQUFVLFFBQVE7WUFDeEQsSUFBSVcsV0FBVyxDQUFDLG9CQUFvQixFQUFFO2dCQUNsQyxNQUFNQyx5QkFBeUJELFdBQVcsQ0FBQyxvQkFBb0I7Z0JBQy9ELE9BQU9BLFdBQVcsQ0FBQyxvQkFBb0I7Z0JBQ3ZDLE1BQU1FLGlCQUFpQkYsV0FBVyxDQUFDLFVBQVU7Z0JBQzdDRSxjQUFjLENBQUMsb0JBQW9CLEdBQUdEO2dCQUN0Q0QsV0FBVyxDQUFDLFVBQVUsR0FBR0U7WUFDN0I7WUFDQUgsWUFBWTdoQixJQUFJLENBQUM4aEI7UUFDckI7UUFDQUgsZUFBZSxDQUFDLFdBQVcsR0FBR0U7UUFDOUIsT0FBT1AsSUFBSSxDQUFDLFNBQVM7UUFDckIsT0FBT0EsSUFBSSxDQUFDLE9BQU87UUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7UUFDckIsT0FBTztZQUFFRTtZQUFNRjtRQUFLO0lBQ3hCO0lBQ0EsMkNBQTJDO0lBQzNDVyxVQUFVOU4sR0FBRyxFQUFFO1FBQ1gsSUFBSSxPQUFPQSxRQUFRLFVBQVU7WUFDekIsT0FBT0EsSUFBSXpVLFVBQVUsQ0FBQyxXQUFXeVUsTUFBTW5aO1FBQzNDO1FBQ0EsSUFBSSxDQUFDdUMsTUFBTUMsT0FBTyxDQUFDMlcsUUFBUUEsSUFBSUcsTUFBTSxJQUFJSCxJQUFJRyxNQUFNLENBQUNuWCxNQUFNLEdBQUcsR0FBRztZQUM1RCxPQUFPZ1gsSUFBSUcsTUFBTSxDQUFDLEVBQUU7UUFDeEI7UUFDQSxPQUFPdFo7SUFDWDtJQUNBLDBDQUEwQztJQUMxQ2tuQixlQUFlL04sR0FBRyxFQUFFO1FBQ2hCLElBQUksT0FBT0EsUUFBUSxVQUFVO1lBQ3pCLE9BQU9BLElBQUl6VSxVQUFVLENBQUMsV0FBV3lVLE1BQU1uWjtRQUMzQztRQUNBLElBQUksQ0FBQ3VDLE1BQU1DLE9BQU8sQ0FBQzJXLE1BQU07WUFDckIsT0FBT0EsSUFBSUksV0FBVztRQUMxQjtRQUNBLE9BQU92WjtJQUNYO0lBQ0EsaUVBQWlFO0lBQ2pFbW5CLGtCQUFrQmhPLEdBQUcsRUFBRXJILE1BQU0sRUFBRTtRQUMzQixNQUFNc1YsWUFBWXRWLFNBQVN0USxPQUFPd0IsTUFBTSxDQUFDLENBQUMsR0FBRzhPLFVBQVUsQ0FBQztRQUN4RCxNQUFNdVYsZUFBZUMsS0FBS0MsR0FBRyxHQUFHQyxRQUFRO1FBQ3hDLElBQUksQ0FBQ0osVUFBVUssV0FBVyxFQUFFO1lBQ3hCTCxVQUFVSyxXQUFXLEdBQUcsaUJBQThCLE9BQWJKO1FBQzdDO1FBQ0EsSUFBSUQsVUFBVXROLElBQUksS0FBSzlaLFdBQVc7WUFDOUIsTUFBTXNaLFNBQVMsSUFBSSxDQUFDMk4sU0FBUyxDQUFDOU47WUFDOUIsTUFBTUksY0FBYyxJQUFJLENBQUMyTixjQUFjLENBQUMvTjtZQUN4QyxJQUFJRyxRQUFRO2dCQUNSLElBQUlBLE9BQU9sWCxRQUFRLENBQUMsV0FBVztvQkFDM0IsZ0RBQWdEO29CQUNoRGdsQixVQUFVdE4sSUFBSSxHQUFHLEdBQXVCLE9BQXBCUixPQUFPaFgsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFHO2dCQUM1QyxPQUNLO29CQUNELDhCQUE4QjtvQkFDOUI4a0IsVUFBVXROLElBQUksR0FBRyxHQUFrQnVOLE9BQWYvTixRQUFPLFVBQXFCLE9BQWIrTjtnQkFDdkM7WUFDSixPQUNLLElBQUk5TixhQUFhO2dCQUNsQjZOLFVBQVV0TixJQUFJLEdBQUcsR0FBdUJ1TixPQUFwQjlOLGFBQVksVUFBcUIsT0FBYjhOO1lBQzVDLE9BQ0s7Z0JBQ0QsTUFBTSxJQUFJdmxCLE1BQU07WUFDcEI7UUFDSjtRQUNBLE9BQU9zbEI7SUFDWDtJQUNBOzs7Ozs7S0FNQyxHQUNELE1BQU1NLGVBQWU5QyxNQUFNLEVBQUU7UUFDekIsSUFBSWhrQixJQUFJQyxJQUFJbU4sSUFBSUM7UUFDaEIsSUFBSTlCO1FBQ0osSUFBSXFhLE9BQU87UUFDWCxJQUFJbUIsY0FBYyxDQUFDO1FBQ25CLElBQUksSUFBSSxDQUFDeFUsU0FBUyxDQUFDRyxVQUFVLElBQUk7WUFDN0IsTUFBTWdULE9BQU8vSCxpQ0FBaUMsSUFBSSxDQUFDcEwsU0FBUyxFQUFFeVI7WUFDOUQ0QixPQUFPdmxCLFVBQVUsdUJBQXVCcWxCLElBQUksQ0FBQyxPQUFPO1lBQ3BEcUIsY0FBY3JCLElBQUksQ0FBQyxTQUFTO1lBQzVCLE9BQU9BLElBQUksQ0FBQyxPQUFPO1lBQ25CLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCbmEsV0FBVyxJQUFJLENBQUNnSCxTQUFTLENBQ3BCZ1QsT0FBTyxDQUFDO2dCQUNUSyxNQUFNQTtnQkFDTm1CLGFBQWFBO2dCQUNickIsTUFBTXNCLEtBQUtDLFNBQVMsQ0FBQ3ZCO2dCQUNyQndCLFlBQVk7Z0JBQ1p0bkIsYUFBYSxDQUFDSSxLQUFLZ2tCLE9BQU85UyxNQUFNLE1BQU0sUUFBUWxSLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0osV0FBVztnQkFDckZ1bkIsYUFBYSxDQUFDbG5CLEtBQUsrakIsT0FBTzlTLE1BQU0sTUFBTSxRQUFRalIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHa25CLFdBQVc7WUFDekYsR0FDS0MsSUFBSSxDQUFDLENBQUNDO2dCQUNQLE9BQU9BLGFBQWF6YSxJQUFJO1lBQzVCO1lBQ0EsT0FBT3JCLFNBQVM2YixJQUFJLENBQUMsQ0FBQy9YO2dCQUNsQixNQUFNaVksT0FBTzlMLG1CQUFtQm5NO2dCQUNoQyxPQUFPaVk7WUFDWDtRQUNKLE9BQ0s7WUFDRCxNQUFNNUIsT0FBT2pJLGdDQUFnQyxJQUFJLENBQUNsTCxTQUFTLEVBQUV5UjtZQUM3RDRCLE9BQU92bEIsVUFBVSxnQ0FBZ0NxbEIsSUFBSSxDQUFDLE9BQU87WUFDN0RxQixjQUFjckIsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJuYSxXQUFXLElBQUksQ0FBQ2dILFNBQVMsQ0FDcEJnVCxPQUFPLENBQUM7Z0JBQ1RLLE1BQU1BO2dCQUNObUIsYUFBYUE7Z0JBQ2JyQixNQUFNc0IsS0FBS0MsU0FBUyxDQUFDdkI7Z0JBQ3JCd0IsWUFBWTtnQkFDWnRuQixhQUFhLENBQUN3TixLQUFLNFcsT0FBTzlTLE1BQU0sTUFBTSxRQUFROUQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHeE4sV0FBVztnQkFDckZ1bkIsYUFBYSxDQUFDOVosS0FBSzJXLE9BQU85UyxNQUFNLE1BQU0sUUFBUTdELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzhaLFdBQVc7WUFDekYsR0FDS0MsSUFBSSxDQUFDLENBQUNDO2dCQUNQLE9BQU9BLGFBQWF6YSxJQUFJO1lBQzVCO1lBQ0EsT0FBT3JCLFNBQVM2YixJQUFJLENBQUMsQ0FBQy9YO2dCQUNsQixNQUFNaVksT0FBT3RNLGtCQUFrQjNMO2dCQUMvQixPQUFPaVk7WUFDWDtRQUNKO0lBQ0o7SUFDQTs7Ozs7O0tBTUMsR0FDRCxNQUFNQyx5QkFBeUJ2RCxNQUFNLEVBQUU7UUFDbkMsSUFBSWhrQixJQUFJQztRQUNSLElBQUlzTDtRQUNKLElBQUlxYSxPQUFPO1FBQ1gsSUFBSW1CLGNBQWMsQ0FBQztRQUNuQixJQUFJLElBQUksQ0FBQ3hVLFNBQVMsQ0FBQ0csVUFBVSxJQUFJO1lBQzdCLE1BQU0sSUFBSXhSLE1BQU07UUFDcEIsT0FDSztZQUNELE1BQU13a0IsT0FBTzdILDBDQUEwQyxJQUFJLENBQUN0TCxTQUFTLEVBQUV5UjtZQUN2RTRCLE9BQU92bEIsVUFBVSxrQ0FBa0NxbEIsSUFBSSxDQUFDLE9BQU87WUFDL0RxQixjQUFjckIsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJuYSxXQUFXLElBQUksQ0FBQ2dILFNBQVMsQ0FDcEJnVCxPQUFPLENBQUM7Z0JBQ1RLLE1BQU1BO2dCQUNObUIsYUFBYUE7Z0JBQ2JyQixNQUFNc0IsS0FBS0MsU0FBUyxDQUFDdkI7Z0JBQ3JCd0IsWUFBWTtnQkFDWnRuQixhQUFhLENBQUNJLEtBQUtna0IsT0FBTzlTLE1BQU0sTUFBTSxRQUFRbFIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSixXQUFXO2dCQUNyRnVuQixhQUFhLENBQUNsbkIsS0FBSytqQixPQUFPOVMsTUFBTSxNQUFNLFFBQVFqUixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdrbkIsV0FBVztZQUN6RixHQUNLQyxJQUFJLENBQUMsQ0FBQ0M7Z0JBQ1AsT0FBT0EsYUFBYXphLElBQUk7WUFDNUI7WUFDQSxPQUFPckIsU0FBUzZiLElBQUksQ0FBQyxDQUFDL1g7Z0JBQ2xCLE1BQU1pWSxPQUFPdE0sa0JBQWtCM0w7Z0JBQy9CLE9BQU9pWTtZQUNYO1FBQ0o7SUFDSjtJQUNBOzs7Ozs7Ozs7O0tBVUMsR0FDRCxNQUFNRSxJQUFJeEQsTUFBTSxFQUFFO1FBQ2QsSUFBSWhrQixJQUFJQyxJQUFJbU4sSUFBSUM7UUFDaEIsSUFBSTlCO1FBQ0osSUFBSXFhLE9BQU87UUFDWCxJQUFJbUIsY0FBYyxDQUFDO1FBQ25CLElBQUksSUFBSSxDQUFDeFUsU0FBUyxDQUFDRyxVQUFVLElBQUk7WUFDN0IsTUFBTWdULE9BQU9yRSw4QkFBOEIsSUFBSSxDQUFDOU8sU0FBUyxFQUFFeVI7WUFDM0Q0QixPQUFPdmxCLFVBQVUsOEJBQThCcWxCLElBQUksQ0FBQyxPQUFPO1lBQzNEcUIsY0FBY3JCLElBQUksQ0FBQyxTQUFTO1lBQzVCLE9BQU9BLElBQUksQ0FBQyxPQUFPO1lBQ25CLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCbmEsV0FBVyxJQUFJLENBQUNnSCxTQUFTLENBQ3BCZ1QsT0FBTyxDQUFDO2dCQUNUSyxNQUFNQTtnQkFDTm1CLGFBQWFBO2dCQUNickIsTUFBTXNCLEtBQUtDLFNBQVMsQ0FBQ3ZCO2dCQUNyQndCLFlBQVk7Z0JBQ1p0bkIsYUFBYSxDQUFDSSxLQUFLZ2tCLE9BQU85UyxNQUFNLE1BQU0sUUFBUWxSLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0osV0FBVztnQkFDckZ1bkIsYUFBYSxDQUFDbG5CLEtBQUsrakIsT0FBTzlTLE1BQU0sTUFBTSxRQUFRalIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHa25CLFdBQVc7WUFDekYsR0FDS0MsSUFBSSxDQUFDLENBQUNDO2dCQUNQLE9BQU9BLGFBQWF6YSxJQUFJO1lBQzVCO1lBQ0EsT0FBT3JCLFNBQVM2YixJQUFJLENBQUMsQ0FBQy9YO2dCQUNsQixNQUFNaVksT0FBTzlMLG1CQUFtQm5NO2dCQUNoQyxPQUFPaVk7WUFDWDtRQUNKLE9BQ0s7WUFDRCxNQUFNNUIsT0FBT3RFLDZCQUE2QixJQUFJLENBQUM3TyxTQUFTLEVBQUV5UjtZQUMxRDRCLE9BQU92bEIsVUFBVSxrQkFBa0JxbEIsSUFBSSxDQUFDLE9BQU87WUFDL0NxQixjQUFjckIsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJuYSxXQUFXLElBQUksQ0FBQ2dILFNBQVMsQ0FDcEJnVCxPQUFPLENBQUM7Z0JBQ1RLLE1BQU1BO2dCQUNObUIsYUFBYUE7Z0JBQ2JyQixNQUFNc0IsS0FBS0MsU0FBUyxDQUFDdkI7Z0JBQ3JCd0IsWUFBWTtnQkFDWnRuQixhQUFhLENBQUN3TixLQUFLNFcsT0FBTzlTLE1BQU0sTUFBTSxRQUFROUQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHeE4sV0FBVztnQkFDckZ1bkIsYUFBYSxDQUFDOVosS0FBSzJXLE9BQU85UyxNQUFNLE1BQU0sUUFBUTdELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzhaLFdBQVc7WUFDekYsR0FDS0MsSUFBSSxDQUFDLENBQUNDO2dCQUNQLE9BQU9BLGFBQWF6YSxJQUFJO1lBQzVCO1lBQ0EsT0FBT3JCLFNBQVM2YixJQUFJLENBQUMsQ0FBQy9YO2dCQUNsQixNQUFNaVksT0FBT3RNLGtCQUFrQjNMO2dCQUMvQixPQUFPaVk7WUFDWDtRQUNKO0lBQ0o7SUFDQTs7Ozs7Ozs7OztLQVVDLEdBQ0QsTUFBTUcsT0FBT3pELE1BQU0sRUFBRTtRQUNqQixJQUFJaGtCLElBQUlDLElBQUltTixJQUFJQztRQUNoQixJQUFJdVksT0FBTztRQUNYLElBQUltQixjQUFjLENBQUM7UUFDbkIsSUFBSSxJQUFJLENBQUN4VSxTQUFTLENBQUNHLFVBQVUsSUFBSTtZQUM3QixNQUFNZ1QsT0FBT3RKLGlDQUFpQyxJQUFJLENBQUM3SixTQUFTLEVBQUV5UjtZQUM5RDRCLE9BQU92bEIsVUFBVSxxQ0FBcUNxbEIsSUFBSSxDQUFDLE9BQU87WUFDbEVxQixjQUFjckIsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckIsTUFBTSxJQUFJLENBQUNuVCxTQUFTLENBQUNnVCxPQUFPLENBQUM7Z0JBQ3pCSyxNQUFNQTtnQkFDTm1CLGFBQWFBO2dCQUNickIsTUFBTXNCLEtBQUtDLFNBQVMsQ0FBQ3ZCO2dCQUNyQndCLFlBQVk7Z0JBQ1p0bkIsYUFBYSxDQUFDSSxLQUFLZ2tCLE9BQU85UyxNQUFNLE1BQU0sUUFBUWxSLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0osV0FBVztnQkFDckZ1bkIsYUFBYSxDQUFDbG5CLEtBQUsrakIsT0FBTzlTLE1BQU0sTUFBTSxRQUFRalIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHa25CLFdBQVc7WUFDekY7UUFDSixPQUNLO1lBQ0QsTUFBTXpCLE9BQU92SixnQ0FBZ0MsSUFBSSxDQUFDNUosU0FBUyxFQUFFeVI7WUFDN0Q0QixPQUFPdmxCLFVBQVUseUJBQXlCcWxCLElBQUksQ0FBQyxPQUFPO1lBQ3REcUIsY0FBY3JCLElBQUksQ0FBQyxTQUFTO1lBQzVCLE9BQU9BLElBQUksQ0FBQyxPQUFPO1lBQ25CLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCLE1BQU0sSUFBSSxDQUFDblQsU0FBUyxDQUFDZ1QsT0FBTyxDQUFDO2dCQUN6QkssTUFBTUE7Z0JBQ05tQixhQUFhQTtnQkFDYnJCLE1BQU1zQixLQUFLQyxTQUFTLENBQUN2QjtnQkFDckJ3QixZQUFZO2dCQUNadG5CLGFBQWEsQ0FBQ3dOLEtBQUs0VyxPQUFPOVMsTUFBTSxNQUFNLFFBQVE5RCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUd4TixXQUFXO2dCQUNyRnVuQixhQUFhLENBQUM5WixLQUFLMlcsT0FBTzlTLE1BQU0sTUFBTSxRQUFRN0QsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHOFosV0FBVztZQUN6RjtRQUNKO0lBQ0o7SUFDQSxNQUFNTyxhQUFhMUQsTUFBTSxFQUFFO1FBQ3ZCLElBQUloa0IsSUFBSUMsSUFBSW1OLElBQUlDO1FBQ2hCLElBQUk5QjtRQUNKLElBQUlxYSxPQUFPO1FBQ1gsSUFBSW1CLGNBQWMsQ0FBQztRQUNuQixJQUFJLElBQUksQ0FBQ3hVLFNBQVMsQ0FBQ0csVUFBVSxJQUFJO1lBQzdCLE1BQU1nVCxPQUFPeEQsZ0NBQWdDOEI7WUFDN0M0QixPQUFPdmxCLFVBQVUsdUJBQXVCcWxCLElBQUksQ0FBQyxPQUFPO1lBQ3BEcUIsY0FBY3JCLElBQUksQ0FBQyxTQUFTO1lBQzVCLE9BQU9BLElBQUksQ0FBQyxPQUFPO1lBQ25CLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCbmEsV0FBVyxJQUFJLENBQUNnSCxTQUFTLENBQ3BCZ1QsT0FBTyxDQUFDO2dCQUNUSyxNQUFNQTtnQkFDTm1CLGFBQWFBO2dCQUNickIsTUFBTXNCLEtBQUtDLFNBQVMsQ0FBQ3ZCO2dCQUNyQndCLFlBQVk7Z0JBQ1p0bkIsYUFBYSxDQUFDSSxLQUFLZ2tCLE9BQU85UyxNQUFNLE1BQU0sUUFBUWxSLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0osV0FBVztnQkFDckZ1bkIsYUFBYSxDQUFDbG5CLEtBQUsrakIsT0FBTzlTLE1BQU0sTUFBTSxRQUFRalIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHa25CLFdBQVc7WUFDekYsR0FDS0MsSUFBSSxDQUFDLENBQUNDO2dCQUNQLE9BQU9BLGFBQWF6YSxJQUFJLEdBQUd3YSxJQUFJLENBQUMsQ0FBQ087b0JBQzdCLE1BQU1wYyxXQUFXb2M7b0JBQ2pCcGMsU0FBUzZZLGVBQWUsR0FBRzt3QkFDdkJyWCxTQUFTc2EsYUFBYXRhLE9BQU87b0JBQ2pDO29CQUNBLE9BQU94QjtnQkFDWDtZQUNKO1lBQ0EsT0FBT0EsU0FBUzZiLElBQUksQ0FBQyxDQUFDL1g7Z0JBQ2xCLE1BQU1pWSxPQUFPaEYsZ0NBQWdDalQ7Z0JBQzdDLE1BQU11WSxZQUFZLElBQUlwWDtnQkFDdEI1UCxPQUFPd0IsTUFBTSxDQUFDd2xCLFdBQVdOO2dCQUN6QixPQUFPTTtZQUNYO1FBQ0osT0FDSztZQUNELE1BQU1sQyxPQUFPekQsK0JBQStCK0I7WUFDNUM0QixPQUFPdmxCLFVBQVUsV0FBV3FsQixJQUFJLENBQUMsT0FBTztZQUN4Q3FCLGNBQWNyQixJQUFJLENBQUMsU0FBUztZQUM1QixPQUFPQSxJQUFJLENBQUMsT0FBTztZQUNuQixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQm5hLFdBQVcsSUFBSSxDQUFDZ0gsU0FBUyxDQUNwQmdULE9BQU8sQ0FBQztnQkFDVEssTUFBTUE7Z0JBQ05tQixhQUFhQTtnQkFDYnJCLE1BQU1zQixLQUFLQyxTQUFTLENBQUN2QjtnQkFDckJ3QixZQUFZO2dCQUNadG5CLGFBQWEsQ0FBQ3dOLEtBQUs0VyxPQUFPOVMsTUFBTSxNQUFNLFFBQVE5RCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUd4TixXQUFXO2dCQUNyRnVuQixhQUFhLENBQUM5WixLQUFLMlcsT0FBTzlTLE1BQU0sTUFBTSxRQUFRN0QsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHOFosV0FBVztZQUN6RixHQUNLQyxJQUFJLENBQUMsQ0FBQ0M7Z0JBQ1AsT0FBT0EsYUFBYXphLElBQUksR0FBR3dhLElBQUksQ0FBQyxDQUFDTztvQkFDN0IsTUFBTXBjLFdBQVdvYztvQkFDakJwYyxTQUFTNlksZUFBZSxHQUFHO3dCQUN2QnJYLFNBQVNzYSxhQUFhdGEsT0FBTztvQkFDakM7b0JBQ0EsT0FBT3hCO2dCQUNYO1lBQ0o7WUFDQSxPQUFPQSxTQUFTNmIsSUFBSSxDQUFDLENBQUMvWDtnQkFDbEIsTUFBTWlZLE9BQU9uRiwrQkFBK0I5UztnQkFDNUMsTUFBTXVZLFlBQVksSUFBSXBYO2dCQUN0QjVQLE9BQU93QixNQUFNLENBQUN3bEIsV0FBV047Z0JBQ3pCLE9BQU9NO1lBQ1g7UUFDSjtJQUNKO0lBQ0E7Ozs7Ozs7Ozs7S0FVQyxHQUNELE1BQU1DLE9BQU83RCxNQUFNLEVBQUU7UUFDakIsSUFBSWhrQixJQUFJQyxJQUFJbU4sSUFBSUM7UUFDaEIsSUFBSTlCO1FBQ0osSUFBSXFhLE9BQU87UUFDWCxJQUFJbUIsY0FBYyxDQUFDO1FBQ25CLElBQUksSUFBSSxDQUFDeFUsU0FBUyxDQUFDRyxVQUFVLElBQUk7WUFDN0IsTUFBTWdULE9BQU8xSCxpQ0FBaUMsSUFBSSxDQUFDekwsU0FBUyxFQUFFeVI7WUFDOUQ0QixPQUFPdmxCLFVBQVUsOEJBQThCcWxCLElBQUksQ0FBQyxPQUFPO1lBQzNEcUIsY0FBY3JCLElBQUksQ0FBQyxTQUFTO1lBQzVCLE9BQU9BLElBQUksQ0FBQyxPQUFPO1lBQ25CLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCbmEsV0FBVyxJQUFJLENBQUNnSCxTQUFTLENBQ3BCZ1QsT0FBTyxDQUFDO2dCQUNUSyxNQUFNQTtnQkFDTm1CLGFBQWFBO2dCQUNickIsTUFBTXNCLEtBQUtDLFNBQVMsQ0FBQ3ZCO2dCQUNyQndCLFlBQVk7Z0JBQ1p0bkIsYUFBYSxDQUFDSSxLQUFLZ2tCLE9BQU85UyxNQUFNLE1BQU0sUUFBUWxSLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0osV0FBVztnQkFDckZ1bkIsYUFBYSxDQUFDbG5CLEtBQUsrakIsT0FBTzlTLE1BQU0sTUFBTSxRQUFRalIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHa25CLFdBQVc7WUFDekYsR0FDS0MsSUFBSSxDQUFDLENBQUNDO2dCQUNQLE9BQU9BLGFBQWF6YSxJQUFJLEdBQUd3YSxJQUFJLENBQUMsQ0FBQ087b0JBQzdCLE1BQU1wYyxXQUFXb2M7b0JBQ2pCcGMsU0FBUzZZLGVBQWUsR0FBRzt3QkFDdkJyWCxTQUFTc2EsYUFBYXRhLE9BQU87b0JBQ2pDO29CQUNBLE9BQU94QjtnQkFDWDtZQUNKO1lBQ0EsT0FBT0EsU0FBUzZiLElBQUksQ0FBQyxDQUFDL1g7Z0JBQ2xCLE1BQU1pWSxPQUFPcEosNEJBQTRCN087Z0JBQ3pDLE9BQU9pWTtZQUNYO1FBQ0osT0FDSztZQUNELE1BQU01QixPQUFPM0gsZ0NBQWdDLElBQUksQ0FBQ3hMLFNBQVMsRUFBRXlSO1lBQzdENEIsT0FBT3ZsQixVQUFVLGtCQUFrQnFsQixJQUFJLENBQUMsT0FBTztZQUMvQ3FCLGNBQWNyQixJQUFJLENBQUMsU0FBUztZQUM1QixPQUFPQSxJQUFJLENBQUMsT0FBTztZQUNuQixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQm5hLFdBQVcsSUFBSSxDQUFDZ0gsU0FBUyxDQUNwQmdULE9BQU8sQ0FBQztnQkFDVEssTUFBTUE7Z0JBQ05tQixhQUFhQTtnQkFDYnJCLE1BQU1zQixLQUFLQyxTQUFTLENBQUN2QjtnQkFDckJ3QixZQUFZO2dCQUNadG5CLGFBQWEsQ0FBQ3dOLEtBQUs0VyxPQUFPOVMsTUFBTSxNQUFNLFFBQVE5RCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUd4TixXQUFXO2dCQUNyRnVuQixhQUFhLENBQUM5WixLQUFLMlcsT0FBTzlTLE1BQU0sTUFBTSxRQUFRN0QsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHOFosV0FBVztZQUN6RixHQUNLQyxJQUFJLENBQUMsQ0FBQ0M7Z0JBQ1AsT0FBT0EsYUFBYXphLElBQUksR0FBR3dhLElBQUksQ0FBQyxDQUFDTztvQkFDN0IsTUFBTXBjLFdBQVdvYztvQkFDakJwYyxTQUFTNlksZUFBZSxHQUFHO3dCQUN2QnJYLFNBQVNzYSxhQUFhdGEsT0FBTztvQkFDakM7b0JBQ0EsT0FBT3hCO2dCQUNYO1lBQ0o7WUFDQSxPQUFPQSxTQUFTNmIsSUFBSSxDQUFDLENBQUMvWDtnQkFDbEIsTUFBTWlZLE9BQU9ySiwyQkFBMkI1TztnQkFDeEMsT0FBT2lZO1lBQ1g7UUFDSjtJQUNKO0lBL2VBeGEsWUFBWXlGLFNBQVMsQ0FBRTs7UUFDbkIsS0FBSztRQUNMLElBQUksQ0FBQ0EsU0FBUyxHQUFHQTtRQUNqQjs7Ozs7Ozs7Ozs7OztTQWFDLEdBQ0QsSUFBSSxDQUFDdVYsSUFBSSxHQUFHO2dCQUFPOUQsMEVBQVMsQ0FBQztZQUN6QixPQUFPLElBQUlGLE1BQU1ELFVBQVVrRSxxQkFBcUIsRUFBRSxDQUFDQyxJQUFNLE1BQUtOLFlBQVksQ0FBQ00sSUFBSSxNQUFNLE1BQUtOLFlBQVksQ0FBQzFELFNBQVNBO1FBQ3BIO1FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O1NBaUJDLEdBQ0QsSUFBSSxDQUFDaUUsTUFBTSxHQUFHLE9BQU9qRTtZQUNqQixJQUFJLElBQUksQ0FBQ3pSLFNBQVMsQ0FBQ0csVUFBVSxJQUFJO2dCQUM3QixxQ0FBcUM7Z0JBQ3JDLHFFQUFxRTtnQkFDckVzUixPQUFPOVMsTUFBTSxHQUFHLElBQUksQ0FBQ3FWLGlCQUFpQixDQUFDdkMsT0FBT3pMLEdBQUcsRUFBRXlMLE9BQU85UyxNQUFNO1lBQ3BFO1lBQ0EsT0FBTyxJQUFJLENBQUM0VixjQUFjLENBQUM5QztRQUMvQjtRQUNBOzs7Ozs7Ozs7Ozs7OztTQWNDLEdBQ0QsSUFBSSxDQUFDa0UsZ0JBQWdCLEdBQUcsT0FBT2xFO1lBQzNCcFcsUUFBUUMsSUFBSSxDQUFDO1lBQ2IsSUFBSSxJQUFJLENBQUMwRSxTQUFTLENBQUNHLFVBQVUsSUFBSTtnQkFDN0IsTUFBTSxJQUFJeFIsTUFBTTtZQUNwQjtZQUNBLE9BQU8sSUFBSSxDQUFDcW1CLHdCQUF3QixDQUFDdkQ7UUFDekM7SUFDSjtBQTRhSjtBQUVBOzs7O0NBSUMsR0FDRCxTQUFTbUUsY0FBYzNqQixVQUFVO0lBQzdCLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNeVgsV0FBVzVaLGVBQWVrQyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJMFgsWUFBWSxNQUFNO1FBQ2xCL2EsZUFBZXNELFVBQVU7WUFBQztTQUFPLEVBQUV5WDtJQUN2QztJQUNBLElBQUk1WixlQUFla0MsWUFBWTtRQUFDO0tBQWMsTUFBTXBGLFdBQVc7UUFDM0QsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE1BQU11RixlQUFlbkUsZUFBZWtDLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlpQyxnQkFBZ0IsTUFBTTtRQUN0QnRGLGVBQWVzRCxVQUFVO1lBQUM7U0FBVyxFQUFFZ0M7SUFDM0M7SUFDQSxPQUFPaEM7QUFDWDtBQUNBLFNBQVMyakIsaUJBQWlCNWpCLFVBQVU7SUFDaEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU0wWSxZQUFZN2EsZUFBZWtDLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUkyWSxhQUFhLE1BQU07UUFDbkIsSUFBSTdYLGtCQUFrQjZYO1FBQ3RCLElBQUl4YixNQUFNQyxPQUFPLENBQUMwRCxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCOUMsR0FBRyxDQUFDLENBQUNrQjtnQkFDbkMsT0FBTzJrQixjQUFjM2tCO1lBQ3pCO1FBQ0o7UUFDQXZDLGVBQWVzRCxVQUFVO1lBQUM7U0FBUSxFQUFFYTtJQUN4QztJQUNBLE1BQU0rWCxXQUFXL2EsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUk2WSxZQUFZLE1BQU07UUFDbEJsYyxlQUFlc0QsVUFBVTtZQUFDO1NBQU8sRUFBRTRZO0lBQ3ZDO0lBQ0EsT0FBTzVZO0FBQ1g7QUFDQSxTQUFTNmpCLGlDQUFpQzlqQixVQUFVLEVBQUUrWSxZQUFZO0lBQzlELE1BQU05WSxXQUFXLENBQUM7SUFDbEIsTUFBTThqQixVQUFVam1CLGVBQWVrQyxZQUFZO1FBQUM7S0FBTTtJQUNsRCxJQUFJK1ksaUJBQWlCbmUsYUFBYW1wQixXQUFXLE1BQU07UUFDL0NwbkIsZUFBZW9jLGNBQWM7WUFBQztTQUFNLEVBQUVnTDtJQUMxQztJQUNBLE1BQU1DLGlCQUFpQmxtQixlQUFla0MsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSStZLGlCQUFpQm5lLGFBQWFvcEIsa0JBQWtCLE1BQU07UUFDdERybkIsZUFBZW9jLGNBQWM7WUFBQztTQUFhLEVBQUVpTDtJQUNqRDtJQUNBLE1BQU12TixrQkFBa0IzWSxlQUFla0MsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSStZLGlCQUFpQm5lLGFBQWE2YixtQkFBbUIsTUFBTTtRQUN2RDlaLGVBQWVvYyxjQUFjO1lBQUM7U0FBYyxFQUFFdEM7SUFDbEQ7SUFDQSxNQUFNbUQsZUFBZTliLGVBQWVrQyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJK1ksaUJBQWlCbmUsYUFBYWdmLGdCQUFnQixNQUFNO1FBQ3BELElBQUk5WSxrQkFBa0IwTyxVQUFVb0s7UUFDaEMsSUFBSXpjLE1BQU1DLE9BQU8sQ0FBQzBELGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0I5QyxHQUFHLENBQUMsQ0FBQ2tCO2dCQUNuQyxPQUFPMGtCLGlCQUFpQjFrQjtZQUM1QjtRQUNKO1FBQ0F2QyxlQUFlb2MsY0FBYztZQUFDO1NBQVcsRUFBRWpZO0lBQy9DO0lBQ0EsTUFBTTRaLHdCQUF3QjVjLGVBQWVrQyxZQUFZO1FBQ3JEO0tBQ0g7SUFDRCxJQUFJK1ksaUJBQWlCbmUsYUFBYThmLHlCQUF5QixNQUFNO1FBQzdEL2QsZUFBZW9jLGNBQWM7WUFBQztTQUFvQixFQUFFNkssaUJBQWlCdlUsU0FBU3FMO0lBQ2xGO0lBQ0EsTUFBTWlCLFlBQVk3ZCxlQUFla0MsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSStZLGlCQUFpQm5lLGFBQWErZ0IsYUFBYSxNQUFNO1FBQ2pELElBQUk3YSxrQkFBa0I2YTtRQUN0QixJQUFJeGUsTUFBTUMsT0FBTyxDQUFDMEQsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQjlDLEdBQUcsQ0FBQyxDQUFDa0I7Z0JBQ25DLE9BQU8ra0IsY0FBYy9rQjtZQUN6QjtRQUNKO1FBQ0F2QyxlQUFlb2MsY0FBYztZQUFDO1NBQVEsRUFBRWpZO0lBQzVDO0lBQ0EsTUFBTSthLGlCQUFpQi9kLGVBQWVrQyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJK1ksaUJBQWlCbmUsYUFBYWloQixrQkFBa0IsTUFBTTtRQUN0RGxmLGVBQWVvYyxjQUFjO1lBQUM7U0FBYSxFQUFFbUwsb0JBQW9Cckk7SUFDckU7SUFDQSxJQUFJL2QsZUFBZWtDLFlBQVk7UUFBQztLQUFhLE1BQU1wRixXQUFXO1FBQzFELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxPQUFPdUQ7QUFDWDtBQUNBLFNBQVNra0Isa0NBQWtDbmtCLFVBQVUsRUFBRStZLFlBQVk7SUFDL0QsTUFBTTlZLFdBQVcsQ0FBQztJQUNsQixNQUFNOGpCLFVBQVVqbUIsZUFBZWtDLFlBQVk7UUFBQztLQUFNO0lBQ2xELElBQUkrWSxpQkFBaUJuZSxhQUFhbXBCLFdBQVcsTUFBTTtRQUMvQ3BuQixlQUFlb2MsY0FBYztZQUFDO1NBQU0sRUFBRWdMO0lBQzFDO0lBQ0EsTUFBTUMsaUJBQWlCbG1CLGVBQWVrQyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJK1ksaUJBQWlCbmUsYUFBYW9wQixrQkFBa0IsTUFBTTtRQUN0RHJuQixlQUFlb2MsY0FBYztZQUFDO1NBQWEsRUFBRWlMO0lBQ2pEO0lBQ0EsTUFBTXZOLGtCQUFrQjNZLGVBQWVrQyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJK1ksaUJBQWlCbmUsYUFBYTZiLG1CQUFtQixNQUFNO1FBQ3ZEOVosZUFBZW9jLGNBQWM7WUFBQztTQUFjLEVBQUV0QztJQUNsRDtJQUNBLE1BQU1tRCxlQUFlOWIsZUFBZWtDLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUkrWSxpQkFBaUJuZSxhQUFhZ2YsZ0JBQWdCLE1BQU07UUFDcEQsSUFBSTlZLGtCQUFrQjBPLFVBQVVvSztRQUNoQyxJQUFJemMsTUFBTUMsT0FBTyxDQUFDMEQsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQjlDLEdBQUcsQ0FBQyxDQUFDa0I7Z0JBQ25DLE9BQU9BO1lBQ1g7UUFDSjtRQUNBdkMsZUFBZW9jLGNBQWM7WUFBQztTQUFXLEVBQUVqWTtJQUMvQztJQUNBLE1BQU00Wix3QkFBd0I1YyxlQUFla0MsWUFBWTtRQUNyRDtLQUNIO0lBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWE4Zix5QkFBeUIsTUFBTTtRQUM3RC9kLGVBQWVvYyxjQUFjO1lBQUM7U0FBb0IsRUFBRTFKLFNBQVNxTDtJQUNqRTtJQUNBLE1BQU1pQixZQUFZN2QsZUFBZWtDLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUkrWSxpQkFBaUJuZSxhQUFhK2dCLGFBQWEsTUFBTTtRQUNqRCxJQUFJN2Esa0JBQWtCNmE7UUFDdEIsSUFBSXhlLE1BQU1DLE9BQU8sQ0FBQzBELGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0I5QyxHQUFHLENBQUMsQ0FBQ2tCO2dCQUNuQyxPQUFPa2xCLGVBQWVsbEI7WUFDMUI7UUFDSjtRQUNBdkMsZUFBZW9jLGNBQWM7WUFBQztTQUFRLEVBQUVqWTtJQUM1QztJQUNBLE1BQU0rYSxpQkFBaUIvZCxlQUFla0MsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSStZLGlCQUFpQm5lLGFBQWFpaEIsa0JBQWtCLE1BQU07UUFDdERsZixlQUFlb2MsY0FBYztZQUFDO1NBQWEsRUFBRThDO0lBQ2pEO0lBQ0EsTUFBTXdJLGlCQUFpQnZtQixlQUFla0MsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSStZLGlCQUFpQm5lLGFBQWF5cEIsa0JBQWtCLE1BQU07UUFDdEQxbkIsZUFBZW9jLGNBQWM7WUFBQztZQUFtQjtTQUFhLEVBQUVzTDtJQUNwRTtJQUNBLE9BQU9wa0I7QUFDWDtBQUNBLFNBQVNxa0IscUNBQXFDdlcsU0FBUyxFQUFFL04sVUFBVTtJQUMvRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTTZXLFlBQVloWixlQUFla0MsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSThXLGFBQWEsTUFBTTtRQUNuQm5hLGVBQWVzRCxVQUFVO1lBQUM7U0FBUSxFQUFFbU8sYUFBYUwsV0FBVytJO0lBQ2hFO0lBQ0EsTUFBTW9DLGFBQWFwYixlQUFla0MsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSWtaLGNBQWMsTUFBTTtRQUNwQjRLLGlDQUFpQzVLLFlBQVlqWjtJQUNqRDtJQUNBLE9BQU9BO0FBQ1g7QUFDQSxTQUFTc2tCLHNDQUFzQ3hXLFNBQVMsRUFBRS9OLFVBQVU7SUFDaEUsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU02VyxZQUFZaFosZUFBZWtDLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUk4VyxhQUFhLE1BQU07UUFDbkJuYSxlQUFlc0QsVUFBVTtZQUFDO1NBQVEsRUFBRW1PLGFBQWFMLFdBQVcrSTtJQUNoRTtJQUNBLE1BQU1vQyxhQUFhcGIsZUFBZWtDLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlrWixjQUFjLE1BQU07UUFDcEJpTCxrQ0FBa0NqTCxZQUFZalo7SUFDbEQ7SUFDQSxPQUFPQTtBQUNYO0FBQ0EsU0FBU3VrQixxQ0FBcUN6VyxTQUFTLEVBQUUvTixVQUFVO0lBQy9ELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNSSxXQUFXdkMsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlLLFlBQVksTUFBTTtRQUNsQjFELGVBQWVzRCxVQUFVO1lBQUM7WUFBUTtTQUFPLEVBQUVtUyxtQkFBbUJyRSxXQUFXMU47SUFDN0U7SUFDQSxPQUFPSjtBQUNYO0FBQ0EsU0FBU3drQixzQ0FBc0MxVyxTQUFTLEVBQUUvTixVQUFVO0lBQ2hFLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNSSxXQUFXdkMsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlLLFlBQVksTUFBTTtRQUNsQjFELGVBQWVzRCxVQUFVO1lBQUM7WUFBUTtTQUFPLEVBQUVtUyxtQkFBbUJyRSxXQUFXMU47SUFDN0U7SUFDQSxPQUFPSjtBQUNYO0FBQ0EsU0FBU3lrQixxQ0FBcUMxa0IsVUFBVTtJQUNwRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXlCLHNCQUFzQjVELGVBQWVrQyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJMEIsdUJBQXVCLE1BQU07UUFDN0IvRSxlQUFlc0QsVUFBVTtZQUFDO1NBQWtCLEVBQUV5QjtJQUNsRDtJQUNBLE9BQU96QjtBQUNYO0FBQ0EsU0FBUzBrQixzQ0FBc0Mza0IsVUFBVTtJQUNyRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXlCLHNCQUFzQjVELGVBQWVrQyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJMEIsdUJBQXVCLE1BQU07UUFDN0IvRSxlQUFlc0QsVUFBVTtZQUFDO1NBQWtCLEVBQUV5QjtJQUNsRDtJQUNBLE9BQU96QjtBQUNYO0FBQ0EsU0FBUzJrQixrQkFBa0I1a0IsVUFBVTtJQUNqQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsSUFBSW5DLGVBQWVrQyxZQUFZO1FBQUM7S0FBYyxNQUFNcEYsV0FBVztRQUMzRCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTXdkLGNBQWNwYyxlQUFla0MsWUFBWTtRQUFDO0tBQVU7SUFDMUQsSUFBSWthLGVBQWUsTUFBTTtRQUNyQnZkLGVBQWVzRCxVQUFVO1lBQUM7U0FBVSxFQUFFaWE7SUFDMUM7SUFDQSxNQUFNalksZUFBZW5FLGVBQWVrQyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJaUMsZ0JBQWdCLE1BQU07UUFDdEJ0RixlQUFlc0QsVUFBVTtZQUFDO1NBQVcsRUFBRWdDO0lBQzNDO0lBQ0EsT0FBT2hDO0FBQ1g7QUFDQSxTQUFTNGtCLHNCQUFzQjdrQixVQUFVO0lBQ3JDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNbWEsU0FBU3RjLGVBQWVrQyxZQUFZO1FBQUM7S0FBSztJQUNoRCxJQUFJb2EsVUFBVSxNQUFNO1FBQ2hCemQsZUFBZXNELFVBQVU7WUFBQztTQUFLLEVBQUVtYTtJQUNyQztJQUNBLE1BQU1DLFdBQVd2YyxlQUFla0MsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSXFhLFlBQVksTUFBTTtRQUNsQjFkLGVBQWVzRCxVQUFVO1lBQUM7U0FBTyxFQUFFb2E7SUFDdkM7SUFDQSxNQUFNaGEsV0FBV3ZDLGVBQWVrQyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJSyxZQUFZLE1BQU07UUFDbEIxRCxlQUFlc0QsVUFBVTtZQUFDO1NBQU8sRUFBRUk7SUFDdkM7SUFDQSxJQUFJdkMsZUFBZWtDLFlBQVk7UUFBQztLQUFjLE1BQU1wRixXQUFXO1FBQzNELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxJQUFJb0IsZUFBZWtDLFlBQVk7UUFBQztLQUFlLE1BQU1wRixXQUFXO1FBQzVELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxPQUFPdUQ7QUFDWDtBQUNBLFNBQVM2a0IsK0JBQStCOWtCLFVBQVU7SUFDOUMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1zYSxXQUFXemMsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUl1YSxZQUFZLE1BQU07UUFDbEI1ZCxlQUFlc0QsVUFBVTtZQUFDO1NBQU8sRUFBRXNhO0lBQ3ZDO0lBQ0EsTUFBTUMsMkJBQTJCMWMsZUFBZWtDLFlBQVk7UUFDeEQ7S0FDSDtJQUNELElBQUl3YSw0QkFBNEIsTUFBTTtRQUNsQzdkLGVBQWVzRCxVQUFVO1lBQUM7U0FBdUIsRUFBRXVhO0lBQ3ZEO0lBQ0EsSUFBSTFjLGVBQWVrQyxZQUFZO1FBQUM7S0FBOEIsTUFDMURwRixXQUFXO1FBQ1gsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE9BQU91RDtBQUNYO0FBQ0EsU0FBUzhrQiw4QkFBOEIva0IsVUFBVTtJQUM3QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsSUFBSW5DLGVBQWVrQyxZQUFZO1FBQUM7S0FBVyxNQUFNcEYsV0FBVztRQUN4RCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTXNvQixrQkFBa0JsbkIsZUFBZWtDLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUlnbEIsbUJBQW1CLE1BQU07UUFDekJyb0IsZUFBZXNELFVBQVU7WUFBQztTQUFjLEVBQUUra0I7SUFDOUM7SUFDQSxNQUFNM2tCLFdBQVd2QyxlQUFla0MsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSUssWUFBWSxNQUFNO1FBQ2xCMUQsZUFBZXNELFVBQVU7WUFBQztTQUFPLEVBQUVJO0lBQ3ZDO0lBQ0EsTUFBTTRrQixpQkFBaUJubkIsZUFBZWtDLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUlpbEIsa0JBQWtCLE1BQU07UUFDeEJ0b0IsZUFBZXNELFVBQVU7WUFBQztTQUFhLEVBQUVnbEI7SUFDN0M7SUFDQSxNQUFNQywyQkFBMkJwbkIsZUFBZWtDLFlBQVk7UUFDeEQ7S0FDSDtJQUNELElBQUlrbEIsNEJBQTRCLE1BQU07UUFDbEN2b0IsZUFBZXNELFVBQVU7WUFBQztTQUF1QixFQUFFaWxCO0lBQ3ZEO0lBQ0EsTUFBTXprQixlQUFlM0MsZUFBZWtDLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlTLGdCQUFnQixNQUFNO1FBQ3RCOUQsZUFBZXNELFVBQVU7WUFBQztTQUFXLEVBQUVRO0lBQzNDO0lBQ0EsTUFBTSthLHlCQUF5QjFkLGVBQWVrQyxZQUFZO1FBQ3REO0tBQ0g7SUFDRCxJQUFJd2IsMEJBQTBCLE1BQU07UUFDaEM3ZSxlQUFlc0QsVUFBVTtZQUFDO1NBQXFCLEVBQUV1YjtJQUNyRDtJQUNBLE9BQU92YjtBQUNYO0FBQ0EsU0FBU2tsQixrQ0FBa0NwWCxTQUFTLEVBQUUvTixVQUFVO0lBQzVELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNSSxXQUFXdkMsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlLLFlBQVksTUFBTTtRQUNsQjFELGVBQWVzRCxVQUFVO1lBQUM7WUFBUTtTQUFPLEVBQUVtUyxtQkFBbUJyRSxXQUFXMU47SUFDN0U7SUFDQSxPQUFPSjtBQUNYO0FBQ0EsU0FBU21sQixtQ0FBbUNyWCxTQUFTLEVBQUUvTixVQUFVO0lBQzdELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNSSxXQUFXdkMsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlLLFlBQVksTUFBTTtRQUNsQjFELGVBQWVzRCxVQUFVO1lBQUM7WUFBUTtTQUFPLEVBQUVtUyxtQkFBbUJyRSxXQUFXMU47SUFDN0U7SUFDQSxPQUFPSjtBQUNYO0FBQ0EsU0FBU29sQixvQkFBb0JybEIsVUFBVTtJQUNuQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsSUFBSW5DLGVBQWVrQyxZQUFZO1FBQUM7S0FBYSxNQUFNcEYsV0FBVztRQUMxRCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTXFnQixtQkFBbUJqZixlQUFla0MsWUFBWTtRQUFDO0tBQWU7SUFDcEUsSUFBSStjLG9CQUFvQixNQUFNO1FBQzFCcGdCLGVBQWVzRCxVQUFVO1lBQUM7U0FBZSxFQUFFOGM7SUFDL0M7SUFDQSxPQUFPOWM7QUFDWDtBQUNBLFNBQVNxbEIsc0JBQXNCdGxCLFVBQVU7SUFDckMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLElBQUluQyxlQUFla0MsWUFBWTtRQUFDO0tBQWlCLE1BQU1wRixXQUFXO1FBQzlELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxJQUFJb0IsZUFBZWtDLFlBQVk7UUFBQztLQUFxQixNQUFNcEYsV0FBVztRQUNsRSxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTXVnQixzQkFBc0JuZixlQUFla0MsWUFBWTtRQUNuRDtLQUNIO0lBQ0QsSUFBSWlkLHVCQUF1QixNQUFNO1FBQzdCdGdCLGVBQWVzRCxVQUFVO1lBQUM7U0FBa0IsRUFBRWdkO0lBQ2xEO0lBQ0EsT0FBT2hkO0FBQ1g7QUFDQSxTQUFTc2xCLGdDQUFnQ3ZsQixVQUFVLEVBQUUrWSxZQUFZO0lBQzdELE1BQU05WSxXQUFXLENBQUM7SUFDbEIsTUFBTW9kLGVBQWV2ZixlQUFla0MsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSStZLGlCQUFpQm5lLGFBQWF5aUIsZ0JBQWdCLE1BQU07UUFDcEQxZ0IsZUFBZW9jLGNBQWM7WUFBQztZQUFVO1NBQVcsRUFBRXNFO0lBQ3pEO0lBQ0EsTUFBTUMsZ0JBQWdCeGYsZUFBZWtDLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUkrWSxpQkFBaUJuZSxhQUFhMGlCLGlCQUFpQixNQUFNO1FBQ3JEM2dCLGVBQWVvYyxjQUFjO1lBQUM7WUFBVTtTQUFZLEVBQUV1RTtJQUMxRDtJQUNBLE9BQU9yZDtBQUNYO0FBQ0EsU0FBU3VsQixpQ0FBaUN4bEIsVUFBVSxFQUFFK1ksWUFBWTtJQUM5RCxNQUFNOVksV0FBVyxDQUFDO0lBQ2xCLE1BQU1vZCxlQUFldmYsZUFBZWtDLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUkrWSxpQkFBaUJuZSxhQUFheWlCLGdCQUFnQixNQUFNO1FBQ3BEMWdCLGVBQWVvYyxjQUFjO1lBQUM7WUFBVTtTQUFXLEVBQUVzRTtJQUN6RDtJQUNBLE1BQU1DLGdCQUFnQnhmLGVBQWVrQyxZQUFZO1FBQUM7S0FBWTtJQUM5RCxJQUFJK1ksaUJBQWlCbmUsYUFBYTBpQixpQkFBaUIsTUFBTTtRQUNyRDNnQixlQUFlb2MsY0FBYztZQUFDO1lBQVU7U0FBWSxFQUFFdUU7SUFDMUQ7SUFDQSxPQUFPcmQ7QUFDWDtBQUNBLFNBQVN3bEIsb0NBQW9DemxCLFVBQVU7SUFDbkQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1pWixhQUFhcGIsZUFBZWtDLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlrWixjQUFjLE1BQU07UUFDcEJxTSxnQ0FBZ0NyTSxZQUFZalo7SUFDaEQ7SUFDQSxPQUFPQTtBQUNYO0FBQ0EsU0FBU3lsQixxQ0FBcUMxbEIsVUFBVTtJQUNwRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTWlaLGFBQWFwYixlQUFla0MsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSWtaLGNBQWMsTUFBTTtRQUNwQnNNLGlDQUFpQ3RNLFlBQVlqWjtJQUNqRDtJQUNBLE9BQU9BO0FBQ1g7QUFDQSxTQUFTMGxCLG9DQUFvQzNsQixVQUFVO0lBQ25ELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNeUIsc0JBQXNCNUQsZUFBZWtDLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUkwQix1QkFBdUIsTUFBTTtRQUM3Qi9FLGVBQWVzRCxVQUFVO1lBQUM7U0FBa0IsRUFBRXlCO0lBQ2xEO0lBQ0EsTUFBTWtjLG9CQUFvQjlmLGVBQWVrQyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJNGQscUJBQXFCLE1BQU07UUFDM0JqaEIsZUFBZXNELFVBQVU7WUFBQztTQUFnQixFQUFFMmQ7SUFDaEQ7SUFDQSxNQUFNZ0kscUJBQXFCOW5CLGVBQWVrQyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJNGxCLHNCQUFzQixNQUFNO1FBQzVCLElBQUk5a0Isa0JBQWtCOGtCO1FBQ3RCLElBQUl6b0IsTUFBTUMsT0FBTyxDQUFDMEQsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQjlDLEdBQUcsQ0FBQyxDQUFDa0I7Z0JBQ25DLE9BQU9BO1lBQ1g7UUFDSjtRQUNBdkMsZUFBZXNELFVBQVU7WUFBQztTQUFpQixFQUFFYTtJQUNqRDtJQUNBLE9BQU9iO0FBQ1g7QUFDQSxTQUFTNGxCLHFDQUFxQzdsQixVQUFVO0lBQ3BELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNeUIsc0JBQXNCNUQsZUFBZWtDLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUkwQix1QkFBdUIsTUFBTTtRQUM3Qi9FLGVBQWVzRCxVQUFVO1lBQUM7U0FBa0IsRUFBRXlCO0lBQ2xEO0lBQ0EsTUFBTWtjLG9CQUFvQjlmLGVBQWVrQyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJNGQscUJBQXFCLE1BQU07UUFDM0JqaEIsZUFBZXNELFVBQVU7WUFBQztTQUFnQixFQUFFMmQ7SUFDaEQ7SUFDQSxNQUFNZ0kscUJBQXFCOW5CLGVBQWVrQyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJNGxCLHNCQUFzQixNQUFNO1FBQzVCLElBQUk5a0Isa0JBQWtCOGtCO1FBQ3RCLElBQUl6b0IsTUFBTUMsT0FBTyxDQUFDMEQsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQjlDLEdBQUcsQ0FBQyxDQUFDa0I7Z0JBQ25DLE9BQU9BO1lBQ1g7UUFDSjtRQUNBdkMsZUFBZXNELFVBQVU7WUFBQztTQUFpQixFQUFFYTtJQUNqRDtJQUNBLE9BQU9iO0FBQ1g7QUFDQSxTQUFTNGpCLGNBQWM3akIsVUFBVTtJQUM3QixNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTWdjLHNCQUFzQm5lLGVBQWVrQyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJaWMsdUJBQXVCLE1BQU07UUFDN0J0ZixlQUFlc0QsVUFBVTtZQUFDO1NBQWtCLEVBQUVnYztJQUNsRDtJQUNBLE1BQU04QiwwQkFBMEJqZ0IsZUFBZWtDLFlBQVk7UUFDdkQ7S0FDSDtJQUNELElBQUkrZCwyQkFBMkIsTUFBTTtRQUNqQ3BoQixlQUFlc0QsVUFBVTtZQUFDO1NBQXNCLEVBQUU4ZDtJQUN0RDtJQUNBLE1BQU1DLHFCQUFxQmxnQixlQUFla0MsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSWdlLHNCQUFzQixNQUFNO1FBQzVCcmhCLGVBQWVzRCxVQUFVO1lBQUM7U0FBaUIsRUFBRStkO0lBQ2pEO0lBQ0EsTUFBTUMsZUFBZW5nQixlQUFla0MsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSWllLGdCQUFnQixNQUFNO1FBQ3RCdGhCLGVBQWVzRCxVQUFVO1lBQUM7U0FBVyxFQUFFMmtCLGtCQUFrQjNHO0lBQzdEO0lBQ0EsTUFBTUMsbUJBQW1CcGdCLGVBQWVrQyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJa2Usb0JBQW9CLE1BQU07UUFDMUJ2aEIsZUFBZXNELFVBQVU7WUFBQztTQUFlLEVBQUU0a0Isc0JBQXNCM0c7SUFDckU7SUFDQSxNQUFNQyx1QkFBdUJyZ0IsZUFBZWtDLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUltZSx3QkFBd0IsTUFBTTtRQUM5QnhoQixlQUFlc0QsVUFBVTtZQUFDO1NBQW1CLEVBQUVrZTtJQUNuRDtJQUNBLE1BQU1DLGlCQUFpQnRnQixlQUFla0MsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSW9lLGtCQUFrQixNQUFNO1FBQ3hCemhCLGVBQWVzRCxVQUFVO1lBQUM7U0FBYSxFQUFFMGpCLGNBQWN2RjtJQUMzRDtJQUNBLE1BQU1DLFdBQVd2Z0IsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlxZSxZQUFZLE1BQU07UUFDbEIxaEIsZUFBZXNELFVBQVU7WUFBQztTQUFPLEVBQUVvZTtJQUN2QztJQUNBLE1BQU1DLGNBQWN4Z0IsZUFBZWtDLFlBQVk7UUFBQztLQUFVO0lBQzFELElBQUlzZSxlQUFlLE1BQU07UUFDckIzaEIsZUFBZXNELFVBQVU7WUFBQztTQUFVLEVBQUVxZTtJQUMxQztJQUNBLE1BQU1DLHVCQUF1QnpnQixlQUFla0MsWUFBWTtRQUNwRDtLQUNIO0lBQ0QsSUFBSXVlLHdCQUF3QixNQUFNO1FBQzlCNWhCLGVBQWVzRCxVQUFVO1lBQUM7U0FBbUIsRUFBRXNlO0lBQ25EO0lBQ0EsTUFBTUMsb0JBQW9CMWdCLGVBQWVrQyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJd2UscUJBQXFCLE1BQU07UUFDM0I3aEIsZUFBZXNELFVBQVU7WUFBQztTQUFnQixFQUFFdWU7SUFDaEQ7SUFDQSxPQUFPdmU7QUFDWDtBQUNBLFNBQVNpa0Isb0JBQW9CbGtCLFVBQVU7SUFDbkMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU0wZSw0QkFBNEI3Z0IsZUFBZWtDLFlBQVk7UUFDekQ7S0FDSDtJQUNELElBQUkyZSw2QkFBNkIsTUFBTTtRQUNuQ2hpQixlQUFlc0QsVUFBVTtZQUFDO1NBQXdCLEVBQUU2a0IsK0JBQStCbkc7SUFDdkY7SUFDQSxNQUFNQyxzQkFBc0I5Z0IsZUFBZWtDLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUk0ZSx1QkFBdUIsTUFBTTtRQUM3QmppQixlQUFlc0QsVUFBVTtZQUFDO1NBQWtCLEVBQUUyZTtJQUNsRDtJQUNBLE9BQU8zZTtBQUNYO0FBQ0EsU0FBU2drQixjQUFjamtCLFVBQVU7SUFDN0IsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU00ZSwyQkFBMkIvZ0IsZUFBZWtDLFlBQVk7UUFDeEQ7S0FDSDtJQUNELElBQUk2ZSw0QkFBNEIsTUFBTTtRQUNsQyxJQUFJL2Qsa0JBQWtCK2Q7UUFDdEIsSUFBSTFoQixNQUFNQyxPQUFPLENBQUMwRCxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCOUMsR0FBRyxDQUFDLENBQUNrQjtnQkFDbkMsT0FBT0E7WUFDWDtRQUNKO1FBQ0F2QyxlQUFlc0QsVUFBVTtZQUFDO1NBQXVCLEVBQUVhO0lBQ3ZEO0lBQ0EsSUFBSWhELGVBQWVrQyxZQUFZO1FBQUM7S0FBWSxNQUFNcEYsV0FBVztRQUN6RCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTW9pQiw0QkFBNEJoaEIsZUFBZWtDLFlBQVk7UUFDekQ7S0FDSDtJQUNELElBQUk4ZSw2QkFBNkIsTUFBTTtRQUNuQ25pQixlQUFlc0QsVUFBVTtZQUFDO1NBQXdCLEVBQUU2ZTtJQUN4RDtJQUNBLE1BQU1DLGtCQUFrQmpoQixlQUFla0MsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSStlLG1CQUFtQixNQUFNO1FBQ3pCcGlCLGVBQWVzRCxVQUFVO1lBQUM7U0FBYyxFQUFFOGU7SUFDOUM7SUFDQSxNQUFNQyxpQkFBaUJsaEIsZUFBZWtDLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUlnZixrQkFBa0IsTUFBTTtRQUN4QnJpQixlQUFlc0QsVUFBVTtZQUFDO1NBQWEsRUFBRStlO0lBQzdDO0lBQ0EsTUFBTUMsb0JBQW9CbmhCLGVBQWVrQyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJaWYscUJBQXFCLE1BQU07UUFDM0J0aUIsZUFBZXNELFVBQVU7WUFBQztTQUFnQixFQUFFZ2Y7SUFDaEQ7SUFDQSxJQUFJbmhCLGVBQWVrQyxZQUFZO1FBQUM7S0FBc0IsTUFBTXBGLFdBQVc7UUFDbkUsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE1BQU13aUIsaUJBQWlCcGhCLGVBQWVrQyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJa2Ysa0JBQWtCLE1BQU07UUFDeEJ2aUIsZUFBZXNELFVBQVU7WUFBQztTQUFhLEVBQUVvbEIsb0JBQW9Cbkc7SUFDakU7SUFDQSxNQUFNQyxtQkFBbUJyaEIsZUFBZWtDLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUltZixvQkFBb0IsTUFBTTtRQUMxQnhpQixlQUFlc0QsVUFBVTtZQUFDO1NBQWUsRUFBRXFsQixzQkFBc0JuRztJQUNyRTtJQUNBLE1BQU1DLGlCQUFpQnRoQixlQUFla0MsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSW9mLGtCQUFrQixNQUFNO1FBQ3hCemlCLGVBQWVzRCxVQUFVO1lBQUM7U0FBYSxFQUFFbWY7SUFDN0M7SUFDQSxPQUFPbmY7QUFDWDtBQUNBLFNBQVNta0IsZUFBZXBrQixVQUFVO0lBQzlCLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNNGUsMkJBQTJCL2dCLGVBQWVrQyxZQUFZO1FBQ3hEO0tBQ0g7SUFDRCxJQUFJNmUsNEJBQTRCLE1BQU07UUFDbEMsSUFBSS9kLGtCQUFrQitkO1FBQ3RCLElBQUkxaEIsTUFBTUMsT0FBTyxDQUFDMEQsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQjlDLEdBQUcsQ0FBQyxDQUFDa0I7Z0JBQ25DLE9BQU82bEIsOEJBQThCN2xCO1lBQ3pDO1FBQ0o7UUFDQXZDLGVBQWVzRCxVQUFVO1lBQUM7U0FBdUIsRUFBRWE7SUFDdkQ7SUFDQSxNQUFNZ2xCLGdCQUFnQmhvQixlQUFla0MsWUFBWTtRQUFDO0tBQVk7SUFDOUQsSUFBSThsQixpQkFBaUIsTUFBTTtRQUN2Qm5wQixlQUFlc0QsVUFBVTtZQUFDO1NBQVksRUFBRTZsQjtJQUM1QztJQUNBLE1BQU1oSCw0QkFBNEJoaEIsZUFBZWtDLFlBQVk7UUFDekQ7S0FDSDtJQUNELElBQUk4ZSw2QkFBNkIsTUFBTTtRQUNuQ25pQixlQUFlc0QsVUFBVTtZQUFDO1NBQXdCLEVBQUU2ZTtJQUN4RDtJQUNBLE1BQU1DLGtCQUFrQmpoQixlQUFla0MsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSStlLG1CQUFtQixNQUFNO1FBQ3pCcGlCLGVBQWVzRCxVQUFVO1lBQUM7U0FBYyxFQUFFOGU7SUFDOUM7SUFDQSxJQUFJamhCLGVBQWVrQyxZQUFZO1FBQUM7S0FBYSxNQUFNcEYsV0FBVztRQUMxRCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTXVpQixvQkFBb0JuaEIsZUFBZWtDLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUlpZixxQkFBcUIsTUFBTTtRQUMzQnRpQixlQUFlc0QsVUFBVTtZQUFDO1NBQWdCLEVBQUVnZjtJQUNoRDtJQUNBLE1BQU04RywwQkFBMEJqb0IsZUFBZWtDLFlBQVk7UUFDdkQ7S0FDSDtJQUNELElBQUkrbEIsMkJBQTJCLE1BQU07UUFDakNwcEIsZUFBZXNELFVBQVU7WUFBQztTQUFzQixFQUFFOGxCO0lBQ3REO0lBQ0EsTUFBTTdHLGlCQUFpQnBoQixlQUFla0MsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSWtmLGtCQUFrQixNQUFNO1FBQ3hCdmlCLGVBQWVzRCxVQUFVO1lBQUM7U0FBYSxFQUFFaWY7SUFDN0M7SUFDQSxNQUFNQyxtQkFBbUJyaEIsZUFBZWtDLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUltZixvQkFBb0IsTUFBTTtRQUMxQnhpQixlQUFlc0QsVUFBVTtZQUFDO1NBQWUsRUFBRWtmO0lBQy9DO0lBQ0EsTUFBTUMsaUJBQWlCdGhCLGVBQWVrQyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJb2Ysa0JBQWtCLE1BQU07UUFDeEJ6aUIsZUFBZXNELFVBQVU7WUFBQztTQUFhLEVBQUVtZjtJQUM3QztJQUNBLE9BQU9uZjtBQUNYO0FBQ0EsU0FBUytsQixpQ0FBaUNobUIsVUFBVSxFQUFFK1ksWUFBWTtJQUM5RCxNQUFNOVksV0FBVyxDQUFDO0lBQ2xCLE1BQU04akIsVUFBVWptQixlQUFla0MsWUFBWTtRQUFDO0tBQU07SUFDbEQsSUFBSStZLGlCQUFpQm5lLGFBQWFtcEIsV0FBVyxNQUFNO1FBQy9DcG5CLGVBQWVvYyxjQUFjO1lBQUM7U0FBTSxFQUFFZ0w7SUFDMUM7SUFDQSxNQUFNQyxpQkFBaUJsbUIsZUFBZWtDLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUkrWSxpQkFBaUJuZSxhQUFhb3BCLGtCQUFrQixNQUFNO1FBQ3REcm5CLGVBQWVvYyxjQUFjO1lBQUM7U0FBYSxFQUFFaUw7SUFDakQ7SUFDQSxPQUFPL2pCO0FBQ1g7QUFDQSxTQUFTZ21CLGtDQUFrQ2ptQixVQUFVLEVBQUUrWSxZQUFZO0lBQy9ELE1BQU05WSxXQUFXLENBQUM7SUFDbEIsTUFBTThqQixVQUFVam1CLGVBQWVrQyxZQUFZO1FBQUM7S0FBTTtJQUNsRCxJQUFJK1ksaUJBQWlCbmUsYUFBYW1wQixXQUFXLE1BQU07UUFDL0NwbkIsZUFBZW9jLGNBQWM7WUFBQztTQUFNLEVBQUVnTDtJQUMxQztJQUNBLE1BQU1DLGlCQUFpQmxtQixlQUFla0MsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSStZLGlCQUFpQm5lLGFBQWFvcEIsa0JBQWtCLE1BQU07UUFDdERybkIsZUFBZW9jLGNBQWM7WUFBQztTQUFhLEVBQUVpTDtJQUNqRDtJQUNBLE9BQU8vakI7QUFDWDtBQUNBLFNBQVNpbUIscUNBQXFDblksU0FBUyxFQUFFL04sVUFBVTtJQUMvRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTUksV0FBV3ZDLGVBQWVrQyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJSyxZQUFZLE1BQU07UUFDbEIxRCxlQUFlc0QsVUFBVTtZQUFDO1lBQVE7U0FBTyxFQUFFbVMsbUJBQW1CckUsV0FBVzFOO0lBQzdFO0lBQ0EsTUFBTTZZLGFBQWFwYixlQUFla0MsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSWtaLGNBQWMsTUFBTTtRQUNwQjhNLGlDQUFpQzlNLFlBQVlqWjtJQUNqRDtJQUNBLE9BQU9BO0FBQ1g7QUFDQSxTQUFTa21CLHNDQUFzQ3BZLFNBQVMsRUFBRS9OLFVBQVU7SUFDaEUsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1JLFdBQVd2QyxlQUFla0MsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSUssWUFBWSxNQUFNO1FBQ2xCMUQsZUFBZXNELFVBQVU7WUFBQztZQUFRO1NBQU8sRUFBRW1TLG1CQUFtQnJFLFdBQVcxTjtJQUM3RTtJQUNBLE1BQU02WSxhQUFhcGIsZUFBZWtDLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlrWixjQUFjLE1BQU07UUFDcEIrTSxrQ0FBa0MvTSxZQUFZalo7SUFDbEQ7SUFDQSxPQUFPQTtBQUNYO0FBRUE7Ozs7Q0FJQyxHQUNELE1BQU1tbUIsZUFBZXhxQjtJQXNCakI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0F5QkMsR0FDRCxNQUFNNm5CLE9BQU9qRSxNQUFNLEVBQUU7UUFDakIsSUFBSWhrQixJQUFJQyxJQUFJbU4sSUFBSUM7UUFDaEIsSUFBSTlCO1FBQ0osSUFBSXFhLE9BQU87UUFDWCxJQUFJbUIsY0FBYyxDQUFDO1FBQ25CLElBQUksSUFBSSxDQUFDeFUsU0FBUyxDQUFDRyxVQUFVLElBQUk7WUFDN0IsTUFBTWdULE9BQU9xRCxzQ0FBc0MsSUFBSSxDQUFDeFcsU0FBUyxFQUFFeVI7WUFDbkU0QixPQUFPdmxCLFVBQVUsa0JBQWtCcWxCLElBQUksQ0FBQyxPQUFPO1lBQy9DcUIsY0FBY3JCLElBQUksQ0FBQyxTQUFTO1lBQzVCLE9BQU9BLElBQUksQ0FBQyxPQUFPO1lBQ25CLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCbmEsV0FBVyxJQUFJLENBQUNnSCxTQUFTLENBQ3BCZ1QsT0FBTyxDQUFDO2dCQUNUSyxNQUFNQTtnQkFDTm1CLGFBQWFBO2dCQUNickIsTUFBTXNCLEtBQUtDLFNBQVMsQ0FBQ3ZCO2dCQUNyQndCLFlBQVk7Z0JBQ1p0bkIsYUFBYSxDQUFDSSxLQUFLZ2tCLE9BQU85UyxNQUFNLE1BQU0sUUFBUWxSLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0osV0FBVztnQkFDckZ1bkIsYUFBYSxDQUFDbG5CLEtBQUsrakIsT0FBTzlTLE1BQU0sTUFBTSxRQUFRalIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHa25CLFdBQVc7WUFDekYsR0FDS0MsSUFBSSxDQUFDLENBQUNDO2dCQUNQLE9BQU9BLGFBQWF6YSxJQUFJO1lBQzVCO1lBQ0EsT0FBT3JCLFNBQVM2YixJQUFJLENBQUMsQ0FBQ0U7Z0JBQ2xCLE9BQU9BO1lBQ1g7UUFDSixPQUNLO1lBQ0QsTUFBTTVCLE9BQU9vRCxxQ0FBcUMsSUFBSSxDQUFDdlcsU0FBUyxFQUFFeVI7WUFDbEU0QixPQUFPdmxCLFVBQVUsa0JBQWtCcWxCLElBQUksQ0FBQyxPQUFPO1lBQy9DcUIsY0FBY3JCLElBQUksQ0FBQyxTQUFTO1lBQzVCLE9BQU9BLElBQUksQ0FBQyxPQUFPO1lBQ25CLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCbmEsV0FBVyxJQUFJLENBQUNnSCxTQUFTLENBQ3BCZ1QsT0FBTyxDQUFDO2dCQUNUSyxNQUFNQTtnQkFDTm1CLGFBQWFBO2dCQUNickIsTUFBTXNCLEtBQUtDLFNBQVMsQ0FBQ3ZCO2dCQUNyQndCLFlBQVk7Z0JBQ1p0bkIsYUFBYSxDQUFDd04sS0FBSzRXLE9BQU85UyxNQUFNLE1BQU0sUUFBUTlELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3hOLFdBQVc7Z0JBQ3JGdW5CLGFBQWEsQ0FBQzlaLEtBQUsyVyxPQUFPOVMsTUFBTSxNQUFNLFFBQVE3RCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUc4WixXQUFXO1lBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQztnQkFDUCxPQUFPQSxhQUFhemEsSUFBSTtZQUM1QjtZQUNBLE9BQU9yQixTQUFTNmIsSUFBSSxDQUFDLENBQUNFO2dCQUNsQixPQUFPQTtZQUNYO1FBQ0o7SUFDSjtJQUNBOzs7Ozs7Ozs7O0tBVUMsR0FDRCxNQUFNRSxJQUFJeEQsTUFBTSxFQUFFO1FBQ2QsSUFBSWhrQixJQUFJQyxJQUFJbU4sSUFBSUM7UUFDaEIsSUFBSTlCO1FBQ0osSUFBSXFhLE9BQU87UUFDWCxJQUFJbUIsY0FBYyxDQUFDO1FBQ25CLElBQUksSUFBSSxDQUFDeFUsU0FBUyxDQUFDRyxVQUFVLElBQUk7WUFDN0IsTUFBTWdULE9BQU9rRSxtQ0FBbUMsSUFBSSxDQUFDclgsU0FBUyxFQUFFeVI7WUFDaEU0QixPQUFPdmxCLFVBQVUsVUFBVXFsQixJQUFJLENBQUMsT0FBTztZQUN2Q3FCLGNBQWNyQixJQUFJLENBQUMsU0FBUztZQUM1QixPQUFPQSxJQUFJLENBQUMsT0FBTztZQUNuQixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQm5hLFdBQVcsSUFBSSxDQUFDZ0gsU0FBUyxDQUNwQmdULE9BQU8sQ0FBQztnQkFDVEssTUFBTUE7Z0JBQ05tQixhQUFhQTtnQkFDYnJCLE1BQU1zQixLQUFLQyxTQUFTLENBQUN2QjtnQkFDckJ3QixZQUFZO2dCQUNadG5CLGFBQWEsQ0FBQ0ksS0FBS2drQixPQUFPOVMsTUFBTSxNQUFNLFFBQVFsUixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdKLFdBQVc7Z0JBQ3JGdW5CLGFBQWEsQ0FBQ2xuQixLQUFLK2pCLE9BQU85UyxNQUFNLE1BQU0sUUFBUWpSLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2tuQixXQUFXO1lBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQztnQkFDUCxPQUFPQSxhQUFhemEsSUFBSTtZQUM1QjtZQUNBLE9BQU9yQixTQUFTNmIsSUFBSSxDQUFDLENBQUNFO2dCQUNsQixPQUFPQTtZQUNYO1FBQ0osT0FDSztZQUNELE1BQU01QixPQUFPaUUsa0NBQWtDLElBQUksQ0FBQ3BYLFNBQVMsRUFBRXlSO1lBQy9ENEIsT0FBT3ZsQixVQUFVLFVBQVVxbEIsSUFBSSxDQUFDLE9BQU87WUFDdkNxQixjQUFjckIsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJuYSxXQUFXLElBQUksQ0FBQ2dILFNBQVMsQ0FDcEJnVCxPQUFPLENBQUM7Z0JBQ1RLLE1BQU1BO2dCQUNObUIsYUFBYUE7Z0JBQ2JyQixNQUFNc0IsS0FBS0MsU0FBUyxDQUFDdkI7Z0JBQ3JCd0IsWUFBWTtnQkFDWnRuQixhQUFhLENBQUN3TixLQUFLNFcsT0FBTzlTLE1BQU0sTUFBTSxRQUFROUQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHeE4sV0FBVztnQkFDckZ1bkIsYUFBYSxDQUFDOVosS0FBSzJXLE9BQU85UyxNQUFNLE1BQU0sUUFBUTdELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzhaLFdBQVc7WUFDekYsR0FDS0MsSUFBSSxDQUFDLENBQUNDO2dCQUNQLE9BQU9BLGFBQWF6YSxJQUFJO1lBQzVCO1lBQ0EsT0FBT3JCLFNBQVM2YixJQUFJLENBQUMsQ0FBQ0U7Z0JBQ2xCLE9BQU9BO1lBQ1g7UUFDSjtJQUNKO0lBQ0E7Ozs7Ozs7Ozs7S0FVQyxHQUNELE1BQU1PLE9BQU83RCxNQUFNLEVBQUU7UUFDakIsSUFBSWhrQixJQUFJQyxJQUFJbU4sSUFBSUM7UUFDaEIsSUFBSTlCO1FBQ0osSUFBSXFhLE9BQU87UUFDWCxJQUFJbUIsY0FBYyxDQUFDO1FBQ25CLElBQUksSUFBSSxDQUFDeFUsU0FBUyxDQUFDRyxVQUFVLElBQUk7WUFDN0IsTUFBTWdULE9BQU91RCxzQ0FBc0MsSUFBSSxDQUFDMVcsU0FBUyxFQUFFeVI7WUFDbkU0QixPQUFPdmxCLFVBQVUsVUFBVXFsQixJQUFJLENBQUMsT0FBTztZQUN2Q3FCLGNBQWNyQixJQUFJLENBQUMsU0FBUztZQUM1QixPQUFPQSxJQUFJLENBQUMsT0FBTztZQUNuQixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQm5hLFdBQVcsSUFBSSxDQUFDZ0gsU0FBUyxDQUNwQmdULE9BQU8sQ0FBQztnQkFDVEssTUFBTUE7Z0JBQ05tQixhQUFhQTtnQkFDYnJCLE1BQU1zQixLQUFLQyxTQUFTLENBQUN2QjtnQkFDckJ3QixZQUFZO2dCQUNadG5CLGFBQWEsQ0FBQ0ksS0FBS2drQixPQUFPOVMsTUFBTSxNQUFNLFFBQVFsUixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdKLFdBQVc7Z0JBQ3JGdW5CLGFBQWEsQ0FBQ2xuQixLQUFLK2pCLE9BQU85UyxNQUFNLE1BQU0sUUFBUWpSLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2tuQixXQUFXO1lBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQztnQkFDUCxPQUFPQSxhQUFhemEsSUFBSSxHQUFHd2EsSUFBSSxDQUFDLENBQUNPO29CQUM3QixNQUFNcGMsV0FBV29jO29CQUNqQnBjLFNBQVM2WSxlQUFlLEdBQUc7d0JBQ3ZCclgsU0FBU3NhLGFBQWF0YSxPQUFPO29CQUNqQztvQkFDQSxPQUFPeEI7Z0JBQ1g7WUFDSjtZQUNBLE9BQU9BLFNBQVM2YixJQUFJLENBQUMsQ0FBQy9YO2dCQUNsQixNQUFNaVksT0FBTzZCLHNDQUFzQzlaO2dCQUNuRCxNQUFNdVksWUFBWSxJQUFJalk7Z0JBQ3RCL08sT0FBT3dCLE1BQU0sQ0FBQ3dsQixXQUFXTjtnQkFDekIsT0FBT007WUFDWDtRQUNKLE9BQ0s7WUFDRCxNQUFNbEMsT0FBT3NELHFDQUFxQyxJQUFJLENBQUN6VyxTQUFTLEVBQUV5UjtZQUNsRTRCLE9BQU92bEIsVUFBVSxVQUFVcWxCLElBQUksQ0FBQyxPQUFPO1lBQ3ZDcUIsY0FBY3JCLElBQUksQ0FBQyxTQUFTO1lBQzVCLE9BQU9BLElBQUksQ0FBQyxPQUFPO1lBQ25CLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCbmEsV0FBVyxJQUFJLENBQUNnSCxTQUFTLENBQ3BCZ1QsT0FBTyxDQUFDO2dCQUNUSyxNQUFNQTtnQkFDTm1CLGFBQWFBO2dCQUNickIsTUFBTXNCLEtBQUtDLFNBQVMsQ0FBQ3ZCO2dCQUNyQndCLFlBQVk7Z0JBQ1p0bkIsYUFBYSxDQUFDd04sS0FBSzRXLE9BQU85UyxNQUFNLE1BQU0sUUFBUTlELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3hOLFdBQVc7Z0JBQ3JGdW5CLGFBQWEsQ0FBQzlaLEtBQUsyVyxPQUFPOVMsTUFBTSxNQUFNLFFBQVE3RCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUc4WixXQUFXO1lBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQztnQkFDUCxPQUFPQSxhQUFhemEsSUFBSSxHQUFHd2EsSUFBSSxDQUFDLENBQUNPO29CQUM3QixNQUFNcGMsV0FBV29jO29CQUNqQnBjLFNBQVM2WSxlQUFlLEdBQUc7d0JBQ3ZCclgsU0FBU3NhLGFBQWF0YSxPQUFPO29CQUNqQztvQkFDQSxPQUFPeEI7Z0JBQ1g7WUFDSjtZQUNBLE9BQU9BLFNBQVM2YixJQUFJLENBQUMsQ0FBQy9YO2dCQUNsQixNQUFNaVksT0FBTzRCLHFDQUFxQzdaO2dCQUNsRCxNQUFNdVksWUFBWSxJQUFJalk7Z0JBQ3RCL08sT0FBT3dCLE1BQU0sQ0FBQ3dsQixXQUFXTjtnQkFDekIsT0FBT007WUFDWDtRQUNKO0lBQ0o7SUFDQTs7Ozs7Ozs7Ozs7OztLQWFDLEdBQ0QsTUFBTWlELE9BQU83RyxNQUFNLEVBQUU7UUFDakIsSUFBSWhrQixJQUFJQyxJQUFJbU4sSUFBSUM7UUFDaEIsSUFBSTlCO1FBQ0osSUFBSXFhLE9BQU87UUFDWCxJQUFJbUIsY0FBYyxDQUFDO1FBQ25CLElBQUksSUFBSSxDQUFDeFUsU0FBUyxDQUFDRyxVQUFVLElBQUk7WUFDN0IsTUFBTWdULE9BQU9pRixzQ0FBc0MsSUFBSSxDQUFDcFksU0FBUyxFQUFFeVI7WUFDbkU0QixPQUFPdmxCLFVBQVUsVUFBVXFsQixJQUFJLENBQUMsT0FBTztZQUN2Q3FCLGNBQWNyQixJQUFJLENBQUMsU0FBUztZQUM1QixPQUFPQSxJQUFJLENBQUMsT0FBTztZQUNuQixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQm5hLFdBQVcsSUFBSSxDQUFDZ0gsU0FBUyxDQUNwQmdULE9BQU8sQ0FBQztnQkFDVEssTUFBTUE7Z0JBQ05tQixhQUFhQTtnQkFDYnJCLE1BQU1zQixLQUFLQyxTQUFTLENBQUN2QjtnQkFDckJ3QixZQUFZO2dCQUNadG5CLGFBQWEsQ0FBQ0ksS0FBS2drQixPQUFPOVMsTUFBTSxNQUFNLFFBQVFsUixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdKLFdBQVc7Z0JBQ3JGdW5CLGFBQWEsQ0FBQ2xuQixLQUFLK2pCLE9BQU85UyxNQUFNLE1BQU0sUUFBUWpSLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2tuQixXQUFXO1lBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQztnQkFDUCxPQUFPQSxhQUFhemEsSUFBSTtZQUM1QjtZQUNBLE9BQU9yQixTQUFTNmIsSUFBSSxDQUFDLENBQUNFO2dCQUNsQixPQUFPQTtZQUNYO1FBQ0osT0FDSztZQUNELE1BQU01QixPQUFPZ0YscUNBQXFDLElBQUksQ0FBQ25ZLFNBQVMsRUFBRXlSO1lBQ2xFNEIsT0FBT3ZsQixVQUFVLFVBQVVxbEIsSUFBSSxDQUFDLE9BQU87WUFDdkNxQixjQUFjckIsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJuYSxXQUFXLElBQUksQ0FBQ2dILFNBQVMsQ0FDcEJnVCxPQUFPLENBQUM7Z0JBQ1RLLE1BQU1BO2dCQUNObUIsYUFBYUE7Z0JBQ2JyQixNQUFNc0IsS0FBS0MsU0FBUyxDQUFDdkI7Z0JBQ3JCd0IsWUFBWTtnQkFDWnRuQixhQUFhLENBQUN3TixLQUFLNFcsT0FBTzlTLE1BQU0sTUFBTSxRQUFROUQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHeE4sV0FBVztnQkFDckZ1bkIsYUFBYSxDQUFDOVosS0FBSzJXLE9BQU85UyxNQUFNLE1BQU0sUUFBUTdELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzhaLFdBQVc7WUFDekYsR0FDS0MsSUFBSSxDQUFDLENBQUNDO2dCQUNQLE9BQU9BLGFBQWF6YSxJQUFJO1lBQzVCO1lBQ0EsT0FBT3JCLFNBQVM2YixJQUFJLENBQUMsQ0FBQ0U7Z0JBQ2xCLE9BQU9BO1lBQ1g7UUFDSjtJQUNKO0lBQ0EsTUFBTUksYUFBYTFELE1BQU0sRUFBRTtRQUN2QixJQUFJaGtCLElBQUlDLElBQUltTixJQUFJQztRQUNoQixJQUFJOUI7UUFDSixJQUFJcWEsT0FBTztRQUNYLElBQUltQixjQUFjLENBQUM7UUFDbkIsSUFBSSxJQUFJLENBQUN4VSxTQUFTLENBQUNHLFVBQVUsSUFBSTtZQUM3QixNQUFNZ1QsT0FBT3dFLHFDQUFxQ2xHO1lBQ2xENEIsT0FBT3ZsQixVQUFVLGtCQUFrQnFsQixJQUFJLENBQUMsT0FBTztZQUMvQ3FCLGNBQWNyQixJQUFJLENBQUMsU0FBUztZQUM1QixPQUFPQSxJQUFJLENBQUMsT0FBTztZQUNuQixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQm5hLFdBQVcsSUFBSSxDQUFDZ0gsU0FBUyxDQUNwQmdULE9BQU8sQ0FBQztnQkFDVEssTUFBTUE7Z0JBQ05tQixhQUFhQTtnQkFDYnJCLE1BQU1zQixLQUFLQyxTQUFTLENBQUN2QjtnQkFDckJ3QixZQUFZO2dCQUNadG5CLGFBQWEsQ0FBQ0ksS0FBS2drQixPQUFPOVMsTUFBTSxNQUFNLFFBQVFsUixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdKLFdBQVc7Z0JBQ3JGdW5CLGFBQWEsQ0FBQ2xuQixLQUFLK2pCLE9BQU85UyxNQUFNLE1BQU0sUUFBUWpSLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2tuQixXQUFXO1lBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQztnQkFDUCxPQUFPQSxhQUFhemEsSUFBSSxHQUFHd2EsSUFBSSxDQUFDLENBQUNPO29CQUM3QixNQUFNcGMsV0FBV29jO29CQUNqQnBjLFNBQVM2WSxlQUFlLEdBQUc7d0JBQ3ZCclgsU0FBU3NhLGFBQWF0YSxPQUFPO29CQUNqQztvQkFDQSxPQUFPeEI7Z0JBQ1g7WUFDSjtZQUNBLE9BQU9BLFNBQVM2YixJQUFJLENBQUMsQ0FBQy9YO2dCQUNsQixNQUFNaVksT0FBTytDLHFDQUFxQ2hiO2dCQUNsRCxNQUFNdVksWUFBWSxJQUFJaFk7Z0JBQ3RCaFAsT0FBT3dCLE1BQU0sQ0FBQ3dsQixXQUFXTjtnQkFDekIsT0FBT007WUFDWDtRQUNKLE9BQ0s7WUFDRCxNQUFNbEMsT0FBT3VFLG9DQUFvQ2pHO1lBQ2pENEIsT0FBT3ZsQixVQUFVLGtCQUFrQnFsQixJQUFJLENBQUMsT0FBTztZQUMvQ3FCLGNBQWNyQixJQUFJLENBQUMsU0FBUztZQUM1QixPQUFPQSxJQUFJLENBQUMsT0FBTztZQUNuQixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQm5hLFdBQVcsSUFBSSxDQUFDZ0gsU0FBUyxDQUNwQmdULE9BQU8sQ0FBQztnQkFDVEssTUFBTUE7Z0JBQ05tQixhQUFhQTtnQkFDYnJCLE1BQU1zQixLQUFLQyxTQUFTLENBQUN2QjtnQkFDckJ3QixZQUFZO2dCQUNadG5CLGFBQWEsQ0FBQ3dOLEtBQUs0VyxPQUFPOVMsTUFBTSxNQUFNLFFBQVE5RCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUd4TixXQUFXO2dCQUNyRnVuQixhQUFhLENBQUM5WixLQUFLMlcsT0FBTzlTLE1BQU0sTUFBTSxRQUFRN0QsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHOFosV0FBVztZQUN6RixHQUNLQyxJQUFJLENBQUMsQ0FBQ0M7Z0JBQ1AsT0FBT0EsYUFBYXphLElBQUksR0FBR3dhLElBQUksQ0FBQyxDQUFDTztvQkFDN0IsTUFBTXBjLFdBQVdvYztvQkFDakJwYyxTQUFTNlksZUFBZSxHQUFHO3dCQUN2QnJYLFNBQVNzYSxhQUFhdGEsT0FBTztvQkFDakM7b0JBQ0EsT0FBT3hCO2dCQUNYO1lBQ0o7WUFDQSxPQUFPQSxTQUFTNmIsSUFBSSxDQUFDLENBQUMvWDtnQkFDbEIsTUFBTWlZLE9BQU82QyxvQ0FBb0M5YTtnQkFDakQsTUFBTXVZLFlBQVksSUFBSWhZO2dCQUN0QmhQLE9BQU93QixNQUFNLENBQUN3bEIsV0FBV047Z0JBQ3pCLE9BQU9NO1lBQ1g7UUFDSjtJQUNKO0lBaFhBOWEsWUFBWXlGLFNBQVMsQ0FBRTs7UUFDbkIsS0FBSztRQUNMLElBQUksQ0FBQ0EsU0FBUyxHQUFHQTtRQUNqQjs7Ozs7Ozs7Ozs7OztTQWFDLEdBQ0QsSUFBSSxDQUFDdVYsSUFBSSxHQUFHO2dCQUFPOUQsMEVBQVMsQ0FBQztZQUN6QixPQUFPLElBQUlGLE1BQU1ELFVBQVVpSCwwQkFBMEIsRUFBRSxDQUFDOUMsSUFBTSxNQUFLTixZQUFZLENBQUNNLElBQUksTUFBTSxNQUFLTixZQUFZLENBQUMxRCxTQUFTQTtRQUN6SDtJQUNKO0FBNlZKO0FBRUE7Ozs7Ozs7Ozs7Ozs7OEVBYThFLEdBQzlFLDhEQUE4RCxHQUc5RCxTQUFTK0csU0FBU0MsQ0FBQztJQUNmLElBQUlDLElBQUksT0FBT2xHLFdBQVcsY0FBY0EsT0FBT21HLFFBQVEsRUFBRUMsSUFBSUYsS0FBS0QsQ0FBQyxDQUFDQyxFQUFFLEVBQUUzcEIsSUFBSTtJQUM1RSxJQUFJNnBCLEdBQUcsT0FBT0EsRUFBRXBxQixJQUFJLENBQUNpcUI7SUFDckIsSUFBSUEsS0FBSyxPQUFPQSxFQUFFenBCLE1BQU0sS0FBSyxVQUFVLE9BQU87UUFDMUMwakIsTUFBTTtZQUNGLElBQUkrRixLQUFLMXBCLEtBQUswcEIsRUFBRXpwQixNQUFNLEVBQUV5cEIsSUFBSSxLQUFLO1lBQ2pDLE9BQU87Z0JBQUVocUIsT0FBT2dxQixLQUFLQSxDQUFDLENBQUMxcEIsSUFBSTtnQkFBRThqQixNQUFNLENBQUM0RjtZQUFFO1FBQzFDO0lBQ0o7SUFDQSxNQUFNLElBQUl0b0IsVUFBVXVvQixJQUFJLDRCQUE0QjtBQUN4RDtBQUVBLFNBQVNHLFFBQVFubkIsQ0FBQztJQUNkLE9BQU8sSUFBSSxZQUFZbW5CLFVBQVcsS0FBSSxDQUFDbm5CLENBQUMsR0FBR0EsR0FBRyxJQUFJLElBQUksSUFBSW1uQixRQUFRbm5CO0FBQ3RFO0FBRUEsU0FBU29uQixpQkFBaUJDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxTQUFTO0lBQ3BELElBQUksQ0FBQ3pHLE9BQU9DLGFBQWEsRUFBRSxNQUFNLElBQUl0aUIsVUFBVTtJQUMvQyxJQUFJK29CLElBQUlELFVBQVVFLEtBQUssQ0FBQ0osU0FBU0MsY0FBYyxFQUFFLEdBQUdqcUIsR0FBR3FxQixJQUFJLEVBQUU7SUFDN0QsT0FBT3JxQixJQUFJVixPQUFPcW5CLE1BQU0sQ0FBQyxDQUFDLE9BQU8yRCxrQkFBa0IsYUFBYUEsZ0JBQWdCaHJCLE1BQUssRUFBR0MsU0FBUyxHQUFHZ3JCLEtBQUssU0FBU0EsS0FBSyxVQUFVQSxLQUFLLFVBQVVDLGNBQWN4cUIsQ0FBQyxDQUFDeWpCLE9BQU9DLGFBQWEsQ0FBQyxHQUFHO1FBQWMsT0FBTyxJQUFJO0lBQUUsR0FBRzFqQjtJQUN0TixTQUFTd3FCLFlBQVlDLENBQUM7UUFBSSxPQUFPLFNBQVU5bkIsQ0FBQztZQUFJLE9BQU8rbkIsUUFBUUMsT0FBTyxDQUFDaG9CLEdBQUdtakIsSUFBSSxDQUFDMkUsR0FBR0c7UUFBUztJQUFHO0lBQzlGLFNBQVNMLEtBQUtNLENBQUMsRUFBRUosQ0FBQztRQUFJLElBQUlOLENBQUMsQ0FBQ1UsRUFBRSxFQUFFO1lBQUU3cUIsQ0FBQyxDQUFDNnFCLEVBQUUsR0FBRyxTQUFVbG9CLENBQUM7Z0JBQUksT0FBTyxJQUFJK25CLFFBQVEsU0FBVUksQ0FBQyxFQUFFQyxDQUFDO29CQUFJVixFQUFFdm5CLElBQUksQ0FBQzt3QkFBQytuQjt3QkFBR2xvQjt3QkFBR21vQjt3QkFBR0M7cUJBQUUsSUFBSSxLQUFLQyxPQUFPSCxHQUFHbG9CO2dCQUFJO1lBQUk7WUFBRyxJQUFJOG5CLEdBQUd6cUIsQ0FBQyxDQUFDNnFCLEVBQUUsR0FBR0osRUFBRXpxQixDQUFDLENBQUM2cUIsRUFBRTtRQUFHO0lBQUU7SUFDdkssU0FBU0csT0FBT0gsQ0FBQyxFQUFFbG9CLENBQUM7UUFBSSxJQUFJO1lBQUVzb0IsS0FBS2QsQ0FBQyxDQUFDVSxFQUFFLENBQUNsb0I7UUFBSyxFQUFFLE9BQU91b0IsR0FBRztZQUFFQyxPQUFPZCxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRWE7UUFBSTtJQUFFO0lBQ2pGLFNBQVNELEtBQUtHLENBQUM7UUFBSUEsRUFBRTFyQixLQUFLLFlBQVlvcUIsVUFBVVksUUFBUUMsT0FBTyxDQUFDUyxFQUFFMXJCLEtBQUssQ0FBQ2lELENBQUMsRUFBRW1qQixJQUFJLENBQUN1RixTQUFTVCxVQUFVTyxPQUFPZCxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRWU7SUFBSTtJQUN2SCxTQUFTQyxRQUFRM3JCLEtBQUs7UUFBSXNyQixPQUFPLFFBQVF0ckI7SUFBUTtJQUNqRCxTQUFTa3JCLE9BQU9sckIsS0FBSztRQUFJc3JCLE9BQU8sU0FBU3RyQjtJQUFRO0lBQ2pELFNBQVN5ckIsT0FBT1YsQ0FBQyxFQUFFOW5CLENBQUM7UUFBSSxJQUFJOG5CLEVBQUU5bkIsSUFBSTBuQixFQUFFaUIsS0FBSyxJQUFJakIsRUFBRXBxQixNQUFNLEVBQUUrcUIsT0FBT1gsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUVBLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRTtJQUFHO0FBQ3JGO0FBRUEsU0FBU2tCLGNBQWM3QixDQUFDO0lBQ3BCLElBQUksQ0FBQ2pHLE9BQU9DLGFBQWEsRUFBRSxNQUFNLElBQUl0aUIsVUFBVTtJQUMvQyxJQUFJeW9CLElBQUlILENBQUMsQ0FBQ2pHLE9BQU9DLGFBQWEsQ0FBQyxFQUFFMWpCO0lBQ2pDLE9BQU82cEIsSUFBSUEsRUFBRXBxQixJQUFJLENBQUNpcUIsS0FBTUEsQ0FBQUEsSUFBSSxPQUFPRCxhQUFhLGFBQWFBLFNBQVNDLEtBQUtBLENBQUMsQ0FBQ2pHLE9BQU9tRyxRQUFRLENBQUMsSUFBSTVwQixJQUFJLENBQUMsR0FBR3VxQixLQUFLLFNBQVNBLEtBQUssVUFBVUEsS0FBSyxXQUFXdnFCLENBQUMsQ0FBQ3lqQixPQUFPQyxhQUFhLENBQUMsR0FBRztRQUFjLE9BQU8sSUFBSTtJQUFFLEdBQUcxakIsQ0FBQUE7SUFDOU0sU0FBU3VxQixLQUFLTSxDQUFDO1FBQUk3cUIsQ0FBQyxDQUFDNnFCLEVBQUUsR0FBR25CLENBQUMsQ0FBQ21CLEVBQUUsSUFBSSxTQUFVbG9CLENBQUM7WUFBSSxPQUFPLElBQUkrbkIsUUFBUSxTQUFVQyxPQUFPLEVBQUVDLE1BQU07Z0JBQUlqb0IsSUFBSSttQixDQUFDLENBQUNtQixFQUFFLENBQUNsb0IsSUFBSXdvQixPQUFPUixTQUFTQyxRQUFRam9CLEVBQUVtaEIsSUFBSSxFQUFFbmhCLEVBQUVqRCxLQUFLO1lBQUc7UUFBSTtJQUFHO0lBQy9KLFNBQVN5ckIsT0FBT1IsT0FBTyxFQUFFQyxNQUFNLEVBQUVqcUIsQ0FBQyxFQUFFZ0MsQ0FBQztRQUFJK25CLFFBQVFDLE9BQU8sQ0FBQ2hvQixHQUFHbWpCLElBQUksQ0FBQyxTQUFTbmpCLENBQUM7WUFBSWdvQixRQUFRO2dCQUFFanJCLE9BQU9pRDtnQkFBR21oQixNQUFNbmpCO1lBQUU7UUFBSSxHQUFHaXFCO0lBQVM7QUFDL0g7QUFFQSxPQUFPWSxvQkFBb0IsYUFBYUEsa0JBQWtCLFNBQVVycUIsS0FBSyxFQUFFc3FCLFVBQVUsRUFBRUMsT0FBTztJQUMxRixJQUFJUixJQUFJLElBQUl0ckIsTUFBTThyQjtJQUNsQixPQUFPUixFQUFFdGhCLElBQUksR0FBRyxtQkFBbUJzaEIsRUFBRS9wQixLQUFLLEdBQUdBLE9BQU8rcEIsRUFBRU8sVUFBVSxHQUFHQSxZQUFZUDtBQUNuRjtBQUVBOzs7O0NBSUMsR0FDRDs7Q0FFQyxHQUNELFNBQVNTLGdCQUFnQjFoQixRQUFRO0lBQzdCLElBQUl2TDtJQUNKLElBQUl1TCxTQUFTbUMsVUFBVSxJQUFJdE8sYUFBYW1NLFNBQVNtQyxVQUFVLENBQUNuTSxNQUFNLEtBQUssR0FBRztRQUN0RSxPQUFPO0lBQ1g7SUFDQSxNQUFNb00sVUFBVSxDQUFDM04sS0FBS3VMLFNBQVNtQyxVQUFVLENBQUMsRUFBRSxNQUFNLFFBQVExTixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUcyTixPQUFPO0lBQzdGLElBQUlBLFlBQVl2TyxXQUFXO1FBQ3ZCLE9BQU87SUFDWDtJQUNBLE9BQU84dEIsZUFBZXZmO0FBQzFCO0FBQ0EsU0FBU3VmLGVBQWV2ZixPQUFPO0lBQzNCLElBQUlBLFFBQVFuQyxLQUFLLEtBQUtwTSxhQUFhdU8sUUFBUW5DLEtBQUssQ0FBQ2pLLE1BQU0sS0FBSyxHQUFHO1FBQzNELE9BQU87SUFDWDtJQUNBLEtBQUssTUFBTWdMLFFBQVFvQixRQUFRbkMsS0FBSyxDQUFFO1FBQzlCLElBQUllLFNBQVNuTixhQUFhd0IsT0FBT1MsSUFBSSxDQUFDa0wsTUFBTWhMLE1BQU0sS0FBSyxHQUFHO1lBQ3RELE9BQU87UUFDWDtJQUNKO0lBQ0EsT0FBTztBQUNYO0FBQ0E7Ozs7O0NBS0MsR0FDRCxTQUFTNHJCLGdCQUFnQkMsT0FBTztJQUM1QiwwQkFBMEI7SUFDMUIsSUFBSUEsUUFBUTdyQixNQUFNLEtBQUssR0FBRztRQUN0QjtJQUNKO0lBQ0EsS0FBSyxNQUFNb00sV0FBV3lmLFFBQVM7UUFDM0IsSUFBSXpmLFFBQVFsQixJQUFJLEtBQUssVUFBVWtCLFFBQVFsQixJQUFJLEtBQUssU0FBUztZQUNyRCxNQUFNLElBQUl2TCxNQUFNLHVDQUFvRCxPQUFieU0sUUFBUWxCLElBQUksRUFBQztRQUN4RTtJQUNKO0FBQ0o7QUFDQTs7Ozs7OztDQU9DLEdBQ0QsU0FBUzRnQixzQkFBc0JDLG9CQUFvQjtJQUMvQyxJQUFJQSx5QkFBeUJsdUIsYUFBYWt1QixxQkFBcUIvckIsTUFBTSxLQUFLLEdBQUc7UUFDekUsT0FBTyxFQUFFO0lBQ2I7SUFDQSxNQUFNZ3NCLGlCQUFpQixFQUFFO0lBQ3pCLE1BQU1oc0IsU0FBUytyQixxQkFBcUIvckIsTUFBTTtJQUMxQyxJQUFJRCxJQUFJO0lBQ1IsTUFBT0EsSUFBSUMsT0FBUTtRQUNmLElBQUkrckIsb0JBQW9CLENBQUNoc0IsRUFBRSxDQUFDbUwsSUFBSSxLQUFLLFFBQVE7WUFDekM4Z0IsZUFBZW5wQixJQUFJLENBQUNrcEIsb0JBQW9CLENBQUNoc0IsRUFBRTtZQUMzQ0E7UUFDSixPQUNLO1lBQ0QsTUFBTWtzQixjQUFjLEVBQUU7WUFDdEIsSUFBSUMsVUFBVTtZQUNkLE1BQU9uc0IsSUFBSUMsVUFBVStyQixvQkFBb0IsQ0FBQ2hzQixFQUFFLENBQUNtTCxJQUFJLEtBQUssUUFBUztnQkFDM0QrZ0IsWUFBWXBwQixJQUFJLENBQUNrcEIsb0JBQW9CLENBQUNoc0IsRUFBRTtnQkFDeEMsSUFBSW1zQixXQUFXLENBQUNQLGVBQWVJLG9CQUFvQixDQUFDaHNCLEVBQUUsR0FBRztvQkFDckRtc0IsVUFBVTtnQkFDZDtnQkFDQW5zQjtZQUNKO1lBQ0EsSUFBSW1zQixTQUFTO2dCQUNURixlQUFlbnBCLElBQUksSUFBSW9wQjtZQUMzQixPQUNLO2dCQUNELDREQUE0RDtnQkFDNURELGVBQWV0VCxHQUFHO1lBQ3RCO1FBQ0o7SUFDSjtJQUNBLE9BQU9zVDtBQUNYO0FBQ0E7O0NBRUMsR0FDRCxNQUFNRztJQUtGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FxQkMsR0FDRHpGLE9BQU9qRSxNQUFNLEVBQUU7UUFDWCxPQUFPLElBQUkySixLQUFLLElBQUksQ0FBQ3BiLFNBQVMsRUFBRSxJQUFJLENBQUNxYixZQUFZLEVBQUU1SixPQUFPeFIsS0FBSyxFQUFFd1IsT0FBTzlTLE1BQU0sRUFDOUUscUVBQXFFO1FBQ3JFLGdCQUFnQjtRQUNoQjJjLGdCQUFnQjdKLE9BQU9vSixPQUFPO0lBQ2xDO0lBL0JBdGdCLFlBQVk4Z0IsWUFBWSxFQUFFcmIsU0FBUyxDQUFFO1FBQ2pDLElBQUksQ0FBQ3FiLFlBQVksR0FBR0E7UUFDcEIsSUFBSSxDQUFDcmIsU0FBUyxHQUFHQTtJQUNyQjtBQTZCSjtBQUNBOzs7Ozs7Q0FNQyxHQUNELE1BQU1vYjtJQVlGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBbUJDLEdBQ0QsTUFBTUcsWUFBWTlKLE1BQU0sRUFBRTtRQUN0QixJQUFJaGtCO1FBQ0osTUFBTSxJQUFJLENBQUMrdEIsV0FBVztRQUN0QixNQUFNQyxlQUFlbmEsU0FBU21RLE9BQU9nSixPQUFPO1FBQzVDLE1BQU1pQixrQkFBa0IsSUFBSSxDQUFDTCxZQUFZLENBQUNNLGVBQWUsQ0FBQztZQUN0RDFiLE9BQU8sSUFBSSxDQUFDQSxLQUFLO1lBQ2pCMmIsVUFBVSxJQUFJLENBQUNDLFVBQVUsQ0FBQyxNQUFNQyxNQUFNLENBQUNMO1lBQ3ZDOWMsUUFBUSxDQUFDbFIsS0FBS2drQixPQUFPOVMsTUFBTSxNQUFNLFFBQVFsUixPQUFPLEtBQUssSUFBSUEsS0FBSyxJQUFJLENBQUNrUixNQUFNO1FBQzdFO1FBQ0EsSUFBSSxDQUFDNmMsV0FBVyxHQUFHLENBQUM7WUFDaEIsSUFBSS90QixJQUFJQyxJQUFJbU47WUFDWixNQUFNN0IsV0FBVyxNQUFNMGlCO1lBQ3ZCLE1BQU1LLGdCQUFnQixDQUFDcnVCLEtBQUssQ0FBQ0QsS0FBS3VMLFNBQVNtQyxVQUFVLE1BQU0sUUFBUTFOLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsRUFBRSxDQUFDLEVBQUUsTUFBTSxRQUFRQyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUcwTixPQUFPO1lBQ2xKLG9FQUFvRTtZQUNwRSxzRUFBc0U7WUFDdEUsNENBQTRDO1lBQzVDLE1BQU00Z0Isc0NBQXNDaGpCLFNBQVNpakIsK0JBQStCO1lBQ3BGLE1BQU0xSixRQUFRLElBQUksQ0FBQ3NKLFVBQVUsQ0FBQyxNQUFNN3NCLE1BQU07WUFDMUMsSUFBSWl0QixrQ0FBa0MsRUFBRTtZQUN4QyxJQUFJRCx1Q0FBdUMsTUFBTTtnQkFDN0NDLGtDQUNJLENBQUNwaEIsS0FBS21oQixvQ0FBb0M3c0IsS0FBSyxDQUFDb2pCLE1BQUssTUFBTyxRQUFRMVgsT0FBTyxLQUFLLElBQUlBLEtBQUssRUFBRTtZQUNuRztZQUNBLE1BQU1vZ0IsY0FBY2MsZ0JBQWdCO2dCQUFDQTthQUFjLEdBQUcsRUFBRTtZQUN4RCxJQUFJLENBQUNHLGFBQWEsQ0FBQ1QsY0FBY1IsYUFBYWdCO1lBQzlDO1FBQ0o7UUFDQSxNQUFNLElBQUksQ0FBQ1QsV0FBVyxDQUFDVyxLQUFLLENBQUM7WUFDekIsdURBQXVEO1lBQ3ZELElBQUksQ0FBQ1gsV0FBVyxHQUFHL0IsUUFBUUMsT0FBTztRQUN0QztRQUNBLE9BQU9nQztJQUNYO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQXFCQyxHQUNELE1BQU1VLGtCQUFrQjNLLE1BQU0sRUFBRTtRQUM1QixJQUFJaGtCO1FBQ0osTUFBTSxJQUFJLENBQUMrdEIsV0FBVztRQUN0QixNQUFNQyxlQUFlbmEsU0FBU21RLE9BQU9nSixPQUFPO1FBQzVDLE1BQU00QixpQkFBaUIsSUFBSSxDQUFDaEIsWUFBWSxDQUFDaUIscUJBQXFCLENBQUM7WUFDM0RyYyxPQUFPLElBQUksQ0FBQ0EsS0FBSztZQUNqQjJiLFVBQVUsSUFBSSxDQUFDQyxVQUFVLENBQUMsTUFBTUMsTUFBTSxDQUFDTDtZQUN2QzljLFFBQVEsQ0FBQ2xSLEtBQUtna0IsT0FBTzlTLE1BQU0sTUFBTSxRQUFRbFIsT0FBTyxLQUFLLElBQUlBLEtBQUssSUFBSSxDQUFDa1IsTUFBTTtRQUM3RTtRQUNBLDJFQUEyRTtRQUMzRSxxRUFBcUU7UUFDckUsNENBQTRDO1FBQzVDLElBQUksQ0FBQzZjLFdBQVcsR0FBR2EsZUFDZHhILElBQUksQ0FBQyxJQUFNaG9CLFdBQ1hzdkIsS0FBSyxDQUFDLElBQU10dkI7UUFDakIsTUFBTW1NLFdBQVcsTUFBTXFqQjtRQUN2QixNQUFNM2EsU0FBUyxJQUFJLENBQUM2YSxxQkFBcUIsQ0FBQ3ZqQixVQUFVeWlCO1FBQ3BELE9BQU8vWjtJQUNYO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FzQkMsR0FDRG1hLGFBQTRCO1lBQWpCVyxVQUFBQSxpRUFBVTtRQUNqQixNQUFNM0IsVUFBVTJCLFVBQ1YxQixzQkFBc0IsSUFBSSxDQUFDRCxPQUFPLElBQ2xDLElBQUksQ0FBQ0EsT0FBTztRQUNsQixxRUFBcUU7UUFDckUsZ0JBQWdCO1FBQ2hCLE9BQU9TLGdCQUFnQlQ7SUFDM0I7SUFDQTBCLHNCQUFzQkYsY0FBYyxFQUFFWixZQUFZLEVBQUU7UUFDaEQsSUFBSWh1QixJQUFJQztRQUNSLE9BQU9vckIsaUJBQWlCLElBQUksRUFBRTJELFdBQVcsVUFBVUM7WUFDL0MsSUFBSTdoQixJQUFJOGhCLEtBQUs3aEIsSUFBSUM7WUFDakIsTUFBTWdoQixnQkFBZ0IsRUFBRTtZQUN4QixJQUFJO2dCQUNBLElBQUssSUFBSS9nQixLQUFLLE1BQU00aEIsbUJBQW1CdEMsY0FBYytCLGlCQUFpQlEsb0JBQW9CQSxxQkFBcUIsTUFBTWhFLFFBQVErRCxpQkFBaUJsSyxJQUFJLEtBQUs3WCxLQUFLZ2lCLG1CQUFtQmhLLElBQUksRUFBRSxDQUFDaFksSUFBSUcsS0FBSyxLQUFNO29CQUNqTUQsS0FBSzhoQixtQkFBbUJwdUIsS0FBSztvQkFDN0J1TSxLQUFLO29CQUNMLE1BQU04aEIsUUFBUS9oQjtvQkFDZCxJQUFJMmYsZ0JBQWdCb0MsUUFBUTt3QkFDeEIsTUFBTTFoQixVQUFVLENBQUMxTixLQUFLLENBQUNELEtBQUtxdkIsTUFBTTNoQixVQUFVLE1BQU0sUUFBUTFOLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsRUFBRSxDQUFDLEVBQUUsTUFBTSxRQUFRQyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUcwTixPQUFPO3dCQUN6SSxJQUFJQSxZQUFZdk8sV0FBVzs0QkFDdkJrdkIsY0FBY2xxQixJQUFJLENBQUN1Sjt3QkFDdkI7b0JBQ0o7b0JBQ0EsTUFBTSxNQUFNeWQsUUFBUWlFO2dCQUN4QjtZQUNKLEVBQ0EsT0FBT0MsT0FBTztnQkFBRUosTUFBTTtvQkFBRXpzQixPQUFPNnNCO2dCQUFNO1lBQUcsU0FDaEM7Z0JBQ0osSUFBSTtvQkFDQSxJQUFJLENBQUMvaEIsTUFBTSxDQUFDSCxNQUFPQyxDQUFBQSxLQUFLOGhCLGlCQUFpQjlKLE1BQU0sR0FBRyxNQUFNK0YsUUFBUS9kLEdBQUd0TSxJQUFJLENBQUNvdUI7Z0JBQzVFLFNBQ1E7b0JBQUUsSUFBSUQsS0FBSyxNQUFNQSxJQUFJenNCLEtBQUs7Z0JBQUU7WUFDeEM7WUFDQSxJQUFJLENBQUNnc0IsYUFBYSxDQUFDVCxjQUFjTTtRQUNyQztJQUNKO0lBQ0FHLGNBQWNjLFNBQVMsRUFBRS9CLFdBQVcsRUFBRWdCLCtCQUErQixFQUFFO1FBQ25FLElBQUlnQixpQkFBaUIsRUFBRTtRQUN2QixJQUFJaEMsWUFBWWpzQixNQUFNLEdBQUcsS0FDckJpc0IsWUFBWWlDLEtBQUssQ0FBQyxDQUFDOWhCLFVBQVlBLFFBQVFsQixJQUFJLEtBQUtyTixZQUFZO1lBQzVEb3dCLGlCQUFpQmhDO1FBQ3JCLE9BQ0s7WUFDRCwwRUFBMEU7WUFDMUUsd0RBQXdEO1lBQ3hEZ0MsZUFBZXByQixJQUFJLENBQUM7Z0JBQ2hCcUksTUFBTTtnQkFDTmpCLE9BQU8sRUFBRTtZQUNiO1FBQ0o7UUFDQSxJQUFJZ2pCLG1DQUNBQSxnQ0FBZ0NqdEIsTUFBTSxHQUFHLEdBQUc7WUFDNUMsSUFBSSxDQUFDNnJCLE9BQU8sQ0FBQ2hwQixJQUFJLElBQUlpcEIsc0JBQXNCbUI7UUFDL0MsT0FDSztZQUNELElBQUksQ0FBQ3BCLE9BQU8sQ0FBQ2hwQixJQUFJLENBQUNtckI7UUFDdEI7UUFDQSxJQUFJLENBQUNuQyxPQUFPLENBQUNocEIsSUFBSSxJQUFJb3JCO0lBQ3pCO0lBM0xBMWlCLFlBQVl5RixTQUFTLEVBQUVxYixZQUFZLEVBQUVwYixLQUFLLEVBQUV0QixTQUFTLENBQUMsQ0FBQyxFQUFFa2MsVUFBVSxFQUFFLENBQUU7UUFDbkUsSUFBSSxDQUFDN2EsU0FBUyxHQUFHQTtRQUNqQixJQUFJLENBQUNxYixZQUFZLEdBQUdBO1FBQ3BCLElBQUksQ0FBQ3BiLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUN0QixNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDa2MsT0FBTyxHQUFHQTtRQUNmLDRFQUE0RTtRQUM1RSxTQUFTO1FBQ1QsSUFBSSxDQUFDVyxXQUFXLEdBQUcvQixRQUFRQyxPQUFPO1FBQ2xDa0IsZ0JBQWdCQztJQUNwQjtBQWtMSjtBQUVBOzs7O0NBSUMsR0FDRDs7Q0FFQyxHQUNELE1BQU1zQyxpQkFBaUJ4dUI7SUFDbkI0TCxZQUFZNmlCLE9BQU8sQ0FBRTtRQUNqQixLQUFLLENBQUNBLFFBQVEzQyxPQUFPO1FBQ3JCLElBQUksQ0FBQzloQixJQUFJLEdBQUc7UUFDWixJQUFJLENBQUM0TCxNQUFNLEdBQUc2WSxRQUFRN1ksTUFBTTtRQUM1QmxXLE9BQU9ndkIsY0FBYyxDQUFDLElBQUksRUFBRUYsU0FBUzd1QixTQUFTO0lBQ2xEO0FBQ0o7QUFFQTs7OztDQUlDLEdBQ0QsaUVBQWlFO0FBQ2pFLFNBQVNndkIsNEJBQTRCcnJCLFVBQVU7SUFDM0MsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1xckIsV0FBV3h0QixlQUFla0MsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSXNyQixZQUFZLE1BQU07UUFDbEIzdUIsZUFBZXNELFVBQVU7WUFBQztTQUFPLEVBQUVxckI7SUFDdkM7SUFDQSxPQUFPcnJCO0FBQ1g7QUFDQSxTQUFTc3JCLDRCQUE0QnZyQixVQUFVO0lBQzNDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNeUIsc0JBQXNCNUQsZUFBZWtDLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUkwQix1QkFBdUIsTUFBTTtRQUM3Qi9FLGVBQWVzRCxVQUFVO1lBQUM7U0FBa0IsRUFBRXlCO0lBQ2xEO0lBQ0EsT0FBT3pCO0FBQ1g7QUFDQSxTQUFTdXJCLDRCQUE0QnhyQixVQUFVO0lBQzNDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNSSxXQUFXdkMsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlLLFlBQVksTUFBTTtRQUNsQjFELGVBQWVzRCxVQUFVO1lBQUM7WUFBUTtTQUFPLEVBQUUyUyxVQUFVdlM7SUFDekQ7SUFDQSxPQUFPSjtBQUNYO0FBQ0EsU0FBU3dyQiw0QkFBNEJ6ckIsVUFBVTtJQUMzQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXlCLHNCQUFzQjVELGVBQWVrQyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJMEIsdUJBQXVCLE1BQU07UUFDN0IvRSxlQUFlc0QsVUFBVTtZQUFDO1NBQWtCLEVBQUV5QjtJQUNsRDtJQUNBLE9BQU96QjtBQUNYO0FBQ0EsU0FBU3lyQix5QkFBeUIxckIsVUFBVTtJQUN4QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTUksV0FBV3ZDLGVBQWVrQyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJSyxZQUFZLE1BQU07UUFDbEIxRCxlQUFlc0QsVUFBVTtZQUFDO1lBQVE7U0FBTyxFQUFFMlMsVUFBVXZTO0lBQ3pEO0lBQ0EsT0FBT0o7QUFDWDtBQUNBLFNBQVMwckIsdUJBQXVCM3JCLFVBQVUsRUFBRStZLFlBQVk7SUFDcEQsTUFBTTlZLFdBQVcsQ0FBQztJQUNsQixNQUFNb2QsZUFBZXZmLGVBQWVrQyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJK1ksaUJBQWlCbmUsYUFBYXlpQixnQkFBZ0IsTUFBTTtRQUNwRDFnQixlQUFlb2MsY0FBYztZQUFDO1lBQVU7U0FBVyxFQUFFc0U7SUFDekQ7SUFDQSxNQUFNQyxnQkFBZ0J4ZixlQUFla0MsWUFBWTtRQUFDO0tBQVk7SUFDOUQsSUFBSStZLGlCQUFpQm5lLGFBQWEwaUIsaUJBQWlCLE1BQU07UUFDckQzZ0IsZUFBZW9jLGNBQWM7WUFBQztZQUFVO1NBQVksRUFBRXVFO0lBQzFEO0lBQ0EsT0FBT3JkO0FBQ1g7QUFDQSxTQUFTMnJCLDJCQUEyQjVyQixVQUFVO0lBQzFDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNaVosYUFBYXBiLGVBQWVrQyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJa1osY0FBYyxNQUFNO1FBQ3BCeVMsdUJBQXVCelMsWUFBWWpaO0lBQ3ZDO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLFNBQVM0ckIsMkJBQTJCN3JCLFVBQVU7SUFDMUMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU15QixzQkFBc0I1RCxlQUFla0MsWUFBWTtRQUNuRDtLQUNIO0lBQ0QsSUFBSTBCLHVCQUF1QixNQUFNO1FBQzdCL0UsZUFBZXNELFVBQVU7WUFBQztTQUFrQixFQUFFeUI7SUFDbEQ7SUFDQSxNQUFNa2Msb0JBQW9COWYsZUFBZWtDLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUk0ZCxxQkFBcUIsTUFBTTtRQUMzQmpoQixlQUFlc0QsVUFBVTtZQUFDO1NBQWdCLEVBQUUyZDtJQUNoRDtJQUNBLE1BQU1rTyxZQUFZaHVCLGVBQWVrQyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJOHJCLGFBQWEsTUFBTTtRQUNuQixJQUFJaHJCLGtCQUFrQmdyQjtRQUN0QixJQUFJM3VCLE1BQU1DLE9BQU8sQ0FBQzBELGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0I5QyxHQUFHLENBQUMsQ0FBQ2tCO2dCQUNuQyxPQUFPQTtZQUNYO1FBQ0o7UUFDQXZDLGVBQWVzRCxVQUFVO1lBQUM7U0FBUSxFQUFFYTtJQUN4QztJQUNBLE9BQU9iO0FBQ1g7QUFFQTs7OztDQUlDLEdBQ0QsTUFBTThyQixjQUFjbndCO0lBc0JoQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBMENDLEdBQ0QsTUFBTW93QixPQUFPeE0sTUFBTSxFQUFFO1FBQ2pCLElBQUksSUFBSSxDQUFDelIsU0FBUyxDQUFDRyxVQUFVLElBQUk7WUFDN0IsTUFBTSxJQUFJeFIsTUFBTTtRQUNwQjtRQUNBLE9BQU8sSUFBSSxDQUFDcVIsU0FBUyxDQUNoQmtlLFVBQVUsQ0FBQ3pNLE9BQU8wTSxJQUFJLEVBQUUxTSxPQUFPOVMsTUFBTSxFQUNyQ2tXLElBQUksQ0FBQyxDQUFDRTtZQUNQLE9BQU9BO1FBQ1g7SUFDSjtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7S0FlQyxHQUNELE1BQU1xSixTQUFTM00sTUFBTSxFQUFFO1FBQ25CLE1BQU0sSUFBSSxDQUFDelIsU0FBUyxDQUFDcWUsWUFBWSxDQUFDNU07SUFDdEM7SUFDQSxNQUFNMEQsYUFBYTFELE1BQU0sRUFBRTtRQUN2QixJQUFJaGtCLElBQUlDO1FBQ1IsSUFBSXNMO1FBQ0osSUFBSXFhLE9BQU87UUFDWCxJQUFJbUIsY0FBYyxDQUFDO1FBQ25CLElBQUksSUFBSSxDQUFDeFUsU0FBUyxDQUFDRyxVQUFVLElBQUk7WUFDN0IsTUFBTSxJQUFJeFIsTUFBTTtRQUNwQixPQUNLO1lBQ0QsTUFBTXdrQixPQUFPMEssMkJBQTJCcE07WUFDeEM0QixPQUFPdmxCLFVBQVUsU0FBU3FsQixJQUFJLENBQUMsT0FBTztZQUN0Q3FCLGNBQWNyQixJQUFJLENBQUMsU0FBUztZQUM1QixPQUFPQSxJQUFJLENBQUMsT0FBTztZQUNuQixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQm5hLFdBQVcsSUFBSSxDQUFDZ0gsU0FBUyxDQUNwQmdULE9BQU8sQ0FBQztnQkFDVEssTUFBTUE7Z0JBQ05tQixhQUFhQTtnQkFDYnJCLE1BQU1zQixLQUFLQyxTQUFTLENBQUN2QjtnQkFDckJ3QixZQUFZO2dCQUNadG5CLGFBQWEsQ0FBQ0ksS0FBS2drQixPQUFPOVMsTUFBTSxNQUFNLFFBQVFsUixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdKLFdBQVc7Z0JBQ3JGdW5CLGFBQWEsQ0FBQ2xuQixLQUFLK2pCLE9BQU85UyxNQUFNLE1BQU0sUUFBUWpSLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2tuQixXQUFXO1lBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQztnQkFDUCxPQUFPQSxhQUFhemEsSUFBSSxHQUFHd2EsSUFBSSxDQUFDLENBQUNPO29CQUM3QixNQUFNcGMsV0FBV29jO29CQUNqQnBjLFNBQVM2WSxlQUFlLEdBQUc7d0JBQ3ZCclgsU0FBU3NhLGFBQWF0YSxPQUFPO29CQUNqQztvQkFDQSxPQUFPeEI7Z0JBQ1g7WUFDSjtZQUNBLE9BQU9BLFNBQVM2YixJQUFJLENBQUMsQ0FBQy9YO2dCQUNsQixNQUFNaVksT0FBTytJLDJCQUEyQmhoQjtnQkFDeEMsTUFBTXVZLFlBQVksSUFBSTFYO2dCQUN0QnRQLE9BQU93QixNQUFNLENBQUN3bEIsV0FBV047Z0JBQ3pCLE9BQU9NO1lBQ1g7UUFDSjtJQUNKO0lBQ0EsTUFBTWQsZUFBZTlDLE1BQU0sRUFBRTtRQUN6QixJQUFJaGtCLElBQUlDO1FBQ1IsSUFBSXNMO1FBQ0osSUFBSXFhLE9BQU87UUFDWCxJQUFJbUIsY0FBYyxDQUFDO1FBQ25CLElBQUksSUFBSSxDQUFDeFUsU0FBUyxDQUFDRyxVQUFVLElBQUk7WUFDN0IsTUFBTSxJQUFJeFIsTUFBTTtRQUNwQixPQUNLO1lBQ0QsTUFBTXdrQixPQUFPbUssNEJBQTRCN0w7WUFDekM0QixPQUFPdmxCLFVBQVUsdUJBQXVCcWxCLElBQUksQ0FBQyxPQUFPO1lBQ3BEcUIsY0FBY3JCLElBQUksQ0FBQyxTQUFTO1lBQzVCLE9BQU9BLElBQUksQ0FBQyxPQUFPO1lBQ25CLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCbmEsV0FBVyxJQUFJLENBQUNnSCxTQUFTLENBQ3BCZ1QsT0FBTyxDQUFDO2dCQUNUSyxNQUFNQTtnQkFDTm1CLGFBQWFBO2dCQUNickIsTUFBTXNCLEtBQUtDLFNBQVMsQ0FBQ3ZCO2dCQUNyQndCLFlBQVk7Z0JBQ1p0bkIsYUFBYSxDQUFDSSxLQUFLZ2tCLE9BQU85UyxNQUFNLE1BQU0sUUFBUWxSLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0osV0FBVztnQkFDckZ1bkIsYUFBYSxDQUFDbG5CLEtBQUsrakIsT0FBTzlTLE1BQU0sTUFBTSxRQUFRalIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHa25CLFdBQVc7WUFDekYsR0FDS0MsSUFBSSxDQUFDLENBQUNDO2dCQUNQLE9BQU9BLGFBQWF6YSxJQUFJO1lBQzVCO1lBQ0EsT0FBT3JCLFNBQVM2YixJQUFJLENBQUMsQ0FBQy9YO2dCQUNsQixNQUFNaVksT0FBT3lJLDRCQUE0QjFnQjtnQkFDekMsTUFBTXVZLFlBQVksSUFBSXpYO2dCQUN0QnZQLE9BQU93QixNQUFNLENBQUN3bEIsV0FBV047Z0JBQ3pCLE9BQU9NO1lBQ1g7UUFDSjtJQUNKO0lBQ0E7Ozs7Ozs7Ozs7Ozs7O0tBY0MsR0FDRCxNQUFNSixJQUFJeEQsTUFBTSxFQUFFO1FBQ2QsSUFBSWhrQixJQUFJQztRQUNSLElBQUlzTDtRQUNKLElBQUlxYSxPQUFPO1FBQ1gsSUFBSW1CLGNBQWMsQ0FBQztRQUNuQixJQUFJLElBQUksQ0FBQ3hVLFNBQVMsQ0FBQ0csVUFBVSxJQUFJO1lBQzdCLE1BQU0sSUFBSXhSLE1BQU07UUFDcEIsT0FDSztZQUNELE1BQU13a0IsT0FBT3dLLHlCQUF5QmxNO1lBQ3RDNEIsT0FBT3ZsQixVQUFVLGdCQUFnQnFsQixJQUFJLENBQUMsT0FBTztZQUM3Q3FCLGNBQWNyQixJQUFJLENBQUMsU0FBUztZQUM1QixPQUFPQSxJQUFJLENBQUMsT0FBTztZQUNuQixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQm5hLFdBQVcsSUFBSSxDQUFDZ0gsU0FBUyxDQUNwQmdULE9BQU8sQ0FBQztnQkFDVEssTUFBTUE7Z0JBQ05tQixhQUFhQTtnQkFDYnJCLE1BQU1zQixLQUFLQyxTQUFTLENBQUN2QjtnQkFDckJ3QixZQUFZO2dCQUNadG5CLGFBQWEsQ0FBQ0ksS0FBS2drQixPQUFPOVMsTUFBTSxNQUFNLFFBQVFsUixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdKLFdBQVc7Z0JBQ3JGdW5CLGFBQWEsQ0FBQ2xuQixLQUFLK2pCLE9BQU85UyxNQUFNLE1BQU0sUUFBUWpSLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2tuQixXQUFXO1lBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQztnQkFDUCxPQUFPQSxhQUFhemEsSUFBSTtZQUM1QjtZQUNBLE9BQU9yQixTQUFTNmIsSUFBSSxDQUFDLENBQUNFO2dCQUNsQixPQUFPQTtZQUNYO1FBQ0o7SUFDSjtJQUNBOzs7Ozs7Ozs7Ozs7S0FZQyxHQUNELE1BQU1PLE9BQU83RCxNQUFNLEVBQUU7UUFDakIsSUFBSWhrQixJQUFJQztRQUNSLElBQUlzTDtRQUNKLElBQUlxYSxPQUFPO1FBQ1gsSUFBSW1CLGNBQWMsQ0FBQztRQUNuQixJQUFJLElBQUksQ0FBQ3hVLFNBQVMsQ0FBQ0csVUFBVSxJQUFJO1lBQzdCLE1BQU0sSUFBSXhSLE1BQU07UUFDcEIsT0FDSztZQUNELE1BQU13a0IsT0FBT3NLLDRCQUE0QmhNO1lBQ3pDNEIsT0FBT3ZsQixVQUFVLGdCQUFnQnFsQixJQUFJLENBQUMsT0FBTztZQUM3Q3FCLGNBQWNyQixJQUFJLENBQUMsU0FBUztZQUM1QixPQUFPQSxJQUFJLENBQUMsT0FBTztZQUNuQixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQm5hLFdBQVcsSUFBSSxDQUFDZ0gsU0FBUyxDQUNwQmdULE9BQU8sQ0FBQztnQkFDVEssTUFBTUE7Z0JBQ05tQixhQUFhQTtnQkFDYnJCLE1BQU1zQixLQUFLQyxTQUFTLENBQUN2QjtnQkFDckJ3QixZQUFZO2dCQUNadG5CLGFBQWEsQ0FBQ0ksS0FBS2drQixPQUFPOVMsTUFBTSxNQUFNLFFBQVFsUixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdKLFdBQVc7Z0JBQ3JGdW5CLGFBQWEsQ0FBQ2xuQixLQUFLK2pCLE9BQU85UyxNQUFNLE1BQU0sUUFBUWpSLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2tuQixXQUFXO1lBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQztnQkFDUCxPQUFPQSxhQUFhemEsSUFBSSxHQUFHd2EsSUFBSSxDQUFDLENBQUNPO29CQUM3QixNQUFNcGMsV0FBV29jO29CQUNqQnBjLFNBQVM2WSxlQUFlLEdBQUc7d0JBQ3ZCclgsU0FBU3NhLGFBQWF0YSxPQUFPO29CQUNqQztvQkFDQSxPQUFPeEI7Z0JBQ1g7WUFDSjtZQUNBLE9BQU9BLFNBQVM2YixJQUFJLENBQUMsQ0FBQy9YO2dCQUNsQixNQUFNaVksT0FBTzJJLDRCQUE0QjVnQjtnQkFDekMsTUFBTXVZLFlBQVksSUFBSXhYO2dCQUN0QnhQLE9BQU93QixNQUFNLENBQUN3bEIsV0FBV047Z0JBQ3pCLE9BQU9NO1lBQ1g7UUFDSjtJQUNKO0lBelFBOWEsWUFBWXlGLFNBQVMsQ0FBRTs7UUFDbkIsS0FBSztRQUNMLElBQUksQ0FBQ0EsU0FBUyxHQUFHQTtRQUNqQjs7Ozs7Ozs7Ozs7OztTQWFDLEdBQ0QsSUFBSSxDQUFDdVYsSUFBSSxHQUFHO2dCQUFPOUQsMEVBQVMsQ0FBQztZQUN6QixPQUFPLElBQUlGLE1BQU1ELFVBQVVnTixnQkFBZ0IsRUFBRSxDQUFDN0ksSUFBTSxNQUFLTixZQUFZLENBQUNNLElBQUksTUFBTSxNQUFLTixZQUFZLENBQUMxRCxTQUFTQTtRQUMvRztJQUNKO0FBc1BKO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVM4TSxjQUFjdHNCLFVBQVU7SUFDN0IsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU15WCxXQUFXNVosZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUkwWCxZQUFZLE1BQU07UUFDbEIvYSxlQUFlc0QsVUFBVTtZQUFDO1NBQU8sRUFBRXlYO0lBQ3ZDO0lBQ0EsSUFBSTVaLGVBQWVrQyxZQUFZO1FBQUM7S0FBYyxNQUFNcEYsV0FBVztRQUMzRCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTXVGLGVBQWVuRSxlQUFla0MsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSWlDLGdCQUFnQixNQUFNO1FBQ3RCdEYsZUFBZXNELFVBQVU7WUFBQztTQUFXLEVBQUVnQztJQUMzQztJQUNBLE9BQU9oQztBQUNYO0FBQ0EsU0FBU3NzQixpQkFBaUJ2c0IsVUFBVTtJQUNoQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTTBZLFlBQVk3YSxlQUFla0MsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSTJZLGFBQWEsTUFBTTtRQUNuQixJQUFJN1gsa0JBQWtCNlg7UUFDdEIsSUFBSXhiLE1BQU1DLE9BQU8sQ0FBQzBELGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0I5QyxHQUFHLENBQUMsQ0FBQ2tCO2dCQUNuQyxPQUFPc3RCLGNBQWN0dEI7WUFDekI7UUFDSjtRQUNBdkMsZUFBZXNELFVBQVU7WUFBQztTQUFRLEVBQUVhO0lBQ3hDO0lBQ0EsTUFBTStYLFdBQVcvYSxlQUFla0MsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSTZZLFlBQVksTUFBTTtRQUNsQmxjLGVBQWVzRCxVQUFVO1lBQUM7U0FBTyxFQUFFNFk7SUFDdkM7SUFDQSxPQUFPNVk7QUFDWDtBQUNBLFNBQVN3c0Isa0JBQWtCenNCLFVBQVU7SUFDakMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLElBQUluQyxlQUFla0MsWUFBWTtRQUFDO0tBQWMsTUFBTXBGLFdBQVc7UUFDM0QsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE1BQU13ZCxjQUFjcGMsZUFBZWtDLFlBQVk7UUFBQztLQUFVO0lBQzFELElBQUlrYSxlQUFlLE1BQU07UUFDckJ2ZCxlQUFlc0QsVUFBVTtZQUFDO1NBQVUsRUFBRWlhO0lBQzFDO0lBQ0EsTUFBTWpZLGVBQWVuRSxlQUFla0MsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSWlDLGdCQUFnQixNQUFNO1FBQ3RCdEYsZUFBZXNELFVBQVU7WUFBQztTQUFXLEVBQUVnQztJQUMzQztJQUNBLE9BQU9oQztBQUNYO0FBQ0EsU0FBU3lzQixzQkFBc0Ixc0IsVUFBVTtJQUNyQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTW1hLFNBQVN0YyxlQUFla0MsWUFBWTtRQUFDO0tBQUs7SUFDaEQsSUFBSW9hLFVBQVUsTUFBTTtRQUNoQnpkLGVBQWVzRCxVQUFVO1lBQUM7U0FBSyxFQUFFbWE7SUFDckM7SUFDQSxNQUFNQyxXQUFXdmMsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlxYSxZQUFZLE1BQU07UUFDbEIxZCxlQUFlc0QsVUFBVTtZQUFDO1NBQU8sRUFBRW9hO0lBQ3ZDO0lBQ0EsTUFBTWhhLFdBQVd2QyxlQUFla0MsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSUssWUFBWSxNQUFNO1FBQ2xCMUQsZUFBZXNELFVBQVU7WUFBQztTQUFPLEVBQUVJO0lBQ3ZDO0lBQ0EsSUFBSXZDLGVBQWVrQyxZQUFZO1FBQUM7S0FBYyxNQUFNcEYsV0FBVztRQUMzRCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsSUFBSW9CLGVBQWVrQyxZQUFZO1FBQUM7S0FBZSxNQUFNcEYsV0FBVztRQUM1RCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsT0FBT3VEO0FBQ1g7QUFDQSxTQUFTMHNCLDhCQUE4QjNzQixVQUFVO0lBQzdDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixJQUFJbkMsZUFBZWtDLFlBQVk7UUFBQztLQUFXLE1BQU1wRixXQUFXO1FBQ3hELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxNQUFNc29CLGtCQUFrQmxuQixlQUFla0MsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSWdsQixtQkFBbUIsTUFBTTtRQUN6QnJvQixlQUFlc0QsVUFBVTtZQUFDO1NBQWMsRUFBRStrQjtJQUM5QztJQUNBLE1BQU0za0IsV0FBV3ZDLGVBQWVrQyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJSyxZQUFZLE1BQU07UUFDbEIxRCxlQUFlc0QsVUFBVTtZQUFDO1NBQU8sRUFBRUk7SUFDdkM7SUFDQSxNQUFNNGtCLGlCQUFpQm5uQixlQUFla0MsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSWlsQixrQkFBa0IsTUFBTTtRQUN4QnRvQixlQUFlc0QsVUFBVTtZQUFDO1NBQWEsRUFBRWdsQjtJQUM3QztJQUNBLE1BQU1DLDJCQUEyQnBuQixlQUFla0MsWUFBWTtRQUN4RDtLQUNIO0lBQ0QsSUFBSWtsQiw0QkFBNEIsTUFBTTtRQUNsQ3ZvQixlQUFlc0QsVUFBVTtZQUFDO1NBQXVCLEVBQUVpbEI7SUFDdkQ7SUFDQSxNQUFNemtCLGVBQWUzQyxlQUFla0MsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSVMsZ0JBQWdCLE1BQU07UUFDdEI5RCxlQUFlc0QsVUFBVTtZQUFDO1NBQVcsRUFBRVE7SUFDM0M7SUFDQSxNQUFNK2EseUJBQXlCMWQsZUFBZWtDLFlBQVk7UUFDdEQ7S0FDSDtJQUNELElBQUl3YiwwQkFBMEIsTUFBTTtRQUNoQzdlLGVBQWVzRCxVQUFVO1lBQUM7U0FBcUIsRUFBRXViO0lBQ3JEO0lBQ0EsT0FBT3ZiO0FBQ1g7QUFDQSxTQUFTMnNCLDJCQUEyQjVzQixVQUFVO0lBQzFDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNNHNCLDJCQUEyQi91QixlQUFla0MsWUFBWTtRQUN4RDtLQUNIO0lBQ0QsSUFBSTZzQiw0QkFBNEIsTUFBTTtRQUNsQ2x3QixlQUFlc0QsVUFBVTtZQUFDO1NBQWMsRUFBRTRzQjtJQUM5QztJQUNBLE1BQU1yUix5QkFBeUIxZCxlQUFla0MsWUFBWTtRQUN0RDtLQUNIO0lBQ0QsSUFBSXdiLDBCQUEwQixNQUFNO1FBQ2hDN2UsZUFBZXNELFVBQVU7WUFBQztTQUFxQixFQUFFdWI7SUFDckQ7SUFDQSxNQUFNc1IscUJBQXFCaHZCLGVBQWVrQyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJOHNCLHNCQUFzQixNQUFNO1FBQzVCbndCLGVBQWVzRCxVQUFVO1lBQUM7U0FBaUIsRUFBRTZzQjtJQUNqRDtJQUNBLE1BQU1oUyxxQkFBcUJoZCxlQUFla0MsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSThhLHNCQUFzQixNQUFNO1FBQzVCbmUsZUFBZXNELFVBQVU7WUFBQztTQUFpQixFQUFFNmE7SUFDakQ7SUFDQSxNQUFNaVMsNEJBQTRCanZCLGVBQWVrQyxZQUFZO1FBQ3pEO0tBQ0g7SUFDRCxJQUFJK3NCLDZCQUE2QixNQUFNO1FBQ25DcHdCLGVBQWVzRCxVQUFVO1lBQUM7U0FBd0IsRUFBRThzQjtJQUN4RDtJQUNBLE1BQU0zUix1QkFBdUJ0ZCxlQUFla0MsWUFBWTtRQUNwRDtLQUNIO0lBQ0QsSUFBSW9iLHdCQUF3QixNQUFNO1FBQzlCemUsZUFBZXNELFVBQVU7WUFBQztTQUFtQixFQUFFbWI7SUFDbkQ7SUFDQSxNQUFNRixlQUFlcGQsZUFBZWtDLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlrYixnQkFBZ0IsTUFBTTtRQUN0QnZlLGVBQWVzRCxVQUFVO1lBQUM7U0FBVyxFQUFFaWI7SUFDM0M7SUFDQSxNQUFNSCxzQkFBc0JqZCxlQUFla0MsWUFBWTtRQUNuRDtLQUNIO0lBQ0QsSUFBSSthLHVCQUF1QixNQUFNO1FBQzdCcGUsZUFBZXNELFVBQVU7WUFBQztTQUFrQixFQUFFOGE7SUFDbEQ7SUFDQSxNQUFNa0Isc0JBQXNCbmUsZUFBZWtDLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUlpYyx1QkFBdUIsTUFBTTtRQUM3QnRmLGVBQWVzRCxVQUFVO1lBQUM7U0FBa0IsRUFBRWdjO0lBQ2xEO0lBQ0EsTUFBTWQsc0JBQXNCcmQsZUFBZWtDLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUltYix1QkFBdUIsTUFBTTtRQUM3QnhlLGVBQWVzRCxVQUFVO1lBQUM7U0FBa0IsRUFBRWtiO0lBQ2xEO0lBQ0EsTUFBTUYsdUJBQXVCbmQsZUFBZWtDLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUlpYix3QkFBd0IsTUFBTTtRQUM5QnRlLGVBQWVzRCxVQUFVO1lBQUM7U0FBbUIsRUFBRWdiO0lBQ25EO0lBQ0EsTUFBTUssdUJBQXVCeGQsZUFBZWtDLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUlzYix3QkFBd0IsTUFBTTtRQUM5QjNlLGVBQWVzRCxVQUFVO1lBQUM7U0FBbUIsRUFBRXFiO0lBQ25EO0lBQ0EsTUFBTVUseUJBQXlCbGUsZUFBZWtDLFlBQVk7UUFDdEQ7S0FDSDtJQUNELElBQUlnYywwQkFBMEIsTUFBTTtRQUNoQ3JmLGVBQWVzRCxVQUFVO1lBQUM7U0FBcUIsRUFBRStiO0lBQ3JEO0lBQ0EsTUFBTVQscUJBQXFCemQsZUFBZWtDLFlBQVk7UUFDbEQ7S0FDSDtJQUNELElBQUl1YixzQkFBc0IsTUFBTTtRQUM1QjVlLGVBQWVzRCxVQUFVO1lBQUM7U0FBaUIsRUFBRXNiO0lBQ2pEO0lBQ0EsTUFBTXlSLG9CQUFvQmx2QixlQUFla0MsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSWd0QixxQkFBcUIsTUFBTTtRQUMzQnJ3QixlQUFlc0QsVUFBVTtZQUFDO1NBQWdCLEVBQUUrc0I7SUFDaEQ7SUFDQSxNQUFNM1IsV0FBV3ZkLGVBQWVrQyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJcWIsWUFBWSxNQUFNO1FBQ2xCMWUsZUFBZXNELFVBQVU7WUFBQztTQUFPLEVBQUVvYjtJQUN2QztJQUNBLE1BQU1hLG1CQUFtQnBlLGVBQWVrQyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJa2Msb0JBQW9CLE1BQU07UUFDMUJ2ZixlQUFlc0QsVUFBVTtZQUFDO1NBQWUsRUFBRWd0Qix1QkFBdUIvUTtJQUN0RTtJQUNBLE1BQU1sQixvQkFBb0JsZCxlQUFla0MsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSWdiLHFCQUFxQixNQUFNO1FBQzNCcmUsZUFBZXNELFVBQVU7WUFBQztTQUFnQixFQUFFK2E7SUFDaEQ7SUFDQSxNQUFNTCxrQkFBa0I3YyxlQUFla0MsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSTJhLG1CQUFtQixNQUFNO1FBQ3pCaGUsZUFBZXNELFVBQVU7WUFBQztTQUFjLEVBQUUwYTtJQUM5QztJQUNBLE1BQU13QixxQkFBcUJyZSxlQUFla0MsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSW1jLHNCQUFzQixNQUFNO1FBQzVCeGYsZUFBZXNELFVBQVU7WUFBQztTQUFpQixFQUFFa2M7SUFDakQ7SUFDQSxNQUFNdEIsV0FBVy9jLGVBQWVrQyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJNmEsWUFBWSxNQUFNO1FBQ2xCbGUsZUFBZXNELFVBQVU7WUFBQztTQUFPLEVBQUU0YTtJQUN2QztJQUNBLE1BQU1ELFdBQVc5YyxlQUFla0MsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSTRhLFlBQVksTUFBTTtRQUNsQmplLGVBQWVzRCxVQUFVO1lBQUM7U0FBTyxFQUFFMmE7SUFDdkM7SUFDQSxJQUFJOWMsZUFBZWtDLFlBQVk7UUFBQztLQUE2QixNQUN6RHBGLFdBQVc7UUFDWCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsT0FBT3VEO0FBQ1g7QUFDQSxTQUFTaXRCLG9CQUFvQmx0QixVQUFVO0lBQ25DLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixJQUFJbkMsZUFBZWtDLFlBQVk7UUFBQztLQUFhLE1BQU1wRixXQUFXO1FBQzFELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxNQUFNcWdCLG1CQUFtQmpmLGVBQWVrQyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJK2Msb0JBQW9CLE1BQU07UUFDMUJwZ0IsZUFBZXNELFVBQVU7WUFBQztTQUFlLEVBQUU4YztJQUMvQztJQUNBLE9BQU85YztBQUNYO0FBQ0EsU0FBU2t0QixzQkFBc0JudEIsVUFBVTtJQUNyQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsSUFBSW5DLGVBQWVrQyxZQUFZO1FBQUM7S0FBaUIsTUFBTXBGLFdBQVc7UUFDOUQsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLElBQUlvQixlQUFla0MsWUFBWTtRQUFDO0tBQXFCLE1BQU1wRixXQUFXO1FBQ2xFLE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxNQUFNdWdCLHNCQUFzQm5mLGVBQWVrQyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJaWQsdUJBQXVCLE1BQU07UUFDN0J0Z0IsZUFBZXNELFVBQVU7WUFBQztTQUFrQixFQUFFZ2Q7SUFDbEQ7SUFDQSxPQUFPaGQ7QUFDWDtBQUNBLFNBQVNtdEIsMkJBQTJCcHRCLFVBQVUsRUFBRStZLFlBQVk7SUFDeEQsTUFBTTlZLFdBQVcsQ0FBQztJQUNsQixNQUFNb3RCLHVCQUF1QnZ2QixlQUFla0MsWUFBWTtRQUNwRDtLQUNIO0lBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWF5eUIsd0JBQXdCLE1BQU07UUFDNUQxd0IsZUFBZW9jLGNBQWM7WUFBQztZQUFTO1NBQW1CLEVBQUVzVTtJQUNoRTtJQUNBLE1BQU1yUix5QkFBeUJsZSxlQUFla0MsWUFBWTtRQUN0RDtLQUNIO0lBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWFvaEIsMEJBQTBCLE1BQU07UUFDOURyZixlQUFlb2MsY0FBYztZQUFDO1lBQVM7WUFBb0I7U0FBcUIsRUFBRWlEO0lBQ3RGO0lBQ0EsTUFBTXJCLGtCQUFrQjdjLGVBQWVrQyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJK1ksaUJBQWlCbmUsYUFBYStmLG1CQUFtQixNQUFNO1FBQ3ZEaGUsZUFBZW9jLGNBQWM7WUFBQztZQUFTO1lBQW9CO1NBQWMsRUFBRTRCO0lBQy9FO0lBQ0EsTUFBTUMsV0FBVzljLGVBQWVrQyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJK1ksaUJBQWlCbmUsYUFBYWdnQixZQUFZLE1BQU07UUFDaERqZSxlQUFlb2MsY0FBYztZQUFDO1lBQVM7WUFBb0I7U0FBTyxFQUFFNkI7SUFDeEU7SUFDQSxNQUFNQyxXQUFXL2MsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUkrWSxpQkFBaUJuZSxhQUFhaWdCLFlBQVksTUFBTTtRQUNoRGxlLGVBQWVvYyxjQUFjO1lBQUM7WUFBUztZQUFvQjtTQUFPLEVBQUU4QjtJQUN4RTtJQUNBLE1BQU1FLHNCQUFzQmpkLGVBQWVrQyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJK1ksaUJBQWlCbmUsYUFBYW1nQix1QkFBdUIsTUFBTTtRQUMzRHBlLGVBQWVvYyxjQUFjO1lBQUM7WUFBUztZQUFvQjtTQUFrQixFQUFFZ0M7SUFDbkY7SUFDQSxNQUFNa0Isc0JBQXNCbmUsZUFBZWtDLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhcWhCLHVCQUF1QixNQUFNO1FBQzNEdGYsZUFBZW9jLGNBQWM7WUFBQztZQUFTO1lBQW9CO1NBQWtCLEVBQUVrRDtJQUNuRjtJQUNBLE1BQU1aLFdBQVd2ZCxlQUFla0MsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSStZLGlCQUFpQm5lLGFBQWF5Z0IsWUFBWSxNQUFNO1FBQ2hEMWUsZUFBZW9jLGNBQWM7WUFBQztZQUFTO1lBQW9CO1NBQU8sRUFBRXNDO0lBQ3hFO0lBQ0EsTUFBTWEsbUJBQW1CcGUsZUFBZWtDLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUkrWSxpQkFBaUJuZSxhQUFhc2hCLG9CQUFvQixNQUFNO1FBQ3hEdmYsZUFBZW9jLGNBQWM7WUFBQztZQUFTO1lBQW9CO1NBQWUsRUFBRTFILGtCQUFrQjZLO0lBQ2xHO0lBQ0EsTUFBTUMscUJBQXFCcmUsZUFBZWtDLFlBQVk7UUFDbEQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhdWhCLHNCQUFzQixNQUFNO1FBQzFEeGYsZUFBZW9jLGNBQWM7WUFBQztZQUFTO1lBQW9CO1NBQWlCLEVBQUVvRDtJQUNsRjtJQUNBLE1BQU00USw0QkFBNEJqdkIsZUFBZWtDLFlBQVk7UUFDekQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhbXlCLDZCQUE2QixNQUFNO1FBQ2pFcHdCLGVBQWVvYyxjQUFjO1lBQUM7WUFBUztZQUFvQjtTQUF3QixFQUFFZ1U7SUFDekY7SUFDQSxNQUFNclMsd0JBQXdCNWMsZUFBZWtDLFlBQVk7UUFDckQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhOGYseUJBQXlCLE1BQU07UUFDN0QvZCxlQUFlb2MsY0FBYztZQUFDO1lBQVM7U0FBb0IsRUFBRXdULGlCQUFpQmxkLFNBQVNxTDtJQUMzRjtJQUNBLE1BQU1pQixZQUFZN2QsZUFBZWtDLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUkrWSxpQkFBaUJuZSxhQUFhK2dCLGFBQWEsTUFBTTtRQUNqRCxJQUFJN2Esa0JBQWtCK1EsT0FBTzhKO1FBQzdCLElBQUl4ZSxNQUFNQyxPQUFPLENBQUMwRCxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCOUMsR0FBRyxDQUFDLENBQUNrQjtnQkFDbkMsT0FBT291QixjQUFjaGMsTUFBTXBTO1lBQy9CO1FBQ0o7UUFDQXZDLGVBQWVvYyxjQUFjO1lBQUM7WUFBUztTQUFRLEVBQUVqWTtJQUNyRDtJQUNBLE1BQU15c0Isd0JBQXdCenZCLGVBQWVrQyxZQUFZO1FBQ3JEO0tBQ0g7SUFDRCxJQUFJK1ksaUJBQWlCbmUsYUFBYTJ5Qix5QkFBeUIsTUFBTTtRQUM3RDV3QixlQUFlb2MsY0FBYztZQUFDO1lBQVM7U0FBb0IsRUFBRXlVLGlDQUFpQ0Q7SUFDbEc7SUFDQSxNQUFNRSw4QkFBOEIzdkIsZUFBZWtDLFlBQVk7UUFDM0Q7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhNnlCLCtCQUErQixNQUFNO1FBQ25FOXdCLGVBQWVvYyxjQUFjO1lBQUM7WUFBUztTQUEwQixFQUFFMFU7SUFDdkU7SUFDQSxNQUFNQywrQkFBK0I1dkIsZUFBZWtDLFlBQVk7UUFDNUQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhOHlCLGdDQUFnQyxNQUFNO1FBQ3BFL3dCLGVBQWVvYyxjQUFjO1lBQUM7WUFBUztTQUEyQixFQUFFMlU7SUFDeEU7SUFDQSxNQUFNQywwQkFBMEI3dkIsZUFBZWtDLFlBQVk7UUFDdkQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhK3lCLDJCQUEyQixNQUFNO1FBQy9EaHhCLGVBQWVvYyxjQUFjO1lBQUM7WUFBUztTQUFzQixFQUFFNFU7SUFDbkU7SUFDQSxNQUFNQywrQkFBK0I5dkIsZUFBZWtDLFlBQVk7UUFDNUQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhZ3pCLGdDQUFnQyxNQUFNO1FBQ3BFanhCLGVBQWVvYyxjQUFjO1lBQUM7WUFBUztTQUEyQixFQUFFNlU7SUFDeEU7SUFDQSxNQUFNQyxrQkFBa0IvdkIsZUFBZWtDLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUkrWSxpQkFBaUJuZSxhQUFhaXpCLG1CQUFtQixNQUFNO1FBQ3ZEbHhCLGVBQWVvYyxjQUFjO1lBQUM7WUFBUztTQUFjLEVBQUU4VTtJQUMzRDtJQUNBLE9BQU81dEI7QUFDWDtBQUNBLFNBQVM2dEIsMEJBQTBCOXRCLFVBQVUsRUFBRStZLFlBQVk7SUFDdkQsTUFBTTlZLFdBQVcsQ0FBQztJQUNsQixNQUFNb3RCLHVCQUF1QnZ2QixlQUFla0MsWUFBWTtRQUNwRDtLQUNIO0lBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWF5eUIsd0JBQXdCLE1BQU07UUFDNUQxd0IsZUFBZW9jLGNBQWM7WUFBQztZQUFTO1NBQW1CLEVBQUU2VCwyQkFBMkJTO0lBQzNGO0lBQ0EsTUFBTXJSLHlCQUF5QmxlLGVBQWVrQyxZQUFZO1FBQ3REO0tBQ0g7SUFDRCxJQUFJK1ksaUJBQWlCbmUsYUFBYW9oQiwwQkFBMEIsTUFBTTtRQUM5RHJmLGVBQWVvYyxjQUFjO1lBQUM7WUFBUztZQUFvQjtTQUFxQixFQUFFaUQ7SUFDdEY7SUFDQSxNQUFNckIsa0JBQWtCN2MsZUFBZWtDLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUkrWSxpQkFBaUJuZSxhQUFhK2YsbUJBQW1CLE1BQU07UUFDdkRoZSxlQUFlb2MsY0FBYztZQUFDO1lBQVM7WUFBb0I7U0FBYyxFQUFFNEI7SUFDL0U7SUFDQSxNQUFNQyxXQUFXOWMsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUkrWSxpQkFBaUJuZSxhQUFhZ2dCLFlBQVksTUFBTTtRQUNoRGplLGVBQWVvYyxjQUFjO1lBQUM7WUFBUztZQUFvQjtTQUFPLEVBQUU2QjtJQUN4RTtJQUNBLE1BQU1DLFdBQVcvYyxlQUFla0MsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSStZLGlCQUFpQm5lLGFBQWFpZ0IsWUFBWSxNQUFNO1FBQ2hEbGUsZUFBZW9jLGNBQWM7WUFBQztZQUFTO1lBQW9CO1NBQU8sRUFBRThCO0lBQ3hFO0lBQ0EsTUFBTUUsc0JBQXNCamQsZUFBZWtDLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhbWdCLHVCQUF1QixNQUFNO1FBQzNEcGUsZUFBZW9jLGNBQWM7WUFBQztZQUFTO1lBQW9CO1NBQWtCLEVBQUVnQztJQUNuRjtJQUNBLE1BQU1rQixzQkFBc0JuZSxlQUFla0MsWUFBWTtRQUNuRDtLQUNIO0lBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWFxaEIsdUJBQXVCLE1BQU07UUFDM0R0ZixlQUFlb2MsY0FBYztZQUFDO1lBQVM7WUFBb0I7U0FBa0IsRUFBRWtEO0lBQ25GO0lBQ0EsTUFBTVosV0FBV3ZkLGVBQWVrQyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJK1ksaUJBQWlCbmUsYUFBYXlnQixZQUFZLE1BQU07UUFDaEQxZSxlQUFlb2MsY0FBYztZQUFDO1lBQVM7WUFBb0I7U0FBTyxFQUFFc0M7SUFDeEU7SUFDQSxNQUFNYSxtQkFBbUJwZSxlQUFla0MsWUFBWTtRQUFDO0tBQWU7SUFDcEUsSUFBSStZLGlCQUFpQm5lLGFBQWFzaEIsb0JBQW9CLE1BQU07UUFDeER2ZixlQUFlb2MsY0FBYztZQUFDO1lBQVM7WUFBb0I7U0FBZSxFQUFFa1UsdUJBQXVCNWIsa0JBQWtCNks7SUFDekg7SUFDQSxNQUFNQyxxQkFBcUJyZSxlQUFla0MsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWF1aEIsc0JBQXNCLE1BQU07UUFDMUR4ZixlQUFlb2MsY0FBYztZQUFDO1lBQVM7WUFBb0I7U0FBaUIsRUFBRW9EO0lBQ2xGO0lBQ0EsTUFBTTRRLDRCQUE0Qmp2QixlQUFla0MsWUFBWTtRQUN6RDtLQUNIO0lBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWFteUIsNkJBQTZCLE1BQU07UUFDakVwd0IsZUFBZW9jLGNBQWM7WUFBQztZQUFTO1lBQW9CO1NBQXdCLEVBQUVnVTtJQUN6RjtJQUNBLE1BQU1yUyx3QkFBd0I1YyxlQUFla0MsWUFBWTtRQUNyRDtLQUNIO0lBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWE4Zix5QkFBeUIsTUFBTTtRQUM3RC9kLGVBQWVvYyxjQUFjO1lBQUM7WUFBUztTQUFvQixFQUFFMUosU0FBU3FMO0lBQzFFO0lBQ0EsTUFBTWlCLFlBQVk3ZCxlQUFla0MsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSStZLGlCQUFpQm5lLGFBQWErZ0IsYUFBYSxNQUFNO1FBQ2pELElBQUk3YSxrQkFBa0IrUSxPQUFPOEo7UUFDN0IsSUFBSXhlLE1BQU1DLE9BQU8sQ0FBQzBELGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0I5QyxHQUFHLENBQUMsQ0FBQ2tCO2dCQUNuQyxPQUFPNnVCLGVBQWV6YyxNQUFNcFM7WUFDaEM7UUFDSjtRQUNBdkMsZUFBZW9jLGNBQWM7WUFBQztZQUFTO1NBQVEsRUFBRWpZO0lBQ3JEO0lBQ0EsTUFBTXlzQix3QkFBd0J6dkIsZUFBZWtDLFlBQVk7UUFDckQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhMnlCLHlCQUF5QixNQUFNO1FBQzdENXdCLGVBQWVvYyxjQUFjO1lBQUM7WUFBUztTQUFvQixFQUFFd1U7SUFDakU7SUFDQSxNQUFNRSw4QkFBOEIzdkIsZUFBZWtDLFlBQVk7UUFDM0Q7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhNnlCLCtCQUErQixNQUFNO1FBQ25FOXdCLGVBQWVvYyxjQUFjO1lBQUM7WUFBUztTQUEwQixFQUFFMFU7SUFDdkU7SUFDQSxNQUFNQywrQkFBK0I1dkIsZUFBZWtDLFlBQVk7UUFDNUQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhOHlCLGdDQUFnQyxNQUFNO1FBQ3BFL3dCLGVBQWVvYyxjQUFjO1lBQUM7WUFBUztTQUEyQixFQUFFMlU7SUFDeEU7SUFDQSxNQUFNQywwQkFBMEI3dkIsZUFBZWtDLFlBQVk7UUFDdkQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhK3lCLDJCQUEyQixNQUFNO1FBQy9EaHhCLGVBQWVvYyxjQUFjO1lBQUM7WUFBUztTQUFzQixFQUFFNFU7SUFDbkU7SUFDQSxNQUFNQywrQkFBK0I5dkIsZUFBZWtDLFlBQVk7UUFDNUQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhZ3pCLGdDQUFnQyxNQUFNO1FBQ3BFanhCLGVBQWVvYyxjQUFjO1lBQUM7WUFBUztTQUEyQixFQUFFNlU7SUFDeEU7SUFDQSxNQUFNQyxrQkFBa0IvdkIsZUFBZWtDLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUkrWSxpQkFBaUJuZSxhQUFhaXpCLG1CQUFtQixNQUFNO1FBQ3ZEbHhCLGVBQWVvYyxjQUFjO1lBQUM7WUFBUztTQUFjLEVBQUU4VTtJQUMzRDtJQUNBLE9BQU81dEI7QUFDWDtBQUNBLFNBQVMrdEIsNkJBQTZCamdCLFNBQVMsRUFBRS9OLFVBQVU7SUFDdkQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU02VyxZQUFZaFosZUFBZWtDLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUk4VyxhQUFhLE1BQU07UUFDbkJuYSxlQUFlc0QsVUFBVTtZQUFDO1lBQVM7U0FBUSxFQUFFNk4sT0FBT0MsV0FBVytJO0lBQ25FO0lBQ0EsTUFBTW9DLGFBQWFwYixlQUFla0MsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSWtaLGNBQWMsTUFBTTtRQUNwQnZjLGVBQWVzRCxVQUFVO1lBQUM7U0FBUyxFQUFFbXRCLDJCQUEyQmxVLFlBQVlqWjtJQUNoRjtJQUNBLE9BQU9BO0FBQ1g7QUFDQSxTQUFTZ3VCLDhCQUE4QmxnQixTQUFTLEVBQUUvTixVQUFVO0lBQ3hELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNNlcsWUFBWWhaLGVBQWVrQyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJOFcsYUFBYSxNQUFNO1FBQ25CbmEsZUFBZXNELFVBQVU7WUFBQztZQUFTO1NBQVEsRUFBRTZOLE9BQU9DLFdBQVcrSTtJQUNuRTtJQUNBLE1BQU1vQyxhQUFhcGIsZUFBZWtDLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlrWixjQUFjLE1BQU07UUFDcEJ2YyxlQUFlc0QsVUFBVTtZQUFDO1NBQVMsRUFBRTZ0QiwwQkFBMEI1VSxZQUFZalo7SUFDL0U7SUFDQSxPQUFPQTtBQUNYO0FBQ0EsU0FBU2l1QixvQ0FBb0NsdUIsVUFBVTtJQUNuRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTWt1Qiw0QkFBNEJyd0IsZUFBZWtDLFlBQVk7UUFDekQ7S0FDSDtJQUNELElBQUltdUIsNkJBQTZCLE1BQU07UUFDbkN4eEIsZUFBZXNELFVBQVU7WUFBQztTQUF3QixFQUFFa3VCO0lBQ3hEO0lBQ0EsT0FBT2x1QjtBQUNYO0FBQ0EsU0FBU211Qiw2Q0FBNkNwdUIsVUFBVTtJQUM1RCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTW91QixzQkFBc0J2d0IsZUFBZWtDLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUlxdUIsdUJBQXVCLE1BQU07UUFDN0IsSUFBSXZ0QixrQkFBa0J1dEI7UUFDdEIsSUFBSWx4QixNQUFNQyxPQUFPLENBQUMwRCxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCOUMsR0FBRyxDQUFDLENBQUNrQjtnQkFDbkMsT0FBT0E7WUFDWDtRQUNKO1FBQ0F2QyxlQUFlc0QsVUFBVTtZQUFDO1NBQWtCLEVBQUVhO0lBQ2xEO0lBQ0EsT0FBT2I7QUFDWDtBQUNBLFNBQVNxdUIsdUNBQXVDdHVCLFVBQVU7SUFDdEQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1zdUIsWUFBWXp3QixlQUFla0MsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSXV1QixhQUFhLE1BQU07UUFDbkIsSUFBSXp0QixrQkFBa0IwTixPQUFPK2Y7UUFDN0IsSUFBSXB4QixNQUFNQyxPQUFPLENBQUMwRCxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCOUMsR0FBRyxDQUFDLENBQUNrQjtnQkFDbkMsT0FBT290QixjQUFjcHRCO1lBQ3pCO1FBQ0o7UUFDQXZDLGVBQWVzRCxVQUFVO1lBQUM7U0FBYyxFQUFFYTtJQUM5QztJQUNBLE1BQU0wdEIsWUFBWTF3QixlQUFla0MsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSXd1QixhQUFhLE1BQU07UUFDbkI3eEIsZUFBZXNELFVBQVU7WUFBQztTQUFRLEVBQUVxc0IsY0FBY3hkLFdBQVcwZjtJQUNqRTtJQUNBLE1BQU1DLHFCQUFxQjN3QixlQUFla0MsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSXl1QixzQkFBc0IsTUFBTTtRQUM1Qjl4QixlQUFlc0QsVUFBVTtZQUFDO1NBQWlCLEVBQUV3dUI7SUFDakQ7SUFDQSxNQUFNdHRCLFlBQVlyRCxlQUFla0MsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSW1CLGFBQWEsTUFBTTtRQUNuQnhFLGVBQWVzRCxVQUFVO1lBQUM7U0FBUSxFQUFFcXNCLGNBQWMxZCxXQUFXek47SUFDakU7SUFDQSxNQUFNa2QsV0FBV3ZnQixlQUFla0MsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSXFlLFlBQVksTUFBTTtRQUNsQjFoQixlQUFlc0QsVUFBVTtZQUFDO1NBQU8sRUFBRW9lO0lBQ3ZDO0lBQ0EsTUFBTXFRLG9CQUFvQjV3QixlQUFla0MsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSTB1QixxQkFBcUIsTUFBTTtRQUMzQi94QixlQUFlc0QsVUFBVTtZQUFDO1NBQWdCLEVBQUV5dUI7SUFDaEQ7SUFDQSxNQUFNQyxrQkFBa0I3d0IsZUFBZWtDLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUkydUIsbUJBQW1CLE1BQU07UUFDekJoeUIsZUFBZXNELFVBQVU7WUFBQztTQUFjLEVBQUUwdUI7SUFDOUM7SUFDQSxPQUFPMXVCO0FBQ1g7QUFDQSxTQUFTMnVCLHdDQUF3QzV1QixVQUFVO0lBQ3ZELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNc3VCLFlBQVl6d0IsZUFBZWtDLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUl1dUIsYUFBYSxNQUFNO1FBQ25CLElBQUl6dEIsa0JBQWtCME4sT0FBTytmO1FBQzdCLElBQUlweEIsTUFBTUMsT0FBTyxDQUFDMEQsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQjlDLEdBQUcsQ0FBQyxDQUFDa0I7Z0JBQ25DLE9BQU9BO1lBQ1g7UUFDSjtRQUNBdkMsZUFBZXNELFVBQVU7WUFBQztTQUFjLEVBQUVhO0lBQzlDO0lBQ0EsTUFBTTB0QixZQUFZMXdCLGVBQWVrQyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJd3VCLGFBQWEsTUFBTTtRQUNuQjd4QixlQUFlc0QsVUFBVTtZQUFDO1NBQVEsRUFBRTZPLFdBQVcwZjtJQUNuRDtJQUNBLE1BQU1DLHFCQUFxQjN3QixlQUFla0MsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSXl1QixzQkFBc0IsTUFBTTtRQUM1Qjl4QixlQUFlc0QsVUFBVTtZQUFDO1NBQWlCLEVBQUV3dUI7SUFDakQ7SUFDQSxNQUFNdHRCLFlBQVlyRCxlQUFla0MsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSW1CLGFBQWEsTUFBTTtRQUNuQnhFLGVBQWVzRCxVQUFVO1lBQUM7U0FBUSxFQUFFMk8sV0FBV3pOO0lBQ25EO0lBQ0EsTUFBTWtkLFdBQVd2Z0IsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlxZSxZQUFZLE1BQU07UUFDbEIxaEIsZUFBZXNELFVBQVU7WUFBQztTQUFPLEVBQUVvZTtJQUN2QztJQUNBLE1BQU1xUSxvQkFBb0I1d0IsZUFBZWtDLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUkwdUIscUJBQXFCLE1BQU07UUFDM0IveEIsZUFBZXNELFVBQVU7WUFBQztTQUFnQixFQUFFeXVCO0lBQ2hEO0lBQ0EsTUFBTUMsa0JBQWtCN3dCLGVBQWVrQyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJMnVCLG1CQUFtQixNQUFNO1FBQ3pCaHlCLGVBQWVzRCxVQUFVO1lBQUM7U0FBYyxFQUFFMHVCO0lBQzlDO0lBQ0EsT0FBTzF1QjtBQUNYO0FBQ0EsU0FBUzR1Qiw0QkFBNEI3dUIsVUFBVTtJQUMzQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTTZ1QixvQkFBb0JoeEIsZUFBZWtDLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUk4dUIscUJBQXFCLE1BQU07UUFDM0JueUIsZUFBZXNELFVBQVU7WUFBQztTQUFnQixFQUFFNnVCO0lBQ2hEO0lBQ0EsTUFBTUMsb0JBQW9CanhCLGVBQWVrQyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJK3VCLHFCQUFxQixNQUFNO1FBQzNCcHlCLGVBQWVzRCxVQUFVO1lBQUM7U0FBZ0IsRUFBRTh1QjtJQUNoRDtJQUNBLE1BQU1DLGVBQWVseEIsZUFBZWtDLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlndkIsZ0JBQWdCLE1BQU07UUFDdEJyeUIsZUFBZXNELFVBQVU7WUFBQztTQUFXLEVBQUUrdUI7SUFDM0M7SUFDQSxNQUFNQywyQkFBMkJueEIsZUFBZWtDLFlBQVk7UUFDeEQ7S0FDSDtJQUNELElBQUlpdkIsNEJBQTRCLE1BQU07UUFDbEN0eUIsZUFBZXNELFVBQVU7WUFBQztTQUF1QixFQUFFZ3ZCO0lBQ3ZEO0lBQ0EsTUFBTXRTLG9CQUFvQjdlLGVBQWVrQyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJMmMscUJBQXFCLE1BQU07UUFDM0JoZ0IsZUFBZXNELFVBQVU7WUFBQztTQUFnQixFQUFFaXZCLHdCQUF3QnZTO0lBQ3hFO0lBQ0EsTUFBTXdTLGFBQWFyeEIsZUFBZWtDLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUltdkIsY0FBYyxNQUFNO1FBQ3BCeHlCLGVBQWVzRCxVQUFVO1lBQUM7U0FBUyxFQUFFa3ZCO0lBQ3pDO0lBQ0EsTUFBTUMsOEJBQThCdHhCLGVBQWVrQyxZQUFZO1FBQzNEO0tBQ0g7SUFDRCxJQUFJb3ZCLCtCQUErQixNQUFNO1FBQ3JDenlCLGVBQWVzRCxVQUFVO1lBQUM7U0FBMEIsRUFBRW12QjtJQUMxRDtJQUNBLE9BQU9udkI7QUFDWDtBQUNBLFNBQVN1c0IsY0FBY3hzQixVQUFVO0lBQzdCLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNZ2Msc0JBQXNCbmUsZUFBZWtDLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUlpYyx1QkFBdUIsTUFBTTtRQUM3QnRmLGVBQWVzRCxVQUFVO1lBQUM7U0FBa0IsRUFBRWdjO0lBQ2xEO0lBQ0EsTUFBTThCLDBCQUEwQmpnQixlQUFla0MsWUFBWTtRQUN2RDtLQUNIO0lBQ0QsSUFBSStkLDJCQUEyQixNQUFNO1FBQ2pDcGhCLGVBQWVzRCxVQUFVO1lBQUM7U0FBc0IsRUFBRThkO0lBQ3REO0lBQ0EsTUFBTUMscUJBQXFCbGdCLGVBQWVrQyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJZ2Usc0JBQXNCLE1BQU07UUFDNUJyaEIsZUFBZXNELFVBQVU7WUFBQztTQUFpQixFQUFFK2Q7SUFDakQ7SUFDQSxNQUFNQyxlQUFlbmdCLGVBQWVrQyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJaWUsZ0JBQWdCLE1BQU07UUFDdEJ0aEIsZUFBZXNELFVBQVU7WUFBQztTQUFXLEVBQUV3c0Isa0JBQWtCeE87SUFDN0Q7SUFDQSxNQUFNQyxtQkFBbUJwZ0IsZUFBZWtDLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUlrZSxvQkFBb0IsTUFBTTtRQUMxQnZoQixlQUFlc0QsVUFBVTtZQUFDO1NBQWUsRUFBRXlzQixzQkFBc0J4TztJQUNyRTtJQUNBLE1BQU1DLHVCQUF1QnJnQixlQUFla0MsWUFBWTtRQUNwRDtLQUNIO0lBQ0QsSUFBSW1lLHdCQUF3QixNQUFNO1FBQzlCeGhCLGVBQWVzRCxVQUFVO1lBQUM7U0FBbUIsRUFBRWtlO0lBQ25EO0lBQ0EsTUFBTUMsaUJBQWlCdGdCLGVBQWVrQyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJb2Usa0JBQWtCLE1BQU07UUFDeEJ6aEIsZUFBZXNELFVBQVU7WUFBQztTQUFhLEVBQUVxc0IsY0FBY2xPO0lBQzNEO0lBQ0EsTUFBTUMsV0FBV3ZnQixlQUFla0MsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSXFlLFlBQVksTUFBTTtRQUNsQjFoQixlQUFlc0QsVUFBVTtZQUFDO1NBQU8sRUFBRW9lO0lBQ3ZDO0lBQ0EsTUFBTUMsY0FBY3hnQixlQUFla0MsWUFBWTtRQUFDO0tBQVU7SUFDMUQsSUFBSXNlLGVBQWUsTUFBTTtRQUNyQjNoQixlQUFlc0QsVUFBVTtZQUFDO1NBQVUsRUFBRXFlO0lBQzFDO0lBQ0EsTUFBTUMsdUJBQXVCemdCLGVBQWVrQyxZQUFZO1FBQ3BEO0tBQ0g7SUFDRCxJQUFJdWUsd0JBQXdCLE1BQU07UUFDOUI1aEIsZUFBZXNELFVBQVU7WUFBQztTQUFtQixFQUFFc2U7SUFDbkQ7SUFDQSxNQUFNQyxvQkFBb0IxZ0IsZUFBZWtDLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUl3ZSxxQkFBcUIsTUFBTTtRQUMzQjdoQixlQUFlc0QsVUFBVTtZQUFDO1NBQWdCLEVBQUV1ZTtJQUNoRDtJQUNBLE9BQU92ZTtBQUNYO0FBQ0EsU0FBU3V0QixpQ0FBaUN4dEIsVUFBVTtJQUNoRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTW92QixhQUFhdnhCLGVBQWVrQyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJcXZCLGNBQWMsTUFBTTtRQUNwQjF5QixlQUFlc0QsVUFBVTtZQUFDO1NBQVMsRUFBRW92QjtJQUN6QztJQUNBLElBQUl2eEIsZUFBZWtDLFlBQVk7UUFBQztLQUFjLE1BQU1wRixXQUFXO1FBQzNELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxPQUFPdUQ7QUFDWDtBQUNBLFNBQVNndEIsdUJBQXVCanRCLFVBQVU7SUFDdEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1xdkIsbUJBQW1CeHhCLGVBQWVrQyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJc3ZCLG9CQUFvQixNQUFNO1FBQzFCM3lCLGVBQWVzRCxVQUFVO1lBQUM7U0FBZSxFQUFFcXZCO0lBQy9DO0lBQ0EsTUFBTUMsa0JBQWtCenhCLGVBQWVrQyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJdXZCLG1CQUFtQixNQUFNO1FBQ3pCNXlCLGVBQWVzRCxVQUFVO1lBQUM7U0FBYyxFQUFFc3ZCO0lBQzlDO0lBQ0EsSUFBSXp4QixlQUFla0MsWUFBWTtRQUFDO0tBQTBCLE1BQU1wRixXQUFXO1FBQ3ZFLE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxPQUFPdUQ7QUFDWDtBQUNBLFNBQVNxdEIsY0FBY3R0QixVQUFVO0lBQzdCLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNNGUsMkJBQTJCL2dCLGVBQWVrQyxZQUFZO1FBQ3hEO0tBQ0g7SUFDRCxJQUFJNmUsNEJBQTRCLE1BQU07UUFDbEMsSUFBSS9kLGtCQUFrQitkO1FBQ3RCLElBQUkxaEIsTUFBTUMsT0FBTyxDQUFDMEQsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQjlDLEdBQUcsQ0FBQyxDQUFDa0I7Z0JBQ25DLE9BQU9BO1lBQ1g7UUFDSjtRQUNBdkMsZUFBZXNELFVBQVU7WUFBQztTQUF1QixFQUFFYTtJQUN2RDtJQUNBLElBQUloRCxlQUFla0MsWUFBWTtRQUFDO0tBQVksTUFBTXBGLFdBQVc7UUFDekQsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE1BQU1vaUIsNEJBQTRCaGhCLGVBQWVrQyxZQUFZO1FBQ3pEO0tBQ0g7SUFDRCxJQUFJOGUsNkJBQTZCLE1BQU07UUFDbkNuaUIsZUFBZXNELFVBQVU7WUFBQztTQUF3QixFQUFFNmU7SUFDeEQ7SUFDQSxNQUFNQyxrQkFBa0JqaEIsZUFBZWtDLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUkrZSxtQkFBbUIsTUFBTTtRQUN6QnBpQixlQUFlc0QsVUFBVTtZQUFDO1NBQWMsRUFBRThlO0lBQzlDO0lBQ0EsTUFBTUMsaUJBQWlCbGhCLGVBQWVrQyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJZ2Ysa0JBQWtCLE1BQU07UUFDeEJyaUIsZUFBZXNELFVBQVU7WUFBQztTQUFhLEVBQUUrZTtJQUM3QztJQUNBLE1BQU1DLG9CQUFvQm5oQixlQUFla0MsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSWlmLHFCQUFxQixNQUFNO1FBQzNCdGlCLGVBQWVzRCxVQUFVO1lBQUM7U0FBZ0IsRUFBRWdmO0lBQ2hEO0lBQ0EsSUFBSW5oQixlQUFla0MsWUFBWTtRQUFDO0tBQXNCLE1BQU1wRixXQUFXO1FBQ25FLE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxNQUFNd2lCLGlCQUFpQnBoQixlQUFla0MsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSWtmLGtCQUFrQixNQUFNO1FBQ3hCdmlCLGVBQWVzRCxVQUFVO1lBQUM7U0FBYSxFQUFFaXRCLG9CQUFvQmhPO0lBQ2pFO0lBQ0EsTUFBTUMsbUJBQW1CcmhCLGVBQWVrQyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJbWYsb0JBQW9CLE1BQU07UUFDMUJ4aUIsZUFBZXNELFVBQVU7WUFBQztTQUFlLEVBQUVrdEIsc0JBQXNCaE87SUFDckU7SUFDQSxNQUFNQyxpQkFBaUJ0aEIsZUFBZWtDLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUlvZixrQkFBa0IsTUFBTTtRQUN4QnppQixlQUFlc0QsVUFBVTtZQUFDO1NBQWEsRUFBRW1mO0lBQzdDO0lBQ0EsT0FBT25mO0FBQ1g7QUFDQSxTQUFTOHRCLGVBQWUvdEIsVUFBVTtJQUM5QixNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTTRlLDJCQUEyQi9nQixlQUFla0MsWUFBWTtRQUN4RDtLQUNIO0lBQ0QsSUFBSTZlLDRCQUE0QixNQUFNO1FBQ2xDLElBQUkvZCxrQkFBa0IrZDtRQUN0QixJQUFJMWhCLE1BQU1DLE9BQU8sQ0FBQzBELGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0I5QyxHQUFHLENBQUMsQ0FBQ2tCO2dCQUNuQyxPQUFPeXRCLDhCQUE4Qnp0QjtZQUN6QztRQUNKO1FBQ0F2QyxlQUFlc0QsVUFBVTtZQUFDO1NBQXVCLEVBQUVhO0lBQ3ZEO0lBQ0EsTUFBTWdsQixnQkFBZ0Job0IsZUFBZWtDLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUk4bEIsaUJBQWlCLE1BQU07UUFDdkJucEIsZUFBZXNELFVBQVU7WUFBQztTQUFZLEVBQUU2bEI7SUFDNUM7SUFDQSxNQUFNaEgsNEJBQTRCaGhCLGVBQWVrQyxZQUFZO1FBQ3pEO0tBQ0g7SUFDRCxJQUFJOGUsNkJBQTZCLE1BQU07UUFDbkNuaUIsZUFBZXNELFVBQVU7WUFBQztTQUF3QixFQUFFNmU7SUFDeEQ7SUFDQSxNQUFNQyxrQkFBa0JqaEIsZUFBZWtDLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUkrZSxtQkFBbUIsTUFBTTtRQUN6QnBpQixlQUFlc0QsVUFBVTtZQUFDO1NBQWMsRUFBRThlO0lBQzlDO0lBQ0EsSUFBSWpoQixlQUFla0MsWUFBWTtRQUFDO0tBQWEsTUFBTXBGLFdBQVc7UUFDMUQsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE1BQU11aUIsb0JBQW9CbmhCLGVBQWVrQyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJaWYscUJBQXFCLE1BQU07UUFDM0J0aUIsZUFBZXNELFVBQVU7WUFBQztTQUFnQixFQUFFZ2Y7SUFDaEQ7SUFDQSxNQUFNOEcsMEJBQTBCam9CLGVBQWVrQyxZQUFZO1FBQ3ZEO0tBQ0g7SUFDRCxJQUFJK2xCLDJCQUEyQixNQUFNO1FBQ2pDcHBCLGVBQWVzRCxVQUFVO1lBQUM7U0FBc0IsRUFBRThsQjtJQUN0RDtJQUNBLE1BQU03RyxpQkFBaUJwaEIsZUFBZWtDLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUlrZixrQkFBa0IsTUFBTTtRQUN4QnZpQixlQUFlc0QsVUFBVTtZQUFDO1NBQWEsRUFBRWlmO0lBQzdDO0lBQ0EsTUFBTUMsbUJBQW1CcmhCLGVBQWVrQyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJbWYsb0JBQW9CLE1BQU07UUFDMUJ4aUIsZUFBZXNELFVBQVU7WUFBQztTQUFlLEVBQUVrZjtJQUMvQztJQUNBLE1BQU1DLGlCQUFpQnRoQixlQUFla0MsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSW9mLGtCQUFrQixNQUFNO1FBQ3hCemlCLGVBQWVzRCxVQUFVO1lBQUM7U0FBYSxFQUFFbWY7SUFDN0M7SUFDQSxPQUFPbmY7QUFDWDtBQUNBLFNBQVNpdkIsd0JBQXdCbHZCLFVBQVU7SUFDdkMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU11dkIsdUJBQXVCMXhCLGVBQWVrQyxZQUFZO1FBQ3BEO0tBQ0g7SUFDRCxJQUFJd3ZCLHdCQUF3QixNQUFNO1FBQzlCN3lCLGVBQWVzRCxVQUFVO1lBQUM7U0FBbUIsRUFBRXV2QjtJQUNuRDtJQUNBLE1BQU1DLDhCQUE4QjN4QixlQUFla0MsWUFBWTtRQUMzRDtLQUNIO0lBQ0QsSUFBSXl2QiwrQkFBK0IsTUFBTTtRQUNyQzl5QixlQUFlc0QsVUFBVTtZQUFDO1NBQTBCLEVBQUV3dkI7SUFDMUQ7SUFDQSxNQUFNQyx5QkFBeUI1eEIsZUFBZWtDLFlBQVk7UUFDdEQ7S0FDSDtJQUNELElBQUkwdkIsMEJBQTBCLE1BQU07UUFDaEMveUIsZUFBZXNELFVBQVU7WUFBQztTQUFxQixFQUFFeXZCO0lBQ3JEO0lBQ0EsTUFBTUMsOEJBQThCN3hCLGVBQWVrQyxZQUFZO1FBQzNEO0tBQ0g7SUFDRCxJQUFJMnZCLCtCQUErQixNQUFNO1FBQ3JDaHpCLGVBQWVzRCxVQUFVO1lBQUM7U0FBMEIsRUFBRTB2QjtJQUMxRDtJQUNBLE1BQU1DLHlCQUF5Qjl4QixlQUFla0MsWUFBWTtRQUN0RDtLQUNIO0lBQ0QsSUFBSTR2QiwwQkFBMEIsTUFBTTtRQUNoQ2p6QixlQUFlc0QsVUFBVTtZQUFDO1NBQXFCLEVBQUUydkI7SUFDckQ7SUFDQSxNQUFNQyxzQkFBc0IveEIsZUFBZWtDLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUk2dkIsdUJBQXVCLE1BQU07UUFDN0JsekIsZUFBZXNELFVBQVU7WUFBQztTQUFrQixFQUFFNHZCO0lBQ2xEO0lBQ0EsTUFBTUMsMEJBQTBCaHlCLGVBQWVrQyxZQUFZO1FBQ3ZEO0tBQ0g7SUFDRCxJQUFJOHZCLDJCQUEyQixNQUFNO1FBQ2pDLElBQUlodkIsa0JBQWtCZ3ZCO1FBQ3RCLElBQUkzeUIsTUFBTUMsT0FBTyxDQUFDMEQsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQjlDLEdBQUcsQ0FBQyxDQUFDa0I7Z0JBQ25DLE9BQU9BO1lBQ1g7UUFDSjtRQUNBdkMsZUFBZXNELFVBQVU7WUFBQztTQUFzQixFQUFFYTtJQUN0RDtJQUNBLE1BQU1pdkIseUJBQXlCanlCLGVBQWVrQyxZQUFZO1FBQ3REO0tBQ0g7SUFDRCxJQUFJK3ZCLDBCQUEwQixNQUFNO1FBQ2hDLElBQUlqdkIsa0JBQWtCaXZCO1FBQ3RCLElBQUk1eUIsTUFBTUMsT0FBTyxDQUFDMEQsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQjlDLEdBQUcsQ0FBQyxDQUFDa0I7Z0JBQ25DLE9BQU9BO1lBQ1g7UUFDSjtRQUNBdkMsZUFBZXNELFVBQVU7WUFBQztTQUFxQixFQUFFYTtJQUNyRDtJQUNBLE1BQU1rdkIsNEJBQTRCbHlCLGVBQWVrQyxZQUFZO1FBQ3pEO0tBQ0g7SUFDRCxJQUFJZ3dCLDZCQUE2QixNQUFNO1FBQ25DLElBQUlsdkIsa0JBQWtCa3ZCO1FBQ3RCLElBQUk3eUIsTUFBTUMsT0FBTyxDQUFDMEQsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQjlDLEdBQUcsQ0FBQyxDQUFDa0I7Z0JBQ25DLE9BQU9BO1lBQ1g7UUFDSjtRQUNBdkMsZUFBZXNELFVBQVU7WUFBQztTQUF3QixFQUFFYTtJQUN4RDtJQUNBLE1BQU1tdkIsaUNBQWlDbnlCLGVBQWVrQyxZQUFZO1FBQzlEO0tBQ0g7SUFDRCxJQUFJaXdCLGtDQUFrQyxNQUFNO1FBQ3hDLElBQUludkIsa0JBQWtCbXZCO1FBQ3RCLElBQUk5eUIsTUFBTUMsT0FBTyxDQUFDMEQsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQjlDLEdBQUcsQ0FBQyxDQUFDa0I7Z0JBQ25DLE9BQU9BO1lBQ1g7UUFDSjtRQUNBdkMsZUFBZXNELFVBQVU7WUFBQztTQUE2QixFQUFFYTtJQUM3RDtJQUNBLE1BQU1vdkIsa0JBQWtCcHlCLGVBQWVrQyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJa3dCLG1CQUFtQixNQUFNO1FBQ3pCdnpCLGVBQWVzRCxVQUFVO1lBQUM7U0FBYyxFQUFFaXdCO0lBQzlDO0lBQ0EsT0FBT2p3QjtBQUNYO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVNrd0IsY0FBY253QixVQUFVO0lBQzdCLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNeVgsV0FBVzVaLGVBQWVrQyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJMFgsWUFBWSxNQUFNO1FBQ2xCL2EsZUFBZXNELFVBQVU7WUFBQztTQUFPLEVBQUV5WDtJQUN2QztJQUNBLElBQUk1WixlQUFla0MsWUFBWTtRQUFDO0tBQWMsTUFBTXBGLFdBQVc7UUFDM0QsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE1BQU11RixlQUFlbkUsZUFBZWtDLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlpQyxnQkFBZ0IsTUFBTTtRQUN0QnRGLGVBQWVzRCxVQUFVO1lBQUM7U0FBVyxFQUFFZ0M7SUFDM0M7SUFDQSxPQUFPaEM7QUFDWDtBQUNBLFNBQVNtd0IsbUJBQW1CcHdCLFVBQVU7SUFDbEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU02WCxjQUFjaGEsZUFBZWtDLFlBQVk7UUFBQztLQUFVO0lBQzFELElBQUk4WCxlQUFlLE1BQU07UUFDckJuYixlQUFlc0QsVUFBVTtZQUFDO1NBQVUsRUFBRTZYO0lBQzFDO0lBQ0EsTUFBTUMsdUJBQXVCamEsZUFBZWtDLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUkrWCx3QkFBd0IsTUFBTTtRQUM5QnBiLGVBQWVzRCxVQUFVO1lBQUM7U0FBbUIsRUFBRW93QiwwQkFBMEJ0WTtJQUM3RTtJQUNBLE1BQU1FLGlCQUFpQm5hLGVBQWVrQyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJaVksa0JBQWtCLE1BQU07UUFDeEJ0YixlQUFlc0QsVUFBVTtZQUFDO1NBQWEsRUFBRWdZO0lBQzdDO0lBQ0EsTUFBTUMsbUJBQW1CcGEsZUFBZWtDLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUlrWSxvQkFBb0IsTUFBTTtRQUMxQnZiLGVBQWVzRCxVQUFVO1lBQUM7U0FBZSxFQUFFaVk7SUFDL0M7SUFDQSxNQUFNQyxrQkFBa0JyYSxlQUFla0MsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSW1ZLG1CQUFtQixNQUFNO1FBQ3pCeGIsZUFBZXNELFVBQVU7WUFBQztTQUFjLEVBQUVrWTtJQUM5QztJQUNBLE1BQU1DLHdCQUF3QnRhLGVBQWVrQyxZQUFZO1FBQ3JEO0tBQ0g7SUFDRCxJQUFJb1kseUJBQXlCLE1BQU07UUFDL0J6YixlQUFlc0QsVUFBVTtZQUFDO1NBQW9CLEVBQUVtWTtJQUNwRDtJQUNBLE1BQU1DLFlBQVl2YSxlQUFla0MsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSXFZLGFBQWEsTUFBTTtRQUNuQjFiLGVBQWVzRCxVQUFVO1lBQUM7U0FBUSxFQUFFb1k7SUFDeEM7SUFDQSxNQUFNQyxxQkFBcUJ4YSxlQUFla0MsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSXNZLHNCQUFzQixNQUFNO1FBQzVCM2IsZUFBZXNELFVBQVU7WUFBQztTQUFpQixFQUFFcVk7SUFDakQ7SUFDQSxNQUFNQyxvQkFBb0J6YSxlQUFla0MsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSXVZLHFCQUFxQixNQUFNO1FBQzNCLElBQUl6WCxrQkFBa0J5WDtRQUN0QixJQUFJcGIsTUFBTUMsT0FBTyxDQUFDMEQsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQjlDLEdBQUcsQ0FBQyxDQUFDa0I7Z0JBQ25DLE9BQU9BO1lBQ1g7UUFDSjtRQUNBdkMsZUFBZXNELFVBQVU7WUFBQztTQUFnQixFQUFFYTtJQUNoRDtJQUNBLE1BQU0wWCx5QkFBeUIxYSxlQUFla0MsWUFBWTtRQUN0RDtLQUNIO0lBQ0QsSUFBSXdZLDBCQUEwQixNQUFNO1FBQ2hDN2IsZUFBZXNELFVBQVU7WUFBQztTQUFxQixFQUFFdVk7SUFDckQ7SUFDQSxPQUFPdlk7QUFDWDtBQUNBLFNBQVNvd0IsMEJBQTBCcndCLFVBQVU7SUFDekMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU13WSxnQkFBZ0IzYSxlQUFla0MsWUFBWTtRQUFDO0tBQWtCO0lBQ3BFLElBQUl5WSxpQkFBaUIsTUFBTTtRQUN2QixJQUFJM1gsa0JBQWtCMlg7UUFDdEIsSUFBSXRiLE1BQU1DLE9BQU8sQ0FBQzBELGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0I5QyxHQUFHLENBQUMsQ0FBQ2tCO2dCQUNuQyxPQUFPQTtZQUNYO1FBQ0o7UUFDQXZDLGVBQWVzRCxVQUFVO1lBQUM7U0FBWSxFQUFFYTtJQUM1QztJQUNBLE9BQU9iO0FBQ1g7QUFDQSxTQUFTcXdCLGdDQUFnQ3ZpQixTQUFTLEVBQUUvTixVQUFVO0lBQzFELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNNlcsWUFBWWhaLGVBQWVrQyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJOFcsYUFBYSxNQUFNO1FBQ25CbmEsZUFBZXNELFVBQVU7WUFBQztZQUFRO1NBQVEsRUFBRTZOLE9BQU9DLFdBQVcrSTtJQUNsRTtJQUNBLE1BQU04QyxlQUFlOWIsZUFBZWtDLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUk0WixnQkFBZ0IsTUFBTTtRQUN0QixJQUFJOVksa0JBQWtCME8sVUFBVW9LO1FBQ2hDLElBQUl6YyxNQUFNQyxPQUFPLENBQUMwRCxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCOUMsR0FBRyxDQUFDLENBQUNrQjtnQkFDbkMsT0FBT0E7WUFDWDtRQUNKO1FBQ0F2QyxlQUFlc0QsVUFBVTtZQUFDO1NBQVcsRUFBRWE7SUFDM0M7SUFDQSxPQUFPYjtBQUNYO0FBQ0EsU0FBU3N3QixnQ0FBZ0N2d0IsVUFBVTtJQUMvQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXlCLHNCQUFzQjVELGVBQWVrQyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJMEIsdUJBQXVCLE1BQU07UUFDN0IvRSxlQUFlc0QsVUFBVTtZQUFDO1NBQWtCLEVBQUV5QjtJQUNsRDtJQUNBLE1BQU04dUIsaUJBQWlCMXlCLGVBQWVrQyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJd3dCLGtCQUFrQixNQUFNO1FBQ3hCLElBQUkxdkIsa0JBQWtCMHZCO1FBQ3RCLElBQUlyekIsTUFBTUMsT0FBTyxDQUFDMEQsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQjlDLEdBQUcsQ0FBQyxDQUFDa0I7Z0JBQ25DLE9BQU9BO1lBQ1g7UUFDSjtRQUNBdkMsZUFBZXNELFVBQVU7WUFBQztTQUFhLEVBQUVhO0lBQzdDO0lBQ0EsT0FBT2I7QUFDWDtBQUNBLFNBQVN3d0IsMkJBQTJCendCLFVBQVU7SUFDMUMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU15d0IsYUFBYTV5QixlQUFla0MsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSTB3QixjQUFjLE1BQU07UUFDcEIvekIsZUFBZXNELFVBQVU7WUFBQztTQUFTLEVBQUV5d0I7SUFDekM7SUFDQSxNQUFNQyxpQkFBaUI3eUIsZUFBZWtDLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUkyd0Isa0JBQWtCLE1BQU07UUFDeEJoMEIsZUFBZXNELFVBQVU7WUFBQztTQUFhLEVBQUUyd0IscUNBQXFDRDtJQUNsRjtJQUNBLE9BQU8xd0I7QUFDWDtBQUNBLFNBQVMyd0IscUNBQXFDNXdCLFVBQVU7SUFDcEQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU00d0IsZ0JBQWdCL3lCLGVBQWVrQyxZQUFZO1FBQUM7S0FBWTtJQUM5RCxJQUFJNndCLGlCQUFpQixNQUFNO1FBQ3ZCbDBCLGVBQWVzRCxVQUFVO1lBQUM7U0FBWSxFQUFFNHdCO0lBQzVDO0lBQ0EsTUFBTTVZLGlCQUFpQm5hLGVBQWVrQyxZQUFZO1FBQUM7S0FBYztJQUNqRSxJQUFJaVksa0JBQWtCLE1BQU07UUFDeEJ0YixlQUFlc0QsVUFBVTtZQUFDO1NBQWEsRUFBRWdZO0lBQzdDO0lBQ0EsT0FBT2hZO0FBQ1g7QUFDQSxTQUFTNndCLGlCQUFpQjl3QixVQUFVO0lBQ2hDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNMFksWUFBWTdhLGVBQWVrQyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJMlksYUFBYSxNQUFNO1FBQ25CLElBQUk3WCxrQkFBa0I2WDtRQUN0QixJQUFJeGIsTUFBTUMsT0FBTyxDQUFDMEQsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQjlDLEdBQUcsQ0FBQyxDQUFDa0I7Z0JBQ25DLE9BQU82eEIsY0FBYzd4QjtZQUN6QjtRQUNKO1FBQ0F2QyxlQUFlc0QsVUFBVTtZQUFDO1NBQVEsRUFBRWE7SUFDeEM7SUFDQSxNQUFNK1gsV0FBVy9hLGVBQWVrQyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJNlksWUFBWSxNQUFNO1FBQ2xCbGMsZUFBZXNELFVBQVU7WUFBQztTQUFPLEVBQUU0WTtJQUN2QztJQUNBLE9BQU81WTtBQUNYO0FBQ0EsU0FBUyt3QiwrQkFBK0JoeEIsVUFBVTtJQUM5QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTWd4QixrQkFBa0JuekIsZUFBZWtDLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUlpeEIsbUJBQW1CLE1BQU07UUFDekJ0MEIsZUFBZXNELFVBQVU7WUFBQztTQUFjLEVBQUVneEI7SUFDOUM7SUFDQSxNQUFNQyxvQ0FBb0NwekIsZUFBZWtDLFlBQVk7UUFDakU7S0FDSDtJQUNELElBQUlreEIscUNBQXFDLE1BQU07UUFDM0N2MEIsZUFBZXNELFVBQVU7WUFBQztTQUFpQixFQUFFaXhCO0lBQ2pEO0lBQ0EsT0FBT2p4QjtBQUNYO0FBQ0EsU0FBU2t4Qix5QkFBeUJueEIsVUFBVTtJQUN4QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsSUFBSW5DLGVBQWVrQyxZQUFZO1FBQUM7S0FBb0IsTUFBTXBGLFdBQVc7UUFDakUsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLElBQUlvQixlQUFla0MsWUFBWTtRQUFDO0tBQVEsTUFBTXBGLFdBQVc7UUFDckQsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLElBQUlvQixlQUFla0MsWUFBWTtRQUFDO0tBQW1CLE1BQU1wRixXQUFXO1FBQ2hFLE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxPQUFPdUQ7QUFDWDtBQUNBLFNBQVNteEIsMEJBQTBCcHhCLFVBQVUsRUFBRStZLFlBQVk7SUFDdkQsTUFBTTlZLFdBQVcsQ0FBQztJQUNsQixNQUFNeWEsd0JBQXdCNWMsZUFBZWtDLFlBQVk7UUFDckQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhOGYseUJBQXlCLE1BQU07UUFDN0QvZCxlQUFlb2MsY0FBYztZQUFDO1NBQW9CLEVBQUUxSixTQUFTcUw7SUFDakU7SUFDQSxNQUFNaUIsWUFBWTdkLGVBQWVrQyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJK1ksaUJBQWlCbmUsYUFBYStnQixhQUFhLE1BQU07UUFDakQsSUFBSTdhLGtCQUFrQjZhO1FBQ3RCLElBQUl4ZSxNQUFNQyxPQUFPLENBQUMwRCxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCOUMsR0FBRyxDQUFDLENBQUNrQjtnQkFDbkMsT0FBT215QixhQUFhbnlCO1lBQ3hCO1FBQ0o7UUFDQXZDLGVBQWVvYyxjQUFjO1lBQUM7U0FBUSxFQUFFalk7SUFDNUM7SUFDQSxNQUFNdXNCLHVCQUF1QnZ2QixlQUFla0MsWUFBWTtRQUNwRDtLQUNIO0lBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWF5eUIsd0JBQXdCLE1BQU07UUFDNUQxd0IsZUFBZW9jLGNBQWM7WUFBQztTQUFtQixFQUFFdVkseUJBQXlCakU7SUFDaEY7SUFDQSxPQUFPcHRCO0FBQ1g7QUFDQSxTQUFTc3hCLDZCQUE2QnhqQixTQUFTLEVBQUUvTixVQUFVO0lBQ3ZELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNNlcsWUFBWWhaLGVBQWVrQyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJOFcsYUFBYSxNQUFNO1FBQ25CbmEsZUFBZXNELFVBQVU7WUFBQztZQUFRO1NBQVEsRUFBRTZOLE9BQU9DLFdBQVcrSTtJQUNsRTtJQUNBLE1BQU04QyxlQUFlOWIsZUFBZWtDLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUk0WixnQkFBZ0IsTUFBTTtRQUN0QixJQUFJOVksa0JBQWtCME8sVUFBVW9LO1FBQ2hDLElBQUl6YyxNQUFNQyxPQUFPLENBQUMwRCxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCOUMsR0FBRyxDQUFDLENBQUNrQjtnQkFDbkMsT0FBTzR4QixpQkFBaUI1eEI7WUFDNUI7UUFDSjtRQUNBdkMsZUFBZXNELFVBQVU7WUFBQztTQUFXLEVBQUVhO0lBQzNDO0lBQ0EsTUFBTW9ZLGFBQWFwYixlQUFla0MsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSWtaLGNBQWMsTUFBTTtRQUNwQmlZLHlCQUF5QmpZO0lBQzdCO0lBQ0EsT0FBT2paO0FBQ1g7QUFDQSxTQUFTdXhCLDhCQUE4QnpqQixTQUFTLEVBQUUvTixVQUFVO0lBQ3hELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNNlcsWUFBWWhaLGVBQWVrQyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJOFcsYUFBYSxNQUFNO1FBQ25CbmEsZUFBZXNELFVBQVU7WUFBQztZQUFRO1NBQVEsRUFBRTZOLE9BQU9DLFdBQVcrSTtJQUNsRTtJQUNBLE1BQU04QyxlQUFlOWIsZUFBZWtDLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUk0WixnQkFBZ0IsTUFBTTtRQUN0QixJQUFJOVksa0JBQWtCME8sVUFBVW9LO1FBQ2hDLElBQUl6YyxNQUFNQyxPQUFPLENBQUMwRCxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCOUMsR0FBRyxDQUFDLENBQUNrQjtnQkFDbkMsT0FBT0E7WUFDWDtRQUNKO1FBQ0F2QyxlQUFlc0QsVUFBVTtZQUFDO1NBQVcsRUFBRWE7SUFDM0M7SUFDQSxNQUFNb1ksYUFBYXBiLGVBQWVrQyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJa1osY0FBYyxNQUFNO1FBQ3BCa1ksMEJBQTBCbFksWUFBWWpaO0lBQzFDO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLFNBQVN3eEIsNkJBQTZCenhCLFVBQVU7SUFDNUMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU15QixzQkFBc0I1RCxlQUFla0MsWUFBWTtRQUNuRDtLQUNIO0lBQ0QsSUFBSTBCLHVCQUF1QixNQUFNO1FBQzdCL0UsZUFBZXNELFVBQVU7WUFBQztTQUFrQixFQUFFeUI7SUFDbEQ7SUFDQSxNQUFNZ3dCLGtCQUFrQjV6QixlQUFla0MsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSTB4QixtQkFBbUIsTUFBTTtRQUN6Qi8wQixlQUFlc0QsVUFBVTtZQUFDO1NBQWMsRUFBRXl4QjtJQUM5QztJQUNBLE1BQU1qQyw4QkFBOEIzeEIsZUFBZWtDLFlBQVk7UUFDM0Q7S0FDSDtJQUNELElBQUl5dkIsK0JBQStCLE1BQU07UUFDckM5eUIsZUFBZXNELFVBQVU7WUFBQztTQUEwQixFQUFFd3ZCO0lBQzFEO0lBQ0EsT0FBT3h2QjtBQUNYO0FBQ0EsU0FBUzB4Qiw4QkFBOEIzeEIsVUFBVTtJQUM3QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXlCLHNCQUFzQjVELGVBQWVrQyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJMEIsdUJBQXVCLE1BQU07UUFDN0IvRSxlQUFlc0QsVUFBVTtZQUFDO1NBQWtCLEVBQUV5QjtJQUNsRDtJQUNBLE1BQU1nd0Isa0JBQWtCNXpCLGVBQWVrQyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJMHhCLG1CQUFtQixNQUFNO1FBQ3pCLzBCLGVBQWVzRCxVQUFVO1lBQUM7U0FBYyxFQUFFeXhCO0lBQzlDO0lBQ0EsT0FBT3p4QjtBQUNYO0FBQ0EsU0FBUzJ4Qiw2QkFBNkI3akIsU0FBUyxFQUFFL04sVUFBVTtJQUN2RCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTTZXLFlBQVloWixlQUFla0MsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSThXLGFBQWEsTUFBTTtRQUNuQm5hLGVBQWVzRCxVQUFVO1lBQUM7WUFBUTtTQUFPLEVBQUU2TixPQUFPQyxXQUFXK0k7SUFDakU7SUFDQSxPQUFPN1c7QUFDWDtBQUNBLFNBQVM0eEIsOEJBQThCOWpCLFNBQVMsRUFBRS9OLFVBQVU7SUFDeEQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU02VyxZQUFZaFosZUFBZWtDLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUk4VyxhQUFhLE1BQU07UUFDbkJuYSxlQUFlc0QsVUFBVTtZQUFDO1lBQVE7U0FBTyxFQUFFNk4sT0FBT0MsV0FBVytJO0lBQ2pFO0lBQ0EsT0FBTzdXO0FBQ1g7QUFDQSxTQUFTNnhCLDZCQUE2Qjl4QixVQUFVO0lBQzVDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNeUIsc0JBQXNCNUQsZUFBZWtDLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUkwQix1QkFBdUIsTUFBTTtRQUM3Qi9FLGVBQWVzRCxVQUFVO1lBQUM7U0FBa0IsRUFBRXlCO0lBQ2xEO0lBQ0EsT0FBT3pCO0FBQ1g7QUFDQSxTQUFTOHhCLDhCQUE4Qi94QixVQUFVO0lBQzdDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNeUIsc0JBQXNCNUQsZUFBZWtDLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUkwQix1QkFBdUIsTUFBTTtRQUM3Qi9FLGVBQWVzRCxVQUFVO1lBQUM7U0FBa0IsRUFBRXlCO0lBQ2xEO0lBQ0EsT0FBT3pCO0FBQ1g7QUFDQSxTQUFTK3hCLHdCQUF3Qmh5QixVQUFVLEVBQUUrWSxZQUFZO0lBQ3JELE1BQU05WSxXQUFXLENBQUM7SUFDbEIsTUFBTWd5QixtQkFBbUJuMEIsZUFBZWtDLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUkrWSxpQkFBaUJuZSxhQUFhcTNCLG9CQUFvQixNQUFNO1FBQ3hEdDFCLGVBQWVvYyxjQUFjO1lBQUM7WUFBYztTQUFhLEVBQUVrWjtJQUMvRDtJQUNBLE1BQU1DLHFCQUFxQnAwQixlQUFla0MsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWFzM0Isc0JBQXNCLE1BQU07UUFDMUR2MUIsZUFBZW9jLGNBQWM7WUFBQztZQUFjO1NBQWlCLEVBQUVtWjtJQUNuRTtJQUNBLE1BQU1DLHFCQUFxQnIwQixlQUFla0MsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWF1M0Isc0JBQXNCLE1BQU07UUFDMUR4MUIsZUFBZW9jLGNBQWM7WUFBQztZQUFjO1NBQWMsRUFBRW9aO0lBQ2hFO0lBQ0EsTUFBTWpWLGtCQUFrQnBmLGVBQWVrQyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJK1ksaUJBQWlCbmUsYUFBYXNpQixtQkFBbUIsTUFBTTtRQUN2RHZnQixlQUFlb2MsY0FBYztZQUFDO1lBQWM7U0FBYyxFQUFFbUU7SUFDaEU7SUFDQSxNQUFNa1Ysb0JBQW9CdDBCLGVBQWVrQyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJK1ksaUJBQWlCbmUsYUFBYXczQixxQkFBcUIsTUFBTTtRQUN6RHoxQixlQUFlb2MsY0FBYztZQUFDO1lBQWM7U0FBZ0IsRUFBRXFaO0lBQ2xFO0lBQ0EsTUFBTS9XLFdBQVd2ZCxlQUFla0MsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSStZLGlCQUFpQm5lLGFBQWF5Z0IsWUFBWSxNQUFNO1FBQ2hEMWUsZUFBZW9jLGNBQWM7WUFBQztZQUFjO1NBQU8sRUFBRXNDO0lBQ3pEO0lBQ0EsTUFBTWdYLHdCQUF3QnYwQixlQUFla0MsWUFBWTtRQUNyRDtLQUNIO0lBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWF5M0IseUJBQXlCLE1BQU07UUFDN0QxMUIsZUFBZW9jLGNBQWM7WUFBQztZQUFjO1NBQWdCLEVBQUVzWjtJQUNsRTtJQUNBLE1BQU1DLHVCQUF1QngwQixlQUFla0MsWUFBWTtRQUNwRDtLQUNIO0lBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWEwM0Isd0JBQXdCLE1BQU07UUFDNUQzMUIsZUFBZW9jLGNBQWM7WUFBQztZQUFjO1NBQW1CLEVBQUV1WjtJQUNyRTtJQUNBLE1BQU1DLDhCQUE4QnowQixlQUFla0MsWUFBWTtRQUMzRDtLQUNIO0lBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWEyM0IsK0JBQStCLE1BQU07UUFDbkU1MUIsZUFBZW9jLGNBQWM7WUFBQztZQUFjO1NBQTBCLEVBQUV3WjtJQUM1RTtJQUNBLE1BQU1DLHVCQUF1QjEwQixlQUFla0MsWUFBWTtRQUNwRDtLQUNIO0lBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWE0M0Isd0JBQXdCLE1BQU07UUFDNUQ3MUIsZUFBZW9jLGNBQWM7WUFBQztZQUFjO1NBQW1CLEVBQUV5WjtJQUNyRTtJQUNBLE1BQU1DLGVBQWUzMEIsZUFBZWtDLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUkrWSxpQkFBaUJuZSxhQUFhNjNCLGdCQUFnQixNQUFNO1FBQ3BEOTFCLGVBQWVvYyxjQUFjO1lBQUM7WUFBYztTQUFXLEVBQUUwWjtJQUM3RDtJQUNBLE1BQU1DLHFCQUFxQjUwQixlQUFla0MsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWE4M0Isc0JBQXNCLE1BQU07UUFDMUQvMUIsZUFBZW9jLGNBQWM7WUFBQztZQUFjO1lBQWlCO1NBQVcsRUFBRTJaO0lBQzlFO0lBQ0EsTUFBTUMsK0JBQStCNzBCLGVBQWVrQyxZQUFZO1FBQzVEO0tBQ0g7SUFDRCxJQUFJK1ksaUJBQWlCbmUsYUFBYSszQixnQ0FBZ0MsTUFBTTtRQUNwRWgyQixlQUFlb2MsY0FBYztZQUFDO1lBQWM7WUFBaUI7U0FBcUIsRUFBRTRaO0lBQ3hGO0lBQ0EsTUFBTUMsbUJBQW1COTBCLGVBQWVrQyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJK1ksaUJBQWlCbmUsYUFBYWc0QixvQkFBb0IsTUFBTTtRQUN4RGoyQixlQUFlb2MsY0FBYztZQUFDO1lBQWM7U0FBZSxFQUFFNlo7SUFDakU7SUFDQSxNQUFNQyxhQUFhLzBCLGVBQWVrQyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJK1ksaUJBQWlCbmUsYUFBYWk0QixjQUFjLE1BQU07UUFDbERsMkIsZUFBZW9jLGNBQWM7WUFBQztTQUFTLEVBQUU4WjtJQUM3QztJQUNBLE1BQU1DLGVBQWVoMUIsZUFBZWtDLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUkrWSxpQkFBaUJuZSxhQUFhazRCLGdCQUFnQixNQUFNO1FBQ3BEbjJCLGVBQWVvYyxjQUFjO1lBQUM7WUFBYztTQUFXLEVBQUUrWjtJQUM3RDtJQUNBLE1BQU1DLGdCQUFnQmoxQixlQUFla0MsWUFBWTtRQUFDO0tBQVk7SUFDOUQsSUFBSStZLGlCQUFpQm5lLGFBQWFtNEIsaUJBQWlCLE1BQU07UUFDckRwMkIsZUFBZW9jLGNBQWM7WUFBQztZQUFjO1lBQWM7U0FBWSxFQUFFZ2E7SUFDNUU7SUFDQSxPQUFPOXlCO0FBQ1g7QUFDQSxTQUFTK3lCLG9DQUFvQ2psQixTQUFTLEVBQUUvTixVQUFVO0lBQzlELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNNlcsWUFBWWhaLGVBQWVrQyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJOFcsYUFBYSxNQUFNO1FBQ25CbmEsZUFBZXNELFVBQVU7WUFBQztZQUFRO1NBQVEsRUFBRTZOLE9BQU9DLFdBQVcrSTtJQUNsRTtJQUNBLE1BQU1tYyxhQUFhbjFCLGVBQWVrQyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJaXpCLGNBQWMsTUFBTTtRQUNwQnQyQixlQUFlc0QsVUFBVTtZQUFDO1lBQWdCO1NBQVMsRUFBRWd6QjtJQUN6RDtJQUNBLE1BQU1DLHNCQUFzQnAxQixlQUFla0MsWUFBWTtRQUNuRDtLQUNIO0lBQ0QsSUFBSWt6Qix1QkFBdUIsTUFBTTtRQUM3QixJQUFJcHlCLGtCQUFrQm95QjtRQUN0QixJQUFJLzFCLE1BQU1DLE9BQU8sQ0FBQzBELGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0I5QyxHQUFHLENBQUMsQ0FBQ2tCO2dCQUNuQyxPQUFPaTBCLGtDQUFrQ2owQjtZQUM3QztRQUNKO1FBQ0F2QyxlQUFlc0QsVUFBVTtZQUFDO1lBQWdCO1NBQWtCLEVBQUVhO0lBQ2xFO0lBQ0EsTUFBTW9ZLGFBQWFwYixlQUFla0MsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSWtaLGNBQWMsTUFBTTtRQUNwQjhZLHdCQUF3QjlZLFlBQVlqWjtJQUN4QztJQUNBLE9BQU9BO0FBQ1g7QUFDQSxTQUFTbXpCLDRCQUE0QnB6QixVQUFVO0lBQzNDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNeUIsc0JBQXNCNUQsZUFBZWtDLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUkwQix1QkFBdUIsTUFBTTtRQUM3Qi9FLGVBQWVzRCxVQUFVO1lBQUM7U0FBa0IsRUFBRXlCO0lBQ2xEO0lBQ0EsTUFBTTJ4QixzQkFBc0J2MUIsZUFBZWtDLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUlxekIsdUJBQXVCLE1BQU07UUFDN0IsSUFBSXZ5QixrQkFBa0J1eUI7UUFDdEIsSUFBSWwyQixNQUFNQyxPQUFPLENBQUMwRCxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCOUMsR0FBRyxDQUFDLENBQUNrQjtnQkFDbkMsT0FBT28wQix5QkFBeUJwMEI7WUFDcEM7UUFDSjtRQUNBdkMsZUFBZXNELFVBQVU7WUFBQztTQUFrQixFQUFFYTtJQUNsRDtJQUNBLE9BQU9iO0FBQ1g7QUFDQSxTQUFTc3pCLDBCQUEwQnZ6QixVQUFVLEVBQUUrWSxZQUFZO0lBQ3ZELE1BQU05WSxXQUFXLENBQUM7SUFDbEIsTUFBTTZaLGVBQWVoYyxlQUFla0MsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSStZLGlCQUFpQm5lLGFBQWFrZixnQkFBZ0IsTUFBTTtRQUNwRG5kLGVBQWVvYyxjQUFjO1lBQUM7WUFBYztTQUFXLEVBQUVlO0lBQzdEO0lBQ0EsTUFBTUMsWUFBWWpjLGVBQWVrQyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJK1ksaUJBQWlCbmUsYUFBYW1mLGFBQWEsTUFBTTtRQUNqRHBkLGVBQWVvYyxjQUFjO1lBQUM7WUFBYztTQUFRLEVBQUVnQjtJQUMxRDtJQUNBLE1BQU1DLDJCQUEyQmxjLGVBQWVrQyxZQUFZO1FBQ3hEO0tBQ0g7SUFDRCxJQUFJK1ksaUJBQWlCbmUsYUFBYW9mLDRCQUE0QixNQUFNO1FBQ2hFcmQsZUFBZW9jLGNBQWM7WUFBQztZQUFjO1NBQXVCLEVBQUVpQjtJQUN6RTtJQUNBLElBQUlsYyxlQUFla0MsWUFBWTtRQUFDO0tBQVcsTUFBTXBGLFdBQVc7UUFDeEQsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLElBQUlvQixlQUFla0MsWUFBWTtRQUFDO0tBQWUsTUFBTXBGLFdBQVc7UUFDNUQsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE9BQU91RDtBQUNYO0FBQ0EsU0FBU3V6QiwyQkFBMkJ4ekIsVUFBVSxFQUFFK1ksWUFBWTtJQUN4RCxNQUFNOVksV0FBVyxDQUFDO0lBQ2xCLE1BQU02WixlQUFlaGMsZUFBZWtDLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUkrWSxpQkFBaUJuZSxhQUFha2YsZ0JBQWdCLE1BQU07UUFDcERuZCxlQUFlb2MsY0FBYztZQUFDO1lBQWU7U0FBWSxFQUFFZTtJQUMvRDtJQUNBLE1BQU1DLFlBQVlqYyxlQUFla0MsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSStZLGlCQUFpQm5lLGFBQWFtZixhQUFhLE1BQU07UUFDakRwZCxlQUFlb2MsY0FBYztZQUFDO1lBQWU7U0FBUSxFQUFFZ0I7SUFDM0Q7SUFDQSxNQUFNQywyQkFBMkJsYyxlQUFla0MsWUFBWTtRQUN4RDtLQUNIO0lBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWFvZiw0QkFBNEIsTUFBTTtRQUNoRXJkLGVBQWVvYyxjQUFjO1lBQUM7WUFBYztTQUF1QixFQUFFaUI7SUFDekU7SUFDQSxNQUFNL1gsZUFBZW5FLGVBQWVrQyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJK1ksaUJBQWlCbmUsYUFBYXFILGdCQUFnQixNQUFNO1FBQ3BEdEYsZUFBZW9jLGNBQWM7WUFBQztZQUFlO1NBQVcsRUFBRTlXO0lBQzlEO0lBQ0EsTUFBTXd4QixtQkFBbUIzMUIsZUFBZWtDLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUkrWSxpQkFBaUJuZSxhQUFhNjRCLG9CQUFvQixNQUFNO1FBQ3hEOTJCLGVBQWVvYyxjQUFjO1lBQUM7WUFBYztTQUFlLEVBQUUwYTtJQUNqRTtJQUNBLE9BQU94ekI7QUFDWDtBQUNBLFNBQVN5ekIsOEJBQThCM2xCLFNBQVMsRUFBRS9OLFVBQVU7SUFDeEQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU02VyxZQUFZaFosZUFBZWtDLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUk4VyxhQUFhLE1BQU07UUFDbkJuYSxlQUFlc0QsVUFBVTtZQUFDO1lBQVE7U0FBUSxFQUFFNk4sT0FBT0MsV0FBVytJO0lBQ2xFO0lBQ0EsTUFBTThDLGVBQWU5YixlQUFla0MsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSTRaLGdCQUFnQixNQUFNO1FBQ3RCLElBQUk5WSxrQkFBa0J3TyxrQkFBa0J2QixXQUFXNkw7UUFDbkQsSUFBSXpjLE1BQU1DLE9BQU8sQ0FBQzBELGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0I5QyxHQUFHLENBQUMsQ0FBQ2tCO2dCQUNuQyxPQUFPQTtZQUNYO1FBQ0o7UUFDQXZDLGVBQWVzRCxVQUFVO1lBQUM7WUFBYztTQUFVLEVBQUVhO0lBQ3hEO0lBQ0EsTUFBTW9ZLGFBQWFwYixlQUFla0MsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSWtaLGNBQWMsTUFBTTtRQUNwQnFhLDBCQUEwQnJhLFlBQVlqWjtJQUMxQztJQUNBLE1BQU0wekIsMkJBQTJCNzFCLGVBQWVrQyxZQUFZO1FBQUM7S0FBUTtJQUNyRSxJQUFJMnpCLDZCQUE2Qi80QixXQUFXO1FBQ3hDK0IsZUFBZXNELFVBQVU7WUFBQztZQUFjO1NBQVEsRUFBRTZOLE9BQU9DLFdBQVc0bEI7SUFDeEU7SUFDQSxPQUFPMXpCO0FBQ1g7QUFDQSxTQUFTMnpCLCtCQUErQjdsQixTQUFTLEVBQUUvTixVQUFVO0lBQ3pELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNNlcsWUFBWWhaLGVBQWVrQyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJOFcsYUFBYSxNQUFNO1FBQ25CbmEsZUFBZXNELFVBQVU7WUFBQztZQUFRO1NBQVEsRUFBRTZOLE9BQU9DLFdBQVcrSTtJQUNsRTtJQUNBLE1BQU04QyxlQUFlOWIsZUFBZWtDLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUk0WixnQkFBZ0IsTUFBTTtRQUN0QixJQUFJOVksa0JBQWtCd08sa0JBQWtCdkIsV0FBVzZMO1FBQ25ELElBQUl6YyxNQUFNQyxPQUFPLENBQUMwRCxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCOUMsR0FBRyxDQUFDLENBQUNrQjtnQkFDbkMsT0FBT0E7WUFDWDtRQUNKO1FBQ0F2QyxlQUFlc0QsVUFBVTtZQUFDO1lBQWU7U0FBVSxFQUFFYTtJQUN6RDtJQUNBLE1BQU1vWSxhQUFhcGIsZUFBZWtDLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlrWixjQUFjLE1BQU07UUFDcEJzYSwyQkFBMkJ0YSxZQUFZalo7SUFDM0M7SUFDQSxPQUFPQTtBQUNYO0FBQ0EsU0FBUzR6Qiw4QkFBOEI3ekIsVUFBVTtJQUM3QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXlCLHNCQUFzQjVELGVBQWVrQyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJMEIsdUJBQXVCLE1BQU07UUFDN0IvRSxlQUFlc0QsVUFBVTtZQUFDO1NBQWtCLEVBQUV5QjtJQUNsRDtJQUNBLE1BQU1veUIsaUJBQWlCaDJCLGVBQWVrQyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJOHpCLGtCQUFrQixNQUFNO1FBQ3hCLElBQUloekIsa0JBQWtCZ3pCO1FBQ3RCLElBQUkzMkIsTUFBTUMsT0FBTyxDQUFDMEQsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQjlDLEdBQUcsQ0FBQyxDQUFDa0I7Z0JBQ25DLE9BQU9BO1lBQ1g7UUFDSjtRQUNBdkMsZUFBZXNELFVBQVU7WUFBQztTQUFhLEVBQUVhO0lBQzdDO0lBQ0EsTUFBTVIsZUFBZXhDLGVBQWVrQyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJTSxnQkFBZ0IsTUFBTTtRQUN0QjNELGVBQWVzRCxVQUFVO1lBQUM7U0FBVyxFQUFFSztJQUMzQztJQUNBLE9BQU9MO0FBQ1g7QUFDQSxTQUFTOHpCLCtCQUErQi96QixVQUFVO0lBQzlDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNeUIsc0JBQXNCNUQsZUFBZWtDLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUkwQix1QkFBdUIsTUFBTTtRQUM3Qi9FLGVBQWVzRCxVQUFVO1lBQUM7U0FBa0IsRUFBRXlCO0lBQ2xEO0lBQ0EsTUFBTW95QixpQkFBaUJoMkIsZUFBZWtDLFlBQVk7UUFDOUM7UUFDQTtLQUNIO0lBQ0QsSUFBSTh6QixrQkFBa0IsTUFBTTtRQUN4QixJQUFJaHpCLGtCQUFrQmd6QjtRQUN0QixJQUFJMzJCLE1BQU1DLE9BQU8sQ0FBQzBELGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0I5QyxHQUFHLENBQUMsQ0FBQ2tCO2dCQUNuQyxPQUFPdXhCLDJCQUEyQnZ4QjtZQUN0QztRQUNKO1FBQ0F2QyxlQUFlc0QsVUFBVTtZQUFDO1NBQWEsRUFBRWE7SUFDN0M7SUFDQSxNQUFNUixlQUFleEMsZUFBZWtDLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlNLGdCQUFnQixNQUFNO1FBQ3RCM0QsZUFBZXNELFVBQVU7WUFBQztTQUFXLEVBQUVLO0lBQzNDO0lBQ0EsT0FBT0w7QUFDWDtBQUNBLFNBQVMrekIsbUJBQW1CaDBCLFVBQVU7SUFDbEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1JLFdBQVd2QyxlQUFla0MsWUFBWTtRQUFDO0tBQVc7SUFDeEQsSUFBSUssWUFBWSxNQUFNO1FBQ2xCMUQsZUFBZXNELFVBQVU7WUFBQztTQUFPLEVBQUVJO0lBQ3ZDO0lBQ0EsTUFBTTR6QixzQkFBc0JuMkIsZUFBZWtDLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUlpMEIsdUJBQXVCLE1BQU07UUFDN0J0M0IsZUFBZXNELFVBQVU7WUFBQztTQUFrQixFQUFFZzBCO0lBQ2xEO0lBQ0EsT0FBT2gwQjtBQUNYO0FBQ0EsU0FBU2kwQixrQkFBa0JsMEIsVUFBVTtJQUNqQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsSUFBSW5DLGVBQWVrQyxZQUFZO1FBQUM7S0FBYyxNQUFNcEYsV0FBVztRQUMzRCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTXdkLGNBQWNwYyxlQUFla0MsWUFBWTtRQUFDO0tBQVU7SUFDMUQsSUFBSWthLGVBQWUsTUFBTTtRQUNyQnZkLGVBQWVzRCxVQUFVO1lBQUM7U0FBVSxFQUFFaWE7SUFDMUM7SUFDQSxNQUFNalksZUFBZW5FLGVBQWVrQyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJaUMsZ0JBQWdCLE1BQU07UUFDdEJ0RixlQUFlc0QsVUFBVTtZQUFDO1NBQVcsRUFBRWdDO0lBQzNDO0lBQ0EsT0FBT2hDO0FBQ1g7QUFDQSxTQUFTazBCLHNCQUFzQm4wQixVQUFVO0lBQ3JDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNbWEsU0FBU3RjLGVBQWVrQyxZQUFZO1FBQUM7S0FBSztJQUNoRCxJQUFJb2EsVUFBVSxNQUFNO1FBQ2hCemQsZUFBZXNELFVBQVU7WUFBQztTQUFLLEVBQUVtYTtJQUNyQztJQUNBLE1BQU1DLFdBQVd2YyxlQUFla0MsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSXFhLFlBQVksTUFBTTtRQUNsQjFkLGVBQWVzRCxVQUFVO1lBQUM7U0FBTyxFQUFFb2E7SUFDdkM7SUFDQSxNQUFNaGEsV0FBV3ZDLGVBQWVrQyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJSyxZQUFZLE1BQU07UUFDbEIxRCxlQUFlc0QsVUFBVTtZQUFDO1NBQU8sRUFBRUk7SUFDdkM7SUFDQSxJQUFJdkMsZUFBZWtDLFlBQVk7UUFBQztLQUFjLE1BQU1wRixXQUFXO1FBQzNELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxJQUFJb0IsZUFBZWtDLFlBQVk7UUFBQztLQUFlLE1BQU1wRixXQUFXO1FBQzVELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxPQUFPdUQ7QUFDWDtBQUNBLFNBQVNtMEIsNkJBQTZCcDBCLFVBQVU7SUFDNUMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1zYSxXQUFXemMsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUl1YSxZQUFZLE1BQU07UUFDbEI1ZCxlQUFlc0QsVUFBVTtZQUFDO1NBQU8sRUFBRXNhO0lBQ3ZDO0lBQ0EsTUFBTUMsMkJBQTJCMWMsZUFBZWtDLFlBQVk7UUFDeEQ7S0FDSDtJQUNELElBQUl3YSw0QkFBNEIsTUFBTTtRQUNsQzdkLGVBQWVzRCxVQUFVO1lBQUM7U0FBdUIsRUFBRXVhO0lBQ3ZEO0lBQ0EsSUFBSTFjLGVBQWVrQyxZQUFZO1FBQUM7S0FBOEIsTUFDMURwRixXQUFXO1FBQ1gsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE9BQU91RDtBQUNYO0FBQ0EsU0FBU28wQiw0QkFBNEJyMEIsVUFBVTtJQUMzQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsSUFBSW5DLGVBQWVrQyxZQUFZO1FBQUM7S0FBVyxNQUFNcEYsV0FBVztRQUN4RCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTXNvQixrQkFBa0JsbkIsZUFBZWtDLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUlnbEIsbUJBQW1CLE1BQU07UUFDekJyb0IsZUFBZXNELFVBQVU7WUFBQztTQUFjLEVBQUUra0I7SUFDOUM7SUFDQSxNQUFNM2tCLFdBQVd2QyxlQUFla0MsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSUssWUFBWSxNQUFNO1FBQ2xCMUQsZUFBZXNELFVBQVU7WUFBQztTQUFPLEVBQUVJO0lBQ3ZDO0lBQ0EsTUFBTTRrQixpQkFBaUJubkIsZUFBZWtDLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUlpbEIsa0JBQWtCLE1BQU07UUFDeEJ0b0IsZUFBZXNELFVBQVU7WUFBQztTQUFhLEVBQUVnbEI7SUFDN0M7SUFDQSxNQUFNQywyQkFBMkJwbkIsZUFBZWtDLFlBQVk7UUFDeEQ7S0FDSDtJQUNELElBQUlrbEIsNEJBQTRCLE1BQU07UUFDbEN2b0IsZUFBZXNELFVBQVU7WUFBQztTQUF1QixFQUFFaWxCO0lBQ3ZEO0lBQ0EsTUFBTXprQixlQUFlM0MsZUFBZWtDLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlTLGdCQUFnQixNQUFNO1FBQ3RCOUQsZUFBZXNELFVBQVU7WUFBQztTQUFXLEVBQUVRO0lBQzNDO0lBQ0EsTUFBTSthLHlCQUF5QjFkLGVBQWVrQyxZQUFZO1FBQ3REO0tBQ0g7SUFDRCxJQUFJd2IsMEJBQTBCLE1BQU07UUFDaEM3ZSxlQUFlc0QsVUFBVTtZQUFDO1NBQXFCLEVBQUV1YjtJQUNyRDtJQUNBLE9BQU92YjtBQUNYO0FBQ0EsU0FBU3EwQiw2QkFBNkJ2bUIsU0FBUyxFQUFFL04sVUFBVSxFQUFFK1ksWUFBWTtJQUNyRSxNQUFNOVksV0FBVyxDQUFDO0lBQ2xCLE1BQU15YSx3QkFBd0I1YyxlQUFla0MsWUFBWTtRQUNyRDtLQUNIO0lBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWE4Zix5QkFBeUIsTUFBTTtRQUM3RC9kLGVBQWVvYyxjQUFjO1lBQUM7U0FBb0IsRUFBRStYLGlCQUFpQnpoQixTQUFTcUw7SUFDbEY7SUFDQSxNQUFNQyxrQkFBa0I3YyxlQUFla0MsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSTJhLG1CQUFtQixNQUFNO1FBQ3pCaGUsZUFBZXNELFVBQVU7WUFBQztTQUFjLEVBQUUwYTtJQUM5QztJQUNBLE1BQU1DLFdBQVc5YyxlQUFla0MsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSTRhLFlBQVksTUFBTTtRQUNsQmplLGVBQWVzRCxVQUFVO1lBQUM7U0FBTyxFQUFFMmE7SUFDdkM7SUFDQSxNQUFNQyxXQUFXL2MsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUk2YSxZQUFZLE1BQU07UUFDbEJsZSxlQUFlc0QsVUFBVTtZQUFDO1NBQU8sRUFBRTRhO0lBQ3ZDO0lBQ0EsTUFBTUMscUJBQXFCaGQsZUFBZWtDLFlBQVk7UUFDbEQ7S0FDSDtJQUNELElBQUk4YSxzQkFBc0IsTUFBTTtRQUM1Qm5lLGVBQWVzRCxVQUFVO1lBQUM7U0FBaUIsRUFBRTZhO0lBQ2pEO0lBQ0EsTUFBTUMsc0JBQXNCamQsZUFBZWtDLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUkrYSx1QkFBdUIsTUFBTTtRQUM3QnBlLGVBQWVzRCxVQUFVO1lBQUM7U0FBa0IsRUFBRThhO0lBQ2xEO0lBQ0EsTUFBTUMsb0JBQW9CbGQsZUFBZWtDLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUlnYixxQkFBcUIsTUFBTTtRQUMzQnJlLGVBQWVzRCxVQUFVO1lBQUM7U0FBZ0IsRUFBRSthO0lBQ2hEO0lBQ0EsTUFBTUMsdUJBQXVCbmQsZUFBZWtDLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUlpYix3QkFBd0IsTUFBTTtRQUM5QnRlLGVBQWVzRCxVQUFVO1lBQUM7U0FBbUIsRUFBRWdiO0lBQ25EO0lBQ0EsTUFBTUMsZUFBZXBkLGVBQWVrQyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJa2IsZ0JBQWdCLE1BQU07UUFDdEJ2ZSxlQUFlc0QsVUFBVTtZQUFDO1NBQVcsRUFBRWliO0lBQzNDO0lBQ0EsTUFBTUMsc0JBQXNCcmQsZUFBZWtDLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUltYix1QkFBdUIsTUFBTTtRQUM3QnhlLGVBQWVzRCxVQUFVO1lBQUM7U0FBa0IsRUFBRWtiO0lBQ2xEO0lBQ0EsTUFBTUMsdUJBQXVCdGQsZUFBZWtDLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUlvYix3QkFBd0IsTUFBTTtRQUM5QnplLGVBQWVzRCxVQUFVO1lBQUM7U0FBbUIsRUFBRW1iO0lBQ25EO0lBQ0EsTUFBTUMsV0FBV3ZkLGVBQWVrQyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJcWIsWUFBWSxNQUFNO1FBQ2xCMWUsZUFBZXNELFVBQVU7WUFBQztTQUFPLEVBQUVvYjtJQUN2QztJQUNBLE1BQU1DLHVCQUF1QnhkLGVBQWVrQyxZQUFZO1FBQ3BEO0tBQ0g7SUFDRCxJQUFJc2Isd0JBQXdCLE1BQU07UUFDOUIzZSxlQUFlc0QsVUFBVTtZQUFDO1NBQW1CLEVBQUVxYjtJQUNuRDtJQUNBLE1BQU1DLHFCQUFxQnpkLGVBQWVrQyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJdWIsc0JBQXNCLE1BQU07UUFDNUI1ZSxlQUFlc0QsVUFBVTtZQUFDO1NBQWlCLEVBQUU2USxRQUFReUs7SUFDekQ7SUFDQSxNQUFNQyx5QkFBeUIxZCxlQUFla0MsWUFBWTtRQUN0RDtLQUNIO0lBQ0QsSUFBSXdiLDBCQUEwQixNQUFNO1FBQ2hDN2UsZUFBZXNELFVBQVU7WUFBQztTQUFxQixFQUFFdWI7SUFDckQ7SUFDQSxJQUFJMWQsZUFBZWtDLFlBQVk7UUFBQztLQUFnQixNQUFNcEYsV0FBVztRQUM3RCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsSUFBSW9CLGVBQWVrQyxZQUFZO1FBQUM7S0FBdUIsTUFBTXBGLFdBQVc7UUFDcEUsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE1BQU0rZSxxQkFBcUIzZCxlQUFla0MsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWE2Z0Isc0JBQXNCLE1BQU07UUFDMUQsSUFBSTNhLGtCQUFrQjJhO1FBQ3RCLElBQUl0ZSxNQUFNQyxPQUFPLENBQUMwRCxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCOUMsR0FBRyxDQUFDLENBQUNrQjtnQkFDbkMsT0FBT3ExQixxQkFBcUJyMUI7WUFDaEM7UUFDSjtRQUNBdkMsZUFBZW9jLGNBQWM7WUFBQztTQUFpQixFQUFFalk7SUFDckQ7SUFDQSxNQUFNNmEsWUFBWTdkLGVBQWVrQyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJK1ksaUJBQWlCbmUsYUFBYStnQixhQUFhLE1BQU07UUFDakQsSUFBSTdhLGtCQUFrQitRLE9BQU84SjtRQUM3QixJQUFJeGUsTUFBTUMsT0FBTyxDQUFDMEQsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQjlDLEdBQUcsQ0FBQyxDQUFDa0I7Z0JBQ25DLE9BQU9zMUIsY0FBY2xqQixNQUFNcFM7WUFDL0I7UUFDSjtRQUNBdkMsZUFBZW9jLGNBQWM7WUFBQztTQUFRLEVBQUVqWTtJQUM1QztJQUNBLE1BQU0rYSxpQkFBaUIvZCxlQUFla0MsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSStZLGlCQUFpQm5lLGFBQWFpaEIsa0JBQWtCLE1BQU07UUFDdERsZixlQUFlb2MsY0FBYztZQUFDO1NBQWEsRUFBRTBiLGtCQUFrQjVZO0lBQ25FO0lBQ0EsSUFBSS9kLGVBQWVrQyxZQUFZO1FBQUM7S0FBUyxNQUFNcEYsV0FBVztRQUN0RCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTXFmLG9CQUFvQmplLGVBQWVrQyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJK1ksaUJBQWlCbmUsYUFBYW1oQixxQkFBcUIsTUFBTTtRQUN6RHBmLGVBQWVvYyxjQUFjO1lBQUM7U0FBZ0IsRUFBRTNHLG1CQUFtQnJFLFdBQVdnTztJQUNsRjtJQUNBLE1BQU1DLHlCQUF5QmxlLGVBQWVrQyxZQUFZO1FBQ3REO0tBQ0g7SUFDRCxJQUFJZ2MsMEJBQTBCLE1BQU07UUFDaENyZixlQUFlc0QsVUFBVTtZQUFDO1NBQXFCLEVBQUUrYjtJQUNyRDtJQUNBLE1BQU1DLHNCQUFzQm5lLGVBQWVrQyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJaWMsdUJBQXVCLE1BQU07UUFDN0J0ZixlQUFlc0QsVUFBVTtZQUFDO1NBQWtCLEVBQUVnYztJQUNsRDtJQUNBLE1BQU1DLG1CQUFtQnBlLGVBQWVrQyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJa2Msb0JBQW9CLE1BQU07UUFDMUJ2ZixlQUFlc0QsVUFBVTtZQUFDO1NBQWUsRUFBRStRLGNBQWNrTDtJQUM3RDtJQUNBLElBQUlwZSxlQUFla0MsWUFBWTtRQUFDO0tBQWlCLE1BQU1wRixXQUFXO1FBQzlELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxNQUFNeWYscUJBQXFCcmUsZUFBZWtDLFlBQVk7UUFDbEQ7S0FDSDtJQUNELElBQUltYyxzQkFBc0IsTUFBTTtRQUM1QnhmLGVBQWVzRCxVQUFVO1lBQUM7U0FBaUIsRUFBRWtjO0lBQ2pEO0lBQ0EsTUFBTUMsa0JBQWtCdGUsZUFBZWtDLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUlvYyxtQkFBbUIsTUFBTTtRQUN6QnpmLGVBQWVzRCxVQUFVO1lBQUM7U0FBYyxFQUFFeTBCLG1CQUFtQnRZO0lBQ2pFO0lBQ0EsT0FBT25jO0FBQ1g7QUFDQSxTQUFTMDBCLDhCQUE4QjVtQixTQUFTLEVBQUUvTixVQUFVLEVBQUUrWSxZQUFZO0lBQ3RFLE1BQU05WSxXQUFXLENBQUM7SUFDbEIsTUFBTXlhLHdCQUF3QjVjLGVBQWVrQyxZQUFZO1FBQ3JEO0tBQ0g7SUFDRCxJQUFJK1ksaUJBQWlCbmUsYUFBYThmLHlCQUF5QixNQUFNO1FBQzdEL2QsZUFBZW9jLGNBQWM7WUFBQztTQUFvQixFQUFFMUosU0FBU3FMO0lBQ2pFO0lBQ0EsTUFBTUMsa0JBQWtCN2MsZUFBZWtDLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUkyYSxtQkFBbUIsTUFBTTtRQUN6QmhlLGVBQWVzRCxVQUFVO1lBQUM7U0FBYyxFQUFFMGE7SUFDOUM7SUFDQSxNQUFNQyxXQUFXOWMsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUk0YSxZQUFZLE1BQU07UUFDbEJqZSxlQUFlc0QsVUFBVTtZQUFDO1NBQU8sRUFBRTJhO0lBQ3ZDO0lBQ0EsTUFBTUMsV0FBVy9jLGVBQWVrQyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJNmEsWUFBWSxNQUFNO1FBQ2xCbGUsZUFBZXNELFVBQVU7WUFBQztTQUFPLEVBQUU0YTtJQUN2QztJQUNBLE1BQU1DLHFCQUFxQmhkLGVBQWVrQyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJOGEsc0JBQXNCLE1BQU07UUFDNUJuZSxlQUFlc0QsVUFBVTtZQUFDO1NBQWlCLEVBQUU2YTtJQUNqRDtJQUNBLE1BQU1DLHNCQUFzQmpkLGVBQWVrQyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJK2EsdUJBQXVCLE1BQU07UUFDN0JwZSxlQUFlc0QsVUFBVTtZQUFDO1NBQWtCLEVBQUU4YTtJQUNsRDtJQUNBLE1BQU1DLG9CQUFvQmxkLGVBQWVrQyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJZ2IscUJBQXFCLE1BQU07UUFDM0JyZSxlQUFlc0QsVUFBVTtZQUFDO1NBQWdCLEVBQUUrYTtJQUNoRDtJQUNBLE1BQU1DLHVCQUF1Qm5kLGVBQWVrQyxZQUFZO1FBQ3BEO0tBQ0g7SUFDRCxJQUFJaWIsd0JBQXdCLE1BQU07UUFDOUJ0ZSxlQUFlc0QsVUFBVTtZQUFDO1NBQW1CLEVBQUVnYjtJQUNuRDtJQUNBLE1BQU1DLGVBQWVwZCxlQUFla0MsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSWtiLGdCQUFnQixNQUFNO1FBQ3RCdmUsZUFBZXNELFVBQVU7WUFBQztTQUFXLEVBQUVpYjtJQUMzQztJQUNBLE1BQU1DLHNCQUFzQnJkLGVBQWVrQyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJbWIsdUJBQXVCLE1BQU07UUFDN0J4ZSxlQUFlc0QsVUFBVTtZQUFDO1NBQWtCLEVBQUVrYjtJQUNsRDtJQUNBLE1BQU1DLHVCQUF1QnRkLGVBQWVrQyxZQUFZO1FBQ3BEO0tBQ0g7SUFDRCxJQUFJb2Isd0JBQXdCLE1BQU07UUFDOUJ6ZSxlQUFlc0QsVUFBVTtZQUFDO1NBQW1CLEVBQUVtYjtJQUNuRDtJQUNBLE1BQU1DLFdBQVd2ZCxlQUFla0MsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSXFiLFlBQVksTUFBTTtRQUNsQjFlLGVBQWVzRCxVQUFVO1lBQUM7U0FBTyxFQUFFb2I7SUFDdkM7SUFDQSxNQUFNQyx1QkFBdUJ4ZCxlQUFla0MsWUFBWTtRQUNwRDtLQUNIO0lBQ0QsSUFBSXNiLHdCQUF3QixNQUFNO1FBQzlCM2UsZUFBZXNELFVBQVU7WUFBQztTQUFtQixFQUFFcWI7SUFDbkQ7SUFDQSxNQUFNQyxxQkFBcUJ6ZCxlQUFla0MsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSXViLHNCQUFzQixNQUFNO1FBQzVCNWUsZUFBZXNELFVBQVU7WUFBQztTQUFpQixFQUFFNlEsUUFBUXlLO0lBQ3pEO0lBQ0EsTUFBTUMseUJBQXlCMWQsZUFBZWtDLFlBQVk7UUFDdEQ7S0FDSDtJQUNELElBQUl3YiwwQkFBMEIsTUFBTTtRQUNoQzdlLGVBQWVzRCxVQUFVO1lBQUM7U0FBcUIsRUFBRXViO0lBQ3JEO0lBQ0EsTUFBTXdSLG9CQUFvQmx2QixlQUFla0MsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSWd0QixxQkFBcUIsTUFBTTtRQUMzQnJ3QixlQUFlc0QsVUFBVTtZQUFDO1NBQWdCLEVBQUUrc0I7SUFDaEQ7SUFDQSxNQUFNSCwyQkFBMkIvdUIsZUFBZWtDLFlBQVk7UUFDeEQ7S0FDSDtJQUNELElBQUk2c0IsNEJBQTRCLE1BQU07UUFDbENsd0IsZUFBZXNELFVBQVU7WUFBQztTQUFjLEVBQUU0c0I7SUFDOUM7SUFDQSxNQUFNcFIscUJBQXFCM2QsZUFBZWtDLFlBQVk7UUFDbEQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhNmdCLHNCQUFzQixNQUFNO1FBQzFELElBQUkzYSxrQkFBa0IyYTtRQUN0QixJQUFJdGUsTUFBTUMsT0FBTyxDQUFDMEQsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQjlDLEdBQUcsQ0FBQyxDQUFDa0I7Z0JBQ25DLE9BQU9BO1lBQ1g7UUFDSjtRQUNBdkMsZUFBZW9jLGNBQWM7WUFBQztTQUFpQixFQUFFalk7SUFDckQ7SUFDQSxNQUFNNmEsWUFBWTdkLGVBQWVrQyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJK1ksaUJBQWlCbmUsYUFBYStnQixhQUFhLE1BQU07UUFDakQsSUFBSTdhLGtCQUFrQitRLE9BQU84SjtRQUM3QixJQUFJeGUsTUFBTUMsT0FBTyxDQUFDMEQsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQjlDLEdBQUcsQ0FBQyxDQUFDa0I7Z0JBQ25DLE9BQU9teUIsYUFBYS9mLE1BQU1wUztZQUM5QjtRQUNKO1FBQ0F2QyxlQUFlb2MsY0FBYztZQUFDO1NBQVEsRUFBRWpZO0lBQzVDO0lBQ0EsTUFBTSthLGlCQUFpQi9kLGVBQWVrQyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJK1ksaUJBQWlCbmUsYUFBYWloQixrQkFBa0IsTUFBTTtRQUN0RGxmLGVBQWVvYyxjQUFjO1lBQUM7U0FBYSxFQUFFOEM7SUFDakQ7SUFDQSxNQUFNZ1gsYUFBYS8wQixlQUFla0MsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSStZLGlCQUFpQm5lLGFBQWFpNEIsY0FBYyxNQUFNO1FBQ2xEbDJCLGVBQWVvYyxjQUFjO1lBQUM7U0FBUyxFQUFFOFo7SUFDN0M7SUFDQSxNQUFNOVcsb0JBQW9CamUsZUFBZWtDLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhbWhCLHFCQUFxQixNQUFNO1FBQ3pEcGYsZUFBZW9jLGNBQWM7WUFBQztTQUFnQixFQUFFM0csbUJBQW1CckUsV0FBV2dPO0lBQ2xGO0lBQ0EsTUFBTUMseUJBQXlCbGUsZUFBZWtDLFlBQVk7UUFDdEQ7S0FDSDtJQUNELElBQUlnYywwQkFBMEIsTUFBTTtRQUNoQ3JmLGVBQWVzRCxVQUFVO1lBQUM7U0FBcUIsRUFBRStiO0lBQ3JEO0lBQ0EsTUFBTUMsc0JBQXNCbmUsZUFBZWtDLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUlpYyx1QkFBdUIsTUFBTTtRQUM3QnRmLGVBQWVzRCxVQUFVO1lBQUM7U0FBa0IsRUFBRWdjO0lBQ2xEO0lBQ0EsTUFBTUMsbUJBQW1CcGUsZUFBZWtDLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUlrYyxvQkFBb0IsTUFBTTtRQUMxQnZmLGVBQWVzRCxVQUFVO1lBQUM7U0FBZSxFQUFFMjBCLHFCQUFxQjVqQixjQUFja0w7SUFDbEY7SUFDQSxNQUFNNFEscUJBQXFCaHZCLGVBQWVrQyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJOHNCLHNCQUFzQixNQUFNO1FBQzVCbndCLGVBQWVzRCxVQUFVO1lBQUM7U0FBaUIsRUFBRTZzQjtJQUNqRDtJQUNBLE1BQU0zUSxxQkFBcUJyZSxlQUFla0MsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSW1jLHNCQUFzQixNQUFNO1FBQzVCeGYsZUFBZXNELFVBQVU7WUFBQztTQUFpQixFQUFFa2M7SUFDakQ7SUFDQSxNQUFNQyxrQkFBa0J0ZSxlQUFla0MsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSW9jLG1CQUFtQixNQUFNO1FBQ3pCemYsZUFBZXNELFVBQVU7WUFBQztTQUFjLEVBQUU0MEIsb0JBQW9Celk7SUFDbEU7SUFDQSxPQUFPbmM7QUFDWDtBQUNBLFNBQVM2MEIsaUNBQWlDL21CLFNBQVMsRUFBRS9OLFVBQVU7SUFDM0QsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU02VyxZQUFZaFosZUFBZWtDLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUk4VyxhQUFhLE1BQU07UUFDbkJuYSxlQUFlc0QsVUFBVTtZQUFDO1lBQVE7U0FBUSxFQUFFNk4sT0FBT0MsV0FBVytJO0lBQ2xFO0lBQ0EsTUFBTThDLGVBQWU5YixlQUFla0MsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSTRaLGdCQUFnQixNQUFNO1FBQ3RCLElBQUk5WSxrQkFBa0IwTyxVQUFVb0s7UUFDaEMsSUFBSXpjLE1BQU1DLE9BQU8sQ0FBQzBELGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0I5QyxHQUFHLENBQUMsQ0FBQ2tCO2dCQUNuQyxPQUFPNHhCLGlCQUFpQjV4QjtZQUM1QjtRQUNKO1FBQ0F2QyxlQUFlc0QsVUFBVTtZQUFDO1NBQVcsRUFBRWE7SUFDM0M7SUFDQSxNQUFNb1ksYUFBYXBiLGVBQWVrQyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJa1osY0FBYyxNQUFNO1FBQ3BCdmMsZUFBZXNELFVBQVU7WUFBQztTQUFtQixFQUFFcTBCLDZCQUE2QnZtQixXQUFXbUwsWUFBWWpaO0lBQ3ZHO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLFNBQVM4MEIsa0NBQWtDaG5CLFNBQVMsRUFBRS9OLFVBQVU7SUFDNUQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU02VyxZQUFZaFosZUFBZWtDLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUk4VyxhQUFhLE1BQU07UUFDbkJuYSxlQUFlc0QsVUFBVTtZQUFDO1lBQVE7U0FBUSxFQUFFNk4sT0FBT0MsV0FBVytJO0lBQ2xFO0lBQ0EsTUFBTThDLGVBQWU5YixlQUFla0MsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSTRaLGdCQUFnQixNQUFNO1FBQ3RCLElBQUk5WSxrQkFBa0IwTyxVQUFVb0s7UUFDaEMsSUFBSXpjLE1BQU1DLE9BQU8sQ0FBQzBELGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0I5QyxHQUFHLENBQUMsQ0FBQ2tCO2dCQUNuQyxPQUFPQTtZQUNYO1FBQ0o7UUFDQXZDLGVBQWVzRCxVQUFVO1lBQUM7U0FBVyxFQUFFYTtJQUMzQztJQUNBLE1BQU1vWSxhQUFhcGIsZUFBZWtDLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlrWixjQUFjLE1BQU07UUFDcEJ2YyxlQUFlc0QsVUFBVTtZQUFDO1NBQW1CLEVBQUUwMEIsOEJBQThCNW1CLFdBQVdtTCxZQUFZalo7SUFDeEc7SUFDQSxPQUFPQTtBQUNYO0FBQ0EsU0FBUyswQixpQ0FBaUNoMUIsVUFBVTtJQUNoRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXlCLHNCQUFzQjVELGVBQWVrQyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJMEIsdUJBQXVCLE1BQU07UUFDN0IvRSxlQUFlc0QsVUFBVTtZQUFDO1NBQWtCLEVBQUV5QjtJQUNsRDtJQUNBLE1BQU02YSxpQkFBaUJ6ZSxlQUFla0MsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSXVjLGtCQUFrQixNQUFNO1FBQ3hCLElBQUl6YixrQkFBa0J5YjtRQUN0QixJQUFJcGYsTUFBTUMsT0FBTyxDQUFDMEQsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQjlDLEdBQUcsQ0FBQyxDQUFDa0I7Z0JBQ25DLE9BQU9reEIsbUJBQW1CbHhCO1lBQzlCO1FBQ0o7UUFDQXZDLGVBQWVzRCxVQUFVO1lBQUM7U0FBYSxFQUFFYTtJQUM3QztJQUNBLE1BQU0wYixtQkFBbUIxZSxlQUFla0MsWUFBWTtRQUFDO0tBQWU7SUFDcEUsSUFBSXdjLG9CQUFvQixNQUFNO1FBQzFCN2YsZUFBZXNELFVBQVU7WUFBQztTQUFlLEVBQUV1YztJQUMvQztJQUNBLE1BQU1DLHFCQUFxQjNlLGVBQWVrQyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJeWMsc0JBQXNCLE1BQU07UUFDNUI5ZixlQUFlc0QsVUFBVTtZQUFDO1NBQWlCLEVBQUV3YztJQUNqRDtJQUNBLE1BQU1DLGlCQUFpQjVlLGVBQWVrQyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJMGMsa0JBQWtCLE1BQU07UUFDeEIvZixlQUFlc0QsVUFBVTtZQUFDO1NBQWEsRUFBRXljO0lBQzdDO0lBQ0EsTUFBTUMsb0JBQW9CN2UsZUFBZWtDLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUkyYyxxQkFBcUIsTUFBTTtRQUMzQmhnQixlQUFlc0QsVUFBVTtZQUFDO1NBQWdCLEVBQUUwYztJQUNoRDtJQUNBLE9BQU8xYztBQUNYO0FBQ0EsU0FBU2cxQixrQ0FBa0NqMUIsVUFBVTtJQUNqRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXlCLHNCQUFzQjVELGVBQWVrQyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJMEIsdUJBQXVCLE1BQU07UUFDN0IvRSxlQUFlc0QsVUFBVTtZQUFDO1NBQWtCLEVBQUV5QjtJQUNsRDtJQUNBLE1BQU02YSxpQkFBaUJ6ZSxlQUFla0MsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSXVjLGtCQUFrQixNQUFNO1FBQ3hCLElBQUl6YixrQkFBa0J5YjtRQUN0QixJQUFJcGYsTUFBTUMsT0FBTyxDQUFDMEQsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQjlDLEdBQUcsQ0FBQyxDQUFDa0I7Z0JBQ25DLE9BQU9BO1lBQ1g7UUFDSjtRQUNBdkMsZUFBZXNELFVBQVU7WUFBQztTQUFhLEVBQUVhO0lBQzdDO0lBQ0EsTUFBTTZWLGlCQUFpQjdZLGVBQWVrQyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJMlcsa0JBQWtCLE1BQU07UUFDeEJoYSxlQUFlc0QsVUFBVTtZQUFDO1NBQWEsRUFBRTBXO0lBQzdDO0lBQ0EsTUFBTTZGLG1CQUFtQjFlLGVBQWVrQyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJd2Msb0JBQW9CLE1BQU07UUFDMUI3ZixlQUFlc0QsVUFBVTtZQUFDO1NBQWUsRUFBRXVjO0lBQy9DO0lBQ0EsTUFBTUMscUJBQXFCM2UsZUFBZWtDLFlBQVk7UUFDbEQ7S0FDSDtJQUNELElBQUl5YyxzQkFBc0IsTUFBTTtRQUM1QjlmLGVBQWVzRCxVQUFVO1lBQUM7U0FBaUIsRUFBRXdjO0lBQ2pEO0lBQ0EsTUFBTUMsaUJBQWlCNWUsZUFBZWtDLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUkwYyxrQkFBa0IsTUFBTTtRQUN4Qi9mLGVBQWVzRCxVQUFVO1lBQUM7U0FBYSxFQUFFeWM7SUFDN0M7SUFDQSxNQUFNQyxvQkFBb0I3ZSxlQUFla0MsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSTJjLHFCQUFxQixNQUFNO1FBQzNCaGdCLGVBQWVzRCxVQUFVO1lBQUM7U0FBZ0IsRUFBRTBjO0lBQ2hEO0lBQ0EsT0FBTzFjO0FBQ1g7QUFDQSxTQUFTaTFCLDRCQUE0QmwxQixVQUFVLEVBQUUrWSxZQUFZO0lBQ3pELE1BQU05WSxXQUFXLENBQUM7SUFDbEIsSUFBSW5DLGVBQWVrQyxZQUFZO1FBQUM7S0FBZSxNQUFNcEYsV0FBVztRQUM1RCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsSUFBSW9CLGVBQWVrQyxZQUFZO1FBQUM7S0FBaUIsTUFBTXBGLFdBQVc7UUFDOUQsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE1BQU15MUIscUJBQXFCcjBCLGVBQWVrQyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJK1ksaUJBQWlCbmUsYUFBYXUzQixzQkFBc0IsTUFBTTtRQUMxRHgxQixlQUFlb2MsY0FBYztZQUFDO1lBQWM7U0FBYyxFQUFFb1o7SUFDaEU7SUFDQSxNQUFNalYsa0JBQWtCcGYsZUFBZWtDLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUkrWSxpQkFBaUJuZSxhQUFhc2lCLG1CQUFtQixNQUFNO1FBQ3ZEdmdCLGVBQWVvYyxjQUFjO1lBQUM7WUFBYztTQUFjLEVBQUVtRTtJQUNoRTtJQUNBLE1BQU1rVixvQkFBb0J0MEIsZUFBZWtDLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhdzNCLHFCQUFxQixNQUFNO1FBQ3pEejFCLGVBQWVvYyxjQUFjO1lBQUM7WUFBYztTQUFnQixFQUFFcVo7SUFDbEU7SUFDQSxJQUFJdDBCLGVBQWVrQyxZQUFZO1FBQUM7S0FBTyxNQUFNcEYsV0FBVztRQUNwRCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTTIxQix3QkFBd0J2MEIsZUFBZWtDLFlBQVk7UUFDckQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFheTNCLHlCQUF5QixNQUFNO1FBQzdEMTFCLGVBQWVvYyxjQUFjO1lBQUM7WUFBYztTQUFnQixFQUFFc1o7SUFDbEU7SUFDQSxNQUFNQyx1QkFBdUJ4MEIsZUFBZWtDLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhMDNCLHdCQUF3QixNQUFNO1FBQzVEMzFCLGVBQWVvYyxjQUFjO1lBQUM7WUFBYztTQUFtQixFQUFFdVo7SUFDckU7SUFDQSxNQUFNQyw4QkFBOEJ6MEIsZUFBZWtDLFlBQVk7UUFDM0Q7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhMjNCLCtCQUErQixNQUFNO1FBQ25FNTFCLGVBQWVvYyxjQUFjO1lBQUM7WUFBYztTQUEwQixFQUFFd1o7SUFDNUU7SUFDQSxNQUFNQyx1QkFBdUIxMEIsZUFBZWtDLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhNDNCLHdCQUF3QixNQUFNO1FBQzVENzFCLGVBQWVvYyxjQUFjO1lBQUM7WUFBYztTQUFtQixFQUFFeVo7SUFDckU7SUFDQSxNQUFNQyxlQUFlMzBCLGVBQWVrQyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJK1ksaUJBQWlCbmUsYUFBYTYzQixnQkFBZ0IsTUFBTTtRQUNwRDkxQixlQUFlb2MsY0FBYztZQUFDO1lBQWM7U0FBVyxFQUFFMFo7SUFDN0Q7SUFDQSxNQUFNQyxxQkFBcUI1MEIsZUFBZWtDLFlBQVk7UUFDbEQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhODNCLHNCQUFzQixNQUFNO1FBQzFELzFCLGVBQWVvYyxjQUFjO1lBQUM7WUFBYztZQUFpQjtTQUFXLEVBQUUyWjtJQUM5RTtJQUNBLE1BQU1DLCtCQUErQjcwQixlQUFla0MsWUFBWTtRQUM1RDtLQUNIO0lBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWErM0IsZ0NBQWdDLE1BQU07UUFDcEVoMkIsZUFBZW9jLGNBQWM7WUFBQztZQUFjO1lBQWlCO1NBQXFCLEVBQUU0WjtJQUN4RjtJQUNBLElBQUk3MEIsZUFBZWtDLFlBQVk7UUFBQztLQUFlLE1BQU1wRixXQUFXO1FBQzVELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxJQUFJb0IsZUFBZWtDLFlBQVk7UUFBQztLQUFTLE1BQU1wRixXQUFXO1FBQ3RELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxNQUFNeWdCLGdCQUFnQnJmLGVBQWVrQyxZQUFZO1FBQUM7S0FBWTtJQUM5RCxJQUFJK1ksaUJBQWlCbmUsYUFBYXVpQixpQkFBaUIsTUFBTTtRQUNyRHhnQixlQUFlb2MsY0FBYztZQUFDO1lBQWM7U0FBa0IsRUFBRW9FO0lBQ3BFO0lBQ0EsSUFBSXJmLGVBQWVrQyxZQUFZO1FBQUM7S0FBZ0IsTUFBTXBGLFdBQVc7UUFDN0QsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE9BQU91RDtBQUNYO0FBQ0EsU0FBU2sxQiw2QkFBNkJuMUIsVUFBVSxFQUFFK1ksWUFBWTtJQUMxRCxNQUFNOVksV0FBVyxDQUFDO0lBQ2xCLE1BQU1neUIsbUJBQW1CbjBCLGVBQWVrQyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJK1ksaUJBQWlCbmUsYUFBYXEzQixvQkFBb0IsTUFBTTtRQUN4RHQxQixlQUFlb2MsY0FBYztZQUFDO1lBQWM7U0FBYSxFQUFFa1o7SUFDL0Q7SUFDQSxNQUFNQyxxQkFBcUJwMEIsZUFBZWtDLFlBQVk7UUFDbEQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhczNCLHNCQUFzQixNQUFNO1FBQzFEdjFCLGVBQWVvYyxjQUFjO1lBQUM7WUFBYztTQUFpQixFQUFFbVo7SUFDbkU7SUFDQSxNQUFNQyxxQkFBcUJyMEIsZUFBZWtDLFlBQVk7UUFDbEQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhdTNCLHNCQUFzQixNQUFNO1FBQzFEeDFCLGVBQWVvYyxjQUFjO1lBQUM7WUFBYztTQUFjLEVBQUVvWjtJQUNoRTtJQUNBLE1BQU1qVixrQkFBa0JwZixlQUFla0MsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSStZLGlCQUFpQm5lLGFBQWFzaUIsbUJBQW1CLE1BQU07UUFDdkR2Z0IsZUFBZW9jLGNBQWM7WUFBQztZQUFjO1NBQWMsRUFBRW1FO0lBQ2hFO0lBQ0EsTUFBTWtWLG9CQUFvQnQwQixlQUFla0MsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWF3M0IscUJBQXFCLE1BQU07UUFDekR6MUIsZUFBZW9jLGNBQWM7WUFBQztZQUFjO1NBQWdCLEVBQUVxWjtJQUNsRTtJQUNBLE1BQU0vVyxXQUFXdmQsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUkrWSxpQkFBaUJuZSxhQUFheWdCLFlBQVksTUFBTTtRQUNoRDFlLGVBQWVvYyxjQUFjO1lBQUM7WUFBYztTQUFPLEVBQUVzQztJQUN6RDtJQUNBLE1BQU1nWCx3QkFBd0J2MEIsZUFBZWtDLFlBQVk7UUFDckQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFheTNCLHlCQUF5QixNQUFNO1FBQzdEMTFCLGVBQWVvYyxjQUFjO1lBQUM7WUFBYztTQUFnQixFQUFFc1o7SUFDbEU7SUFDQSxNQUFNQyx1QkFBdUJ4MEIsZUFBZWtDLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhMDNCLHdCQUF3QixNQUFNO1FBQzVEMzFCLGVBQWVvYyxjQUFjO1lBQUM7WUFBYztTQUFtQixFQUFFdVo7SUFDckU7SUFDQSxNQUFNQyw4QkFBOEJ6MEIsZUFBZWtDLFlBQVk7UUFDM0Q7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhMjNCLCtCQUErQixNQUFNO1FBQ25FNTFCLGVBQWVvYyxjQUFjO1lBQUM7WUFBYztTQUEwQixFQUFFd1o7SUFDNUU7SUFDQSxNQUFNQyx1QkFBdUIxMEIsZUFBZWtDLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhNDNCLHdCQUF3QixNQUFNO1FBQzVENzFCLGVBQWVvYyxjQUFjO1lBQUM7WUFBYztTQUFtQixFQUFFeVo7SUFDckU7SUFDQSxNQUFNQyxlQUFlMzBCLGVBQWVrQyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJK1ksaUJBQWlCbmUsYUFBYTYzQixnQkFBZ0IsTUFBTTtRQUNwRDkxQixlQUFlb2MsY0FBYztZQUFDO1lBQWM7U0FBVyxFQUFFMFo7SUFDN0Q7SUFDQSxNQUFNQyxxQkFBcUI1MEIsZUFBZWtDLFlBQVk7UUFDbEQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhODNCLHNCQUFzQixNQUFNO1FBQzFELzFCLGVBQWVvYyxjQUFjO1lBQUM7WUFBYztZQUFpQjtTQUFXLEVBQUUyWjtJQUM5RTtJQUNBLE1BQU1DLCtCQUErQjcwQixlQUFla0MsWUFBWTtRQUM1RDtLQUNIO0lBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWErM0IsZ0NBQWdDLE1BQU07UUFDcEVoMkIsZUFBZW9jLGNBQWM7WUFBQztZQUFjO1lBQWlCO1NBQXFCLEVBQUU0WjtJQUN4RjtJQUNBLE1BQU1DLG1CQUFtQjkwQixlQUFla0MsWUFBWTtRQUFDO0tBQWU7SUFDcEUsSUFBSStZLGlCQUFpQm5lLGFBQWFnNEIsb0JBQW9CLE1BQU07UUFDeERqMkIsZUFBZW9jLGNBQWM7WUFBQztZQUFjO1NBQWUsRUFBRTZaO0lBQ2pFO0lBQ0EsTUFBTUMsYUFBYS8wQixlQUFla0MsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSStZLGlCQUFpQm5lLGFBQWFpNEIsY0FBYyxNQUFNO1FBQ2xEbDJCLGVBQWVvYyxjQUFjO1lBQUM7U0FBUyxFQUFFOFo7SUFDN0M7SUFDQSxNQUFNMVYsZ0JBQWdCcmYsZUFBZWtDLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUkrWSxpQkFBaUJuZSxhQUFhdWlCLGlCQUFpQixNQUFNO1FBQ3JEeGdCLGVBQWVvYyxjQUFjO1lBQUM7WUFBYztTQUFrQixFQUFFb0U7SUFDcEU7SUFDQSxNQUFNaVksb0JBQW9CdDNCLGVBQWVrQyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJK1ksaUJBQWlCbmUsYUFBYXc2QixxQkFBcUIsTUFBTTtRQUN6RHo0QixlQUFlb2MsY0FBYztZQUFDO1lBQWM7U0FBZ0IsRUFBRXFjO0lBQ2xFO0lBQ0EsT0FBT24xQjtBQUNYO0FBQ0EsU0FBU28xQixnQ0FBZ0N0bkIsU0FBUyxFQUFFL04sVUFBVTtJQUMxRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTTZXLFlBQVloWixlQUFla0MsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSThXLGFBQWEsTUFBTTtRQUNuQm5hLGVBQWVzRCxVQUFVO1lBQUM7WUFBUTtTQUFRLEVBQUU2TixPQUFPQyxXQUFXK0k7SUFDbEU7SUFDQSxNQUFNbWMsYUFBYW4xQixlQUFla0MsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSWl6QixjQUFjLE1BQU07UUFDcEJ0MkIsZUFBZXNELFVBQVU7WUFBQztZQUFnQjtTQUFTLEVBQUVnekI7SUFDekQ7SUFDQSxNQUFNL1osYUFBYXBiLGVBQWVrQyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJa1osY0FBYyxNQUFNO1FBQ3BCZ2MsNEJBQTRCaGMsWUFBWWpaO0lBQzVDO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLFNBQVNxMUIsaUNBQWlDdm5CLFNBQVMsRUFBRS9OLFVBQVU7SUFDM0QsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU02VyxZQUFZaFosZUFBZWtDLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUk4VyxhQUFhLE1BQU07UUFDbkJuYSxlQUFlc0QsVUFBVTtZQUFDO1lBQVE7U0FBUSxFQUFFNk4sT0FBT0MsV0FBVytJO0lBQ2xFO0lBQ0EsTUFBTW1jLGFBQWFuMUIsZUFBZWtDLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlpekIsY0FBYyxNQUFNO1FBQ3BCdDJCLGVBQWVzRCxVQUFVO1lBQUM7WUFBZ0I7U0FBUyxFQUFFZ3pCO0lBQ3pEO0lBQ0EsTUFBTS9aLGFBQWFwYixlQUFla0MsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSWtaLGNBQWMsTUFBTTtRQUNwQmljLDZCQUE2QmpjLFlBQVlqWjtJQUM3QztJQUNBLE9BQU9BO0FBQ1g7QUFDQSxTQUFTczFCLGdDQUFnQ3YxQixVQUFVO0lBQy9DLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNeUIsc0JBQXNCNUQsZUFBZWtDLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUkwQix1QkFBdUIsTUFBTTtRQUM3Qi9FLGVBQWVzRCxVQUFVO1lBQUM7U0FBa0IsRUFBRXlCO0lBQ2xEO0lBQ0EsTUFBTTJ4QixzQkFBc0J2MUIsZUFBZWtDLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUlxekIsdUJBQXVCLE1BQU07UUFDN0IsSUFBSXZ5QixrQkFBa0J1eUI7UUFDdEIsSUFBSWwyQixNQUFNQyxPQUFPLENBQUMwRCxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCOUMsR0FBRyxDQUFDLENBQUNrQjtnQkFDbkMsT0FBT3MyQix3QkFBd0J0MkI7WUFDbkM7UUFDSjtRQUNBdkMsZUFBZXNELFVBQVU7WUFBQztTQUFrQixFQUFFYTtJQUNsRDtJQUNBLE1BQU0yMEIscUNBQXFDMzNCLGVBQWVrQyxZQUFZO1FBQ2xFO0tBQ0g7SUFDRCxJQUFJeTFCLHNDQUFzQyxNQUFNO1FBQzVDOTRCLGVBQWVzRCxVQUFVO1lBQUM7U0FBaUMsRUFBRXkxQiwwQkFBMEJEO0lBQzNGO0lBQ0EsT0FBT3gxQjtBQUNYO0FBQ0EsU0FBUzAxQixpQ0FBaUMzMUIsVUFBVTtJQUNoRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXlCLHNCQUFzQjVELGVBQWVrQyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJMEIsdUJBQXVCLE1BQU07UUFDN0IvRSxlQUFlc0QsVUFBVTtZQUFDO1NBQWtCLEVBQUV5QjtJQUNsRDtJQUNBLE1BQU0yeEIsc0JBQXNCdjFCLGVBQWVrQyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJcXpCLHVCQUF1QixNQUFNO1FBQzdCLElBQUl2eUIsa0JBQWtCdXlCO1FBQ3RCLElBQUlsMkIsTUFBTUMsT0FBTyxDQUFDMEQsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQjlDLEdBQUcsQ0FBQyxDQUFDa0I7Z0JBQ25DLE9BQU9vMEIseUJBQXlCcDBCO1lBQ3BDO1FBQ0o7UUFDQXZDLGVBQWVzRCxVQUFVO1lBQUM7U0FBa0IsRUFBRWE7SUFDbEQ7SUFDQSxNQUFNMjBCLHFDQUFxQzMzQixlQUFla0MsWUFBWTtRQUNsRTtLQUNIO0lBQ0QsSUFBSXkxQixzQ0FBc0MsTUFBTTtRQUM1Qzk0QixlQUFlc0QsVUFBVTtZQUFDO1NBQWlDLEVBQUUyMUIsMkJBQTJCSDtJQUM1RjtJQUNBLE9BQU94MUI7QUFDWDtBQUNBLFNBQVM0MUIsNEJBQTRCNzFCLFVBQVUsRUFBRStZLFlBQVk7SUFDekQsTUFBTTlZLFdBQVcsQ0FBQztJQUNsQixNQUFNNjFCLHFCQUFxQmg0QixlQUFla0MsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWFrN0Isc0JBQXNCLE1BQU07UUFDMURuNUIsZUFBZW9jLGNBQWM7WUFBQztZQUFjO1NBQWMsRUFBRStjO0lBQ2hFO0lBQ0EsSUFBSWg0QixlQUFla0MsWUFBWTtRQUFDO0tBQWUsTUFBTXBGLFdBQVc7UUFDNUQsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLElBQUlvQixlQUFla0MsWUFBWTtRQUFDO0tBQU0sTUFBTXBGLFdBQVc7UUFDbkQsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE1BQU1xNUIsc0JBQXNCajRCLGVBQWVrQyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJK1ksaUJBQWlCbmUsYUFBYW03Qix1QkFBdUIsTUFBTTtRQUMzRHA1QixlQUFlb2MsY0FBYztZQUFDO1lBQWM7U0FBa0IsRUFBRWdkO0lBQ3BFO0lBQ0EsSUFBSWo0QixlQUFla0MsWUFBWTtRQUFDO0tBQU8sTUFBTXBGLFdBQVc7UUFDcEQsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE1BQU13Z0Isa0JBQWtCcGYsZUFBZWtDLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUkrWSxpQkFBaUJuZSxhQUFhc2lCLG1CQUFtQixNQUFNO1FBQ3ZEdmdCLGVBQWVvYyxjQUFjO1lBQUM7WUFBYztTQUFjLEVBQUVtRTtJQUNoRTtJQUNBLE1BQU04WSxpQkFBaUJsNEIsZUFBZWtDLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUkrWSxpQkFBaUJuZSxhQUFhbzdCLGtCQUFrQixNQUFNO1FBQ3REcjVCLGVBQWVvYyxjQUFjO1lBQUM7WUFBYztTQUFhLEVBQUVpZDtJQUMvRDtJQUNBLE1BQU0xRCx1QkFBdUJ4MEIsZUFBZWtDLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhMDNCLHdCQUF3QixNQUFNO1FBQzVEMzFCLGVBQWVvYyxjQUFjO1lBQUM7WUFBYztTQUFtQixFQUFFdVo7SUFDckU7SUFDQSxJQUFJeDBCLGVBQWVrQyxZQUFZO1FBQUM7S0FBYyxNQUFNcEYsV0FBVztRQUMzRCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTXcxQixxQkFBcUJwMEIsZUFBZWtDLFlBQVk7UUFDbEQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhczNCLHNCQUFzQixNQUFNO1FBQzFEdjFCLGVBQWVvYyxjQUFjO1lBQUM7WUFBYztTQUFpQixFQUFFbVo7SUFDbkU7SUFDQSxNQUFNa0Qsb0JBQW9CdDNCLGVBQWVrQyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJK1ksaUJBQWlCbmUsYUFBYXc2QixxQkFBcUIsTUFBTTtRQUN6RHo0QixlQUFlb2MsY0FBYztZQUFDO1lBQWM7U0FBZ0IsRUFBRXFjO0lBQ2xFO0lBQ0EsSUFBSXQzQixlQUFla0MsWUFBWTtRQUFDO0tBQWdCLE1BQU1wRixXQUFXO1FBQzdELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxNQUFNdTVCLGdCQUFnQm40QixlQUFla0MsWUFBWTtRQUFDO0tBQVk7SUFDOUQsSUFBSStZLGlCQUFpQm5lLGFBQWFxN0IsaUJBQWlCLE1BQU07UUFDckR0NUIsZUFBZW9jLGNBQWM7WUFBQztZQUFnQjtTQUFZLEVBQUVtZCxhQUFhRDtJQUM3RTtJQUNBLE1BQU0vQyxzQkFBc0JwMUIsZUFBZWtDLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhczRCLHVCQUF1QixNQUFNO1FBQzNELElBQUlweUIsa0JBQWtCb3lCO1FBQ3RCLElBQUkvMUIsTUFBTUMsT0FBTyxDQUFDMEQsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQjlDLEdBQUcsQ0FBQyxDQUFDa0I7Z0JBQ25DLE9BQU9pM0IscUNBQXFDajNCO1lBQ2hEO1FBQ0o7UUFDQXZDLGVBQWVvYyxjQUFjO1lBQUM7WUFBZ0I7U0FBa0IsRUFBRWpZO0lBQ3RFO0lBQ0EsSUFBSWhELGVBQWVrQyxZQUFZO1FBQUM7S0FBTyxNQUFNcEYsV0FBVztRQUNwRCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsSUFBSW9CLGVBQWVrQyxZQUFZO1FBQUM7S0FBcUIsTUFBTXBGLFdBQVc7UUFDbEUsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE9BQU91RDtBQUNYO0FBQ0EsU0FBU20yQiw2QkFBNkJwMkIsVUFBVSxFQUFFK1ksWUFBWTtJQUMxRCxNQUFNOVksV0FBVyxDQUFDO0lBQ2xCLE1BQU02MUIscUJBQXFCaDRCLGVBQWVrQyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJK1ksaUJBQWlCbmUsYUFBYWs3QixzQkFBc0IsTUFBTTtRQUMxRG41QixlQUFlb2MsY0FBYztZQUFDO1lBQWM7U0FBYyxFQUFFK2M7SUFDaEU7SUFDQSxNQUFNN0QsbUJBQW1CbjBCLGVBQWVrQyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJK1ksaUJBQWlCbmUsYUFBYXEzQixvQkFBb0IsTUFBTTtRQUN4RHQxQixlQUFlb2MsY0FBYztZQUFDO1lBQWM7U0FBYSxFQUFFa1o7SUFDL0Q7SUFDQSxNQUFNb0UsVUFBVXY0QixlQUFla0MsWUFBWTtRQUFDO0tBQU07SUFDbEQsSUFBSStZLGlCQUFpQm5lLGFBQWF5N0IsV0FBVyxNQUFNO1FBQy9DMTVCLGVBQWVvYyxjQUFjO1lBQUM7WUFBYztTQUFNLEVBQUVzZDtJQUN4RDtJQUNBLE1BQU1OLHNCQUFzQmo0QixlQUFla0MsWUFBWTtRQUNuRDtLQUNIO0lBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWFtN0IsdUJBQXVCLE1BQU07UUFDM0RwNUIsZUFBZW9jLGNBQWM7WUFBQztZQUFjO1NBQWtCLEVBQUVnZDtJQUNwRTtJQUNBLE1BQU0xYSxXQUFXdmQsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUkrWSxpQkFBaUJuZSxhQUFheWdCLFlBQVksTUFBTTtRQUNoRDFlLGVBQWVvYyxjQUFjO1lBQUM7WUFBYztTQUFPLEVBQUVzQztJQUN6RDtJQUNBLE1BQU02QixrQkFBa0JwZixlQUFla0MsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSStZLGlCQUFpQm5lLGFBQWFzaUIsbUJBQW1CLE1BQU07UUFDdkR2Z0IsZUFBZW9jLGNBQWM7WUFBQztZQUFjO1NBQWMsRUFBRW1FO0lBQ2hFO0lBQ0EsTUFBTThZLGlCQUFpQmw0QixlQUFla0MsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSStZLGlCQUFpQm5lLGFBQWFvN0Isa0JBQWtCLE1BQU07UUFDdERyNUIsZUFBZW9jLGNBQWM7WUFBQztZQUFjO1NBQWEsRUFBRWlkO0lBQy9EO0lBQ0EsTUFBTTFELHVCQUF1QngwQixlQUFla0MsWUFBWTtRQUNwRDtLQUNIO0lBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWEwM0Isd0JBQXdCLE1BQU07UUFDNUQzMUIsZUFBZW9jLGNBQWM7WUFBQztZQUFjO1NBQW1CLEVBQUV1WjtJQUNyRTtJQUNBLE1BQU1nRSxrQkFBa0J4NEIsZUFBZWtDLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUkrWSxpQkFBaUJuZSxhQUFhMDdCLG1CQUFtQixNQUFNO1FBQ3ZEMzVCLGVBQWVvYyxjQUFjO1lBQUM7WUFBYztTQUFjLEVBQUV1ZDtJQUNoRTtJQUNBLE1BQU1wRSxxQkFBcUJwMEIsZUFBZWtDLFlBQVk7UUFDbEQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhczNCLHNCQUFzQixNQUFNO1FBQzFEdjFCLGVBQWVvYyxjQUFjO1lBQUM7WUFBYztTQUFpQixFQUFFbVo7SUFDbkU7SUFDQSxNQUFNa0Qsb0JBQW9CdDNCLGVBQWVrQyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJK1ksaUJBQWlCbmUsYUFBYXc2QixxQkFBcUIsTUFBTTtRQUN6RHo0QixlQUFlb2MsY0FBYztZQUFDO1lBQWM7U0FBZ0IsRUFBRXFjO0lBQ2xFO0lBQ0EsTUFBTW1CLG9CQUFvQno0QixlQUFla0MsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWEyN0IscUJBQXFCLE1BQU07UUFDekQ1NUIsZUFBZW9jLGNBQWM7WUFBQztZQUFjO1NBQWdCLEVBQUV3ZDtJQUNsRTtJQUNBLE1BQU1OLGdCQUFnQm40QixlQUFla0MsWUFBWTtRQUFDO0tBQVk7SUFDOUQsSUFBSStZLGlCQUFpQm5lLGFBQWFxN0IsaUJBQWlCLE1BQU07UUFDckR0NUIsZUFBZW9jLGNBQWM7WUFBQztZQUFnQjtTQUFZLEVBQUV5ZCxjQUFjUDtJQUM5RTtJQUNBLE1BQU0vQyxzQkFBc0JwMUIsZUFBZWtDLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhczRCLHVCQUF1QixNQUFNO1FBQzNELElBQUlweUIsa0JBQWtCb3lCO1FBQ3RCLElBQUkvMUIsTUFBTUMsT0FBTyxDQUFDMEQsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQjlDLEdBQUcsQ0FBQyxDQUFDa0I7Z0JBQ25DLE9BQU91M0Isc0NBQXNDdjNCO1lBQ2pEO1FBQ0o7UUFDQXZDLGVBQWVvYyxjQUFjO1lBQUM7WUFBZ0I7U0FBa0IsRUFBRWpZO0lBQ3RFO0lBQ0EsTUFBTTQxQixXQUFXNTRCLGVBQWVrQyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJK1ksaUJBQWlCbmUsYUFBYTg3QixZQUFZLE1BQU07UUFDaEQvNUIsZUFBZW9jLGNBQWM7WUFBQztZQUFnQjtTQUFPLEVBQUU0ZCw0QkFBNEJEO0lBQ3ZGO0lBQ0EsTUFBTUUseUJBQXlCOTRCLGVBQWVrQyxZQUFZO1FBQ3REO0tBQ0g7SUFDRCxJQUFJK1ksaUJBQWlCbmUsYUFBYWc4QiwwQkFBMEIsTUFBTTtRQUM5RGo2QixlQUFlb2MsY0FBYztZQUFDO1lBQWM7U0FBcUIsRUFBRTZkO0lBQ3ZFO0lBQ0EsT0FBTzMyQjtBQUNYO0FBQ0EsU0FBUzQyQixpQ0FBaUM3MkIsVUFBVTtJQUNoRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTUksV0FBV3ZDLGVBQWVrQyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJSyxZQUFZLE1BQU07UUFDbEIxRCxlQUFlc0QsVUFBVTtZQUFDO1NBQU8sRUFBRUk7SUFDdkM7SUFDQSxNQUFNQyxlQUFleEMsZUFBZWtDLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlNLGdCQUFnQixNQUFNO1FBQ3RCM0QsZUFBZXNELFVBQVU7WUFBQztTQUFXLEVBQUVLO0lBQzNDO0lBQ0EsTUFBTUMsV0FBV3pDLGVBQWVrQyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJTyxZQUFZLE1BQU07UUFDbEI1RCxlQUFlc0QsVUFBVTtZQUFDO1NBQU8sRUFBRU07SUFDdkM7SUFDQSxNQUFNQyxZQUFZMUMsZUFBZWtDLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUlRLGFBQWEsTUFBTTtRQUNuQjdELGVBQWVzRCxVQUFVO1lBQUM7U0FBUSxFQUFFTztJQUN4QztJQUNBLE1BQU1DLGVBQWUzQyxlQUFla0MsWUFBWTtRQUM1QztRQUNBO0tBQ0g7SUFDRCxJQUFJUyxnQkFBZ0IsTUFBTTtRQUN0QjlELGVBQWVzRCxVQUFVO1lBQUM7U0FBVyxFQUFFNjJCLGdDQUFnQ3IyQjtJQUMzRTtJQUNBLE9BQU9SO0FBQ1g7QUFDQSxTQUFTODJCLGtDQUFrQy8yQixVQUFVO0lBQ2pELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNSSxXQUFXdkMsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlLLFlBQVksTUFBTTtRQUNsQjFELGVBQWVzRCxVQUFVO1lBQUM7U0FBTyxFQUFFSTtJQUN2QztJQUNBLE1BQU1DLGVBQWV4QyxlQUFla0MsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSU0sZ0JBQWdCLE1BQU07UUFDdEIzRCxlQUFlc0QsVUFBVTtZQUFDO1NBQVcsRUFBRUs7SUFDM0M7SUFDQSxNQUFNQyxXQUFXekMsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlPLFlBQVksTUFBTTtRQUNsQjVELGVBQWVzRCxVQUFVO1lBQUM7U0FBTyxFQUFFTTtJQUN2QztJQUNBLE1BQU1DLFlBQVkxQyxlQUFla0MsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSVEsYUFBYSxNQUFNO1FBQ25CN0QsZUFBZXNELFVBQVU7WUFBQztTQUFRLEVBQUVPO0lBQ3hDO0lBQ0EsTUFBTUMsZUFBZTNDLGVBQWVrQyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJUyxnQkFBZ0IsTUFBTTtRQUN0QjlELGVBQWVzRCxVQUFVO1lBQUM7U0FBVyxFQUFFKzJCLGlDQUFpQ3YyQjtJQUM1RTtJQUNBLE9BQU9SO0FBQ1g7QUFDQSxTQUFTZzNCLGdDQUFnQ2xwQixTQUFTLEVBQUUvTixVQUFVO0lBQzFELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNNlcsWUFBWWhaLGVBQWVrQyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJOFcsYUFBYSxNQUFNO1FBQ25CbmEsZUFBZXNELFVBQVU7WUFBQztZQUFRO1NBQVEsRUFBRTZOLE9BQU9DLFdBQVcrSTtJQUNsRTtJQUNBLE1BQU1tYyxhQUFhbjFCLGVBQWVrQyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJaXpCLGNBQWMsTUFBTTtRQUNwQnQyQixlQUFlc0QsVUFBVTtZQUFDO1lBQWdCO1NBQVMsRUFBRWd6QjtJQUN6RDtJQUNBLE1BQU1pRSxZQUFZcDVCLGVBQWVrQyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJazNCLGFBQWEsTUFBTTtRQUNuQnY2QixlQUFlc0QsVUFBVTtZQUFDO1lBQWdCO1NBQVEsRUFBRWkyQixhQUFhZ0I7SUFDckU7SUFDQSxNQUFNLzFCLFlBQVlyRCxlQUFla0MsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSW1CLGFBQWEsTUFBTTtRQUNuQnhFLGVBQWVzRCxVQUFVO1lBQUM7WUFBZ0I7U0FBUSxFQUFFazNCLGFBQWFoMkI7SUFDckU7SUFDQSxNQUFNaTJCLGFBQWF0NUIsZUFBZWtDLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlvM0IsY0FBYyxNQUFNO1FBQ3BCQyw0QkFBNEJELFlBQVluM0I7SUFDNUM7SUFDQSxNQUFNaVosYUFBYXBiLGVBQWVrQyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJa1osY0FBYyxNQUFNO1FBQ3BCMmMsNEJBQTRCM2MsWUFBWWpaO0lBQzVDO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLFNBQVNxM0IsaUNBQWlDdnBCLFNBQVMsRUFBRS9OLFVBQVU7SUFDM0QsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU02VyxZQUFZaFosZUFBZWtDLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUk4VyxhQUFhLE1BQU07UUFDbkJuYSxlQUFlc0QsVUFBVTtZQUFDO1lBQVE7U0FBUSxFQUFFNk4sT0FBT0MsV0FBVytJO0lBQ2xFO0lBQ0EsTUFBTW1jLGFBQWFuMUIsZUFBZWtDLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlpekIsY0FBYyxNQUFNO1FBQ3BCdDJCLGVBQWVzRCxVQUFVO1lBQUM7WUFBZ0I7U0FBUyxFQUFFZ3pCO0lBQ3pEO0lBQ0EsTUFBTWlFLFlBQVlwNUIsZUFBZWtDLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUlrM0IsYUFBYSxNQUFNO1FBQ25CdjZCLGVBQWVzRCxVQUFVO1lBQUM7WUFBZ0I7U0FBUSxFQUFFdTJCLGNBQWNVO0lBQ3RFO0lBQ0EsTUFBTS8xQixZQUFZckQsZUFBZWtDLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUltQixhQUFhLE1BQU07UUFDbkJ4RSxlQUFlc0QsVUFBVTtZQUFDO1lBQWdCO1NBQVEsRUFBRXMzQixjQUFjcDJCO0lBQ3RFO0lBQ0EsTUFBTWkyQixhQUFhdDVCLGVBQWVrQyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJbzNCLGNBQWMsTUFBTTtRQUNwQkksNkJBQTZCSixZQUFZbjNCO0lBQzdDO0lBQ0EsTUFBTWlaLGFBQWFwYixlQUFla0MsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSWtaLGNBQWMsTUFBTTtRQUNwQmtkLDZCQUE2QmxkLFlBQVlqWjtJQUM3QztJQUNBLE9BQU9BO0FBQ1g7QUFDQSxTQUFTNjJCLGdDQUFnQzkyQixVQUFVO0lBQy9DLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNWSxzQkFBc0IvQyxlQUFla0MsWUFBWTtRQUNuRDtLQUNIO0lBQ0QsSUFBSWEsdUJBQXVCLE1BQU07UUFDN0IsSUFBSUMsa0JBQWtCRDtRQUN0QixJQUFJMUQsTUFBTUMsT0FBTyxDQUFDMEQsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQjlDLEdBQUcsQ0FBQyxDQUFDa0I7Z0JBQ25DLE9BQU91NEIsd0JBQXdCdjRCO1lBQ25DO1FBQ0o7UUFDQXZDLGVBQWVzRCxVQUFVO1lBQUM7U0FBa0IsRUFBRWE7SUFDbEQ7SUFDQSxNQUFNRSw0QkFBNEJsRCxlQUFla0MsWUFBWTtRQUN6RDtLQUNIO0lBQ0QsSUFBSWdCLDZCQUE2QixNQUFNO1FBQ25DckUsZUFBZXNELFVBQVU7WUFBQztTQUF3QixFQUFFZTtJQUN4RDtJQUNBLE1BQU1DLDhCQUE4Qm5ELGVBQWVrQyxZQUFZO1FBQzNEO0tBQ0g7SUFDRCxJQUFJaUIsK0JBQStCLE1BQU07UUFDckN0RSxlQUFlc0QsVUFBVTtZQUFDO1NBQTBCLEVBQUVnQjtJQUMxRDtJQUNBLE9BQU9oQjtBQUNYO0FBQ0EsU0FBUysyQixpQ0FBaUNoM0IsVUFBVTtJQUNoRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTVksc0JBQXNCL0MsZUFBZWtDLFlBQVk7UUFBQztLQUFTO0lBQ2pFLElBQUlhLHVCQUF1QixNQUFNO1FBQzdCLElBQUlDLGtCQUFrQkQ7UUFDdEIsSUFBSTFELE1BQU1DLE9BQU8sQ0FBQzBELGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0I5QyxHQUFHLENBQUMsQ0FBQ2tCO2dCQUNuQyxPQUFPdzRCLHlCQUF5Qng0QjtZQUNwQztRQUNKO1FBQ0F2QyxlQUFlc0QsVUFBVTtZQUFDO1NBQWtCLEVBQUVhO0lBQ2xEO0lBQ0EsTUFBTUUsNEJBQTRCbEQsZUFBZWtDLFlBQVk7UUFDekQ7S0FDSDtJQUNELElBQUlnQiw2QkFBNkIsTUFBTTtRQUNuQ3JFLGVBQWVzRCxVQUFVO1lBQUM7U0FBd0IsRUFBRWU7SUFDeEQ7SUFDQSxNQUFNQyw4QkFBOEJuRCxlQUFla0MsWUFBWTtRQUMzRDtLQUNIO0lBQ0QsSUFBSWlCLCtCQUErQixNQUFNO1FBQ3JDdEUsZUFBZXNELFVBQVU7WUFBQztTQUEwQixFQUFFZ0I7SUFDMUQ7SUFDQSxPQUFPaEI7QUFDWDtBQUNBLFNBQVNvM0IsNEJBQTRCcjNCLFVBQVUsRUFBRStZLFlBQVk7SUFDekQsTUFBTTlZLFdBQVcsQ0FBQztJQUNsQixNQUFNZ3pCLGFBQWFuMUIsZUFBZWtDLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUkrWSxpQkFBaUJuZSxhQUFhcTRCLGNBQWMsTUFBTTtRQUNsRHQyQixlQUFlb2MsY0FBYztZQUFDO1lBQWdCO1NBQVMsRUFBRWthO0lBQzdEO0lBQ0EsTUFBTWlFLFlBQVlwNUIsZUFBZWtDLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUkrWSxpQkFBaUJuZSxhQUFhczhCLGFBQWEsTUFBTTtRQUNqRHY2QixlQUFlb2MsY0FBYztZQUFDO1lBQWdCO1NBQVEsRUFBRW1kLGFBQWFnQjtJQUN6RTtJQUNBLE1BQU0vMUIsWUFBWXJELGVBQWVrQyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJK1ksaUJBQWlCbmUsYUFBYXVHLGFBQWEsTUFBTTtRQUNqRHhFLGVBQWVvYyxjQUFjO1lBQUM7WUFBZ0I7U0FBUSxFQUFFb2UsYUFBYWgyQjtJQUN6RTtJQUNBLE9BQU9sQjtBQUNYO0FBQ0EsU0FBU3UzQiw2QkFBNkJ4M0IsVUFBVSxFQUFFK1ksWUFBWTtJQUMxRCxNQUFNOVksV0FBVyxDQUFDO0lBQ2xCLE1BQU1nekIsYUFBYW4xQixlQUFla0MsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSStZLGlCQUFpQm5lLGFBQWFxNEIsY0FBYyxNQUFNO1FBQ2xEdDJCLGVBQWVvYyxjQUFjO1lBQUM7WUFBZ0I7U0FBUyxFQUFFa2E7SUFDN0Q7SUFDQSxNQUFNaUUsWUFBWXA1QixlQUFla0MsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSStZLGlCQUFpQm5lLGFBQWFzOEIsYUFBYSxNQUFNO1FBQ2pEdjZCLGVBQWVvYyxjQUFjO1lBQUM7WUFBZ0I7U0FBUSxFQUFFeWQsY0FBY1U7SUFDMUU7SUFDQSxNQUFNLzFCLFlBQVlyRCxlQUFla0MsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSStZLGlCQUFpQm5lLGFBQWF1RyxhQUFhLE1BQU07UUFDakR4RSxlQUFlb2MsY0FBYztZQUFDO1lBQWdCO1NBQVEsRUFBRXdlLGNBQWNwMkI7SUFDMUU7SUFDQSxPQUFPbEI7QUFDWDtBQUNBLFNBQVN1MUIsd0JBQXdCeDFCLFVBQVU7SUFDdkMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1pM0IsWUFBWXA1QixlQUFla0MsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSWszQixhQUFhLE1BQU07UUFDbkJ2NkIsZUFBZXNELFVBQVU7WUFBQztTQUFRLEVBQUUwM0IsZUFBZVQ7SUFDdkQ7SUFDQSxNQUFNVSx3QkFBd0I5NUIsZUFBZWtDLFlBQVk7UUFDckQ7S0FDSDtJQUNELElBQUk0M0IseUJBQXlCLE1BQU07UUFDL0JqN0IsZUFBZXNELFVBQVU7WUFBQztTQUFvQixFQUFFMjNCO0lBQ3BEO0lBQ0EsTUFBTUMsdUJBQXVCLzVCLGVBQWVrQyxZQUFZO1FBQUM7S0FBUTtJQUNqRSxJQUFJNjNCLHdCQUF3QixNQUFNO1FBQzlCbDdCLGVBQWVzRCxVQUFVO1lBQUM7U0FBbUIsRUFBRXkxQiwwQkFBMEJtQztJQUM3RTtJQUNBLE9BQU81M0I7QUFDWDtBQUNBLFNBQVNxekIseUJBQXlCdHpCLFVBQVU7SUFDeEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1pM0IsWUFBWXA1QixlQUFla0MsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSWszQixhQUFhLE1BQU07UUFDbkJ2NkIsZUFBZXNELFVBQVU7WUFBQztTQUFRLEVBQUU2M0IsZ0JBQWdCWjtJQUN4RDtJQUNBLE1BQU1VLHdCQUF3Qjk1QixlQUFla0MsWUFBWTtRQUNyRDtLQUNIO0lBQ0QsSUFBSTQzQix5QkFBeUIsTUFBTTtRQUMvQmo3QixlQUFlc0QsVUFBVTtZQUFDO1NBQW9CLEVBQUUyM0I7SUFDcEQ7SUFDQSxNQUFNQyx1QkFBdUIvNUIsZUFBZWtDLFlBQVk7UUFBQztLQUFRO0lBQ2pFLElBQUk2M0Isd0JBQXdCLE1BQU07UUFDOUJsN0IsZUFBZXNELFVBQVU7WUFBQztTQUFtQixFQUFFMjFCLDJCQUEyQmlDO0lBQzlFO0lBQ0EsTUFBTUUscUJBQXFCajZCLGVBQWVrQyxZQUFZO1FBQUM7S0FBUztJQUNoRSxJQUFJKzNCLHNCQUFzQixNQUFNO1FBQzVCcDdCLGVBQWVzRCxVQUFVO1lBQUM7U0FBaUIsRUFBRTgzQjtJQUNqRDtJQUNBLE9BQU85M0I7QUFDWDtBQUNBLFNBQVMrM0IsNkJBQTZCaDRCLFVBQVU7SUFDNUMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU15MkIsV0FBVzU0QixlQUFla0MsWUFBWTtRQUFDO0tBQVE7SUFDckQsSUFBSTAyQixZQUFZLE1BQU07UUFDbEIvNUIsZUFBZXNELFVBQVU7WUFBQztTQUFPLEVBQUU2M0IsZ0JBQWdCcEI7SUFDdkQ7SUFDQSxNQUFNN0QsYUFBYS8wQixlQUFla0MsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSTZ5QixjQUFjLE1BQU07UUFDcEIsSUFBSS94QixrQkFBa0IreEI7UUFDdEIsSUFBSTExQixNQUFNQyxPQUFPLENBQUMwRCxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCOUMsR0FBRyxDQUFDLENBQUNrQjtnQkFDbkMsT0FBT0E7WUFDWDtRQUNKO1FBQ0F2QyxlQUFlc0QsVUFBVTtZQUFDO1NBQVMsRUFBRWE7SUFDekM7SUFDQSxPQUFPYjtBQUNYO0FBQ0EsU0FBU3czQix3QkFBd0J6M0IsVUFBVTtJQUN2QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTWtCLFlBQVlyRCxlQUFla0MsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSW1CLGFBQWEsTUFBTTtRQUNuQnhFLGVBQWVzRCxVQUFVO1lBQUM7U0FBUSxFQUFFZzRCLGVBQWU5MkI7SUFDdkQ7SUFDQSxPQUFPbEI7QUFDWDtBQUNBLFNBQVN5M0IseUJBQXlCMTNCLFVBQVU7SUFDeEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1rQixZQUFZckQsZUFBZWtDLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUltQixhQUFhLE1BQU07UUFDbkJ4RSxlQUFlc0QsVUFBVTtZQUFDO1NBQVEsRUFBRWk0QixnQkFBZ0IvMkI7SUFDeEQ7SUFDQSxPQUFPbEI7QUFDWDtBQUNBLFNBQVNxeEIseUJBQXlCdHhCLFVBQVU7SUFDeEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU00c0IsMkJBQTJCL3VCLGVBQWVrQyxZQUFZO1FBQ3hEO0tBQ0g7SUFDRCxJQUFJNnNCLDRCQUE0QixNQUFNO1FBQ2xDbHdCLGVBQWVzRCxVQUFVO1lBQUM7U0FBYyxFQUFFNHNCO0lBQzlDO0lBQ0EsTUFBTXJSLHlCQUF5QjFkLGVBQWVrQyxZQUFZO1FBQ3REO0tBQ0g7SUFDRCxJQUFJd2IsMEJBQTBCLE1BQU07UUFDaEM3ZSxlQUFlc0QsVUFBVTtZQUFDO1NBQXFCLEVBQUV1YjtJQUNyRDtJQUNBLE1BQU1zUixxQkFBcUJodkIsZUFBZWtDLFlBQVk7UUFDbEQ7S0FDSDtJQUNELElBQUk4c0Isc0JBQXNCLE1BQU07UUFDNUJud0IsZUFBZXNELFVBQVU7WUFBQztTQUFpQixFQUFFNnNCO0lBQ2pEO0lBQ0EsTUFBTWhTLHFCQUFxQmhkLGVBQWVrQyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJOGEsc0JBQXNCLE1BQU07UUFDNUJuZSxlQUFlc0QsVUFBVTtZQUFDO1NBQWlCLEVBQUU2YTtJQUNqRDtJQUNBLE1BQU1pUyw0QkFBNEJqdkIsZUFBZWtDLFlBQVk7UUFDekQ7S0FDSDtJQUNELElBQUkrc0IsNkJBQTZCLE1BQU07UUFDbkNwd0IsZUFBZXNELFVBQVU7WUFBQztTQUF3QixFQUFFOHNCO0lBQ3hEO0lBQ0EsTUFBTTNSLHVCQUF1QnRkLGVBQWVrQyxZQUFZO1FBQ3BEO0tBQ0g7SUFDRCxJQUFJb2Isd0JBQXdCLE1BQU07UUFDOUJ6ZSxlQUFlc0QsVUFBVTtZQUFDO1NBQW1CLEVBQUVtYjtJQUNuRDtJQUNBLE1BQU1GLGVBQWVwZCxlQUFla0MsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSWtiLGdCQUFnQixNQUFNO1FBQ3RCdmUsZUFBZXNELFVBQVU7WUFBQztTQUFXLEVBQUVpYjtJQUMzQztJQUNBLE1BQU1ILHNCQUFzQmpkLGVBQWVrQyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJK2EsdUJBQXVCLE1BQU07UUFDN0JwZSxlQUFlc0QsVUFBVTtZQUFDO1NBQWtCLEVBQUU4YTtJQUNsRDtJQUNBLE1BQU1rQixzQkFBc0JuZSxlQUFla0MsWUFBWTtRQUNuRDtLQUNIO0lBQ0QsSUFBSWljLHVCQUF1QixNQUFNO1FBQzdCdGYsZUFBZXNELFVBQVU7WUFBQztTQUFrQixFQUFFZ2M7SUFDbEQ7SUFDQSxNQUFNZCxzQkFBc0JyZCxlQUFla0MsWUFBWTtRQUNuRDtLQUNIO0lBQ0QsSUFBSW1iLHVCQUF1QixNQUFNO1FBQzdCeGUsZUFBZXNELFVBQVU7WUFBQztTQUFrQixFQUFFa2I7SUFDbEQ7SUFDQSxNQUFNRix1QkFBdUJuZCxlQUFla0MsWUFBWTtRQUNwRDtLQUNIO0lBQ0QsSUFBSWliLHdCQUF3QixNQUFNO1FBQzlCdGUsZUFBZXNELFVBQVU7WUFBQztTQUFtQixFQUFFZ2I7SUFDbkQ7SUFDQSxNQUFNSyx1QkFBdUJ4ZCxlQUFla0MsWUFBWTtRQUNwRDtLQUNIO0lBQ0QsSUFBSXNiLHdCQUF3QixNQUFNO1FBQzlCM2UsZUFBZXNELFVBQVU7WUFBQztTQUFtQixFQUFFcWI7SUFDbkQ7SUFDQSxNQUFNVSx5QkFBeUJsZSxlQUFla0MsWUFBWTtRQUN0RDtLQUNIO0lBQ0QsSUFBSWdjLDBCQUEwQixNQUFNO1FBQ2hDcmYsZUFBZXNELFVBQVU7WUFBQztTQUFxQixFQUFFK2I7SUFDckQ7SUFDQSxNQUFNVCxxQkFBcUJ6ZCxlQUFla0MsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSXViLHNCQUFzQixNQUFNO1FBQzVCNWUsZUFBZXNELFVBQVU7WUFBQztTQUFpQixFQUFFc2I7SUFDakQ7SUFDQSxNQUFNeVIsb0JBQW9CbHZCLGVBQWVrQyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJZ3RCLHFCQUFxQixNQUFNO1FBQzNCcndCLGVBQWVzRCxVQUFVO1lBQUM7U0FBZ0IsRUFBRStzQjtJQUNoRDtJQUNBLE1BQU0zUixXQUFXdmQsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlxYixZQUFZLE1BQU07UUFDbEIxZSxlQUFlc0QsVUFBVTtZQUFDO1NBQU8sRUFBRW9iO0lBQ3ZDO0lBQ0EsTUFBTWEsbUJBQW1CcGUsZUFBZWtDLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUlrYyxvQkFBb0IsTUFBTTtRQUMxQnZmLGVBQWVzRCxVQUFVO1lBQUM7U0FBZSxFQUFFMjBCLHFCQUFxQjFZO0lBQ3BFO0lBQ0EsTUFBTWxCLG9CQUFvQmxkLGVBQWVrQyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJZ2IscUJBQXFCLE1BQU07UUFDM0JyZSxlQUFlc0QsVUFBVTtZQUFDO1NBQWdCLEVBQUUrYTtJQUNoRDtJQUNBLE1BQU1MLGtCQUFrQjdjLGVBQWVrQyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJMmEsbUJBQW1CLE1BQU07UUFDekJoZSxlQUFlc0QsVUFBVTtZQUFDO1NBQWMsRUFBRTBhO0lBQzlDO0lBQ0EsTUFBTXdCLHFCQUFxQnJlLGVBQWVrQyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJbWMsc0JBQXNCLE1BQU07UUFDNUJ4ZixlQUFlc0QsVUFBVTtZQUFDO1NBQWlCLEVBQUVrYztJQUNqRDtJQUNBLE1BQU10QixXQUFXL2MsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUk2YSxZQUFZLE1BQU07UUFDbEJsZSxlQUFlc0QsVUFBVTtZQUFDO1NBQU8sRUFBRTRhO0lBQ3ZDO0lBQ0EsTUFBTUQsV0FBVzljLGVBQWVrQyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJNGEsWUFBWSxNQUFNO1FBQ2xCamUsZUFBZXNELFVBQVU7WUFBQztTQUFPLEVBQUUyYTtJQUN2QztJQUNBLElBQUk5YyxlQUFla0MsWUFBWTtRQUFDO0tBQTZCLE1BQ3pEcEYsV0FBVztRQUNYLE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxPQUFPdUQ7QUFDWDtBQUNBLFNBQVNrNEIsMEJBQTBCcHFCLFNBQVMsRUFBRS9OLFVBQVU7SUFDcEQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU02VyxZQUFZaFosZUFBZWtDLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUk4VyxhQUFhLE1BQU07UUFDbkJuYSxlQUFlc0QsVUFBVTtZQUFDO1lBQVE7U0FBTyxFQUFFNk4sT0FBT0MsV0FBVytJO0lBQ2pFO0lBQ0EsT0FBTzdXO0FBQ1g7QUFDQSxTQUFTbTRCLDJCQUEyQnJxQixTQUFTLEVBQUUvTixVQUFVO0lBQ3JELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNNlcsWUFBWWhaLGVBQWVrQyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJOFcsYUFBYSxNQUFNO1FBQ25CbmEsZUFBZXNELFVBQVU7WUFBQztZQUFRO1NBQU8sRUFBRTZOLE9BQU9DLFdBQVcrSTtJQUNqRTtJQUNBLE9BQU83VztBQUNYO0FBQ0EsU0FBU280QixvQkFBb0JyNEIsVUFBVTtJQUNuQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsSUFBSW5DLGVBQWVrQyxZQUFZO1FBQUM7S0FBYSxNQUFNcEYsV0FBVztRQUMxRCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTXFnQixtQkFBbUJqZixlQUFla0MsWUFBWTtRQUFDO0tBQWU7SUFDcEUsSUFBSStjLG9CQUFvQixNQUFNO1FBQzFCcGdCLGVBQWVzRCxVQUFVO1lBQUM7U0FBZSxFQUFFOGM7SUFDL0M7SUFDQSxPQUFPOWM7QUFDWDtBQUNBLFNBQVNxNEIsc0JBQXNCdDRCLFVBQVU7SUFDckMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLElBQUluQyxlQUFla0MsWUFBWTtRQUFDO0tBQWlCLE1BQU1wRixXQUFXO1FBQzlELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxJQUFJb0IsZUFBZWtDLFlBQVk7UUFBQztLQUFxQixNQUFNcEYsV0FBVztRQUNsRSxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTXVnQixzQkFBc0JuZixlQUFla0MsWUFBWTtRQUNuRDtLQUNIO0lBQ0QsSUFBSWlkLHVCQUF1QixNQUFNO1FBQzdCdGdCLGVBQWVzRCxVQUFVO1lBQUM7U0FBa0IsRUFBRWdkO0lBQ2xEO0lBQ0EsT0FBT2hkO0FBQ1g7QUFDQSxTQUFTeTBCLG1CQUFtQjEwQixVQUFVO0lBQ2xDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNaWQsa0JBQWtCcGYsZUFBZWtDLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUlrZCxtQkFBbUIsTUFBTTtRQUN6QnZnQixlQUFlc0QsVUFBVTtZQUFDO1NBQWMsRUFBRWlkO0lBQzlDO0lBQ0EsTUFBTUMsZ0JBQWdCcmYsZUFBZWtDLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUltZCxpQkFBaUIsTUFBTTtRQUN2QnhnQixlQUFlc0QsVUFBVTtZQUFDO1NBQVksRUFBRWtkO0lBQzVDO0lBQ0EsSUFBSXJmLGVBQWVrQyxZQUFZO1FBQUM7S0FBaUIsTUFBTXBGLFdBQVc7UUFDOUQsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLElBQUlvQixlQUFla0MsWUFBWTtRQUFDO0tBQTJCLE1BQ3ZEcEYsV0FBVztRQUNYLE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxPQUFPdUQ7QUFDWDtBQUNBLFNBQVM0MEIsb0JBQW9CNzBCLFVBQVU7SUFDbkMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1pZCxrQkFBa0JwZixlQUFla0MsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSWtkLG1CQUFtQixNQUFNO1FBQ3pCdmdCLGVBQWVzRCxVQUFVO1lBQUM7U0FBYyxFQUFFaWQ7SUFDOUM7SUFDQSxNQUFNQyxnQkFBZ0JyZixlQUFla0MsWUFBWTtRQUFDO0tBQVk7SUFDOUQsSUFBSW1kLGlCQUFpQixNQUFNO1FBQ3ZCeGdCLGVBQWVzRCxVQUFVO1lBQUM7U0FBWSxFQUFFa2Q7SUFDNUM7SUFDQSxNQUFNdVYscUJBQXFCNTBCLGVBQWVrQyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJMHlCLHNCQUFzQixNQUFNO1FBQzVCLzFCLGVBQWVzRCxVQUFVO1lBQUM7WUFBc0I7U0FBVyxFQUFFeXlCO0lBQ2pFO0lBQ0EsTUFBTUMsK0JBQStCNzBCLGVBQWVrQyxZQUFZO1FBQzVEO0tBQ0g7SUFDRCxJQUFJMnlCLGdDQUFnQyxNQUFNO1FBQ3RDaDJCLGVBQWVzRCxVQUFVO1lBQUM7WUFBc0I7U0FBcUIsRUFBRTB5QjtJQUMzRTtJQUNBLE9BQU8xeUI7QUFDWDtBQUNBLFNBQVMwM0IsZUFBZTMzQixVQUFVO0lBQzlCLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNdVMsaUJBQWlCMVUsZUFBZWtDLFlBQVk7UUFDOUM7S0FDSDtJQUNELElBQUl3UyxrQkFBa0IsTUFBTTtRQUN4QjdWLGVBQWVzRCxVQUFVO1lBQUM7U0FBYSxFQUFFc1MsT0FBT0M7SUFDcEQ7SUFDQSxNQUFNdlEsZUFBZW5FLGVBQWVrQyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJaUMsZ0JBQWdCLE1BQU07UUFDdEJ0RixlQUFlc0QsVUFBVTtZQUFDO1NBQVcsRUFBRWdDO0lBQzNDO0lBQ0EsT0FBT2hDO0FBQ1g7QUFDQSxTQUFTNjNCLGdCQUFnQjkzQixVQUFVO0lBQy9CLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNb1csYUFBYXZZLGVBQWVrQyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJcVcsY0FBYyxNQUFNO1FBQ3BCMVosZUFBZXNELFVBQVU7WUFBQztTQUFTLEVBQUVvVztJQUN6QztJQUNBLE1BQU03RCxpQkFBaUIxVSxlQUFla0MsWUFBWTtRQUM5QztLQUNIO0lBQ0QsSUFBSXdTLGtCQUFrQixNQUFNO1FBQ3hCN1YsZUFBZXNELFVBQVU7WUFBQztTQUFhLEVBQUVzUyxPQUFPQztJQUNwRDtJQUNBLE1BQU12USxlQUFlbkUsZUFBZWtDLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlpQyxnQkFBZ0IsTUFBTTtRQUN0QnRGLGVBQWVzRCxVQUFVO1lBQUM7U0FBVyxFQUFFZ0M7SUFDM0M7SUFDQSxPQUFPaEM7QUFDWDtBQUNBLFNBQVNpMkIsYUFBYWwyQixVQUFVO0lBQzVCLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixJQUFJbkMsZUFBZWtDLFlBQVk7UUFBQztLQUFTLE1BQU1wRixXQUFXO1FBQ3RELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxNQUFNOFYsaUJBQWlCMVUsZUFBZWtDLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUl3UyxrQkFBa0IsTUFBTTtRQUN4QjdWLGVBQWVzRCxVQUFVO1lBQUM7U0FBcUIsRUFBRXNTLE9BQU9DO0lBQzVEO0lBQ0EsTUFBTXZRLGVBQWVuRSxlQUFla0MsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSWlDLGdCQUFnQixNQUFNO1FBQ3RCdEYsZUFBZXNELFVBQVU7WUFBQztTQUFXLEVBQUVnQztJQUMzQztJQUNBLE9BQU9oQztBQUNYO0FBQ0EsU0FBU3UyQixjQUFjeDJCLFVBQVU7SUFDN0IsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1vVyxhQUFhdlksZUFBZWtDLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlxVyxjQUFjLE1BQU07UUFDcEIxWixlQUFlc0QsVUFBVTtZQUFDO1NBQVMsRUFBRW9XO0lBQ3pDO0lBQ0EsTUFBTTdELGlCQUFpQjFVLGVBQWVrQyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJd1Msa0JBQWtCLE1BQU07UUFDeEI3VixlQUFlc0QsVUFBVTtZQUFDO1NBQXFCLEVBQUVzUyxPQUFPQztJQUM1RDtJQUNBLE1BQU12USxlQUFlbkUsZUFBZWtDLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlpQyxnQkFBZ0IsTUFBTTtRQUN0QnRGLGVBQWVzRCxVQUFVO1lBQUM7U0FBVyxFQUFFZ0M7SUFDM0M7SUFDQSxPQUFPaEM7QUFDWDtBQUNBLFNBQVNzNEIsd0JBQXdCeHFCLFNBQVMsRUFBRS9OLFVBQVUsRUFBRStZLFlBQVk7SUFDaEUsTUFBTTlZLFdBQVcsQ0FBQztJQUNsQixNQUFNb2QsZUFBZXZmLGVBQWVrQyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJK1ksaUJBQWlCbmUsYUFBYXlpQixnQkFBZ0IsTUFBTTtRQUNwRDFnQixlQUFlb2MsY0FBYztZQUFDO1lBQVU7U0FBVyxFQUFFc0U7SUFDekQ7SUFDQSxNQUFNQyxnQkFBZ0J4ZixlQUFla0MsWUFBWTtRQUFDO0tBQVk7SUFDOUQsSUFBSStZLGlCQUFpQm5lLGFBQWEwaUIsaUJBQWlCLE1BQU07UUFDckQzZ0IsZUFBZW9jLGNBQWM7WUFBQztZQUFVO1NBQVksRUFBRXVFO0lBQzFEO0lBQ0EsTUFBTUUsYUFBYTFmLGVBQWVrQyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJK1ksaUJBQWlCbmUsYUFBYTRpQixjQUFjLE1BQU07UUFDbEQ3Z0IsZUFBZW9jLGNBQWM7WUFBQztZQUFVO1NBQVMsRUFBRXlFO0lBQ3ZEO0lBQ0EsTUFBTWdiLGdCQUFnQjE2QixlQUFla0MsWUFBWTtRQUFDO0tBQVk7SUFDOUQsSUFBSStZLGlCQUFpQm5lLGFBQWE0OUIsaUJBQWlCLE1BQU07UUFDckQ3N0IsZUFBZW9jLGNBQWM7WUFBQztZQUFRO1NBQWEsRUFBRWhHLFdBQVdoRixXQUFXeXFCO0lBQy9FO0lBQ0EsT0FBT3Y0QjtBQUNYO0FBQ0EsU0FBU3c0Qix5QkFBeUIxcUIsU0FBUyxFQUFFL04sVUFBVSxFQUFFK1ksWUFBWTtJQUNqRSxNQUFNOVksV0FBVyxDQUFDO0lBQ2xCLE1BQU1vZCxlQUFldmYsZUFBZWtDLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUkrWSxpQkFBaUJuZSxhQUFheWlCLGdCQUFnQixNQUFNO1FBQ3BEMWdCLGVBQWVvYyxjQUFjO1lBQUM7WUFBVTtTQUFXLEVBQUVzRTtJQUN6RDtJQUNBLE1BQU1DLGdCQUFnQnhmLGVBQWVrQyxZQUFZO1FBQUM7S0FBWTtJQUM5RCxJQUFJK1ksaUJBQWlCbmUsYUFBYTBpQixpQkFBaUIsTUFBTTtRQUNyRDNnQixlQUFlb2MsY0FBYztZQUFDO1lBQVU7U0FBWSxFQUFFdUU7SUFDMUQ7SUFDQSxNQUFNRSxhQUFhMWYsZUFBZWtDLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUkrWSxpQkFBaUJuZSxhQUFhNGlCLGNBQWMsTUFBTTtRQUNsRDdnQixlQUFlb2MsY0FBYztZQUFDO1lBQVU7U0FBUyxFQUFFeUU7SUFDdkQ7SUFDQSxNQUFNZ2IsZ0JBQWdCMTZCLGVBQWVrQyxZQUFZO1FBQUM7S0FBWTtJQUM5RCxJQUFJK1ksaUJBQWlCbmUsYUFBYTQ5QixpQkFBaUIsTUFBTTtRQUNyRDc3QixlQUFlb2MsY0FBYztZQUFDO1lBQVE7U0FBYSxFQUFFaEcsV0FBV2hGLFdBQVd5cUI7SUFDL0U7SUFDQSxPQUFPdjRCO0FBQ1g7QUFDQSxTQUFTeTRCLDRCQUE0QjNxQixTQUFTLEVBQUUvTixVQUFVO0lBQ3RELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNaVosYUFBYXBiLGVBQWVrQyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJa1osY0FBYyxNQUFNO1FBQ3BCcWYsd0JBQXdCeHFCLFdBQVdtTCxZQUFZalo7SUFDbkQ7SUFDQSxPQUFPQTtBQUNYO0FBQ0EsU0FBUzA0Qiw2QkFBNkI1cUIsU0FBUyxFQUFFL04sVUFBVTtJQUN2RCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTWlaLGFBQWFwYixlQUFla0MsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSWtaLGNBQWMsTUFBTTtRQUNwQnVmLHlCQUF5QjFxQixXQUFXbUwsWUFBWWpaO0lBQ3BEO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLFNBQVMyNEIsNEJBQTRCNTRCLFVBQVU7SUFDM0MsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU15QixzQkFBc0I1RCxlQUFla0MsWUFBWTtRQUNuRDtLQUNIO0lBQ0QsSUFBSTBCLHVCQUF1QixNQUFNO1FBQzdCL0UsZUFBZXNELFVBQVU7WUFBQztTQUFrQixFQUFFeUI7SUFDbEQ7SUFDQSxNQUFNa2Msb0JBQW9COWYsZUFBZWtDLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUk0ZCxxQkFBcUIsTUFBTTtRQUMzQmpoQixlQUFlc0QsVUFBVTtZQUFDO1NBQWdCLEVBQUUyZDtJQUNoRDtJQUNBLE1BQU1pYixhQUFhLzZCLGVBQWVrQyxZQUFZO1FBQUM7S0FBUTtJQUN2RCxJQUFJNjRCLGNBQWMsTUFBTTtRQUNwQixJQUFJLzNCLGtCQUFrQm9TLGVBQWUybEI7UUFDckMsSUFBSTE3QixNQUFNQyxPQUFPLENBQUMwRCxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCOUMsR0FBRyxDQUFDLENBQUNrQjtnQkFDbkMsT0FBTzQ1QixlQUFlNTVCO1lBQzFCO1FBQ0o7UUFDQXZDLGVBQWVzRCxVQUFVO1lBQUM7U0FBUyxFQUFFYTtJQUN6QztJQUNBLE9BQU9iO0FBQ1g7QUFDQSxTQUFTODRCLDZCQUE2Qi80QixVQUFVO0lBQzVDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNeUIsc0JBQXNCNUQsZUFBZWtDLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUkwQix1QkFBdUIsTUFBTTtRQUM3Qi9FLGVBQWVzRCxVQUFVO1lBQUM7U0FBa0IsRUFBRXlCO0lBQ2xEO0lBQ0EsTUFBTWtjLG9CQUFvQjlmLGVBQWVrQyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJNGQscUJBQXFCLE1BQU07UUFDM0JqaEIsZUFBZXNELFVBQVU7WUFBQztTQUFnQixFQUFFMmQ7SUFDaEQ7SUFDQSxNQUFNaWIsYUFBYS82QixlQUFla0MsWUFBWTtRQUFDO0tBQVE7SUFDdkQsSUFBSTY0QixjQUFjLE1BQU07UUFDcEIsSUFBSS8zQixrQkFBa0JvUyxlQUFlMmxCO1FBQ3JDLElBQUkxN0IsTUFBTUMsT0FBTyxDQUFDMEQsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQjlDLEdBQUcsQ0FBQyxDQUFDa0I7Z0JBQ25DLE9BQU84NUIsZ0JBQWdCOTVCO1lBQzNCO1FBQ0o7UUFDQXZDLGVBQWVzRCxVQUFVO1lBQUM7U0FBUyxFQUFFYTtJQUN6QztJQUNBLE9BQU9iO0FBQ1g7QUFDQSxTQUFTZzVCLDRCQUE0Qmo1QixVQUFVO0lBQzNDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNaTVCLGVBQWVwN0IsZUFBZWtDLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlrNUIsZ0JBQWdCLE1BQU07UUFDdEJ2OEIsZUFBZXNELFVBQVU7WUFBQztTQUFXLEVBQUVpNUI7SUFDM0M7SUFDQSxNQUFNQywwQkFBMEJyN0IsZUFBZWtDLFlBQVk7UUFDdkQ7S0FDSDtJQUNELElBQUltNUIsMkJBQTJCLE1BQU07UUFDakN4OEIsZUFBZXNELFVBQVU7WUFBQztTQUFjLEVBQUVrNUI7SUFDOUM7SUFDQSxNQUFNQyxtQkFBbUJ0N0IsZUFBZWtDLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUlvNUIsb0JBQW9CLE1BQU07UUFDMUJ6OEIsZUFBZXNELFVBQVU7WUFBQztTQUFXLEVBQUVtNUI7SUFDM0M7SUFDQSxPQUFPbjVCO0FBQ1g7QUFDQSxTQUFTNjRCLGVBQWU5NEIsVUFBVTtJQUM5QixNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTUksV0FBV3ZDLGVBQWVrQyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJSyxZQUFZLE1BQU07UUFDbEIxRCxlQUFlc0QsVUFBVTtZQUFDO1NBQU8sRUFBRUk7SUFDdkM7SUFDQSxNQUFNb1csa0JBQWtCM1ksZUFBZWtDLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUl5VyxtQkFBbUIsTUFBTTtRQUN6QjlaLGVBQWVzRCxVQUFVO1lBQUM7U0FBYyxFQUFFd1c7SUFDOUM7SUFDQSxNQUFNdU8sa0JBQWtCbG5CLGVBQWVrQyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJZ2xCLG1CQUFtQixNQUFNO1FBQ3pCcm9CLGVBQWVzRCxVQUFVO1lBQUM7U0FBYyxFQUFFK2tCO0lBQzlDO0lBQ0EsTUFBTXFVLGNBQWN2N0IsZUFBZWtDLFlBQVk7UUFBQztLQUFVO0lBQzFELElBQUlxNUIsZUFBZSxNQUFNO1FBQ3JCMThCLGVBQWVzRCxVQUFVO1lBQUM7U0FBVSxFQUFFbzVCO0lBQzFDO0lBQ0EsTUFBTUMscUJBQXFCeDdCLGVBQWVrQyxZQUFZO1FBQUM7S0FBUTtJQUMvRCxJQUFJczVCLHNCQUFzQixNQUFNO1FBQzVCMzhCLGVBQWVzRCxVQUFVO1lBQUM7U0FBaUIsRUFBRXM1Qix3QkFBd0JEO0lBQ3pFO0lBQ0EsTUFBTUUsc0JBQXNCMTdCLGVBQWVrQyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJdzVCLHVCQUF1QixNQUFNO1FBQzdCNzhCLGVBQWVzRCxVQUFVO1lBQUM7U0FBa0IsRUFBRXU1QjtJQUNsRDtJQUNBLE1BQU1DLHVCQUF1QjM3QixlQUFla0MsWUFBWTtRQUNwRDtLQUNIO0lBQ0QsSUFBSXk1Qix3QkFBd0IsTUFBTTtRQUM5Qjk4QixlQUFlc0QsVUFBVTtZQUFDO1NBQW1CLEVBQUV3NUI7SUFDbkQ7SUFDQSxNQUFNQyx1QkFBdUI1N0IsZUFBZWtDLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUkwNUIsd0JBQXdCLE1BQU07UUFDOUIvOEIsZUFBZXNELFVBQVU7WUFBQztTQUFtQixFQUFFeTVCO0lBQ25EO0lBQ0EsTUFBTS9lLGtCQUFrQjdjLGVBQWVrQyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJMmEsbUJBQW1CLE1BQU07UUFDekJoZSxlQUFlc0QsVUFBVTtZQUFDO1NBQWMsRUFBRTBhO0lBQzlDO0lBQ0EsTUFBTWdmLHFCQUFxQjc3QixlQUFla0MsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSTI1QixzQkFBc0IsTUFBTTtRQUM1Qmg5QixlQUFlc0QsVUFBVTtZQUFDO1NBQWlCLEVBQUUwNUI7SUFDakQ7SUFDQSxNQUFNL2UsV0FBVzljLGVBQWVrQyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJNGEsWUFBWSxNQUFNO1FBQ2xCamUsZUFBZXNELFVBQVU7WUFBQztTQUFPLEVBQUUyYTtJQUN2QztJQUNBLE1BQU1DLFdBQVcvYyxlQUFla0MsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSTZhLFlBQVksTUFBTTtRQUNsQmxlLGVBQWVzRCxVQUFVO1lBQUM7U0FBTyxFQUFFNGE7SUFDdkM7SUFDQSxNQUFNK2UsZUFBZTk3QixlQUFla0MsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSTQ1QixnQkFBZ0IsTUFBTTtRQUN0Qmo5QixlQUFlc0QsVUFBVTtZQUFDO1NBQVcsRUFBRTI1QjtJQUMzQztJQUNBLE9BQU8zNUI7QUFDWDtBQUNBLFNBQVMrNEIsZ0JBQWdCaDVCLFVBQVU7SUFDL0IsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1JLFdBQVd2QyxlQUFla0MsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSUssWUFBWSxNQUFNO1FBQ2xCMUQsZUFBZXNELFVBQVU7WUFBQztTQUFPLEVBQUVJO0lBQ3ZDO0lBQ0EsTUFBTW9XLGtCQUFrQjNZLGVBQWVrQyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJeVcsbUJBQW1CLE1BQU07UUFDekI5WixlQUFlc0QsVUFBVTtZQUFDO1NBQWMsRUFBRXdXO0lBQzlDO0lBQ0EsTUFBTXVPLGtCQUFrQmxuQixlQUFla0MsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSWdsQixtQkFBbUIsTUFBTTtRQUN6QnJvQixlQUFlc0QsVUFBVTtZQUFDO1NBQWMsRUFBRStrQjtJQUM5QztJQUNBLE1BQU1xVSxjQUFjdjdCLGVBQWVrQyxZQUFZO1FBQUM7S0FBWTtJQUM1RCxJQUFJcTVCLGVBQWUsTUFBTTtRQUNyQjE4QixlQUFlc0QsVUFBVTtZQUFDO1NBQVUsRUFBRW81QjtJQUMxQztJQUNBLE1BQU1RLGdCQUFnQi83QixlQUFla0MsWUFBWTtRQUFDO0tBQWlCO0lBQ25FLElBQUk2NUIsaUJBQWlCLE1BQU07UUFDdkIsSUFBSS80QixrQkFBa0IrNEI7UUFDdEIsSUFBSTE4QixNQUFNQyxPQUFPLENBQUMwRCxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCOUMsR0FBRyxDQUFDLENBQUNrQjtnQkFDbkMsT0FBTzgwQixtQkFBbUI5MEI7WUFDOUI7UUFDSjtRQUNBdkMsZUFBZXNELFVBQVU7WUFBQztTQUFZLEVBQUVhO0lBQzVDO0lBQ0EsTUFBTSt4QixhQUFhLzBCLGVBQWVrQyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJNnlCLGNBQWMsTUFBTTtRQUNwQmwyQixlQUFlc0QsVUFBVTtZQUFDO1NBQVMsRUFBRTR5QjtJQUN6QztJQUNBLE1BQU15RyxxQkFBcUJ4N0IsZUFBZWtDLFlBQVk7UUFBQztLQUFRO0lBQy9ELElBQUlzNUIsc0JBQXNCLE1BQU07UUFDNUIzOEIsZUFBZXNELFVBQVU7WUFBQztTQUFpQixFQUFFNjVCLHlCQUF5QlI7SUFDMUU7SUFDQSxNQUFNUywwQkFBMEJqOEIsZUFBZWtDLFlBQVk7UUFDdkQ7S0FDSDtJQUNELElBQUkrNUIsMkJBQTJCLE1BQU07UUFDakNwOUIsZUFBZXNELFVBQVU7WUFBQztTQUFzQixFQUFFODVCO0lBQ3REO0lBQ0EsTUFBTUMsa0JBQWtCbDhCLGVBQWVrQyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJZzZCLG1CQUFtQixNQUFNO1FBQ3pCLElBQUlsNUIsa0JBQWtCazVCO1FBQ3RCLElBQUk3OEIsTUFBTUMsT0FBTyxDQUFDMEQsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQjlDLEdBQUcsQ0FBQyxDQUFDa0I7Z0JBQ25DLE9BQU9BO1lBQ1g7UUFDSjtRQUNBdkMsZUFBZXNELFVBQVU7WUFBQztTQUFjLEVBQUVhO0lBQzlDO0lBQ0EsT0FBT2I7QUFDWDtBQUNBLFNBQVM4d0IsY0FBYy93QixVQUFVO0lBQzdCLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNZ2Msc0JBQXNCbmUsZUFBZWtDLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUlpYyx1QkFBdUIsTUFBTTtRQUM3QnRmLGVBQWVzRCxVQUFVO1lBQUM7U0FBa0IsRUFBRWdjO0lBQ2xEO0lBQ0EsTUFBTThCLDBCQUEwQmpnQixlQUFla0MsWUFBWTtRQUN2RDtLQUNIO0lBQ0QsSUFBSStkLDJCQUEyQixNQUFNO1FBQ2pDcGhCLGVBQWVzRCxVQUFVO1lBQUM7U0FBc0IsRUFBRThkO0lBQ3REO0lBQ0EsTUFBTUMscUJBQXFCbGdCLGVBQWVrQyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJZ2Usc0JBQXNCLE1BQU07UUFDNUJyaEIsZUFBZXNELFVBQVU7WUFBQztTQUFpQixFQUFFK2Q7SUFDakQ7SUFDQSxNQUFNQyxlQUFlbmdCLGVBQWVrQyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJaWUsZ0JBQWdCLE1BQU07UUFDdEJ0aEIsZUFBZXNELFVBQVU7WUFBQztTQUFXLEVBQUVpMEIsa0JBQWtCalc7SUFDN0Q7SUFDQSxNQUFNQyxtQkFBbUJwZ0IsZUFBZWtDLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUlrZSxvQkFBb0IsTUFBTTtRQUMxQnZoQixlQUFlc0QsVUFBVTtZQUFDO1NBQWUsRUFBRWswQixzQkFBc0JqVztJQUNyRTtJQUNBLE1BQU1DLHVCQUF1QnJnQixlQUFla0MsWUFBWTtRQUNwRDtLQUNIO0lBQ0QsSUFBSW1lLHdCQUF3QixNQUFNO1FBQzlCeGhCLGVBQWVzRCxVQUFVO1lBQUM7U0FBbUIsRUFBRWtlO0lBQ25EO0lBQ0EsTUFBTUMsaUJBQWlCdGdCLGVBQWVrQyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJb2Usa0JBQWtCLE1BQU07UUFDeEJ6aEIsZUFBZXNELFVBQVU7WUFBQztTQUFhLEVBQUVrd0IsY0FBYy9SO0lBQzNEO0lBQ0EsTUFBTUMsV0FBV3ZnQixlQUFla0MsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSXFlLFlBQVksTUFBTTtRQUNsQjFoQixlQUFlc0QsVUFBVTtZQUFDO1NBQU8sRUFBRW9lO0lBQ3ZDO0lBQ0EsTUFBTUMsY0FBY3hnQixlQUFla0MsWUFBWTtRQUFDO0tBQVU7SUFDMUQsSUFBSXNlLGVBQWUsTUFBTTtRQUNyQjNoQixlQUFlc0QsVUFBVTtZQUFDO1NBQVUsRUFBRXFlO0lBQzFDO0lBQ0EsTUFBTUMsdUJBQXVCemdCLGVBQWVrQyxZQUFZO1FBQ3BEO0tBQ0g7SUFDRCxJQUFJdWUsd0JBQXdCLE1BQU07UUFDOUI1aEIsZUFBZXNELFVBQVU7WUFBQztTQUFtQixFQUFFc2U7SUFDbkQ7SUFDQSxNQUFNQyxvQkFBb0IxZ0IsZUFBZWtDLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUl3ZSxxQkFBcUIsTUFBTTtRQUMzQjdoQixlQUFlc0QsVUFBVTtZQUFDO1NBQWdCLEVBQUV1ZTtJQUNoRDtJQUNBLE9BQU92ZTtBQUNYO0FBQ0EsU0FBU2c2QixxQkFBcUJqNkIsVUFBVTtJQUNwQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTWk2QixtQkFBbUJwOEIsZUFBZWtDLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUlrNkIsb0JBQW9CLE1BQU07UUFDMUJ2OUIsZUFBZXNELFVBQVU7WUFBQztTQUFRLEVBQUV1MkIsY0FBYzBEO0lBQ3REO0lBQ0EsT0FBT2o2QjtBQUNYO0FBQ0EsU0FBU2s2Qiw2QkFBNkJuNkIsVUFBVSxFQUFFK1ksWUFBWTtJQUMxRCxNQUFNOVksV0FBVyxDQUFDO0lBQ2xCLE1BQU1reUIscUJBQXFCcjBCLGVBQWVrQyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJK1ksaUJBQWlCbmUsYUFBYXUzQixzQkFBc0IsTUFBTTtRQUMxRHgxQixlQUFlb2MsY0FBYztZQUFDO1lBQWM7U0FBYyxFQUFFb1o7SUFDaEU7SUFDQSxNQUFNWSxnQkFBZ0JqMUIsZUFBZWtDLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUkrWSxpQkFBaUJuZSxhQUFhbTRCLGlCQUFpQixNQUFNO1FBQ3JEcDJCLGVBQWVvYyxjQUFjO1lBQUM7WUFBYztTQUFZLEVBQUVnYTtJQUM5RDtJQUNBLE1BQU1kLG1CQUFtQm4wQixlQUFla0MsWUFBWTtRQUFDO0tBQWU7SUFDcEUsSUFBSStZLGlCQUFpQm5lLGFBQWFxM0Isb0JBQW9CLE1BQU07UUFDeER0MUIsZUFBZW9jLGNBQWM7WUFBQztZQUFjO1NBQWEsRUFBRWtaO0lBQy9EO0lBQ0EsTUFBTTVXLFdBQVd2ZCxlQUFla0MsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSStZLGlCQUFpQm5lLGFBQWF5Z0IsWUFBWSxNQUFNO1FBQ2hEMWUsZUFBZW9jLGNBQWM7WUFBQztZQUFjO1NBQU8sRUFBRXNDO0lBQ3pEO0lBQ0EsTUFBTWdYLHdCQUF3QnYwQixlQUFla0MsWUFBWTtRQUNyRDtLQUNIO0lBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWF5M0IseUJBQXlCLE1BQU07UUFDN0QxMUIsZUFBZW9jLGNBQWM7WUFBQztZQUFjO1NBQWdCLEVBQUVzWjtJQUNsRTtJQUNBLE1BQU1DLHVCQUF1QngwQixlQUFla0MsWUFBWTtRQUNwRDtLQUNIO0lBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWEwM0Isd0JBQXdCLE1BQU07UUFDNUQzMUIsZUFBZW9jLGNBQWM7WUFBQztZQUFjO1NBQW1CLEVBQUV1WjtJQUNyRTtJQUNBLE1BQU1NLG1CQUFtQjkwQixlQUFla0MsWUFBWTtRQUFDO0tBQWU7SUFDcEUsSUFBSStZLGlCQUFpQm5lLGFBQWFnNEIsb0JBQW9CLE1BQU07UUFDeERqMkIsZUFBZW9jLGNBQWM7WUFBQztZQUFjO1NBQWUsRUFBRTZaO0lBQ2pFO0lBQ0EsTUFBTUYscUJBQXFCNTBCLGVBQWVrQyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJK1ksaUJBQWlCbmUsYUFBYTgzQixzQkFBc0IsTUFBTTtRQUMxRC8xQixlQUFlb2MsY0FBYztZQUFDO1lBQWM7WUFBaUI7U0FBVyxFQUFFMlo7SUFDOUU7SUFDQSxNQUFNQywrQkFBK0I3MEIsZUFBZWtDLFlBQVk7UUFDNUQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhKzNCLGdDQUFnQyxNQUFNO1FBQ3BFaDJCLGVBQWVvYyxjQUFjO1lBQUM7WUFBYztZQUFpQjtTQUFxQixFQUFFNFo7SUFDeEY7SUFDQSxNQUFNeUMsb0JBQW9CdDNCLGVBQWVrQyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJK1ksaUJBQWlCbmUsYUFBYXc2QixxQkFBcUIsTUFBTTtRQUN6RHo0QixlQUFlb2MsY0FBYztZQUFDO1lBQWM7U0FBZ0IsRUFBRXFjO0lBQ2xFO0lBQ0EsTUFBTXZDLGFBQWEvMEIsZUFBZWtDLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUkrWSxpQkFBaUJuZSxhQUFhaTRCLGNBQWMsTUFBTTtRQUNsRGwyQixlQUFlb2MsY0FBYztZQUFDO1NBQVMsRUFBRThaO0lBQzdDO0lBQ0EsT0FBTzV5QjtBQUNYO0FBQ0EsU0FBU202QixpQ0FBaUNyc0IsU0FBUyxFQUFFL04sVUFBVTtJQUMzRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTTZXLFlBQVloWixlQUFla0MsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSThXLGFBQWEsTUFBTTtRQUNuQm5hLGVBQWVzRCxVQUFVO1lBQUM7WUFBUTtTQUFRLEVBQUU2TixPQUFPQyxXQUFXK0k7SUFDbEU7SUFDQSxNQUFNc2dCLGFBQWF0NUIsZUFBZWtDLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlvM0IsY0FBYyxNQUFNO1FBQ3BCaUQsNkJBQTZCakQsWUFBWW4zQjtJQUM3QztJQUNBLE1BQU1pWixhQUFhcGIsZUFBZWtDLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlrWixjQUFjLE1BQU07UUFDcEJpaEIsNkJBQTZCamhCLFlBQVlqWjtJQUM3QztJQUNBLE9BQU9BO0FBQ1g7QUFDQSxTQUFTcTZCLGlDQUFpQ3Q2QixVQUFVO0lBQ2hELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNb3pCLHNCQUFzQnYxQixlQUFla0MsWUFBWTtRQUNuRDtLQUNIO0lBQ0QsSUFBSXF6Qix1QkFBdUIsTUFBTTtRQUM3QixJQUFJdnlCLGtCQUFrQnV5QjtRQUN0QixJQUFJbDJCLE1BQU1DLE9BQU8sQ0FBQzBELGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0I5QyxHQUFHLENBQUMsQ0FBQ2tCO2dCQUNuQyxPQUFPbzBCLHlCQUF5QnAwQjtZQUNwQztRQUNKO1FBQ0F2QyxlQUFlc0QsVUFBVTtZQUFDO1NBQWtCLEVBQUVhO0lBQ2xEO0lBQ0EsT0FBT2I7QUFDWDtBQUNBLFNBQVNvNkIsNkJBQTZCcjZCLFVBQVUsRUFBRStZLFlBQVk7SUFDMUQsTUFBTTlZLFdBQVcsQ0FBQztJQUNsQixNQUFNZ3pCLGFBQWFuMUIsZUFBZWtDLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUkrWSxpQkFBaUJuZSxhQUFhcTRCLGNBQWMsTUFBTTtRQUNsRHQyQixlQUFlb2MsY0FBYztZQUFDO1lBQWdCO1NBQVMsRUFBRWthO0lBQzdEO0lBQ0EsTUFBTXNILGtCQUFrQno4QixlQUFla0MsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSStZLGlCQUFpQm5lLGFBQWEyL0IsbUJBQW1CLE1BQU07UUFDdkQ1OUIsZUFBZW9jLGNBQWM7WUFBQztZQUFnQjtZQUFlO1NBQVEsRUFBRXlkLGNBQWMrRDtJQUN6RjtJQUNBLE1BQU1DLG9CQUFvQjE4QixlQUFla0MsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWE0L0IscUJBQXFCLE1BQU07UUFDekQsSUFBSTE1QixrQkFBa0IwNUI7UUFDdEIsSUFBSXI5QixNQUFNQyxPQUFPLENBQUMwRCxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCOUMsR0FBRyxDQUFDLENBQUNrQjtnQkFDbkMsT0FBTys2QixxQkFBcUIvNkI7WUFDaEM7UUFDSjtRQUNBdkMsZUFBZW9jLGNBQWM7WUFBQztZQUFnQjtTQUFnQixFQUFFalk7SUFDcEU7SUFDQSxPQUFPYjtBQUNYO0FBQ0EsU0FBU2t6QixrQ0FBa0NuekIsVUFBVTtJQUNqRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXc2QixxQkFBcUIzOEIsZUFBZWtDLFlBQVk7UUFDbEQ7S0FDSDtJQUNELElBQUl5NkIsc0JBQXNCLE1BQU07UUFDNUI5OUIsZUFBZXNELFVBQVU7WUFBQztTQUFpQixFQUFFdTJCLGNBQWNpRTtJQUMvRDtJQUNBLE1BQU1DLGtCQUFrQjU4QixlQUFla0MsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSTA2QixtQkFBbUIsTUFBTTtRQUN6Qi85QixlQUFlc0QsVUFBVTtZQUFDO1NBQWMsRUFBRXk2QjtJQUM5QztJQUNBLE1BQU1DLG9CQUFvQjc4QixlQUFla0MsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSTI2QixxQkFBcUIsTUFBTTtRQUMzQmgrQixlQUFlc0QsVUFBVTtZQUFDO1NBQWdCLEVBQUUwNkI7SUFDaEQ7SUFDQSxNQUFNQyxzQkFBc0I5OEIsZUFBZWtDLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUk0NkIsdUJBQXVCLE1BQU07UUFDN0JqK0IsZUFBZXNELFVBQVU7WUFBQztTQUFrQixFQUFFZzVCLDRCQUE0QjJCO0lBQzlFO0lBQ0EsTUFBTUMseUJBQXlCLzhCLGVBQWVrQyxZQUFZO1FBQ3REO0tBQ0g7SUFDRCxJQUFJNjZCLDBCQUEwQixNQUFNO1FBQ2hDbCtCLGVBQWVzRCxVQUFVO1lBQUM7U0FBcUIsRUFBRSt3QiwrQkFBK0I2SjtJQUNwRjtJQUNBLE1BQU1DLHVCQUF1Qmg5QixlQUFla0MsWUFBWTtRQUNwRDtLQUNIO0lBQ0QsSUFBSTg2Qix3QkFBd0IsTUFBTTtRQUM5Qm4rQixlQUFlc0QsVUFBVTtZQUFDO1NBQW1CLEVBQUU2NkI7SUFDbkQ7SUFDQSxNQUFNQyx5QkFBeUJqOUIsZUFBZWtDLFlBQVk7UUFDdEQ7S0FDSDtJQUNELElBQUkrNkIsMEJBQTBCLE1BQU07UUFDaENwK0IsZUFBZXNELFVBQVU7WUFBQztTQUFxQixFQUFFODZCO0lBQ3JEO0lBQ0EsT0FBTzk2QjtBQUNYO0FBQ0EsU0FBU3kxQiwwQkFBMEIxMUIsVUFBVTtJQUN6QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTSs2QixpQkFBaUJsOUIsZUFBZWtDLFlBQVk7UUFDOUM7UUFDQTtLQUNIO0lBQ0QsSUFBSWc3QixrQkFBa0IsTUFBTTtRQUN4QnIrQixlQUFlc0QsVUFBVTtZQUFDO1NBQWEsRUFBRSs2QjtJQUM3QztJQUNBLE1BQU1DLGFBQWFuOUIsZUFBZWtDLFlBQVk7UUFDMUM7UUFDQTtLQUNIO0lBQ0QsSUFBSWk3QixjQUFjLE1BQU07UUFDcEJ0K0IsZUFBZXNELFVBQVU7WUFBQztTQUFTLEVBQUVnN0I7SUFDekM7SUFDQSxNQUFNQyxrQkFBa0JwOUIsZUFBZWtDLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUlrN0IsbUJBQW1CLE1BQU07UUFDekJ2K0IsZUFBZXNELFVBQVU7WUFBQztTQUFjLEVBQUVpN0I7SUFDOUM7SUFDQSxPQUFPajdCO0FBQ1g7QUFDQSxTQUFTMjFCLDJCQUEyQjUxQixVQUFVO0lBQzFDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNKzZCLGlCQUFpQmw5QixlQUFla0MsWUFBWTtRQUM5QztRQUNBO0tBQ0g7SUFDRCxJQUFJZzdCLGtCQUFrQixNQUFNO1FBQ3hCcitCLGVBQWVzRCxVQUFVO1lBQUM7U0FBYSxFQUFFKzZCO0lBQzdDO0lBQ0EsTUFBTUMsYUFBYW45QixlQUFla0MsWUFBWTtRQUMxQztRQUNBO0tBQ0g7SUFDRCxJQUFJaTdCLGNBQWMsTUFBTTtRQUNwQnQrQixlQUFlc0QsVUFBVTtZQUFDO1NBQVMsRUFBRWc3QjtJQUN6QztJQUNBLE1BQU1DLGtCQUFrQnA5QixlQUFla0MsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSWs3QixtQkFBbUIsTUFBTTtRQUN6QnYrQixlQUFlc0QsVUFBVTtZQUFDO1NBQWMsRUFBRWk3QjtJQUM5QztJQUNBLE9BQU9qN0I7QUFDWDtBQUNBLFNBQVNzMEIscUJBQXFCdjBCLFVBQVU7SUFDcEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU13ZSxlQUFlM2dCLGVBQWVrQyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJeWUsZ0JBQWdCLE1BQU07UUFDdEI5aEIsZUFBZXNELFVBQVU7WUFBQztTQUFXLEVBQUV3ZTtJQUMzQztJQUNBLElBQUkzZ0IsZUFBZWtDLFlBQVk7UUFBQztLQUFTLE1BQU1wRixXQUFXO1FBQ3RELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxNQUFNZ2lCLGdCQUFnQjVnQixlQUFla0MsWUFBWTtRQUFDO0tBQVk7SUFDOUQsSUFBSTBlLGlCQUFpQixNQUFNO1FBQ3ZCL2hCLGVBQWVzRCxVQUFVO1lBQUM7U0FBWSxFQUFFeWU7SUFDNUM7SUFDQSxPQUFPemU7QUFDWDtBQUNBLFNBQVNrN0Isc0JBQXNCbjdCLFVBQVU7SUFDckMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1pM0IsWUFBWXA1QixlQUFla0MsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSWszQixhQUFhLE1BQU07UUFDbkJ2NkIsZUFBZXNELFVBQVU7WUFBQztTQUFRLEVBQUV1MkIsY0FBY1U7SUFDdEQ7SUFDQSxPQUFPajNCO0FBQ1g7QUFDQSxTQUFTbTdCLDJCQUEyQnA3QixVQUFVLEVBQUUrWSxZQUFZO0lBQ3hELE1BQU05WSxXQUFXLENBQUM7SUFDbEIsTUFBTXNhLFdBQVd6YyxlQUFla0MsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSStZLGlCQUFpQm5lLGFBQWEyZixZQUFZLE1BQU07UUFDaEQ1ZCxlQUFlb2MsY0FBYztZQUFDO1lBQWM7U0FBTyxFQUFFd0I7SUFDekQ7SUFDQSxNQUFNOGdCLHFCQUFxQnY5QixlQUFla0MsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWF5Z0Msc0JBQXNCLE1BQU07UUFDMUQxK0IsZUFBZW9jLGNBQWM7WUFBQztZQUFjO1NBQWlCLEVBQUVzaUI7SUFDbkU7SUFDQSxNQUFNQywwQkFBMEJ4OUIsZUFBZWtDLFlBQVk7UUFDdkQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhMGdDLDJCQUEyQixNQUFNO1FBQy9EMytCLGVBQWVvYyxjQUFjO1lBQUM7WUFBYztTQUFzQixFQUFFdWlCO0lBQ3hFO0lBQ0EsTUFBTWxDLG1CQUFtQnQ3QixlQUFla0MsWUFBWTtRQUFDO0tBQWU7SUFDcEUsSUFBSStZLGlCQUFpQm5lLGFBQWF3K0Isb0JBQW9CLE1BQU07UUFDeER6OEIsZUFBZW9jLGNBQWM7WUFBQztZQUFjO1NBQWUsRUFBRXFnQjtJQUNqRTtJQUNBLE1BQU1tQywyQkFBMkJ6OUIsZUFBZWtDLFlBQVk7UUFDeEQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhMmdDLDRCQUE0QixNQUFNO1FBQ2hFNStCLGVBQWVvYyxjQUFjO1lBQUM7WUFBYztTQUF1QixFQUFFd2lCO0lBQ3pFO0lBQ0EsTUFBTTFJLGFBQWEvMEIsZUFBZWtDLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUkrWSxpQkFBaUJuZSxhQUFhaTRCLGNBQWMsTUFBTTtRQUNsRGwyQixlQUFlb2MsY0FBYztZQUFDO1NBQVMsRUFBRThaO0lBQzdDO0lBQ0EsT0FBTzV5QjtBQUNYO0FBQ0EsU0FBU3U3QiwrQkFBK0J6dEIsU0FBUyxFQUFFL04sVUFBVTtJQUN6RCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTTZXLFlBQVloWixlQUFla0MsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSThXLGFBQWEsTUFBTTtRQUNuQm5hLGVBQWVzRCxVQUFVO1lBQUM7WUFBUTtTQUFRLEVBQUU2TixPQUFPQyxXQUFXK0k7SUFDbEU7SUFDQSxNQUFNc2dCLGFBQWF0NUIsZUFBZWtDLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlvM0IsY0FBYyxNQUFNO1FBQ3BCcUUsMkJBQTJCckUsWUFBWW4zQjtJQUMzQztJQUNBLE1BQU1pWixhQUFhcGIsZUFBZWtDLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlrWixjQUFjLE1BQU07UUFDcEJraUIsMkJBQTJCbGlCLFlBQVlqWjtJQUMzQztJQUNBLE9BQU9BO0FBQ1g7QUFDQSxTQUFTeTdCLCtCQUErQjE3QixVQUFVO0lBQzlDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNMDdCLHFCQUFxQjc5QixlQUFla0MsWUFBWTtRQUFDO0tBQWM7SUFDckUsSUFBSTI3QixzQkFBc0IsTUFBTTtRQUM1QixJQUFJNzZCLGtCQUFrQjY2QjtRQUN0QixJQUFJeCtCLE1BQU1DLE9BQU8sQ0FBQzBELGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0I5QyxHQUFHLENBQUMsQ0FBQ2tCO2dCQUNuQyxPQUFPODRCLDZCQUE2Qjk0QjtZQUN4QztRQUNKO1FBQ0F2QyxlQUFlc0QsVUFBVTtZQUFDO1NBQWlCLEVBQUVhO0lBQ2pEO0lBQ0EsT0FBT2I7QUFDWDtBQUNBLFNBQVN3N0IsMkJBQTJCejdCLFVBQVUsRUFBRStZLFlBQVk7SUFDeEQsTUFBTTlZLFdBQVcsQ0FBQztJQUNsQixNQUFNZ3pCLGFBQWFuMUIsZUFBZWtDLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUkrWSxpQkFBaUJuZSxhQUFhcTRCLGNBQWMsTUFBTTtRQUNsRHQyQixlQUFlb2MsY0FBYztZQUFDO1lBQWdCO1NBQVMsRUFBRWthO0lBQzdEO0lBQ0EsTUFBTWlFLFlBQVlwNUIsZUFBZWtDLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUkrWSxpQkFBaUJuZSxhQUFhczhCLGFBQWEsTUFBTTtRQUNqRHY2QixlQUFlb2MsY0FBYztZQUFDO1lBQWdCO1NBQVEsRUFBRXlkLGNBQWNVO0lBQzFFO0lBQ0EsTUFBTTBFLG9CQUFvQjk5QixlQUFla0MsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWFnaEMscUJBQXFCLE1BQU07UUFDekRqL0IsZUFBZW9jLGNBQWM7WUFBQztZQUFnQjtTQUFXLEVBQUVvaUIsc0JBQXNCUztJQUNyRjtJQUNBLE9BQU8zN0I7QUFDWDtBQUNBLFNBQVMyMEIscUJBQXFCNTBCLFVBQVU7SUFDcEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1xdkIsbUJBQW1CeHhCLGVBQWVrQyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJc3ZCLG9CQUFvQixNQUFNO1FBQzFCM3lCLGVBQWVzRCxVQUFVO1lBQUM7U0FBZSxFQUFFcXZCO0lBQy9DO0lBQ0EsTUFBTUMsa0JBQWtCenhCLGVBQWVrQyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJdXZCLG1CQUFtQixNQUFNO1FBQ3pCNXlCLGVBQWVzRCxVQUFVO1lBQUM7U0FBYyxFQUFFc3ZCO0lBQzlDO0lBQ0EsSUFBSXp4QixlQUFla0MsWUFBWTtRQUFDO0tBQTBCLE1BQU1wRixXQUFXO1FBQ3ZFLE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxPQUFPdUQ7QUFDWDtBQUNBLFNBQVN3MEIsa0JBQWtCejBCLFVBQVU7SUFDakMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU0wZSw0QkFBNEI3Z0IsZUFBZWtDLFlBQVk7UUFDekQ7S0FDSDtJQUNELElBQUkyZSw2QkFBNkIsTUFBTTtRQUNuQ2hpQixlQUFlc0QsVUFBVTtZQUFDO1NBQXdCLEVBQUVtMEIsNkJBQTZCelY7SUFDckY7SUFDQSxNQUFNQyxzQkFBc0I5Z0IsZUFBZWtDLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUk0ZSx1QkFBdUIsTUFBTTtRQUM3QmppQixlQUFlc0QsVUFBVTtZQUFDO1NBQWtCLEVBQUUyZTtJQUNsRDtJQUNBLE9BQU8zZTtBQUNYO0FBQ0EsU0FBU3UwQixjQUFjeDBCLFVBQVU7SUFDN0IsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU00ZSwyQkFBMkIvZ0IsZUFBZWtDLFlBQVk7UUFDeEQ7S0FDSDtJQUNELElBQUk2ZSw0QkFBNEIsTUFBTTtRQUNsQyxJQUFJL2Qsa0JBQWtCK2Q7UUFDdEIsSUFBSTFoQixNQUFNQyxPQUFPLENBQUMwRCxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCOUMsR0FBRyxDQUFDLENBQUNrQjtnQkFDbkMsT0FBT0E7WUFDWDtRQUNKO1FBQ0F2QyxlQUFlc0QsVUFBVTtZQUFDO1NBQXVCLEVBQUVhO0lBQ3ZEO0lBQ0EsSUFBSWhELGVBQWVrQyxZQUFZO1FBQUM7S0FBWSxNQUFNcEYsV0FBVztRQUN6RCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTW9pQiw0QkFBNEJoaEIsZUFBZWtDLFlBQVk7UUFDekQ7S0FDSDtJQUNELElBQUk4ZSw2QkFBNkIsTUFBTTtRQUNuQ25pQixlQUFlc0QsVUFBVTtZQUFDO1NBQXdCLEVBQUU2ZTtJQUN4RDtJQUNBLE1BQU1DLGtCQUFrQmpoQixlQUFla0MsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSStlLG1CQUFtQixNQUFNO1FBQ3pCcGlCLGVBQWVzRCxVQUFVO1lBQUM7U0FBYyxFQUFFOGU7SUFDOUM7SUFDQSxNQUFNQyxpQkFBaUJsaEIsZUFBZWtDLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUlnZixrQkFBa0IsTUFBTTtRQUN4QnJpQixlQUFlc0QsVUFBVTtZQUFDO1NBQWEsRUFBRStlO0lBQzdDO0lBQ0EsTUFBTUMsb0JBQW9CbmhCLGVBQWVrQyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJaWYscUJBQXFCLE1BQU07UUFDM0J0aUIsZUFBZXNELFVBQVU7WUFBQztTQUFnQixFQUFFZ2Y7SUFDaEQ7SUFDQSxJQUFJbmhCLGVBQWVrQyxZQUFZO1FBQUM7S0FBc0IsTUFBTXBGLFdBQVc7UUFDbkUsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE1BQU13aUIsaUJBQWlCcGhCLGVBQWVrQyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJa2Ysa0JBQWtCLE1BQU07UUFDeEJ2aUIsZUFBZXNELFVBQVU7WUFBQztTQUFhLEVBQUVvNEIsb0JBQW9Cblo7SUFDakU7SUFDQSxNQUFNQyxtQkFBbUJyaEIsZUFBZWtDLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUltZixvQkFBb0IsTUFBTTtRQUMxQnhpQixlQUFlc0QsVUFBVTtZQUFDO1NBQWUsRUFBRXE0QixzQkFBc0JuWjtJQUNyRTtJQUNBLE1BQU1DLGlCQUFpQnRoQixlQUFla0MsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSW9mLGtCQUFrQixNQUFNO1FBQ3hCemlCLGVBQWVzRCxVQUFVO1lBQUM7U0FBYSxFQUFFbWY7SUFDN0M7SUFDQSxPQUFPbmY7QUFDWDtBQUNBLFNBQVNveEIsYUFBYXJ4QixVQUFVO0lBQzVCLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNNGUsMkJBQTJCL2dCLGVBQWVrQyxZQUFZO1FBQ3hEO0tBQ0g7SUFDRCxJQUFJNmUsNEJBQTRCLE1BQU07UUFDbEMsSUFBSS9kLGtCQUFrQitkO1FBQ3RCLElBQUkxaEIsTUFBTUMsT0FBTyxDQUFDMEQsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQjlDLEdBQUcsQ0FBQyxDQUFDa0I7Z0JBQ25DLE9BQU9tMUIsNEJBQTRCbjFCO1lBQ3ZDO1FBQ0o7UUFDQXZDLGVBQWVzRCxVQUFVO1lBQUM7U0FBdUIsRUFBRWE7SUFDdkQ7SUFDQSxNQUFNZ2xCLGdCQUFnQmhvQixlQUFla0MsWUFBWTtRQUFDO0tBQVk7SUFDOUQsSUFBSThsQixpQkFBaUIsTUFBTTtRQUN2Qm5wQixlQUFlc0QsVUFBVTtZQUFDO1NBQVksRUFBRTZsQjtJQUM1QztJQUNBLE1BQU1oSCw0QkFBNEJoaEIsZUFBZWtDLFlBQVk7UUFDekQ7S0FDSDtJQUNELElBQUk4ZSw2QkFBNkIsTUFBTTtRQUNuQ25pQixlQUFlc0QsVUFBVTtZQUFDO1NBQXdCLEVBQUU2ZTtJQUN4RDtJQUNBLE1BQU1DLGtCQUFrQmpoQixlQUFla0MsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSStlLG1CQUFtQixNQUFNO1FBQ3pCcGlCLGVBQWVzRCxVQUFVO1lBQUM7U0FBYyxFQUFFOGU7SUFDOUM7SUFDQSxJQUFJamhCLGVBQWVrQyxZQUFZO1FBQUM7S0FBYSxNQUFNcEYsV0FBVztRQUMxRCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTXVpQixvQkFBb0JuaEIsZUFBZWtDLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUlpZixxQkFBcUIsTUFBTTtRQUMzQnRpQixlQUFlc0QsVUFBVTtZQUFDO1NBQWdCLEVBQUVnZjtJQUNoRDtJQUNBLE1BQU04RywwQkFBMEJqb0IsZUFBZWtDLFlBQVk7UUFDdkQ7S0FDSDtJQUNELElBQUkrbEIsMkJBQTJCLE1BQU07UUFDakNwcEIsZUFBZXNELFVBQVU7WUFBQztTQUFzQixFQUFFOGxCO0lBQ3REO0lBQ0EsTUFBTTdHLGlCQUFpQnBoQixlQUFla0MsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSWtmLGtCQUFrQixNQUFNO1FBQ3hCdmlCLGVBQWVzRCxVQUFVO1lBQUM7U0FBYSxFQUFFaWY7SUFDN0M7SUFDQSxNQUFNQyxtQkFBbUJyaEIsZUFBZWtDLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUltZixvQkFBb0IsTUFBTTtRQUMxQnhpQixlQUFlc0QsVUFBVTtZQUFDO1NBQWUsRUFBRWtmO0lBQy9DO0lBQ0EsTUFBTUMsaUJBQWlCdGhCLGVBQWVrQyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJb2Ysa0JBQWtCLE1BQU07UUFDeEJ6aUIsZUFBZXNELFVBQVU7WUFBQztTQUFhLEVBQUVtZjtJQUM3QztJQUNBLE9BQU9uZjtBQUNYO0FBQ0EsU0FBU3M1Qix3QkFBd0J2NUIsVUFBVTtJQUN2QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTTQ3QixnQkFBZ0IvOUIsZUFBZWtDLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUk2N0IsaUJBQWlCLE1BQU07UUFDdkJsL0IsZUFBZXNELFVBQVU7WUFBQztTQUFZLEVBQUU0N0I7SUFDNUM7SUFDQSxNQUFNbGxCLGlCQUFpQjdZLGVBQWVrQyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJMlcsa0JBQWtCLE1BQU07UUFDeEJoYSxlQUFlc0QsVUFBVTtZQUFDO1NBQWEsRUFBRTBXO0lBQzdDO0lBQ0EsTUFBTUUsaUJBQWlCL1ksZUFBZWtDLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUk2VyxrQkFBa0IsTUFBTTtRQUN4QmxhLGVBQWVzRCxVQUFVO1lBQUM7U0FBYSxFQUFFNFc7SUFDN0M7SUFDQSxPQUFPNVc7QUFDWDtBQUNBLFNBQVM2NUIseUJBQXlCOTVCLFVBQVU7SUFDeEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU00N0IsZ0JBQWdCLzlCLGVBQWVrQyxZQUFZO1FBQzdDO1FBQ0E7S0FDSDtJQUNELElBQUk2N0IsaUJBQWlCLE1BQU07UUFDdkJsL0IsZUFBZXNELFVBQVU7WUFBQztTQUFZLEVBQUU0N0I7SUFDNUM7SUFDQSxNQUFNbGxCLGlCQUFpQjdZLGVBQWVrQyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJMlcsa0JBQWtCLE1BQU07UUFDeEJoYSxlQUFlc0QsVUFBVTtZQUFDO1NBQWEsRUFBRTBXO0lBQzdDO0lBQ0EsTUFBTUUsaUJBQWlCL1ksZUFBZWtDLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUk2VyxrQkFBa0IsTUFBTTtRQUN4QmxhLGVBQWVzRCxVQUFVO1lBQUM7U0FBYSxFQUFFNFc7SUFDN0M7SUFDQSxPQUFPNVc7QUFDWDtBQUNBLFNBQVM2N0IseUJBQXlCOTdCLFVBQVUsRUFBRStZLFlBQVk7SUFDdEQsTUFBTTlZLFdBQVcsQ0FBQztJQUNsQixNQUFNd1csa0JBQWtCM1ksZUFBZWtDLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUkrWSxpQkFBaUJuZSxhQUFhNmIsbUJBQW1CLE1BQU07UUFDdkQ5WixlQUFlb2MsY0FBYztZQUFDO1NBQWMsRUFBRXRDO0lBQ2xEO0lBQ0EsTUFBTXVPLGtCQUFrQmxuQixlQUFla0MsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSStZLGlCQUFpQm5lLGFBQWFvcUIsbUJBQW1CLE1BQU07UUFDdkRyb0IsZUFBZW9jLGNBQWM7WUFBQztTQUFjLEVBQUVpTTtJQUNsRDtJQUNBLE1BQU0rVSwwQkFBMEJqOEIsZUFBZWtDLFlBQVk7UUFDdkQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhbS9CLDJCQUEyQixNQUFNO1FBQy9EcDlCLGVBQWVvYyxjQUFjO1lBQUM7U0FBc0IsRUFBRWdoQjtJQUMxRDtJQUNBLE9BQU85NUI7QUFDWDtBQUNBLFNBQVM4N0IsMEJBQTBCLzdCLFVBQVUsRUFBRStZLFlBQVk7SUFDdkQsTUFBTTlZLFdBQVcsQ0FBQztJQUNsQixNQUFNd1csa0JBQWtCM1ksZUFBZWtDLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUkrWSxpQkFBaUJuZSxhQUFhNmIsbUJBQW1CLE1BQU07UUFDdkQ5WixlQUFlb2MsY0FBYztZQUFDO1NBQWMsRUFBRXRDO0lBQ2xEO0lBQ0EsTUFBTXVPLGtCQUFrQmxuQixlQUFla0MsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSStZLGlCQUFpQm5lLGFBQWFvcUIsbUJBQW1CLE1BQU07UUFDdkRyb0IsZUFBZW9jLGNBQWM7WUFBQztTQUFjLEVBQUVpTTtJQUNsRDtJQUNBLE1BQU0rVSwwQkFBMEJqOEIsZUFBZWtDLFlBQVk7UUFDdkQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhbS9CLDJCQUEyQixNQUFNO1FBQy9EcDlCLGVBQWVvYyxjQUFjO1lBQUM7U0FBc0IsRUFBRWdoQjtJQUMxRDtJQUNBLE9BQU85NUI7QUFDWDtBQUNBLFNBQVMrN0IsNkJBQTZCanVCLFNBQVMsRUFBRS9OLFVBQVU7SUFDdkQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU02VyxZQUFZaFosZUFBZWtDLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUk4VyxhQUFhLE1BQU07UUFDbkJuYSxlQUFlc0QsVUFBVTtZQUFDO1lBQVE7U0FBTyxFQUFFNk4sT0FBT0MsV0FBVytJO0lBQ2pFO0lBQ0EsTUFBTW9DLGFBQWFwYixlQUFla0MsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSWtaLGNBQWMsTUFBTTtRQUNwQjRpQix5QkFBeUI1aUIsWUFBWWpaO0lBQ3pDO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLFNBQVNnOEIsOEJBQThCbHVCLFNBQVMsRUFBRS9OLFVBQVU7SUFDeEQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU02VyxZQUFZaFosZUFBZWtDLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUk4VyxhQUFhLE1BQU07UUFDbkJuYSxlQUFlc0QsVUFBVTtZQUFDO1lBQVE7U0FBUSxFQUFFNk4sT0FBT0MsV0FBVytJO0lBQ2xFO0lBQ0EsTUFBTW9DLGFBQWFwYixlQUFla0MsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSWtaLGNBQWMsTUFBTTtRQUNwQjZpQiwwQkFBMEI3aUIsWUFBWWpaO0lBQzFDO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLFNBQVNpOEIsc0NBQXNDbDhCLFVBQVUsRUFBRStZLFlBQVk7SUFDbkUsTUFBTTlZLFdBQVcsQ0FBQztJQUNsQixNQUFNZ3lCLG1CQUFtQm4wQixlQUFla0MsWUFBWTtRQUFDO0tBQWU7SUFDcEUsSUFBSStZLGlCQUFpQm5lLGFBQWFxM0Isb0JBQW9CLE1BQU07UUFDeER0MUIsZUFBZW9jLGNBQWM7WUFBQztZQUFjO1NBQWEsRUFBRWtaO0lBQy9EO0lBQ0EsTUFBTUksd0JBQXdCdjBCLGVBQWVrQyxZQUFZO1FBQ3JEO0tBQ0g7SUFDRCxJQUFJK1ksaUJBQWlCbmUsYUFBYXkzQix5QkFBeUIsTUFBTTtRQUM3RDExQixlQUFlb2MsY0FBYztZQUFDO1lBQWM7U0FBZ0IsRUFBRXNaO0lBQ2xFO0lBQ0EsTUFBTUMsdUJBQXVCeDBCLGVBQWVrQyxZQUFZO1FBQ3BEO0tBQ0g7SUFDRCxJQUFJK1ksaUJBQWlCbmUsYUFBYTAzQix3QkFBd0IsTUFBTTtRQUM1RDMxQixlQUFlb2MsY0FBYztZQUFDO1lBQWM7U0FBbUIsRUFBRXVaO0lBQ3JFO0lBQ0EsTUFBTUUsdUJBQXVCMTBCLGVBQWVrQyxZQUFZO1FBQ3BEO0tBQ0g7SUFDRCxJQUFJK1ksaUJBQWlCbmUsYUFBYTQzQix3QkFBd0IsTUFBTTtRQUM1RDcxQixlQUFlb2MsY0FBYztZQUFDO1lBQWM7U0FBbUIsRUFBRXlaO0lBQ3JFO0lBQ0EsTUFBTUUscUJBQXFCNTBCLGVBQWVrQyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJK1ksaUJBQWlCbmUsYUFBYTgzQixzQkFBc0IsTUFBTTtRQUMxRC8xQixlQUFlb2MsY0FBYztZQUFDO1lBQWM7WUFBaUI7U0FBVyxFQUFFMlo7SUFDOUU7SUFDQSxNQUFNQywrQkFBK0I3MEIsZUFBZWtDLFlBQVk7UUFDNUQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhKzNCLGdDQUFnQyxNQUFNO1FBQ3BFaDJCLGVBQWVvYyxjQUFjO1lBQUM7WUFBYztZQUFpQjtTQUFxQixFQUFFNFo7SUFDeEY7SUFDQSxNQUFNd0osd0JBQXdCcitCLGVBQWVrQyxZQUFZO1FBQ3JEO0tBQ0g7SUFDRCxJQUFJK1ksaUJBQWlCbmUsYUFBYXVoQyx5QkFBeUIsTUFBTTtRQUM3RHgvQixlQUFlb2MsY0FBYztZQUFDO1lBQWM7WUFBaUI7U0FBb0IsRUFBRW9qQjtJQUN2RjtJQUNBLE1BQU1DLDhCQUE4QnQrQixlQUFla0MsWUFBWTtRQUMzRDtLQUNIO0lBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWF3aEMsK0JBQStCLE1BQU07UUFDbkV6L0IsZUFBZW9jLGNBQWM7WUFBQztZQUFjO1lBQWlCO1NBQTBCLEVBQUVxakI7SUFDN0Y7SUFDQSxNQUFNdkosYUFBYS8wQixlQUFla0MsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSStZLGlCQUFpQm5lLGFBQWFpNEIsY0FBYyxNQUFNO1FBQ2xEbDJCLGVBQWVvYyxjQUFjO1lBQUM7U0FBUyxFQUFFOFo7SUFDN0M7SUFDQSxNQUFNVixxQkFBcUJyMEIsZUFBZWtDLFlBQVk7UUFDbEQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhdTNCLHNCQUFzQixNQUFNO1FBQzFEeDFCLGVBQWVvYyxjQUFjO1lBQUM7WUFBYztTQUFjLEVBQUVvWjtJQUNoRTtJQUNBLE1BQU01WCxXQUFXemMsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUkrWSxpQkFBaUJuZSxhQUFhMmYsWUFBWSxNQUFNO1FBQ2hENWQsZUFBZW9jLGNBQWM7WUFBQztZQUFjO1NBQU8sRUFBRXdCO0lBQ3pEO0lBQ0EsT0FBT3RhO0FBQ1g7QUFDQSxTQUFTbzhCLDBDQUEwQ3R1QixTQUFTLEVBQUUvTixVQUFVO0lBQ3BFLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNNlcsWUFBWWhaLGVBQWVrQyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJOFcsYUFBYSxNQUFNO1FBQ25CbmEsZUFBZXNELFVBQVU7WUFBQztZQUFRO1NBQVEsRUFBRTZOLE9BQU9DLFdBQVcrSTtJQUNsRTtJQUNBLE1BQU1vZ0IsWUFBWXA1QixlQUFla0MsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSWszQixhQUFhLE1BQU07UUFDbkJ2NkIsZUFBZXNELFVBQVU7WUFBQztZQUFnQjtTQUFRLEVBQUV1MkIsY0FBY1U7SUFDdEU7SUFDQSxNQUFNb0Ysb0JBQW9CeCtCLGVBQWVrQyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJczhCLHFCQUFxQixNQUFNO1FBQzNCMy9CLGVBQWVzRCxVQUFVO1lBQUM7WUFBYztZQUFpQjtTQUFnQixFQUFFcThCO0lBQy9FO0lBQ0EsTUFBTXBqQixhQUFhcGIsZUFBZWtDLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlrWixjQUFjLE1BQU07UUFDcEJnakIsc0NBQXNDaGpCLFlBQVlqWjtJQUN0RDtJQUNBLE9BQU9BO0FBQ1g7QUFDQSxTQUFTczhCLCtCQUErQnY4QixVQUFVO0lBQzlDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNeUIsc0JBQXNCNUQsZUFBZWtDLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUkwQix1QkFBdUIsTUFBTTtRQUM3Qi9FLGVBQWVzRCxVQUFVO1lBQUM7U0FBa0IsRUFBRXlCO0lBQ2xEO0lBQ0EsTUFBTTJ4QixzQkFBc0J2MUIsZUFBZWtDLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUlxekIsdUJBQXVCLE1BQU07UUFDN0IsSUFBSXZ5QixrQkFBa0J1eUI7UUFDdEIsSUFBSWwyQixNQUFNQyxPQUFPLENBQUMwRCxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCOUMsR0FBRyxDQUFDLENBQUNrQjtnQkFDbkMsT0FBT28wQix5QkFBeUJwMEI7WUFDcEM7UUFDSjtRQUNBdkMsZUFBZXNELFVBQVU7WUFBQztTQUFrQixFQUFFYTtJQUNsRDtJQUNBLE9BQU9iO0FBQ1g7QUFDQSxTQUFTZzRCLGVBQWVqNEIsVUFBVTtJQUM5QixNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTThCLFVBQVVqRSxlQUFla0MsWUFBWTtRQUFDO0tBQU07SUFDbEQsSUFBSStCLFdBQVcsTUFBTTtRQUNqQnBGLGVBQWVzRCxVQUFVO1lBQUM7U0FBTSxFQUFFOEI7SUFDdEM7SUFDQSxNQUFNQyxpQkFBaUJsRSxlQUFla0MsWUFBWTtRQUFDO0tBQWU7SUFDbEUsSUFBSWdDLGtCQUFrQixNQUFNO1FBQ3hCckYsZUFBZXNELFVBQVU7WUFBQztTQUFhLEVBQUVzUyxPQUFPdlE7SUFDcEQ7SUFDQSxNQUFNQyxlQUFlbkUsZUFBZWtDLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlpQyxnQkFBZ0IsTUFBTTtRQUN0QnRGLGVBQWVzRCxVQUFVO1lBQUM7U0FBVyxFQUFFZ0M7SUFDM0M7SUFDQSxPQUFPaEM7QUFDWDtBQUNBLFNBQVNpNEIsZ0JBQWdCbDRCLFVBQVU7SUFDL0IsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU04QixVQUFVakUsZUFBZWtDLFlBQVk7UUFBQztLQUFTO0lBQ3JELElBQUkrQixXQUFXLE1BQU07UUFDakJwRixlQUFlc0QsVUFBVTtZQUFDO1NBQU0sRUFBRThCO0lBQ3RDO0lBQ0EsTUFBTUMsaUJBQWlCbEUsZUFBZWtDLFlBQVk7UUFDOUM7S0FDSDtJQUNELElBQUlnQyxrQkFBa0IsTUFBTTtRQUN4QnJGLGVBQWVzRCxVQUFVO1lBQUM7U0FBYSxFQUFFc1MsT0FBT3ZRO0lBQ3BEO0lBQ0EsTUFBTUMsZUFBZW5FLGVBQWVrQyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJaUMsZ0JBQWdCLE1BQU07UUFDdEJ0RixlQUFlc0QsVUFBVTtZQUFDO1NBQVcsRUFBRWdDO0lBQzNDO0lBQ0EsT0FBT2hDO0FBQ1g7QUFDQSxTQUFTMDJCLDRCQUE0QjMyQixVQUFVO0lBQzNDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNaTNCLFlBQVlwNUIsZUFBZWtDLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUlrM0IsYUFBYSxNQUFNO1FBQ25CdjZCLGVBQWVzRCxVQUFVO1lBQUM7U0FBUSxFQUFFdTJCLGNBQWNVO0lBQ3REO0lBQ0EsTUFBTWdDLGVBQWVwN0IsZUFBZWtDLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlrNUIsZ0JBQWdCLE1BQU07UUFDdEJ2OEIsZUFBZXNELFVBQVU7WUFBQztTQUFXLEVBQUVpNUI7SUFDM0M7SUFDQSxPQUFPajVCO0FBQ1g7QUFDQSxTQUFTazJCLHFDQUFxQ24yQixVQUFVO0lBQ3BELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNaTNCLFlBQVlwNUIsZUFBZWtDLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUlrM0IsYUFBYSxNQUFNO1FBQ25CdjZCLGVBQWVzRCxVQUFVO1lBQUM7U0FBUSxFQUFFaTJCLGFBQWFnQjtJQUNyRDtJQUNBLE1BQU15RCxvQkFBb0I3OEIsZUFBZWtDLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUkyNkIscUJBQXFCLE1BQU07UUFDM0JoK0IsZUFBZXNELFVBQVU7WUFBQztTQUFnQixFQUFFMDZCO0lBQ2hEO0lBQ0EsT0FBTzE2QjtBQUNYO0FBQ0EsU0FBU3cyQixzQ0FBc0N6MkIsVUFBVTtJQUNyRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTWkzQixZQUFZcDVCLGVBQWVrQyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJazNCLGFBQWEsTUFBTTtRQUNuQnY2QixlQUFlc0QsVUFBVTtZQUFDO1NBQVEsRUFBRXUyQixjQUFjVTtJQUN0RDtJQUNBLE1BQU15RCxvQkFBb0I3OEIsZUFBZWtDLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUkyNkIscUJBQXFCLE1BQU07UUFDM0JoK0IsZUFBZXNELFVBQVU7WUFBQztTQUFnQixFQUFFMDZCO0lBQ2hEO0lBQ0EsT0FBTzE2QjtBQUNYO0FBQ0EsU0FBU2szQixhQUFhbjNCLFVBQVU7SUFDNUIsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU04QixVQUFVakUsZUFBZWtDLFlBQVk7UUFBQztLQUFNO0lBQ2xELElBQUkrQixXQUFXLE1BQU07UUFDakJwRixlQUFlc0QsVUFBVTtZQUFDO1NBQU0sRUFBRThCO0lBQ3RDO0lBQ0EsTUFBTUMsaUJBQWlCbEUsZUFBZWtDLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUlnQyxrQkFBa0IsTUFBTTtRQUN4QnJGLGVBQWVzRCxVQUFVO1lBQUM7U0FBZSxFQUFFc1MsT0FBT3ZRO0lBQ3REO0lBQ0EsTUFBTUMsZUFBZW5FLGVBQWVrQyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJaUMsZ0JBQWdCLE1BQU07UUFDdEJ0RixlQUFlc0QsVUFBVTtZQUFDO1NBQVcsRUFBRWdDO0lBQzNDO0lBQ0EsT0FBT2hDO0FBQ1g7QUFDQSxTQUFTczNCLGNBQWN2M0IsVUFBVTtJQUM3QixNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTThCLFVBQVVqRSxlQUFla0MsWUFBWTtRQUFDO0tBQU07SUFDbEQsSUFBSStCLFdBQVcsTUFBTTtRQUNqQnBGLGVBQWVzRCxVQUFVO1lBQUM7U0FBUyxFQUFFOEI7SUFDekM7SUFDQSxNQUFNQyxpQkFBaUJsRSxlQUFla0MsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSWdDLGtCQUFrQixNQUFNO1FBQ3hCckYsZUFBZXNELFVBQVU7WUFBQztTQUFxQixFQUFFc1MsT0FBT3ZRO0lBQzVEO0lBQ0EsTUFBTUMsZUFBZW5FLGVBQWVrQyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJaUMsZ0JBQWdCLE1BQU07UUFDdEJ0RixlQUFlc0QsVUFBVTtZQUFDO1NBQVcsRUFBRWdDO0lBQzNDO0lBQ0EsT0FBT2hDO0FBQ1g7QUFFQTs7OztDQUlDLEdBQ0QsaUVBQWlFO0FBQ2pFLFNBQVN1OEIsbUNBQW1DeDhCLFVBQVUsRUFBRStZLFlBQVk7SUFDaEUsTUFBTTlZLFdBQVcsQ0FBQztJQUNsQixNQUFNd1csa0JBQWtCM1ksZUFBZWtDLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUkrWSxpQkFBaUJuZSxhQUFhNmIsbUJBQW1CLE1BQU07UUFDdkQ5WixlQUFlb2MsY0FBYztZQUFDO1NBQWMsRUFBRXRDO0lBQ2xEO0lBQ0EsT0FBT3hXO0FBQ1g7QUFDQSxTQUFTdzhCLHVDQUF1Q3o4QixVQUFVO0lBQ3RELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNaVosYUFBYXBiLGVBQWVrQyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJa1osY0FBYyxNQUFNO1FBQ3BCc2pCLG1DQUFtQ3RqQixZQUFZalo7SUFDbkQ7SUFDQSxPQUFPQTtBQUNYO0FBQ0EsU0FBU3k4QixtQ0FBbUMxOEIsVUFBVSxFQUFFK1ksWUFBWTtJQUNoRSxNQUFNOVksV0FBVyxDQUFDO0lBQ2xCLE1BQU0wOEIsWUFBWTcrQixlQUFla0MsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSStZLGlCQUFpQm5lLGFBQWEraEMsYUFBYSxNQUFNO1FBQ2pEaGdDLGVBQWVvYyxjQUFjO1lBQUM7WUFBVTtTQUFRLEVBQUU0akI7SUFDdEQ7SUFDQSxPQUFPMThCO0FBQ1g7QUFDQSxTQUFTMjhCLHVDQUF1QzU4QixVQUFVO0lBQ3RELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNSSxXQUFXdkMsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlLLFlBQVksTUFBTTtRQUNsQjFELGVBQWVzRCxVQUFVO1lBQUM7WUFBUTtTQUFPLEVBQUVJO0lBQy9DO0lBQ0EsTUFBTTZZLGFBQWFwYixlQUFla0MsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSWtaLGNBQWMsTUFBTTtRQUNwQndqQixtQ0FBbUN4akIsWUFBWWpaO0lBQ25EO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLFNBQVM0OEIsb0NBQW9DNzhCLFVBQVU7SUFDbkQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1JLFdBQVd2QyxlQUFla0MsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSUssWUFBWSxNQUFNO1FBQ2xCMUQsZUFBZXNELFVBQVU7WUFBQztZQUFRO1NBQU8sRUFBRUk7SUFDL0M7SUFDQSxPQUFPSjtBQUNYO0FBQ0EsU0FBUzY4Qix3QkFBd0I5OEIsVUFBVSxFQUFFK1ksWUFBWTtJQUNyRCxNQUFNOVksV0FBVyxDQUFDO0lBQ2xCLE1BQU04OEIscUJBQXFCai9CLGVBQWVrQyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJK1ksaUJBQWlCbmUsYUFBYW1pQyxzQkFBc0IsTUFBTTtRQUMxRCxJQUFJajhCLGtCQUFrQmk4QjtRQUN0QixJQUFJNS9CLE1BQU1DLE9BQU8sQ0FBQzBELGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0I5QyxHQUFHLENBQUMsQ0FBQ2tCO2dCQUNuQyxPQUFPQTtZQUNYO1FBQ0o7UUFDQXZDLGVBQWVvYyxjQUFjO1lBQUM7U0FBaUIsRUFBRWpZO0lBQ3JEO0lBQ0EsTUFBTWs4QixxQkFBcUJsL0IsZUFBZWtDLFlBQVk7UUFDbEQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhb2lDLHNCQUFzQixNQUFNO1FBQzFEcmdDLGVBQWVvYyxjQUFjO1lBQUM7U0FBaUIsRUFBRWlrQjtJQUNyRDtJQUNBLE9BQU8vOEI7QUFDWDtBQUNBLFNBQVNnOUIsNkJBQTZCajlCLFVBQVU7SUFDNUMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1JLFdBQVd2QyxlQUFla0MsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSUssWUFBWSxNQUFNO1FBQ2xCMUQsZUFBZXNELFVBQVU7WUFBQztTQUFPLEVBQUVJO0lBQ3ZDO0lBQ0EsTUFBTUMsZUFBZXhDLGVBQWVrQyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJTSxnQkFBZ0IsTUFBTTtRQUN0QjNELGVBQWVzRCxVQUFVO1lBQUM7U0FBVyxFQUFFSztJQUMzQztJQUNBLE1BQU1DLFdBQVd6QyxlQUFla0MsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSU8sWUFBWSxNQUFNO1FBQ2xCNUQsZUFBZXNELFVBQVU7WUFBQztTQUFPLEVBQUVNO0lBQ3ZDO0lBQ0EsTUFBTUMsWUFBWTFDLGVBQWVrQyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJUSxhQUFhLE1BQU07UUFDbkI3RCxlQUFlc0QsVUFBVTtZQUFDO1NBQVEsRUFBRU87SUFDeEM7SUFDQSxNQUFNQyxlQUFlM0MsZUFBZWtDLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlTLGdCQUFnQixNQUFNO1FBQ3RCOUQsZUFBZXNELFVBQVU7WUFBQztTQUFXLEVBQUVpOUIsNEJBQTRCejhCO0lBQ3ZFO0lBQ0EsT0FBT1I7QUFDWDtBQUNBLFNBQVNrOUIsNEJBQTRCbjlCLFVBQVU7SUFDM0MsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1tOUIsMEJBQTBCdC9CLGVBQWVrQyxZQUFZO1FBQ3ZEO0tBQ0g7SUFDRCxJQUFJbzlCLDJCQUEyQixNQUFNO1FBQ2pDemdDLGVBQWVzRCxVQUFVO1lBQUM7WUFBUTtTQUF5QixFQUFFbTlCO0lBQ2pFO0lBQ0EsTUFBTXJuQixlQUFlalksZUFBZWtDLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUkrVixnQkFBZ0IsTUFBTTtRQUN0QnBaLGVBQWVzRCxVQUFVO1lBQUM7U0FBVyxFQUFFOFY7SUFDM0M7SUFDQSxNQUFNbUQsYUFBYXBiLGVBQWVrQyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJa1osY0FBYyxNQUFNO1FBQ3BCNGpCLHdCQUF3QjVqQixZQUFZalo7SUFDeEM7SUFDQSxPQUFPQTtBQUNYO0FBQ0EsU0FBU2k5Qiw0QkFBNEJsOUIsVUFBVTtJQUMzQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXlCLHNCQUFzQjVELGVBQWVrQyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJMEIsdUJBQXVCLE1BQU07UUFDN0IvRSxlQUFlc0QsVUFBVTtZQUFDO1NBQWtCLEVBQUV5QjtJQUNsRDtJQUNBLE1BQU1DLGFBQWE3RCxlQUFla0MsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSTJCLGNBQWMsTUFBTTtRQUNwQmhGLGVBQWVzRCxVQUFVO1lBQUM7U0FBUyxFQUFFMEI7SUFDekM7SUFDQSxNQUFNQyxtQkFBbUI5RCxlQUFla0MsWUFBWTtRQUFDO0tBQWU7SUFDcEUsSUFBSTRCLG9CQUFvQixNQUFNO1FBQzFCakYsZUFBZXNELFVBQVU7WUFBQztTQUFlLEVBQUUyQjtJQUMvQztJQUNBLE9BQU8zQjtBQUNYO0FBQ0EsU0FBU285QixrQ0FBa0NyOUIsVUFBVSxFQUFFK1ksWUFBWTtJQUMvRCxNQUFNOVksV0FBVyxDQUFDO0lBQ2xCLE1BQU1vZCxlQUFldmYsZUFBZWtDLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUkrWSxpQkFBaUJuZSxhQUFheWlCLGdCQUFnQixNQUFNO1FBQ3BEMWdCLGVBQWVvYyxjQUFjO1lBQUM7WUFBVTtTQUFXLEVBQUVzRTtJQUN6RDtJQUNBLE1BQU1DLGdCQUFnQnhmLGVBQWVrQyxZQUFZO1FBQUM7S0FBWTtJQUM5RCxJQUFJK1ksaUJBQWlCbmUsYUFBYTBpQixpQkFBaUIsTUFBTTtRQUNyRDNnQixlQUFlb2MsY0FBYztZQUFDO1lBQVU7U0FBWSxFQUFFdUU7SUFDMUQ7SUFDQSxPQUFPcmQ7QUFDWDtBQUNBLFNBQVNxOUIsc0NBQXNDdDlCLFVBQVU7SUFDckQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1pWixhQUFhcGIsZUFBZWtDLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlrWixjQUFjLE1BQU07UUFDcEJta0Isa0NBQWtDbmtCLFlBQVlqWjtJQUNsRDtJQUNBLE9BQU9BO0FBQ1g7QUFDQSxTQUFTczlCLHNDQUFzQ3Y5QixVQUFVO0lBQ3JELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNeUIsc0JBQXNCNUQsZUFBZWtDLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUkwQix1QkFBdUIsTUFBTTtRQUM3Qi9FLGVBQWVzRCxVQUFVO1lBQUM7U0FBa0IsRUFBRXlCO0lBQ2xEO0lBQ0EsTUFBTWtjLG9CQUFvQjlmLGVBQWVrQyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJNGQscUJBQXFCLE1BQU07UUFDM0JqaEIsZUFBZXNELFVBQVU7WUFBQztTQUFnQixFQUFFMmQ7SUFDaEQ7SUFDQSxNQUFNNGYsdUJBQXVCMS9CLGVBQWVrQyxZQUFZO1FBQ3BEO0tBQ0g7SUFDRCxJQUFJdzlCLHdCQUF3QixNQUFNO1FBQzlCLElBQUkxOEIsa0JBQWtCMDhCO1FBQ3RCLElBQUlyZ0MsTUFBTUMsT0FBTyxDQUFDMEQsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQjlDLEdBQUcsQ0FBQyxDQUFDa0I7Z0JBQ25DLE9BQU9BO1lBQ1g7UUFDSjtRQUNBdkMsZUFBZXNELFVBQVU7WUFBQztTQUFtQixFQUFFYTtJQUNuRDtJQUNBLE9BQU9iO0FBQ1g7QUFDQSxTQUFTdzlCLHFDQUFxQ3o5QixVQUFVLEVBQUUrWSxZQUFZO0lBQ2xFLE1BQU05WSxXQUFXLENBQUM7SUFDbEIsTUFBTWdDLGVBQWVuRSxlQUFla0MsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSStZLGlCQUFpQm5lLGFBQWFxSCxnQkFBZ0IsTUFBTTtRQUNwRHRGLGVBQWVvYyxjQUFjO1lBQUM7U0FBVyxFQUFFOVc7SUFDL0M7SUFDQSxNQUFNd1Usa0JBQWtCM1ksZUFBZWtDLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUkrWSxpQkFBaUJuZSxhQUFhNmIsbUJBQW1CLE1BQU07UUFDdkQ5WixlQUFlb2MsY0FBYztZQUFDO1NBQWMsRUFBRXRDO0lBQ2xEO0lBQ0EsTUFBTXNtQixxQkFBcUJqL0IsZUFBZWtDLFlBQVk7UUFDbEQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhbWlDLHNCQUFzQixNQUFNO1FBQzFELElBQUlqOEIsa0JBQWtCaThCO1FBQ3RCLElBQUk1L0IsTUFBTUMsT0FBTyxDQUFDMEQsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQjlDLEdBQUcsQ0FBQyxDQUFDa0I7Z0JBQ25DLE9BQU9BO1lBQ1g7UUFDSjtRQUNBdkMsZUFBZW9jLGNBQWM7WUFBQztTQUFpQixFQUFFalk7SUFDckQ7SUFDQSxNQUFNazhCLHFCQUFxQmwvQixlQUFla0MsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWFvaUMsc0JBQXNCLE1BQU07UUFDMURyZ0MsZUFBZW9jLGNBQWM7WUFBQztTQUFpQixFQUFFaWtCO0lBQ3JEO0lBQ0EsT0FBTy84QjtBQUNYO0FBQ0EsU0FBU3k5Qix5Q0FBeUMxOUIsVUFBVTtJQUN4RCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTW05QiwwQkFBMEJ0L0IsZUFBZWtDLFlBQVk7UUFDdkQ7S0FDSDtJQUNELElBQUlvOUIsMkJBQTJCLE1BQU07UUFDakN6Z0MsZUFBZXNELFVBQVU7WUFBQztZQUFRO1NBQXlCLEVBQUVtOUI7SUFDakU7SUFDQSxNQUFNbGtCLGFBQWFwYixlQUFla0MsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSWtaLGNBQWMsTUFBTTtRQUNwQnVrQixxQ0FBcUN2a0IsWUFBWWpaO0lBQ3JEO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLFNBQVMwOUIsa0RBQWtEMzlCLFVBQVU7SUFDakUsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU15QixzQkFBc0I1RCxlQUFla0MsWUFBWTtRQUNuRDtLQUNIO0lBQ0QsSUFBSTBCLHVCQUF1QixNQUFNO1FBQzdCL0UsZUFBZXNELFVBQVU7WUFBQztTQUFrQixFQUFFeUI7SUFDbEQ7SUFDQSxPQUFPekI7QUFDWDtBQUVBOzs7O0NBSUMsR0FDRCxNQUFNMjlCLHNCQUFzQjtBQUM1QixNQUFNQyx3QkFBd0I7QUFDOUIsTUFBTUMsb0JBQW9CO0FBQzFCLE1BQU1DLDJCQUEyQjtBQUNqQyxNQUFNQyxjQUFjLFVBQVUsMkJBQTJCO0FBQ3pELE1BQU1DLGdCQUFnQixvQkFBZ0MsT0FBWkQ7QUFDMUMsTUFBTUUsZ0NBQWdDO0FBQ3RDLE1BQU1DLGdDQUFnQztBQUN0QyxNQUFNQyxpQkFBaUI7QUFDdkI7OztDQUdDLEdBQ0QsTUFBTUM7SUF1QkY7Ozs7O0tBS0MsR0FDREMsNkJBQTZCO1FBQ3pCLElBQUksSUFBSSxDQUFDQyxhQUFhLENBQUNDLE9BQU8sSUFDMUIsSUFBSSxDQUFDRCxhQUFhLENBQUNFLFFBQVEsSUFDM0IsSUFBSSxDQUFDRixhQUFhLENBQUNFLFFBQVEsS0FBSyxVQUFVO1lBQzFDLG9CQUFvQjtZQUNwQixPQUFPLFdBQXVDLE9BQTVCLElBQUksQ0FBQ0YsYUFBYSxDQUFDRSxRQUFRLEVBQUM7UUFDbEQ7UUFDQSwrREFBK0Q7UUFDL0QsT0FBUTtJQUNaO0lBQ0E7Ozs7OztLQU1DLEdBQ0RDLDBCQUEwQjtRQUN0QixJQUFJLElBQUksQ0FBQ0gsYUFBYSxDQUFDQyxPQUFPLElBQUksSUFBSSxDQUFDRCxhQUFhLENBQUNFLFFBQVEsRUFBRTtZQUMzRCwyREFBMkQ7WUFDM0QsSUFBSSxDQUFDRixhQUFhLENBQUNJLE1BQU0sR0FBRy9qQztZQUM1QjtRQUNKO1FBQ0EsMkVBQTJFO1FBQzNFLElBQUksQ0FBQzJqQyxhQUFhLENBQUNDLE9BQU8sR0FBRzVqQztRQUM3QixJQUFJLENBQUMyakMsYUFBYSxDQUFDRSxRQUFRLEdBQUc3akM7SUFDbEM7SUFDQXNULGFBQWE7UUFDVCxJQUFJMVM7UUFDSixPQUFPLENBQUNBLEtBQUssSUFBSSxDQUFDK2lDLGFBQWEsQ0FBQ2xqQyxRQUFRLE1BQU0sUUFBUUcsT0FBTyxLQUFLLElBQUlBLEtBQUs7SUFDL0U7SUFDQThTLGFBQWE7UUFDVCxPQUFPLElBQUksQ0FBQ2l3QixhQUFhLENBQUNDLE9BQU87SUFDckM7SUFDQWp3QixjQUFjO1FBQ1YsT0FBTyxJQUFJLENBQUNnd0IsYUFBYSxDQUFDRSxRQUFRO0lBQ3RDO0lBQ0FHLGdCQUFnQjtRQUNaLElBQUksSUFBSSxDQUFDTCxhQUFhLENBQUNuakMsV0FBVyxJQUM5QixJQUFJLENBQUNtakMsYUFBYSxDQUFDbmpDLFdBQVcsQ0FBQ3lqQyxVQUFVLEtBQUtqa0MsV0FBVztZQUN6RCxPQUFPLElBQUksQ0FBQzJqQyxhQUFhLENBQUNuakMsV0FBVyxDQUFDeWpDLFVBQVU7UUFDcEQ7UUFDQSxNQUFNLElBQUluaUMsTUFBTTtJQUNwQjtJQUNBdkIsYUFBYTtRQUNULElBQUksSUFBSSxDQUFDb2pDLGFBQWEsQ0FBQ25qQyxXQUFXLElBQzlCLElBQUksQ0FBQ21qQyxhQUFhLENBQUNuakMsV0FBVyxDQUFDTSxPQUFPLEtBQUtkLFdBQVc7WUFDdEQsT0FBTyxJQUFJLENBQUMyakMsYUFBYSxDQUFDbmpDLFdBQVcsQ0FBQ00sT0FBTztRQUNqRDtRQUNBLE1BQU0sSUFBSWdCLE1BQU07SUFDcEI7SUFDQW9pQyxnQkFBZ0I7UUFDWixPQUFPLElBQUksQ0FBQ0MscUJBQXFCLENBQUMsSUFBSSxDQUFDUixhQUFhLENBQUNuakMsV0FBVztJQUNwRTtJQUNBNGpDLGFBQWE7UUFDVCxJQUFJLElBQUksQ0FBQ1QsYUFBYSxDQUFDbmpDLFdBQVcsSUFDOUIsSUFBSSxDQUFDbWpDLGFBQWEsQ0FBQ25qQyxXQUFXLENBQUNtTixPQUFPLEtBQUszTixXQUFXO1lBQ3RELE9BQU8sSUFBSSxDQUFDMmpDLGFBQWEsQ0FBQ25qQyxXQUFXLENBQUNtTixPQUFPO1FBQ2pELE9BQ0s7WUFDRCxNQUFNLElBQUk3TCxNQUFNO1FBQ3BCO0lBQ0o7SUFDQXFpQyxzQkFBc0IzakMsV0FBVyxFQUFFO1FBQy9CLElBQUksQ0FBQ0EsZUFDREEsWUFBWU0sT0FBTyxLQUFLZCxhQUN4QlEsWUFBWXlqQyxVQUFVLEtBQUtqa0MsV0FBVztZQUN0QyxNQUFNLElBQUk4QixNQUFNO1FBQ3BCO1FBQ0EsTUFBTWhCLFVBQVVOLFlBQVlNLE9BQU8sQ0FBQ3NCLFFBQVEsQ0FBQyxPQUN2QzVCLFlBQVlNLE9BQU8sQ0FBQ3dCLEtBQUssQ0FBQyxHQUFHLENBQUMsS0FDOUI5QixZQUFZTSxPQUFPO1FBQ3pCLE1BQU11akMsYUFBYTtZQUFDdmpDO1NBQVE7UUFDNUIsSUFBSU4sWUFBWXlqQyxVQUFVLElBQUl6akMsWUFBWXlqQyxVQUFVLEtBQUssSUFBSTtZQUN6REksV0FBV3IvQixJQUFJLENBQUN4RSxZQUFZeWpDLFVBQVU7UUFDMUM7UUFDQSxPQUFPSSxXQUFXQyxJQUFJLENBQUM7SUFDM0I7SUFDQUMsc0JBQXNCO1FBQ2xCLE9BQU8sWUFBb0QsT0FBeEMsSUFBSSxDQUFDWixhQUFhLENBQUNDLE9BQU8sRUFBQyxlQUF5QyxPQUE1QixJQUFJLENBQUNELGFBQWEsQ0FBQ0UsUUFBUTtJQUMxRjtJQUNBVyxZQUFZO1FBQ1IsT0FBTyxJQUFJLENBQUNiLGFBQWEsQ0FBQ0ksTUFBTTtJQUNwQztJQUNBVSxzQkFBc0I7UUFDbEIsTUFBTTNqQyxVQUFVLElBQUksQ0FBQ1AsVUFBVTtRQUMvQixNQUFNbWtDLFdBQVcsSUFBSUMsSUFBSTdqQztRQUN6QjRqQyxTQUFTRSxRQUFRLEdBQUdGLFNBQVNFLFFBQVEsSUFBSSxVQUFVLE9BQU87UUFDMUQsT0FBT0YsU0FBU2xkLFFBQVE7SUFDNUI7SUFDQXFkLFdBQVdDLEdBQUcsRUFBRTtRQUNaLElBQUksSUFBSSxDQUFDbkIsYUFBYSxDQUFDbmpDLFdBQVcsRUFBRTtZQUNoQyxJQUFJLENBQUNtakMsYUFBYSxDQUFDbmpDLFdBQVcsQ0FBQ00sT0FBTyxHQUFHZ2tDO1FBQzdDLE9BQ0s7WUFDRCxNQUFNLElBQUloakMsTUFBTTtRQUNwQjtJQUNKO0lBQ0FpakMsYUFBYXZlLElBQUksRUFBRWhtQixXQUFXLEVBQUV3a0Msc0JBQXNCLEVBQUU7UUFDcEQsTUFBTVgsYUFBYTtZQUFDLElBQUksQ0FBQ0YscUJBQXFCLENBQUMzakM7U0FBYTtRQUM1RCxJQUFJd2tDLHdCQUF3QjtZQUN4QlgsV0FBV3IvQixJQUFJLENBQUMsSUFBSSxDQUFDdS9CLG1CQUFtQjtRQUM1QztRQUNBLElBQUkvZCxTQUFTLElBQUk7WUFDYjZkLFdBQVdyL0IsSUFBSSxDQUFDd2hCO1FBQ3BCO1FBQ0EsTUFBTXNlLE1BQU0sSUFBSUgsSUFBSSxHQUF3QixPQUFyQk4sV0FBV0MsSUFBSSxDQUFDO1FBQ3ZDLE9BQU9RO0lBQ1g7SUFDQUcsK0JBQStCOWUsT0FBTyxFQUFFO1FBQ3BDLElBQUksSUFBSSxDQUFDd2QsYUFBYSxDQUFDSSxNQUFNLEVBQUU7WUFDM0IsT0FBTztRQUNYO1FBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQ0osYUFBYSxDQUFDbGpDLFFBQVEsRUFBRTtZQUM5QixPQUFPO1FBQ1g7UUFDQSxJQUFJMGxCLFFBQVFLLElBQUksQ0FBQzloQixVQUFVLENBQUMsY0FBYztZQUN0QyxzQ0FBc0M7WUFDdEMsNENBQTRDO1lBQzVDLE9BQU87UUFDWDtRQUNBLElBQUl5aEIsUUFBUTJCLFVBQVUsS0FBSyxTQUN2QjNCLFFBQVFLLElBQUksQ0FBQzloQixVQUFVLENBQUMsNkJBQTZCO1lBQ3JELDhEQUE4RDtZQUM5RCxtRUFBbUU7WUFDbkUsbURBQW1EO1lBQ25ELE9BQU87UUFDWDtRQUNBLE9BQU87SUFDWDtJQUNBLE1BQU15aEIsUUFBUUEsT0FBTyxFQUFFO1FBQ25CLElBQUkrZSxxQkFBcUIsSUFBSSxDQUFDdkIsYUFBYSxDQUFDbmpDLFdBQVc7UUFDdkQsSUFBSTJsQixRQUFRM2xCLFdBQVcsRUFBRTtZQUNyQjBrQyxxQkFBcUIsSUFBSSxDQUFDQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUN4QixhQUFhLENBQUNuakMsV0FBVyxFQUFFMmxCLFFBQVEzbEIsV0FBVztRQUNsRztRQUNBLE1BQU13a0MseUJBQXlCLElBQUksQ0FBQ0MsOEJBQThCLENBQUM5ZTtRQUNuRSxNQUFNMmUsTUFBTSxJQUFJLENBQUNDLFlBQVksQ0FBQzVlLFFBQVFLLElBQUksRUFBRTBlLG9CQUFvQkY7UUFDaEUsSUFBSTdlLFFBQVF3QixXQUFXLEVBQUU7WUFDckIsS0FBSyxNQUFNLENBQUNwbUIsS0FBS0ssTUFBTSxJQUFJSixPQUFPbUMsT0FBTyxDQUFDd2lCLFFBQVF3QixXQUFXLEVBQUc7Z0JBQzVEbWQsSUFBSU0sWUFBWSxDQUFDQyxNQUFNLENBQUM5akMsS0FBS00sT0FBT0Q7WUFDeEM7UUFDSjtRQUNBLElBQUkwakMsY0FBYyxDQUFDO1FBQ25CLElBQUluZixRQUFRMkIsVUFBVSxLQUFLLE9BQU87WUFDOUIsSUFBSTNCLFFBQVFHLElBQUksSUFBSUgsUUFBUUcsSUFBSSxLQUFLLE1BQU07Z0JBQ3ZDLE1BQU0sSUFBSXhrQixNQUFNO1lBQ3BCO1FBQ0osT0FDSztZQUNEd2pDLFlBQVloZixJQUFJLEdBQUdILFFBQVFHLElBQUk7UUFDbkM7UUFDQWdmLGNBQWMsTUFBTSxJQUFJLENBQUNDLG9DQUFvQyxDQUFDRCxhQUFhSixvQkFBb0JKLElBQUl0ZCxRQUFRLElBQUlyQixRQUFRNEIsV0FBVztRQUNsSSxPQUFPLElBQUksQ0FBQ3lkLFlBQVksQ0FBQ1YsS0FBS1EsYUFBYW5mLFFBQVEyQixVQUFVO0lBQ2pFO0lBQ0FxZCxpQkFBaUJNLGVBQWUsRUFBRUMsa0JBQWtCLEVBQUU7UUFDbEQsTUFBTVIscUJBQXFCdGQsS0FBSytkLEtBQUssQ0FBQy9kLEtBQUtDLFNBQVMsQ0FBQzRkO1FBQ3JELEtBQUssTUFBTSxDQUFDbGtDLEtBQUtLLE1BQU0sSUFBSUosT0FBT21DLE9BQU8sQ0FBQytoQyxvQkFBcUI7WUFDM0QsOEJBQThCO1lBQzlCLElBQUksT0FBTzlqQyxVQUFVLFVBQVU7Z0JBQzNCLHNFQUFzRTtnQkFDdEUsa0VBQWtFO2dCQUNsRSxpQkFBaUI7Z0JBQ2pCc2pDLGtCQUFrQixDQUFDM2pDLElBQUksR0FBR0MsT0FBT3dCLE1BQU0sQ0FBQ3hCLE9BQU93QixNQUFNLENBQUMsQ0FBQyxHQUFHa2lDLGtCQUFrQixDQUFDM2pDLElBQUksR0FBR0s7WUFDeEYsT0FDSyxJQUFJQSxVQUFVNUIsV0FBVztnQkFDMUIsc0VBQXNFO2dCQUN0RSxrRUFBa0U7Z0JBQ2xFLGlCQUFpQjtnQkFDakJrbEMsa0JBQWtCLENBQUMzakMsSUFBSSxHQUFHSztZQUM5QjtRQUNKO1FBQ0EsT0FBT3NqQztJQUNYO0lBQ0EsTUFBTVUsY0FBY3pmLE9BQU8sRUFBRTtRQUN6QixJQUFJK2UscUJBQXFCLElBQUksQ0FBQ3ZCLGFBQWEsQ0FBQ25qQyxXQUFXO1FBQ3ZELElBQUkybEIsUUFBUTNsQixXQUFXLEVBQUU7WUFDckIwa0MscUJBQXFCLElBQUksQ0FBQ0MsZ0JBQWdCLENBQUMsSUFBSSxDQUFDeEIsYUFBYSxDQUFDbmpDLFdBQVcsRUFBRTJsQixRQUFRM2xCLFdBQVc7UUFDbEc7UUFDQSxNQUFNd2tDLHlCQUF5QixJQUFJLENBQUNDLDhCQUE4QixDQUFDOWU7UUFDbkUsTUFBTTJlLE1BQU0sSUFBSSxDQUFDQyxZQUFZLENBQUM1ZSxRQUFRSyxJQUFJLEVBQUUwZSxvQkFBb0JGO1FBQ2hFLElBQUksQ0FBQ0YsSUFBSU0sWUFBWSxDQUFDemdDLEdBQUcsQ0FBQyxVQUFVbWdDLElBQUlNLFlBQVksQ0FBQ2hkLEdBQUcsQ0FBQyxXQUFXLE9BQU87WUFDdkUwYyxJQUFJTSxZQUFZLENBQUNTLEdBQUcsQ0FBQyxPQUFPO1FBQ2hDO1FBQ0EsSUFBSVAsY0FBYyxDQUFDO1FBQ25CQSxZQUFZaGYsSUFBSSxHQUFHSCxRQUFRRyxJQUFJO1FBQy9CZ2YsY0FBYyxNQUFNLElBQUksQ0FBQ0Msb0NBQW9DLENBQUNELGFBQWFKLG9CQUFvQkosSUFBSXRkLFFBQVEsSUFBSXJCLFFBQVE0QixXQUFXO1FBQ2xJLE9BQU8sSUFBSSxDQUFDK2QsYUFBYSxDQUFDaEIsS0FBS1EsYUFBYW5mLFFBQVEyQixVQUFVO0lBQ2xFO0lBQ0EsTUFBTXlkLHFDQUFxQ0QsV0FBVyxFQUFFOWtDLFdBQVcsRUFBRXNrQyxHQUFHLEVBQUUvYyxXQUFXLEVBQUU7UUFDbkYsSUFBSSxlQUFnQnZuQixZQUFZdWxDLE9BQU8sSUFBS2hlLGFBQWE7WUFDckQsTUFBTWllLGtCQUFrQixJQUFJQztZQUM1QixNQUFNQyxTQUFTRixnQkFBZ0JFLE1BQU07WUFDckMsSUFBSTFsQyxZQUFZdWxDLE9BQU8sSUFBSSxDQUFDdmxDLGdCQUFnQixRQUFRQSxnQkFBZ0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsWUFBWXVsQyxPQUFPLElBQUksR0FBRztnQkFDNUcsTUFBTUksZ0JBQWdCQyxXQUFXLElBQU1KLGdCQUFnQkssS0FBSyxJQUFJN2xDLFlBQVl1bEMsT0FBTztnQkFDbkYsSUFBSUksaUJBQ0EsT0FBT0EsY0FBY0csS0FBSyxLQUN0QixZQUFZO29CQUNoQix5REFBeUQ7b0JBQ3pELGtEQUFrRDtvQkFDbERILGNBQWNHLEtBQUs7Z0JBQ3ZCO1lBQ0o7WUFDQSxJQUFJdmUsYUFBYTtnQkFDYkEsWUFBWXdlLGdCQUFnQixDQUFDLFNBQVM7b0JBQ2xDUCxnQkFBZ0JLLEtBQUs7Z0JBQ3pCO1lBQ0o7WUFDQWYsWUFBWVksTUFBTSxHQUFHQTtRQUN6QjtRQUNBLElBQUkxbEMsZUFBZUEsWUFBWWdtQyxTQUFTLEtBQUssTUFBTTtZQUMvQ0MsOEJBQThCbkIsYUFBYTlrQyxZQUFZZ21DLFNBQVM7UUFDcEU7UUFDQWxCLFlBQVkzM0IsT0FBTyxHQUFHLE1BQU0sSUFBSSxDQUFDKzRCLGtCQUFrQixDQUFDbG1DLGFBQWFza0M7UUFDakUsT0FBT1E7SUFDWDtJQUNBLE1BQU1FLGFBQWFWLEdBQUcsRUFBRVEsV0FBVyxFQUFFeGQsVUFBVSxFQUFFO1FBQzdDLE9BQU8sSUFBSSxDQUFDNmUsT0FBTyxDQUFDN0IsSUFBSXRkLFFBQVEsSUFBSWhtQixPQUFPd0IsTUFBTSxDQUFDeEIsT0FBT3dCLE1BQU0sQ0FBQyxDQUFDLEdBQUdzaUMsY0FBYztZQUFFc0IsUUFBUTllO1FBQVcsSUFDbEdFLElBQUksQ0FBQyxPQUFPN2I7WUFDYixNQUFNMDZCLGtCQUFrQjE2QjtZQUN4QixPQUFPLElBQUlvQixhQUFhcEI7UUFDNUIsR0FDS21qQixLQUFLLENBQUMsQ0FBQ2xDO1lBQ1IsSUFBSUEsYUFBYXRyQixPQUFPO2dCQUNwQixNQUFNc3JCO1lBQ1YsT0FDSztnQkFDRCxNQUFNLElBQUl0ckIsTUFBTThsQixLQUFLQyxTQUFTLENBQUN1RjtZQUNuQztRQUNKO0lBQ0o7SUFDQSxNQUFNMFksY0FBY2hCLEdBQUcsRUFBRVEsV0FBVyxFQUFFeGQsVUFBVSxFQUFFO1FBQzlDLE9BQU8sSUFBSSxDQUFDNmUsT0FBTyxDQUFDN0IsSUFBSXRkLFFBQVEsSUFBSWhtQixPQUFPd0IsTUFBTSxDQUFDeEIsT0FBT3dCLE1BQU0sQ0FBQyxDQUFDLEdBQUdzaUMsY0FBYztZQUFFc0IsUUFBUTllO1FBQVcsSUFDbEdFLElBQUksQ0FBQyxPQUFPN2I7WUFDYixNQUFNMDZCLGtCQUFrQjE2QjtZQUN4QixPQUFPLElBQUksQ0FBQ3VqQixxQkFBcUIsQ0FBQ3ZqQjtRQUN0QyxHQUNLbWpCLEtBQUssQ0FBQyxDQUFDbEM7WUFDUixJQUFJQSxhQUFhdHJCLE9BQU87Z0JBQ3BCLE1BQU1zckI7WUFDVixPQUNLO2dCQUNELE1BQU0sSUFBSXRyQixNQUFNOGxCLEtBQUtDLFNBQVMsQ0FBQ3VGO1lBQ25DO1FBQ0o7SUFDSjtJQUNBc0Msc0JBQXNCdmpCLFFBQVEsRUFBRTtRQUM1QixJQUFJdkw7UUFDSixPQUFPcXJCLGlCQUFpQixJQUFJLEVBQUUyRCxXQUFXLFVBQVVDO1lBQy9DLE1BQU1pWCxTQUFTLENBQUNsbUMsS0FBS3VMLGFBQWEsUUFBUUEsYUFBYSxLQUFLLElBQUksS0FBSyxJQUFJQSxTQUFTbWEsSUFBSSxNQUFNLFFBQVExbEIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHbW1DLFNBQVM7WUFDekksTUFBTUMsVUFBVSxJQUFJQyxZQUFZO1lBQ2hDLElBQUksQ0FBQ0gsUUFBUTtnQkFDVCxNQUFNLElBQUlobEMsTUFBTTtZQUNwQjtZQUNBLElBQUk7Z0JBQ0EsSUFBSW9sQyxTQUFTO2dCQUNiLE1BQU8sS0FBTTtvQkFDVCxNQUFNLEVBQUVsaEIsSUFBSSxFQUFFcGtCLEtBQUssRUFBRSxHQUFHLE1BQU1vcUIsUUFBUThhLE9BQU9LLElBQUk7b0JBQ2pELElBQUluaEIsTUFBTTt3QkFDTixJQUFJa2hCLE9BQU9FLElBQUksR0FBR2psQyxNQUFNLEdBQUcsR0FBRzs0QkFDMUIsTUFBTSxJQUFJTCxNQUFNO3dCQUNwQjt3QkFDQTtvQkFDSjtvQkFDQSxNQUFNdWxDLGNBQWNMLFFBQVFNLE1BQU0sQ0FBQzFsQyxPQUFPO3dCQUFFMmxDLFFBQVE7b0JBQUs7b0JBQ3pELDJEQUEyRDtvQkFDM0QsSUFBSTt3QkFDQSxNQUFNQyxZQUFZNWYsS0FBSytkLEtBQUssQ0FBQzBCO3dCQUM3QixJQUFJLFdBQVdHLFdBQVc7NEJBQ3RCLE1BQU1DLFlBQVk3ZixLQUFLK2QsS0FBSyxDQUFDL2QsS0FBS0MsU0FBUyxDQUFDMmYsU0FBUyxDQUFDLFFBQVE7NEJBQzlELE1BQU05dkIsU0FBUyt2QixTQUFTLENBQUMsU0FBUzs0QkFDbEMsTUFBTTc2QixPQUFPNjZCLFNBQVMsQ0FBQyxPQUFPOzRCQUM5QixNQUFNQyxlQUFlLGVBQTBCOWYsT0FBWGxRLFFBQU8sTUFBOEIsT0FBMUJrUSxLQUFLQyxTQUFTLENBQUMyZjs0QkFDOUQsSUFBSTU2QixRQUFRLE9BQU9BLE9BQU8sS0FBSztnQ0FDM0IsTUFBTSs2QixXQUFXLElBQUlyWCxTQUFTO29DQUMxQjFDLFNBQVM4WjtvQ0FDVGh3QixRQUFROUs7Z0NBQ1o7Z0NBQ0EsTUFBTSs2Qjs0QkFDVjt3QkFDSjtvQkFDSixFQUNBLE9BQU92YSxHQUFHO3dCQUNOLE1BQU0vcEIsUUFBUStwQjt3QkFDZCxJQUFJL3BCLE1BQU15SSxJQUFJLEtBQUssWUFBWTs0QkFDM0IsTUFBTXNoQjt3QkFDVjtvQkFDSjtvQkFDQThaLFVBQVVHO29CQUNWLElBQUkvbEMsUUFBUTRsQyxPQUFPNWxDLEtBQUssQ0FBQ2tpQztvQkFDekIsTUFBT2xpQyxNQUFPO3dCQUNWLE1BQU1zbUMsdUJBQXVCdG1DLEtBQUssQ0FBQyxFQUFFO3dCQUNyQyxJQUFJOzRCQUNBLE1BQU11bUMsa0JBQWtCLElBQUlDLFNBQVNGLHNCQUFzQjtnQ0FDdkRqNkIsU0FBU3hCLGFBQWEsUUFBUUEsYUFBYSxLQUFLLElBQUksS0FBSyxJQUFJQSxTQUFTd0IsT0FBTztnQ0FDN0UrSixRQUFRdkwsYUFBYSxRQUFRQSxhQUFhLEtBQUssSUFBSSxLQUFLLElBQUlBLFNBQVN1TCxNQUFNO2dDQUMzRXF3QixZQUFZNTdCLGFBQWEsUUFBUUEsYUFBYSxLQUFLLElBQUksS0FBSyxJQUFJQSxTQUFTNDdCLFVBQVU7NEJBQ3ZGOzRCQUNBLE1BQU0sTUFBTS9iLFFBQVEsSUFBSXplLGFBQWFzNkI7NEJBQ3JDWCxTQUFTQSxPQUFPNWtDLEtBQUssQ0FBQ2hCLEtBQUssQ0FBQyxFQUFFLENBQUNhLE1BQU07NEJBQ3JDYixRQUFRNGxDLE9BQU81bEMsS0FBSyxDQUFDa2lDO3dCQUN6QixFQUNBLE9BQU9wVyxHQUFHOzRCQUNOLE1BQU0sSUFBSXRyQixNQUFNLGtDQUEyRHNyQixPQUF6QndhLHNCQUFxQixNQUFNLE9BQUZ4YTt3QkFDL0U7b0JBQ0o7Z0JBQ0o7WUFDSixTQUNRO2dCQUNKMFosT0FBT2tCLFdBQVc7WUFDdEI7UUFDSjtJQUNKO0lBQ0EsTUFBTXJCLFFBQVE3QixHQUFHLEVBQUVRLFdBQVcsRUFBRTtRQUM1QixPQUFPMkMsTUFBTW5ELEtBQUtRLGFBQWFoVyxLQUFLLENBQUMsQ0FBQ2xDO1lBQ2xDLE1BQU0sSUFBSXRyQixNQUFNLGFBQWUsT0FBRnNyQixHQUFFO1FBQ25DO0lBQ0o7SUFDQThhLG9CQUFvQjtRQUNoQixNQUFNdjZCLFVBQVUsQ0FBQztRQUNqQixNQUFNdzZCLHFCQUFxQjlFLGdCQUFnQixNQUFNLElBQUksQ0FBQ00sYUFBYSxDQUFDeUUsY0FBYztRQUNsRno2QixPQUFPLENBQUN1MUIsa0JBQWtCLEdBQUdpRjtRQUM3Qng2QixPQUFPLENBQUN3MUIseUJBQXlCLEdBQUdnRjtRQUNwQ3g2QixPQUFPLENBQUNxMUIsb0JBQW9CLEdBQUc7UUFDL0IsT0FBT3IxQjtJQUNYO0lBQ0EsTUFBTSs0QixtQkFBbUJsbUMsV0FBVyxFQUFFc2tDLEdBQUcsRUFBRTtRQUN2QyxNQUFNbjNCLFVBQVUsSUFBSTA2QjtRQUNwQixJQUFJN25DLGVBQWVBLFlBQVltTixPQUFPLEVBQUU7WUFDcEMsS0FBSyxNQUFNLENBQUNwTSxLQUFLSyxNQUFNLElBQUlKLE9BQU9tQyxPQUFPLENBQUNuRCxZQUFZbU4sT0FBTyxFQUFHO2dCQUM1REEsUUFBUTAzQixNQUFNLENBQUM5akMsS0FBS0s7WUFDeEI7WUFDQSx3RUFBd0U7WUFDeEUsZ0RBQWdEO1lBQ2hELElBQUlwQixZQUFZdWxDLE9BQU8sSUFBSXZsQyxZQUFZdWxDLE9BQU8sR0FBRyxHQUFHO2dCQUNoRHA0QixRQUFRMDNCLE1BQU0sQ0FBQ3BDLHVCQUF1QnBoQyxPQUFPeW1DLEtBQUtDLElBQUksQ0FBQy9uQyxZQUFZdWxDLE9BQU8sR0FBRztZQUNqRjtRQUNKO1FBQ0EsTUFBTSxJQUFJLENBQUNwQyxhQUFhLENBQUM2RSxJQUFJLENBQUNDLGNBQWMsQ0FBQzk2QixTQUFTbTNCO1FBQ3RELE9BQU9uM0I7SUFDWDtJQUNBKzZCLFlBQVlwWCxJQUFJLEVBQUU7UUFDZCxJQUFJMXdCO1FBQ0osSUFBSTRZLFdBQVc7UUFDZixJQUFJLE9BQU84WCxTQUFTLFVBQVU7WUFDMUI5WCxXQUFXOFgsS0FBS2p3QixPQUFPLENBQUMsV0FBVztZQUNuQ21ZLFdBQVcsQ0FBQzVZLEtBQUs0WSxTQUFTM1YsS0FBSyxDQUFDLFNBQVNnWCxHQUFHLEVBQUMsTUFBTyxRQUFRamEsT0FBTyxLQUFLLElBQUlBLEtBQUs7UUFDckY7UUFDQSxPQUFPNFk7SUFDWDtJQUNBOzs7Ozs7Ozs7O0tBVUMsR0FDRCxNQUFNNlgsV0FBV0MsSUFBSSxFQUFFeGYsTUFBTSxFQUFFO1FBQzNCLElBQUlsUjtRQUNKLE1BQU0rbkMsZUFBZSxDQUFDO1FBQ3RCLElBQUk3MkIsVUFBVSxNQUFNO1lBQ2hCNjJCLGFBQWExOUIsUUFBUSxHQUFHNkcsT0FBTzdHLFFBQVE7WUFDdkMwOUIsYUFBYTc4QixJQUFJLEdBQUdnRyxPQUFPaEcsSUFBSTtZQUMvQjY4QixhQUFhbGhCLFdBQVcsR0FBRzNWLE9BQU8yVixXQUFXO1FBQ2pEO1FBQ0EsSUFBSWtoQixhQUFhNzhCLElBQUksSUFBSSxDQUFDNjhCLGFBQWE3OEIsSUFBSSxDQUFDcEgsVUFBVSxDQUFDLFdBQVc7WUFDOURpa0MsYUFBYTc4QixJQUFJLEdBQUcsU0FBMkIsT0FBbEI2OEIsYUFBYTc4QixJQUFJO1FBQ2xEO1FBQ0EsTUFBTTg4QixXQUFXLElBQUksQ0FBQ2pGLGFBQWEsQ0FBQ2lGLFFBQVE7UUFDNUMsTUFBTUMsV0FBVyxNQUFNRCxTQUFTRSxJQUFJLENBQUN4WDtRQUNyQ3FYLGFBQWFJLFNBQVMsR0FBR2xuQyxPQUFPZ25DLFNBQVNHLElBQUk7UUFDN0MsTUFBTS85QixXQUFXLENBQUNySyxLQUFLa1IsV0FBVyxRQUFRQSxXQUFXLEtBQUssSUFBSSxLQUFLLElBQUlBLE9BQU83RyxRQUFRLE1BQU0sUUFBUXJLLE9BQU8sS0FBSyxJQUFJQSxLQUFLaW9DLFNBQVN4ekIsSUFBSTtRQUN0SSxJQUFJcEssYUFBYWpMLGFBQWFpTCxhQUFhLElBQUk7WUFDM0MsTUFBTSxJQUFJbkosTUFBTTtRQUNwQjtRQUNBNm1DLGFBQWExOUIsUUFBUSxHQUFHQTtRQUN4QixNQUFNcWIsT0FBTztZQUNUZ0wsTUFBTXFYO1FBQ1Y7UUFDQSxNQUFNbnZCLFdBQVcsSUFBSSxDQUFDa3ZCLFdBQVcsQ0FBQ3BYO1FBQ2xDLE1BQU05SyxPQUFPdmxCLFVBQVUsdUJBQXVCcWxCLElBQUksQ0FBQyxPQUFPO1FBQzFELE1BQU0yaUIsWUFBWSxNQUFNLElBQUksQ0FBQ0MsY0FBYyxDQUFDMWlCLE1BQU1taUIsYUFBYUksU0FBUyxFQUFFSixhQUFhMTlCLFFBQVEsRUFBRXVPLFVBQVU4TSxNQUFNeFUsV0FBVyxRQUFRQSxXQUFXLEtBQUssSUFBSSxLQUFLLElBQUlBLE9BQU90UixXQUFXO1FBQ25MLE9BQU9vb0MsU0FBU3hYLE1BQU0sQ0FBQ0UsTUFBTTJYLFdBQVcsSUFBSTtJQUNoRDtJQUNBOzs7Ozs7Ozs7OztLQVdDLEdBQ0QsTUFBTUUsNEJBQTRCQyxtQkFBbUIsRUFBRTlYLElBQUksRUFBRXhmLE1BQU0sRUFBRTtRQUNqRSxJQUFJbFI7UUFDSixNQUFNZ29DLFdBQVcsSUFBSSxDQUFDakYsYUFBYSxDQUFDaUYsUUFBUTtRQUM1QyxNQUFNQyxXQUFXLE1BQU1ELFNBQVNFLElBQUksQ0FBQ3hYO1FBQ3JDLE1BQU15WCxZQUFZbG5DLE9BQU9nbkMsU0FBU0csSUFBSTtRQUN0QyxNQUFNLzlCLFdBQVcsQ0FBQ3JLLEtBQUtrUixXQUFXLFFBQVFBLFdBQVcsS0FBSyxJQUFJLEtBQUssSUFBSUEsT0FBTzdHLFFBQVEsTUFBTSxRQUFRckssT0FBTyxLQUFLLElBQUlBLEtBQUtpb0MsU0FBU3h6QixJQUFJO1FBQ3RJLElBQUlwSyxhQUFhakwsYUFBYWlMLGFBQWEsSUFBSTtZQUMzQyxNQUFNLElBQUluSixNQUFNO1FBQ3BCO1FBQ0EsTUFBTTBrQixPQUFPLGlCQUFxQyxPQUFwQjRpQixxQkFBb0I7UUFDbEQsTUFBTTV2QixXQUFXLElBQUksQ0FBQ2t2QixXQUFXLENBQUNwWDtRQUNsQyxNQUFNaEwsT0FBTyxDQUFDO1FBQ2QsSUFBSXhVLFVBQVUsTUFBTTtZQUNoQit3QixxQ0FBcUMvd0IsUUFBUXdVO1FBQ2pEO1FBQ0EsTUFBTTJpQixZQUFZLE1BQU0sSUFBSSxDQUFDQyxjQUFjLENBQUMxaUIsTUFBTXVpQixXQUFXOTlCLFVBQVV1TyxVQUFVOE0sTUFBTXhVLFdBQVcsUUFBUUEsV0FBVyxLQUFLLElBQUksS0FBSyxJQUFJQSxPQUFPdFIsV0FBVztRQUN6SixPQUFPb29DLFNBQVNTLHVCQUF1QixDQUFDL1gsTUFBTTJYLFdBQVcsSUFBSTtJQUNqRTtJQUNBOzs7OztLQUtDLEdBQ0QsTUFBTXpYLGFBQWE1TSxNQUFNLEVBQUU7UUFDdkIsTUFBTTBrQixhQUFhLElBQUksQ0FBQzNGLGFBQWEsQ0FBQzJGLFVBQVU7UUFDaEQsTUFBTUEsV0FBVy9YLFFBQVEsQ0FBQzNNLFFBQVEsSUFBSTtJQUMxQztJQUNBLE1BQU1za0IsZUFBZTFpQixJQUFJLEVBQUV1aUIsU0FBUyxFQUFFOTlCLFFBQVEsRUFBRXVPLFFBQVEsRUFBRThNLElBQUksRUFBRWlqQixpQkFBaUIsRUFBRTtRQUMvRSxJQUFJM29DO1FBQ0osSUFBSUosY0FBYyxDQUFDO1FBQ25CLElBQUkrb0MsbUJBQW1CO1lBQ25CL29DLGNBQWMrb0M7UUFDbEIsT0FDSztZQUNEL29DLGNBQWM7Z0JBQ1Z5akMsWUFBWTtnQkFDWnQyQixTQUFTbk0sT0FBT3dCLE1BQU0sQ0FBQztvQkFBRSxnQkFBZ0I7b0JBQW9CLDBCQUEwQjtvQkFBYSx5QkFBeUI7b0JBQVMsdUNBQXVDLEdBQWEsT0FBVitsQztvQkFBYSxxQ0FBcUMsR0FBWSxPQUFUOTlCO2dCQUFXLEdBQUl1TyxXQUFXO29CQUFFLDJCQUEyQkE7Z0JBQVMsSUFBSSxDQUFDO1lBQzlTO1FBQ0o7UUFDQSxNQUFNeU8sZUFBZSxNQUFNLElBQUksQ0FBQzlCLE9BQU8sQ0FBQztZQUNwQ0s7WUFDQUYsTUFBTXNCLEtBQUtDLFNBQVMsQ0FBQ3ZCO1lBQ3JCd0IsWUFBWTtZQUNadG5CO1FBQ0o7UUFDQSxJQUFJLENBQUN5bkIsZ0JBQWdCLENBQUVBLENBQUFBLGlCQUFpQixRQUFRQSxpQkFBaUIsS0FBSyxJQUFJLEtBQUssSUFBSUEsYUFBYXRhLE9BQU8sR0FBRztZQUN0RyxNQUFNLElBQUk3TCxNQUFNO1FBQ3BCO1FBQ0EsTUFBTW1uQyxZQUFZLENBQUNyb0MsS0FBS3FuQixpQkFBaUIsUUFBUUEsaUJBQWlCLEtBQUssSUFBSSxLQUFLLElBQUlBLGFBQWF0YSxPQUFPLE1BQU0sUUFBUS9NLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsRUFBRSxDQUFDLG9CQUFvQjtRQUN0SyxJQUFJcW9DLGNBQWNqcEMsV0FBVztZQUN6QixNQUFNLElBQUk4QixNQUFNO1FBQ3BCO1FBQ0EsT0FBT21uQztJQUNYO0lBamVBdjdCLFlBQVk4N0IsSUFBSSxDQUFFO1FBQ2QsSUFBSTVvQyxJQUFJQztRQUNSLElBQUksQ0FBQzhpQyxhQUFhLEdBQUduaUMsT0FBT3dCLE1BQU0sQ0FBQ3hCLE9BQU93QixNQUFNLENBQUMsQ0FBQyxHQUFHd21DLE9BQU87WUFBRTVGLFNBQVM0RixLQUFLNUYsT0FBTztZQUFFQyxVQUFVMkYsS0FBSzNGLFFBQVE7WUFBRUUsUUFBUXlGLEtBQUt6RixNQUFNO1lBQUV0akMsVUFBVStvQyxLQUFLL29DLFFBQVE7UUFBQztRQUMzSixNQUFNZ3BDLGtCQUFrQixDQUFDO1FBQ3pCLElBQUksSUFBSSxDQUFDOUYsYUFBYSxDQUFDbGpDLFFBQVEsRUFBRTtZQUM3QmdwQyxnQkFBZ0J4RixVQUFVLEdBQ3RCLENBQUNyakMsS0FBSyxJQUFJLENBQUMraUMsYUFBYSxDQUFDTSxVQUFVLE1BQU0sUUFBUXJqQyxPQUFPLEtBQUssSUFBSUEsS0FBSzBpQztZQUMxRW1HLGdCQUFnQjNvQyxPQUFPLEdBQUcsSUFBSSxDQUFDNGlDLDBCQUEwQjtZQUN6RCxJQUFJLENBQUNJLHVCQUF1QjtRQUNoQyxPQUNLO1lBQ0QsYUFBYTtZQUNiMkYsZ0JBQWdCeEYsVUFBVSxHQUN0QixDQUFDcGpDLEtBQUssSUFBSSxDQUFDOGlDLGFBQWEsQ0FBQ00sVUFBVSxNQUFNLFFBQVFwakMsT0FBTyxLQUFLLElBQUlBLEtBQUswaUM7WUFDMUVrRyxnQkFBZ0Izb0MsT0FBTyxHQUFJO1FBQy9CO1FBQ0Eyb0MsZ0JBQWdCOTdCLE9BQU8sR0FBRyxJQUFJLENBQUN1NkIsaUJBQWlCO1FBQ2hELElBQUksQ0FBQ3ZFLGFBQWEsQ0FBQ25qQyxXQUFXLEdBQUdpcEM7UUFDakMsSUFBSUQsS0FBS2hwQyxXQUFXLEVBQUU7WUFDbEIsSUFBSSxDQUFDbWpDLGFBQWEsQ0FBQ25qQyxXQUFXLEdBQUcsSUFBSSxDQUFDMmtDLGdCQUFnQixDQUFDc0UsaUJBQWlCRCxLQUFLaHBDLFdBQVc7UUFDNUY7SUFDSjtBQTZjSjtBQUNBLGVBQWVxbUMsa0JBQWtCMTZCLFFBQVE7SUFDckMsSUFBSXZMO0lBQ0osSUFBSXVMLGFBQWFuTSxXQUFXO1FBQ3hCLE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxJQUFJLENBQUNxSyxTQUFTdTlCLEVBQUUsRUFBRTtRQUNkLE1BQU1oeUIsU0FBU3ZMLFNBQVN1TCxNQUFNO1FBQzlCLElBQUlpeUI7UUFDSixJQUFJLENBQUMvb0MsS0FBS3VMLFNBQVN3QixPQUFPLENBQUN5YSxHQUFHLENBQUMsZUFBYyxNQUFPLFFBQVF4bkIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHeVMsUUFBUSxDQUFDLHFCQUFxQjtZQUNsSHMyQixZQUFZLE1BQU14OUIsU0FBU3FCLElBQUk7UUFDbkMsT0FDSztZQUNEbThCLFlBQVk7Z0JBQ1J0bUMsT0FBTztvQkFDSHVxQixTQUFTLE1BQU16aEIsU0FBU1AsSUFBSTtvQkFDNUJnQixNQUFNVCxTQUFTdUwsTUFBTTtvQkFDckJBLFFBQVF2TCxTQUFTNDdCLFVBQVU7Z0JBQy9CO1lBQ0o7UUFDSjtRQUNBLE1BQU1MLGVBQWU5ZixLQUFLQyxTQUFTLENBQUM4aEI7UUFDcEMsSUFBSWp5QixVQUFVLE9BQU9BLFNBQVMsS0FBSztZQUMvQixNQUFNaXdCLFdBQVcsSUFBSXJYLFNBQVM7Z0JBQzFCMUMsU0FBUzhaO2dCQUNUaHdCLFFBQVFBO1lBQ1o7WUFDQSxNQUFNaXdCO1FBQ1Y7UUFDQSxNQUFNLElBQUk3bEMsTUFBTTRsQztJQUNwQjtBQUNKO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0QsU0FBU2pCLDhCQUE4Qm5CLFdBQVcsRUFBRWtCLFNBQVM7SUFDekQsSUFBSSxDQUFDQSxhQUFhaGxDLE9BQU9TLElBQUksQ0FBQ3VrQyxXQUFXcmtDLE1BQU0sS0FBSyxHQUFHO1FBQ25EO0lBQ0o7SUFDQSxJQUFJbWpDLFlBQVloZixJQUFJLFlBQVlzakIsTUFBTTtRQUNsQ3A3QixRQUFRQyxJQUFJLENBQUM7UUFDYjtJQUNKO0lBQ0EsSUFBSW83QixvQkFBb0IsQ0FBQztJQUN6Qix5RUFBeUU7SUFDekUsc0NBQXNDO0lBQ3RDLElBQUksT0FBT3ZFLFlBQVloZixJQUFJLEtBQUssWUFBWWdmLFlBQVloZixJQUFJLENBQUNua0IsTUFBTSxHQUFHLEdBQUc7UUFDckUsSUFBSTtZQUNBLE1BQU0ybkMsYUFBYWxpQixLQUFLK2QsS0FBSyxDQUFDTCxZQUFZaGYsSUFBSTtZQUM5QyxJQUFJLE9BQU93akIsZUFBZSxZQUN0QkEsZUFBZSxRQUNmLENBQUN2bkMsTUFBTUMsT0FBTyxDQUFDc25DLGFBQWE7Z0JBQzVCRCxvQkFBb0JDO1lBQ3hCLE9BQ0s7Z0JBQ0R0N0IsUUFBUUMsSUFBSSxDQUFDO2dCQUNiO1lBQ0o7UUFDQSwrREFBK0QsR0FDbkUsRUFDQSxPQUFPMmUsR0FBRztZQUNONWUsUUFBUUMsSUFBSSxDQUFDO1lBQ2I7UUFDSjtJQUNKO0lBQ0EsU0FBU3M3QixVQUFVQyxNQUFNLEVBQUVDLE1BQU07UUFDN0IsTUFBTXg5QixTQUFTakwsT0FBT3dCLE1BQU0sQ0FBQyxDQUFDLEdBQUdnbkM7UUFDakMsSUFBSyxNQUFNem9DLE9BQU8wb0MsT0FBUTtZQUN0QixJQUFJem9DLE9BQU9DLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNzb0MsUUFBUTFvQyxNQUFNO2dCQUNuRCxNQUFNMm9DLGNBQWNELE1BQU0sQ0FBQzFvQyxJQUFJO2dCQUMvQixNQUFNNG9DLGNBQWMxOUIsTUFBTSxDQUFDbEwsSUFBSTtnQkFDL0IsSUFBSTJvQyxlQUNBLE9BQU9BLGdCQUFnQixZQUN2QixDQUFDM25DLE1BQU1DLE9BQU8sQ0FBQzBuQyxnQkFDZkMsZUFDQSxPQUFPQSxnQkFBZ0IsWUFDdkIsQ0FBQzVuQyxNQUFNQyxPQUFPLENBQUMybkMsY0FBYztvQkFDN0IxOUIsTUFBTSxDQUFDbEwsSUFBSSxHQUFHd29DLFVBQVVJLGFBQWFEO2dCQUN6QyxPQUNLO29CQUNELElBQUlDLGVBQ0FELGVBQ0EsT0FBT0MsZ0JBQWdCLE9BQU9ELGFBQWE7d0JBQzNDMTdCLFFBQVFDLElBQUksQ0FBQyxtRUFBMkYsT0FBeEJsTixLQUFJLHNCQUFxRCxPQUFqQyxPQUFPNG9DLGFBQVksZ0JBQWlDLE9BQW5CLE9BQU9ELGFBQVk7b0JBQ2hLO29CQUNBejlCLE1BQU0sQ0FBQ2xMLElBQUksR0FBRzJvQztnQkFDbEI7WUFDSjtRQUNKO1FBQ0EsT0FBT3o5QjtJQUNYO0lBQ0EsTUFBTTI5QixhQUFhTCxVQUFVRixtQkFBbUJyRDtJQUNoRGxCLFlBQVloZixJQUFJLEdBQUdzQixLQUFLQyxTQUFTLENBQUN1aUI7QUFDdEM7QUFFQTs7OztDQUlDLEdBQ0QseUVBQXlFO0FBQ3pFLE1BQU1DLFlBQVk7QUFDbEIsc0VBQXNFO0FBQ3RFLGFBQWE7QUFDYixJQUFJQywrQkFBK0I7QUFDbkMsMkRBQTJEO0FBQzNELFNBQVNDLGdCQUFnQnJ6QixLQUFLO0lBQzFCLEtBQUssTUFBTVAsUUFBUU8sTUFBTztRQUN0QixJQUFJc3pCLGtCQUFrQjd6QixPQUFPO1lBQ3pCLE9BQU87UUFDWDtRQUNBLElBQUksT0FBT0EsU0FBUyxZQUFZLGlCQUFpQkEsTUFBTTtZQUNuRCxPQUFPO1FBQ1g7SUFDSjtJQUNBLE9BQU8yekI7QUFDWDtBQUNBLDhEQUE4RDtBQUM5RCxTQUFTRyxrQkFBa0I5OEIsT0FBTztJQUM5QixJQUFJL007SUFDSixNQUFNOHBDLGlCQUFpQixDQUFDOXBDLEtBQUsrTSxPQUFPLENBQUN3MUIseUJBQXlCLE1BQU0sUUFBUXZpQyxPQUFPLEtBQUssSUFBSUEsS0FBSztJQUNqRytNLE9BQU8sQ0FBQ3cxQix5QkFBeUIsR0FBRyxDQUFDdUgsaUJBQWlCLElBQWMsT0FBVkwsVUFBVSxFQUFHTSxTQUFTO0FBQ3BGO0FBQ0EscUVBQXFFO0FBQ3JFLFNBQVNILGtCQUFrQkksTUFBTTtJQUM3QixPQUFRQSxXQUFXLFFBQ2YsT0FBT0EsV0FBVyxZQUNsQkEsa0JBQWtCQztBQUMxQjtBQUNBLHNDQUFzQztBQUN0QyxTQUFTQyxhQUFhQyxTQUFTO1FBQUVDLFdBQUFBLGlFQUFXO0lBQ3hDLE9BQU8vZSxpQkFBaUIsSUFBSSxFQUFFMkQsV0FBVyxVQUFVcWI7UUFDL0MsSUFBSUMsU0FBU2xyQztRQUNiLElBQUltckMsV0FBVztRQUNmLE1BQU9BLFdBQVdILFNBQVU7WUFDeEIsTUFBTUksSUFBSSxNQUFNcGYsUUFBUStlLFVBQVVNLFNBQVMsQ0FBQztnQkFBRUg7WUFBTztZQUNyRCxLQUFLLE1BQU12MEIsUUFBUXkwQixFQUFFbDBCLEtBQUssQ0FBRTtnQkFDeEIsTUFBTSxNQUFNOFUsUUFBUXJWO2dCQUNwQncwQjtZQUNKO1lBQ0EsSUFBSSxDQUFDQyxFQUFFRSxVQUFVLEVBQUU7Z0JBQ2Y7WUFDSjtZQUNBSixTQUFTRSxFQUFFRSxVQUFVO1FBQ3pCO0lBQ0o7QUFDSjtBQUNBOzs7Ozs7Q0FNQyxHQUNELE1BQU1UO0lBT0Y7O0tBRUMsR0FDRCxPQUFPaGlCLE9BQU8waUIsVUFBVSxFQUFFejVCLE1BQU0sRUFBRTtRQUM5QixPQUFPLElBQUkrNEIsZ0JBQWdCVSxZQUFZejVCO0lBQzNDO0lBQ0E7Ozs7OztLQU1DLEdBQ0QsTUFBTTA1QixhQUFhO1FBQ2YsSUFBSTVxQyxJQUFJa3ZCLEtBQUtqdkIsSUFBSW1OO1FBQ2pCLElBQUksSUFBSSxDQUFDK0ssUUFBUSxDQUFDNVcsTUFBTSxHQUFHLEdBQUc7WUFDMUI7UUFDSjtRQUNBLE1BQU1zcEMsY0FBYyxDQUFDO1FBQ3JCLE1BQU0xeUIsV0FBVyxFQUFFO1FBQ25CLEtBQUssTUFBTWd5QixhQUFhLElBQUksQ0FBQ1EsVUFBVSxDQUFFO1lBQ3JDLElBQUk7Z0JBQ0EsSUFBSyxJQUFJdDlCLEtBQUssTUFBTUMsS0FBTTRoQixDQUFBQSxNQUFNLEtBQUssR0FBR3JDLGNBQWNxZCxhQUFhQyxXQUFVLEdBQUk1OEIsSUFBSUEsS0FBSyxNQUFNRCxHQUFHMlgsSUFBSSxJQUFJamxCLEtBQUt1TixHQUFHNlgsSUFBSSxFQUFFLENBQUNwbEIsSUFBSXFOLEtBQUssS0FBTTtvQkFDcklELEtBQUtHLEdBQUd2TSxLQUFLO29CQUNicU0sS0FBSztvQkFDTCxNQUFNd0ssVUFBVXpLO29CQUNoQitLLFNBQVMvVCxJQUFJLENBQUN5VDtvQkFDZCxNQUFNUSxjQUFjUixRQUFRM00sSUFBSTtvQkFDaEMsSUFBSTIvQixXQUFXLENBQUN4eUIsWUFBWSxFQUFFO3dCQUMxQixNQUFNLElBQUluWCxNQUFNLDJCQUF1QyxPQUFabVgsYUFBWTtvQkFDM0Q7b0JBQ0F3eUIsV0FBVyxDQUFDeHlCLFlBQVksR0FBRzh4QjtnQkFDL0I7WUFDSixFQUNBLE9BQU83YSxPQUFPO2dCQUFFSixNQUFNO29CQUFFenNCLE9BQU82c0I7Z0JBQU07WUFBRyxTQUNoQztnQkFDSixJQUFJO29CQUNBLElBQUksQ0FBQ2ppQixNQUFNLENBQUNyTixNQUFPQyxDQUFBQSxLQUFLcU4sR0FBRytYLE1BQU0sR0FBRyxNQUFNcGxCLEdBQUdjLElBQUksQ0FBQ3VNO2dCQUN0RCxTQUNRO29CQUFFLElBQUk0aEIsS0FBSyxNQUFNQSxJQUFJenNCLEtBQUs7Z0JBQUU7WUFDeEM7UUFDSjtRQUNBLElBQUksQ0FBQzBWLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDMnlCLHVCQUF1QixHQUFHRDtJQUNuQztJQUNBLE1BQU05MEIsT0FBTztRQUNULE1BQU0sSUFBSSxDQUFDNjBCLFVBQVU7UUFDckIsT0FBTzF5QixxQkFBcUIsSUFBSSxDQUFDQyxRQUFRLEVBQUUsSUFBSSxDQUFDakgsTUFBTTtJQUMxRDtJQUNBLE1BQU02NUIsU0FBU3o4QixhQUFhLEVBQUU7UUFDMUIsTUFBTSxJQUFJLENBQUNzOEIsVUFBVTtRQUNyQixNQUFNSSw0QkFBNEIsRUFBRTtRQUNwQyxLQUFLLE1BQU01L0IsZ0JBQWdCa0QsY0FBZTtZQUN0QyxJQUFJbEQsYUFBYUYsSUFBSSxJQUFJLElBQUksQ0FBQzQvQix1QkFBdUIsRUFBRTtnQkFDbkQsTUFBTVgsWUFBWSxJQUFJLENBQUNXLHVCQUF1QixDQUFDMS9CLGFBQWFGLElBQUksQ0FBQztnQkFDakUsSUFBSSsvQixpQkFBaUI3ckM7Z0JBQ3JCLHFFQUFxRTtnQkFDckUsSUFBSSxJQUFJLENBQUM4UixNQUFNLENBQUNpMEIsT0FBTyxFQUFFO29CQUNyQjhGLGlCQUFpQjt3QkFDYjlGLFNBQVMsSUFBSSxDQUFDajBCLE1BQU0sQ0FBQ2kwQixPQUFPO29CQUNoQztnQkFDSjtnQkFDQSxNQUFNK0YsbUJBQW1CLE1BQU1mLFVBQVVZLFFBQVEsQ0FBQztvQkFDOUM3L0IsTUFBTUUsYUFBYUYsSUFBSTtvQkFDdkI4akIsV0FBVzVqQixhQUFhRCxJQUFJO2dCQUNoQyxHQUNBLGlFQUFpRTtnQkFDakUsa0JBQWtCO2dCQUNsQi9MLFdBQVc2ckM7Z0JBQ1hELDBCQUEwQjVtQyxJQUFJLENBQUM7b0JBQzNCcUgsa0JBQWtCO3dCQUNkUCxNQUFNRSxhQUFhRixJQUFJO3dCQUN2QkssVUFBVTIvQixpQkFBaUJDLE9BQU8sR0FDNUI7NEJBQUUxb0MsT0FBT3lvQzt3QkFBaUIsSUFDMUJBO29CQUNWO2dCQUNKO1lBQ0o7UUFDSjtRQUNBLE9BQU9GO0lBQ1g7SUF0RkFsK0IsWUFBWTY5QixhQUFhLEVBQUUsRUFBRXo1QixNQUFNLENBQUU7UUFDakMsSUFBSSxDQUFDaUgsUUFBUSxHQUFHLEVBQUU7UUFDbEIsSUFBSSxDQUFDMnlCLHVCQUF1QixHQUFHLENBQUM7UUFDaEMsSUFBSSxDQUFDSCxVQUFVLEdBQUdBO1FBQ2xCLElBQUksQ0FBQ3o1QixNQUFNLEdBQUdBO0lBQ2xCO0FBa0ZKO0FBQ0EsU0FBU2s2QixZQUFZNTBCLE1BQU07SUFDdkIsT0FBUUEsV0FBVyxRQUNmLE9BQU9BLFdBQVcsWUFDbEIsZUFBZUEsVUFDZixPQUFPQSxPQUFPaTBCLFNBQVMsS0FBSztBQUNwQztBQUNBOzs7Ozs7Ozs7Q0FTQyxHQUNELFNBQVNZO0lBQVU7UUFBR2xnQyxLQUFILHVCQUFPOztJQUN0QiwrQkFBK0I7SUFDL0J1K0IsK0JBQStCO0lBQy9CLElBQUl2K0IsS0FBSzVKLE1BQU0sS0FBSyxHQUFHO1FBQ25CLE1BQU0sSUFBSUwsTUFBTTtJQUNwQjtJQUNBLE1BQU1vcUMsY0FBY25nQyxJQUFJLENBQUNBLEtBQUs1SixNQUFNLEdBQUcsRUFBRTtJQUN6QyxJQUFJNnBDLFlBQVlFLGNBQWM7UUFDMUIsT0FBT3JCLGdCQUFnQmhpQixNQUFNLENBQUM5YyxNQUFNLENBQUM7SUFDekM7SUFDQSxPQUFPOCtCLGdCQUFnQmhpQixNQUFNLENBQUM5YyxLQUFLekosS0FBSyxDQUFDLEdBQUd5SixLQUFLNUosTUFBTSxHQUFHLElBQUkrcEM7QUFDbEU7QUFFQTs7OztDQUlDLEdBQ0Q7Ozs7Ozs7Ozs7OztDQVlDLEdBQ0QsZUFBZUMseUJBQXlCaDVCLFNBQVMsRUFBRWk1QixTQUFTLEVBQUVDLEtBQUs7SUFDL0QsTUFBTUMsZ0JBQWdCLElBQUl6NUI7SUFDMUIsSUFBSTdRO0lBQ0osSUFBSXFxQyxNQUFNcnFDLElBQUksWUFBWTRuQyxNQUFNO1FBQzVCNW5DLE9BQU80bEIsS0FBSytkLEtBQUssQ0FBQyxNQUFNMEcsTUFBTXJxQyxJQUFJLENBQUM0SixJQUFJO0lBQzNDLE9BQ0s7UUFDRDVKLE9BQU80bEIsS0FBSytkLEtBQUssQ0FBQzBHLE1BQU1ycUMsSUFBSTtJQUNoQztJQUNBUixPQUFPd0IsTUFBTSxDQUFDc3BDLGVBQWV0cUM7SUFDN0JvcUMsVUFBVUU7QUFDZDtBQUNBOzs7OztFQUtFLEdBQ0YsTUFBTUM7SUFNRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7TUE2QkUsR0FDRixNQUFNQyxRQUFRNW5CLE1BQU0sRUFBRTtRQUNsQixJQUFJaGtCLElBQUlDO1FBQ1IsSUFBSSxJQUFJLENBQUNzUyxTQUFTLENBQUNHLFVBQVUsSUFBSTtZQUM3QixNQUFNLElBQUl4UixNQUFNO1FBQ3BCO1FBQ0EwTSxRQUFRQyxJQUFJLENBQUM7UUFDYixNQUFNZytCLG1CQUFtQixJQUFJLENBQUN0NUIsU0FBUyxDQUFDc3hCLG1CQUFtQjtRQUMzRCxNQUFNUixhQUFhLElBQUksQ0FBQzl3QixTQUFTLENBQUM2d0IsYUFBYTtRQUMvQyxNQUFNcjJCLFVBQVUrK0IsZUFBZSxJQUFJLENBQUN2NUIsU0FBUyxDQUFDKzBCLGlCQUFpQjtRQUMvRCxNQUFNbkUsU0FBUyxJQUFJLENBQUM1d0IsU0FBUyxDQUFDcXhCLFNBQVM7UUFDdkMsTUFBTU0sTUFBTSxHQUF1RGIsT0FBcER3SSxrQkFBaUIscUNBQXlGMUksT0FBdERFLFlBQVcsNkNBQWtELE9BQVBGO1FBQ3pILElBQUk0SSxnQkFBZ0IsS0FBUTtRQUM1QixNQUFNQyxnQkFBZ0IsSUFBSWhnQixRQUFRLENBQUNDO1lBQy9COGYsZ0JBQWdCOWY7UUFDcEI7UUFDQSxNQUFNZ2dCLFlBQVlqb0IsT0FBT2lvQixTQUFTO1FBQ2xDLE1BQU1DLHdCQUF3QjtZQUMxQkgsY0FBYyxDQUFDO1FBQ25CO1FBQ0EsTUFBTXg1QixZQUFZLElBQUksQ0FBQ0EsU0FBUztRQUNoQyxNQUFNNDVCLHFCQUFxQjtZQUN2QkMsUUFBUUY7WUFDUlYsV0FBVyxDQUFDQztnQkFDUixLQUFLRix5QkFBeUJoNUIsV0FBVzA1QixVQUFVVCxTQUFTLEVBQUVDO1lBQ2xFO1lBQ0FZLFNBQVMsQ0FBQ3JzQyxLQUFLaXNDLGNBQWMsUUFBUUEsY0FBYyxLQUFLLElBQUksS0FBSyxJQUFJQSxVQUFVSSxPQUFPLE1BQU0sUUFBUXJzQyxPQUFPLEtBQUssSUFBSUEsS0FBSyxTQUFVd3NCLENBQUMsR0FDcEk7WUFDQThmLFNBQVMsQ0FBQ3JzQyxLQUFLZ3NDLGNBQWMsUUFBUUEsY0FBYyxLQUFLLElBQUksS0FBSyxJQUFJQSxVQUFVSyxPQUFPLE1BQU0sUUFBUXJzQyxPQUFPLEtBQUssSUFBSUEsS0FBSyxTQUFVdXNCLENBQUMsR0FDcEk7UUFDSjtRQUNBLE1BQU0rZixPQUFPLElBQUksQ0FBQ0MsZ0JBQWdCLENBQUN2a0IsTUFBTSxDQUFDaWMsS0FBS3VJLGVBQWUxL0IsVUFBVW8vQjtRQUN4RUksS0FBS1gsT0FBTztRQUNaLDBEQUEwRDtRQUMxRCxNQUFNSTtRQUNOLE1BQU14NUIsUUFBUUYsT0FBTyxJQUFJLENBQUNDLFNBQVMsRUFBRXlSLE9BQU94UixLQUFLO1FBQ2pELE1BQU1rNkIsUUFBUTtZQUFFbDZCO1FBQU07UUFDdEIsTUFBTW02QixnQkFBZ0I7WUFBRUQ7UUFBTTtRQUM5QkgsS0FBS0ssSUFBSSxDQUFDNWxCLEtBQUtDLFNBQVMsQ0FBQzBsQjtRQUN6QixPQUFPLElBQUlFLGlCQUFpQk4sTUFBTSxJQUFJLENBQUNoNkIsU0FBUztJQUNwRDtJQTFFQXpGLFlBQVl5RixTQUFTLEVBQUVxMUIsSUFBSSxFQUFFNEUsZ0JBQWdCLENBQUU7UUFDM0MsSUFBSSxDQUFDajZCLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDcTFCLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUM0RSxnQkFBZ0IsR0FBR0E7SUFDNUI7QUF1RUo7QUFDQTs7OztFQUlFLEdBQ0YsTUFBTUs7SUFLRjs7Ozs7Ozs7OztLQVVDLEdBQ0QsTUFBTUMsbUJBQW1COW9CLE1BQU0sRUFBRTtRQUM3QixJQUFJLENBQUNBLE9BQU8rb0IsZUFBZSxJQUN2Qm5zQyxPQUFPUyxJQUFJLENBQUMyaUIsT0FBTytvQixlQUFlLEVBQUV4ckMsTUFBTSxLQUFLLEdBQUc7WUFDbEQsTUFBTSxJQUFJTCxNQUFNO1FBQ3BCO1FBQ0EsTUFBTThyQyxnQkFBZ0JwYSw2Q0FBNkM1TztRQUNuRSxJQUFJLENBQUN1b0IsSUFBSSxDQUFDSyxJQUFJLENBQUM1bEIsS0FBS0MsU0FBUyxDQUFDO1lBQUUrbEI7UUFBYztJQUNsRDtJQUNBOzs7Ozs7Ozs7O0tBVUMsR0FDRCxNQUFNQyx5QkFBeUJqcEIsTUFBTSxFQUFFO1FBQ25DLElBQUksQ0FBQ0EsT0FBT2twQixxQkFBcUIsRUFBRTtZQUMvQmxwQixPQUFPa3BCLHFCQUFxQixHQUFHLENBQUM7UUFDcEM7UUFDQSxNQUFNQyxzQkFBc0J6YSxvQ0FBb0MxTztRQUNoRSxJQUFJLENBQUN1b0IsSUFBSSxDQUFDSyxJQUFJLENBQUM1bEIsS0FBS0MsU0FBUyxDQUFDa21CO0lBQ2xDO0lBQ0FDLG9CQUFvQkMsZUFBZSxFQUFFO1FBQ2pDLE1BQU1WLGdCQUFnQjtZQUFFVTtRQUFnQjtRQUN4QyxJQUFJLENBQUNkLElBQUksQ0FBQ0ssSUFBSSxDQUFDNWxCLEtBQUtDLFNBQVMsQ0FBQzBsQjtJQUNsQztJQUNBOzs7O0tBSUMsR0FDRFcsT0FBTztRQUNILElBQUksQ0FBQ0YsbUJBQW1CLENBQUNwakMseUJBQXlCdWpDLElBQUk7SUFDMUQ7SUFDQTs7Ozs7S0FLQyxHQUNEQyxRQUFRO1FBQ0osSUFBSSxDQUFDSixtQkFBbUIsQ0FBQ3BqQyx5QkFBeUJ5akMsS0FBSztJQUMzRDtJQUNBOzs7OztLQUtDLEdBQ0RDLE9BQU87UUFDSCxJQUFJLENBQUNOLG1CQUFtQixDQUFDcGpDLHlCQUF5QjJqQyxJQUFJO0lBQzFEO0lBQ0E7Ozs7O0tBS0MsR0FDREMsZUFBZTtRQUNYLElBQUksQ0FBQ1IsbUJBQW1CLENBQUNwakMseUJBQXlCNmpDLGFBQWE7SUFDbkU7SUFDQTs7OztLQUlDLEdBQ0RDLFFBQVE7UUFDSixJQUFJLENBQUN2QixJQUFJLENBQUN1QixLQUFLO0lBQ25CO0lBdkZBaGhDLFlBQVl5L0IsSUFBSSxFQUFFaDZCLFNBQVMsQ0FBRTtRQUN6QixJQUFJLENBQUNnNkIsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ2g2QixTQUFTLEdBQUdBO0lBQ3JCO0FBcUZKO0FBQ0EsNEVBQTRFO0FBQzVFLDRFQUE0RTtBQUM1RSwrQ0FBK0M7QUFDL0MsU0FBU2s2QixlQUFlMS9CLE9BQU87SUFDM0IsTUFBTWdoQyxZQUFZLENBQUM7SUFDbkJoaEMsUUFBUWloQyxPQUFPLENBQUMsQ0FBQ2h0QyxPQUFPTDtRQUNwQm90QyxTQUFTLENBQUNwdEMsSUFBSSxHQUFHSztJQUNyQjtJQUNBLE9BQU8rc0M7QUFDWDtBQUNBLHVFQUF1RTtBQUN2RSw0RUFBNEU7QUFDNUUsaUJBQWlCO0FBQ2pCLFNBQVNqQyxlQUFldHBDLEdBQUc7SUFDdkIsTUFBTXVLLFVBQVUsSUFBSTA2QjtJQUNwQixLQUFLLE1BQU0sQ0FBQzltQyxLQUFLSyxNQUFNLElBQUlKLE9BQU9tQyxPQUFPLENBQUNQLEtBQU07UUFDNUN1SyxRQUFRMDNCLE1BQU0sQ0FBQzlqQyxLQUFLSztJQUN4QjtJQUNBLE9BQU8rTDtBQUNYO0FBRUE7Ozs7Q0FJQyxHQUNELE1BQU1raEMsZ0NBQWdDO0FBQ3RDOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNELGVBQWVDLHVCQUF1QjM3QixTQUFTLEVBQUVpNUIsU0FBUyxFQUFFQyxLQUFLO0lBQzdELE1BQU1DLGdCQUFnQixJQUFJaDZCO0lBQzFCLElBQUl5OEI7SUFDSixJQUFJMUMsTUFBTXJxQyxJQUFJLFlBQVk0bkMsTUFBTTtRQUM1Qm1GLFdBQVcsTUFBTTFDLE1BQU1ycUMsSUFBSSxDQUFDNEosSUFBSTtJQUNwQyxPQUNLLElBQUl5Z0MsTUFBTXJxQyxJQUFJLFlBQVlndEMsYUFBYTtRQUN4Q0QsV0FBVyxJQUFJOUgsY0FBY0ssTUFBTSxDQUFDK0UsTUFBTXJxQyxJQUFJO0lBQ2xELE9BQ0s7UUFDRCtzQyxXQUFXMUMsTUFBTXJxQyxJQUFJO0lBQ3pCO0lBQ0EsTUFBTUEsT0FBTzRsQixLQUFLK2QsS0FBSyxDQUFDb0o7SUFDeEIsSUFBSTU3QixVQUFVRyxVQUFVLElBQUk7UUFDeEIsTUFBTTRVLE9BQU8rTCw0QkFBNEJqeUI7UUFDekNSLE9BQU93QixNQUFNLENBQUNzcEMsZUFBZXBrQjtJQUNqQyxPQUNLO1FBQ0QsTUFBTUEsT0FBT2xtQjtRQUNiUixPQUFPd0IsTUFBTSxDQUFDc3BDLGVBQWVwa0I7SUFDakM7SUFDQWtrQixVQUFVRTtBQUNkO0FBQ0E7Ozs7O0VBS0UsR0FDRixNQUFNMkM7SUFPRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7TUF5Q0UsR0FDRixNQUFNekMsUUFBUTVuQixNQUFNLEVBQUU7UUFDbEIsSUFBSWhrQixJQUFJQyxJQUFJbU4sSUFBSUMsSUFBSUMsSUFBSUM7UUFDeEIsd0RBQXdEO1FBQ3hELElBQUl5VyxPQUFPOVMsTUFBTSxJQUFJOFMsT0FBTzlTLE1BQU0sQ0FBQ3RSLFdBQVcsRUFBRTtZQUM1QyxNQUFNLElBQUlzQixNQUFNLHFFQUNaLG9FQUNBO1FBQ1I7UUFDQSxNQUFNMnFDLG1CQUFtQixJQUFJLENBQUN0NUIsU0FBUyxDQUFDc3hCLG1CQUFtQjtRQUMzRCxNQUFNUixhQUFhLElBQUksQ0FBQzl3QixTQUFTLENBQUM2d0IsYUFBYTtRQUMvQyxJQUFJYztRQUNKLE1BQU1vSyxnQkFBZ0IsSUFBSSxDQUFDLzdCLFNBQVMsQ0FBQ2l4QixVQUFVO1FBQy9DLElBQUl4ZixPQUFPOVMsTUFBTSxJQUNiOFMsT0FBTzlTLE1BQU0sQ0FBQ29GLEtBQUssSUFDbkJxekIsZ0JBQWdCM2xCLE9BQU85UyxNQUFNLENBQUNvRixLQUFLLEdBQUc7WUFDdEN1ekIsa0JBQWtCeUU7UUFDdEI7UUFDQSxNQUFNdmhDLFVBQVV3aEMsYUFBYUQ7UUFDN0IsSUFBSSxJQUFJLENBQUMvN0IsU0FBUyxDQUFDRyxVQUFVLElBQUk7WUFDN0J3eEIsTUFBTSxHQUFrRGIsT0FBL0N3SSxrQkFBaUIsZ0NBQXlDLE9BQVh4SSxZQUFXO1lBQ25FLE1BQU0sSUFBSSxDQUFDdUUsSUFBSSxDQUFDQyxjQUFjLENBQUM5NkIsU0FBU20zQjtRQUM1QyxPQUNLO1lBQ0QsTUFBTWYsU0FBUyxJQUFJLENBQUM1d0IsU0FBUyxDQUFDcXhCLFNBQVM7WUFDdkMsSUFBSW9DLFNBQVM7WUFDYixJQUFJdmtDLFVBQVU7WUFDZCxJQUFJMGhDLFdBQVcsUUFBUUEsV0FBVyxLQUFLLElBQUksS0FBSyxJQUFJQSxPQUFPci9CLFVBQVUsQ0FBQyxpQkFBaUI7Z0JBQ25GOEosUUFBUUMsSUFBSSxDQUFDO2dCQUNiLElBQUl3MUIsZUFBZSxXQUFXO29CQUMxQnoxQixRQUFRQyxJQUFJLENBQUM7Z0JBQ2pCO2dCQUNBbTRCLFNBQVM7Z0JBQ1R2a0MsVUFBVTtZQUNkO1lBQ0F5aUMsTUFBTSxHQUF1RGIsT0FBcER3SSxrQkFBaUIscUNBQW1FN0YsT0FBaEMzQyxZQUFXLHVCQUErQjVoQyxPQUFWdWtDLFFBQU8sS0FBYzdDLE9BQVgxaEMsU0FBUSxLQUFVLE9BQVAwaEM7UUFDdEg7UUFDQSxJQUFJNEksZ0JBQWdCLEtBQVE7UUFDNUIsTUFBTUMsZ0JBQWdCLElBQUloZ0IsUUFBUSxDQUFDQztZQUMvQjhmLGdCQUFnQjlmO1FBQ3BCO1FBQ0EsTUFBTWdnQixZQUFZam9CLE9BQU9pb0IsU0FBUztRQUNsQyxNQUFNQyx3QkFBd0I7WUFDMUIsSUFBSWxzQztZQUNIQSxDQUFBQSxLQUFLaXNDLGNBQWMsUUFBUUEsY0FBYyxLQUFLLElBQUksS0FBSyxJQUFJQSxVQUFVRyxNQUFNLE1BQU0sUUFBUXBzQyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdlLElBQUksQ0FBQ2tyQztZQUMzSEYsY0FBYyxDQUFDO1FBQ25CO1FBQ0EsTUFBTXg1QixZQUFZLElBQUksQ0FBQ0EsU0FBUztRQUNoQyxNQUFNNDVCLHFCQUFxQjtZQUN2QkMsUUFBUUY7WUFDUlYsV0FBVyxDQUFDQztnQkFDUixLQUFLeUMsdUJBQXVCMzdCLFdBQVcwNUIsVUFBVVQsU0FBUyxFQUFFQztZQUNoRTtZQUNBWSxTQUFTLENBQUNyc0MsS0FBS2lzQyxjQUFjLFFBQVFBLGNBQWMsS0FBSyxJQUFJLEtBQUssSUFBSUEsVUFBVUksT0FBTyxNQUFNLFFBQVFyc0MsT0FBTyxLQUFLLElBQUlBLEtBQUssU0FBVXdzQixDQUFDLEdBQ3BJO1lBQ0E4ZixTQUFTLENBQUNyc0MsS0FBS2dzQyxjQUFjLFFBQVFBLGNBQWMsS0FBSyxJQUFJLEtBQUssSUFBSUEsVUFBVUssT0FBTyxNQUFNLFFBQVFyc0MsT0FBTyxLQUFLLElBQUlBLEtBQUssU0FBVXVzQixDQUFDLEdBQ3BJO1FBQ0o7UUFDQSxNQUFNK2YsT0FBTyxJQUFJLENBQUNDLGdCQUFnQixDQUFDdmtCLE1BQU0sQ0FBQ2ljLEtBQUtzSyxhQUFhemhDLFVBQVVvL0I7UUFDdEVJLEtBQUtYLE9BQU87UUFDWiwwREFBMEQ7UUFDMUQsTUFBTUk7UUFDTixJQUFJbjVCLG1CQUFtQlAsT0FBTyxJQUFJLENBQUNDLFNBQVMsRUFBRXlSLE9BQU94UixLQUFLO1FBQzFELElBQUksSUFBSSxDQUFDRCxTQUFTLENBQUNHLFVBQVUsTUFDekJHLGlCQUFpQi9PLFVBQVUsQ0FBQyxnQkFBZ0I7WUFDNUMsTUFBTWsvQixVQUFVLElBQUksQ0FBQ3p3QixTQUFTLENBQUNPLFVBQVU7WUFDekMsTUFBTW13QixXQUFXLElBQUksQ0FBQzF3QixTQUFTLENBQUNRLFdBQVc7WUFDM0NGLG1CQUNJLFlBQWlDb3dCLE9BQXJCRCxTQUFRLGVBQXNCLE9BQVRDLFVBQVMsT0FBS3B3QjtRQUN2RDtRQUNBLElBQUk4NUIsZ0JBQWdCLENBQUM7UUFDckIsSUFBSSxJQUFJLENBQUNwNkIsU0FBUyxDQUFDRyxVQUFVLE1BQ3pCLENBQUMsQ0FBQ3RGLEtBQUs0VyxPQUFPOVMsTUFBTSxNQUFNLFFBQVE5RCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdxaEMsa0JBQWtCLE1BQU1ydkMsV0FBVztZQUNqRyxnREFBZ0Q7WUFDaEQsSUFBSTRrQixPQUFPOVMsTUFBTSxLQUFLOVIsV0FBVztnQkFDN0I0a0IsT0FBTzlTLE1BQU0sR0FBRztvQkFBRXU5QixvQkFBb0I7d0JBQUM1bUMsU0FBUzZtQyxLQUFLO3FCQUFDO2dCQUFDO1lBQzNELE9BQ0s7Z0JBQ0QxcUIsT0FBTzlTLE1BQU0sQ0FBQ3U5QixrQkFBa0IsR0FBRztvQkFBQzVtQyxTQUFTNm1DLEtBQUs7aUJBQUM7WUFDdkQ7UUFDSjtRQUNBLElBQUksQ0FBQ3JoQyxLQUFLMlcsT0FBTzlTLE1BQU0sTUFBTSxRQUFRN0QsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHc2hDLGdCQUFnQixFQUFFO1lBQy9FLGtEQUFrRDtZQUNsRC9nQyxRQUFRQyxJQUFJLENBQUM7UUFDakI7UUFDQSxNQUFNK2dDLGFBQWEsQ0FBQ3JoQyxLQUFLLENBQUNELEtBQUswVyxPQUFPOVMsTUFBTSxNQUFNLFFBQVE1RCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdnSixLQUFLLE1BQU0sUUFBUS9JLE9BQU8sS0FBSyxJQUFJQSxLQUFLLEVBQUU7UUFDaEksTUFBTXNoQyxpQkFBaUIsRUFBRTtRQUN6QixLQUFLLE1BQU05NEIsUUFBUTY0QixXQUFZO1lBQzNCLElBQUksSUFBSSxDQUFDRSxjQUFjLENBQUMvNEIsT0FBTztnQkFDM0IsTUFBTWc1QixlQUFlaDVCO2dCQUNyQjg0QixlQUFlenFDLElBQUksQ0FBQyxNQUFNMnFDLGFBQWFoNUIsSUFBSTtZQUMvQyxPQUNLO2dCQUNEODRCLGVBQWV6cUMsSUFBSSxDQUFDMlI7WUFDeEI7UUFDSjtRQUNBLElBQUk4NEIsZUFBZXR0QyxNQUFNLEdBQUcsR0FBRztZQUMzQnlpQixPQUFPOVMsTUFBTSxDQUFDb0YsS0FBSyxHQUFHdTRCO1FBQzFCO1FBQ0EsTUFBTUcsd0JBQXdCO1lBQzFCeDhCLE9BQU9LO1lBQ1AzQixRQUFROFMsT0FBTzlTLE1BQU07WUFDckIrNkIsV0FBV2pvQixPQUFPaW9CLFNBQVM7UUFDL0I7UUFDQSxJQUFJLElBQUksQ0FBQzE1QixTQUFTLENBQUNHLFVBQVUsSUFBSTtZQUM3Qmk2QixnQkFBZ0JsYSw4QkFBOEIsSUFBSSxDQUFDbGdCLFNBQVMsRUFBRXk4QjtRQUNsRSxPQUNLO1lBQ0RyQyxnQkFBZ0JuYSw2QkFBNkIsSUFBSSxDQUFDamdCLFNBQVMsRUFBRXk4QjtRQUNqRTtRQUNBLE9BQU9yQyxhQUFhLENBQUMsU0FBUztRQUM5QkosS0FBS0ssSUFBSSxDQUFDNWxCLEtBQUtDLFNBQVMsQ0FBQzBsQjtRQUN6QixPQUFPLElBQUlzQyxRQUFRMUMsTUFBTSxJQUFJLENBQUNoNkIsU0FBUztJQUMzQztJQUNBLDhEQUE4RDtJQUM5RHU4QixlQUFlLzRCLElBQUksRUFBRTtRQUNqQixPQUFPLGNBQWNBLFFBQVEsT0FBT0EsS0FBS2cxQixRQUFRLEtBQUs7SUFDMUQ7SUFwS0FqK0IsWUFBWXlGLFNBQVMsRUFBRXExQixJQUFJLEVBQUU0RSxnQkFBZ0IsQ0FBRTtRQUMzQyxJQUFJLENBQUNqNkIsU0FBUyxHQUFHQTtRQUNqQixJQUFJLENBQUNxMUIsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQzRFLGdCQUFnQixHQUFHQTtRQUN4QixJQUFJLENBQUMwQyxLQUFLLEdBQUcsSUFBSXZELFVBQVUsSUFBSSxDQUFDcDVCLFNBQVMsRUFBRSxJQUFJLENBQUNxMUIsSUFBSSxFQUFFLElBQUksQ0FBQzRFLGdCQUFnQjtJQUMvRTtBQWdLSjtBQUNBLE1BQU0yQywwQ0FBMEM7SUFDNUNDLGNBQWM7QUFDbEI7QUFDQTs7OztFQUlFLEdBQ0YsTUFBTUg7SUFLRkksbUJBQW1COThCLFNBQVMsRUFBRXlSLE1BQU0sRUFBRTtRQUNsQyxJQUFJQSxPQUFPc3JCLEtBQUssS0FBSyxRQUFRdHJCLE9BQU9zckIsS0FBSyxLQUFLbHdDLFdBQVc7WUFDckQsSUFBSSt1QixXQUFXLEVBQUU7WUFDakIsSUFBSTtnQkFDQUEsV0FBV25hLFVBQVVnUSxPQUFPc3JCLEtBQUs7Z0JBQ2pDLElBQUksQ0FBQy84QixVQUFVRyxVQUFVLElBQUk7b0JBQ3pCeWIsV0FBV0EsU0FBUzNyQixHQUFHLENBQUMsQ0FBQ2tCLE9BQVM0eEIsaUJBQWlCNXhCO2dCQUN2RDtZQUNKLEVBQ0EsT0FBTzFELElBQUk7Z0JBQ1AsTUFBTSxJQUFJa0IsTUFBTSxtREFBc0UsT0FBcEIsT0FBTzhpQixPQUFPc3JCLEtBQUssRUFBQztZQUMxRjtZQUNBLE9BQU87Z0JBQ0h0QyxlQUFlO29CQUFFc0MsT0FBT25oQjtvQkFBVWloQixjQUFjcHJCLE9BQU9vckIsWUFBWTtnQkFBQztZQUN4RTtRQUNKO1FBQ0EsT0FBTztZQUNIcEMsZUFBZTtnQkFBRW9DLGNBQWNwckIsT0FBT29yQixZQUFZO1lBQUM7UUFDdkQ7SUFDSjtJQUNBRyx5QkFBeUJoOUIsU0FBUyxFQUFFeVIsTUFBTSxFQUFFO1FBQ3hDLElBQUloUyxvQkFBb0IsRUFBRTtRQUMxQixJQUFJZ1MsT0FBT2hTLGlCQUFpQixJQUFJLE1BQU07WUFDbEMsTUFBTSxJQUFJOVEsTUFBTTtRQUNwQjtRQUNBLElBQUksQ0FBQ1MsTUFBTUMsT0FBTyxDQUFDb2lCLE9BQU9oUyxpQkFBaUIsR0FBRztZQUMxQ0Esb0JBQW9CO2dCQUFDZ1MsT0FBT2hTLGlCQUFpQjthQUFDO1FBQ2xELE9BQ0s7WUFDREEsb0JBQW9CZ1MsT0FBT2hTLGlCQUFpQjtRQUNoRDtRQUNBLElBQUlBLGtCQUFrQnpRLE1BQU0sS0FBSyxHQUFHO1lBQ2hDLE1BQU0sSUFBSUwsTUFBTTtRQUNwQjtRQUNBLEtBQUssTUFBTXVLLG9CQUFvQnVHLGtCQUFtQjtZQUM5QyxJQUFJLE9BQU92RyxxQkFBcUIsWUFDNUJBLHFCQUFxQixRQUNyQixDQUFFLFdBQVVBLGdCQUFlLEtBQzNCLENBQUUsZUFBY0EsZ0JBQWUsR0FBSTtnQkFDbkMsTUFBTSxJQUFJdkssTUFBTSw0Q0FBb0UsT0FBeEIsT0FBT3VLLGtCQUFpQjtZQUN4RjtZQUNBLElBQUksQ0FBQzhHLFVBQVVHLFVBQVUsTUFBTSxDQUFFLFNBQVFqSCxnQkFBZSxHQUFJO2dCQUN4RCxNQUFNLElBQUl2SyxNQUFNK3NDO1lBQ3BCO1FBQ0o7UUFDQSxNQUFNdEIsZ0JBQWdCO1lBQ2xCNkMsY0FBYztnQkFBRXg5QixtQkFBbUJBO1lBQWtCO1FBQ3pEO1FBQ0EsT0FBTzI2QjtJQUNYO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQWdEQyxHQUNEOEMsa0JBQWtCenJCLE1BQU0sRUFBRTtRQUN0QkEsU0FBU3BqQixPQUFPd0IsTUFBTSxDQUFDeEIsT0FBT3dCLE1BQU0sQ0FBQyxDQUFDLEdBQUcrc0MsMENBQTBDbnJCO1FBQ25GLE1BQU0yb0IsZ0JBQWdCLElBQUksQ0FBQzBDLGtCQUFrQixDQUFDLElBQUksQ0FBQzk4QixTQUFTLEVBQUV5UjtRQUM5RCxJQUFJLENBQUN1b0IsSUFBSSxDQUFDSyxJQUFJLENBQUM1bEIsS0FBS0MsU0FBUyxDQUFDMGxCO0lBQ2xDO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQXFCQyxHQUNEK0Msa0JBQWtCMXJCLE1BQU0sRUFBRTtRQUN0QixJQUFJMm9CLGdCQUFnQixDQUFDO1FBQ3JCLElBQUksSUFBSSxDQUFDcDZCLFNBQVMsQ0FBQ0csVUFBVSxJQUFJO1lBQzdCaTZCLGdCQUFnQjtnQkFDWixpQkFBaUJ2Wix3Q0FBd0NwUDtZQUM3RDtRQUNKLE9BQ0s7WUFDRDJvQixnQkFBZ0I7Z0JBQ1osaUJBQWlCN1osdUNBQXVDOU87WUFDNUQ7UUFDSjtRQUNBLElBQUksQ0FBQ3VvQixJQUFJLENBQUNLLElBQUksQ0FBQzVsQixLQUFLQyxTQUFTLENBQUMwbEI7SUFDbEM7SUFDQTs7Ozs7Ozs7Ozs7OztLQWFDLEdBQ0RnRCxpQkFBaUIzckIsTUFBTSxFQUFFO1FBQ3JCLElBQUlBLE9BQU9oUyxpQkFBaUIsSUFBSSxNQUFNO1lBQ2xDLE1BQU0sSUFBSTlRLE1BQU07UUFDcEI7UUFDQSxNQUFNeXJDLGdCQUFnQixJQUFJLENBQUM0Qyx3QkFBd0IsQ0FBQyxJQUFJLENBQUNoOUIsU0FBUyxFQUFFeVI7UUFDcEUsSUFBSSxDQUFDdW9CLElBQUksQ0FBQ0ssSUFBSSxDQUFDNWxCLEtBQUtDLFNBQVMsQ0FBQzBsQjtJQUNsQztJQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBc0JDLEdBQ0RtQixRQUFRO1FBQ0osSUFBSSxDQUFDdkIsSUFBSSxDQUFDdUIsS0FBSztJQUNuQjtJQTlMQWhoQyxZQUFZeS9CLElBQUksRUFBRWg2QixTQUFTLENBQUU7UUFDekIsSUFBSSxDQUFDZzZCLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNoNkIsU0FBUyxHQUFHQTtJQUNyQjtBQTRMSjtBQUNBLDRFQUE0RTtBQUM1RSw0RUFBNEU7QUFDNUUsK0NBQStDO0FBQy9DLFNBQVNpOEIsYUFBYXpoQyxPQUFPO0lBQ3pCLE1BQU1naEMsWUFBWSxDQUFDO0lBQ25CaGhDLFFBQVFpaEMsT0FBTyxDQUFDLENBQUNodEMsT0FBT0w7UUFDcEJvdEMsU0FBUyxDQUFDcHRDLElBQUksR0FBR0s7SUFDckI7SUFDQSxPQUFPK3NDO0FBQ1g7QUFDQSx1RUFBdUU7QUFDdkUsNEVBQTRFO0FBQzVFLGlCQUFpQjtBQUNqQixTQUFTUSxhQUFhL3JDLEdBQUc7SUFDckIsTUFBTXVLLFVBQVUsSUFBSTA2QjtJQUNwQixLQUFLLE1BQU0sQ0FBQzltQyxLQUFLSyxNQUFNLElBQUlKLE9BQU9tQyxPQUFPLENBQUNQLEtBQU07UUFDNUN1SyxRQUFRMDNCLE1BQU0sQ0FBQzlqQyxLQUFLSztJQUN4QjtJQUNBLE9BQU8rTDtBQUNYO0FBRUE7Ozs7Q0FJQyxHQUNELE1BQU02aUMsMkJBQTJCO0FBQ2pDLDREQUE0RCxHQUM1RCxTQUFTQyxpQkFBaUIzK0IsTUFBTTtJQUM1QixJQUFJbFIsSUFBSUMsSUFBSW1OO0lBQ1osSUFBSSxDQUFDcE4sS0FBS2tSLFdBQVcsUUFBUUEsV0FBVyxLQUFLLElBQUksS0FBSyxJQUFJQSxPQUFPNCtCLHdCQUF3QixNQUFNLFFBQVE5dkMsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHK3ZDLE9BQU8sRUFBRTtRQUN4SSxPQUFPO0lBQ1g7SUFDQSxJQUFJQyx1QkFBdUI7SUFDM0IsS0FBSyxNQUFNajZCLFFBQVEsQ0FBQzlWLEtBQUtpUixXQUFXLFFBQVFBLFdBQVcsS0FBSyxJQUFJLEtBQUssSUFBSUEsT0FBT29GLEtBQUssTUFBTSxRQUFRclcsT0FBTyxLQUFLLElBQUlBLEtBQUssRUFBRSxDQUFFO1FBQ3hILElBQUk2dUMsZUFBZS80QixPQUFPO1lBQ3RCaTZCLHVCQUF1QjtZQUN2QjtRQUNKO0lBQ0o7SUFDQSxJQUFJLENBQUNBLHNCQUFzQjtRQUN2QixPQUFPO0lBQ1g7SUFDQSxNQUFNQyxXQUFXLENBQUM3aUMsS0FBSzhELFdBQVcsUUFBUUEsV0FBVyxLQUFLLElBQUksS0FBSyxJQUFJQSxPQUFPNCtCLHdCQUF3QixNQUFNLFFBQVExaUMsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHOGlDLGtCQUFrQjtJQUNsSyxJQUFJLFlBQWNELENBQUFBLFdBQVcsS0FBSyxDQUFDRSxPQUFPQyxTQUFTLENBQUNILFNBQVEsS0FDeERBLFlBQVksR0FBRztRQUNmcmlDLFFBQVFDLElBQUksQ0FBQyxvTUFBb01vaUM7UUFDak4sT0FBTztJQUNYO0lBQ0EsT0FBTztBQUNYO0FBQ0EsU0FBU25CLGVBQWUvNEIsSUFBSTtJQUN4QixPQUFPLGNBQWNBLFFBQVEsT0FBT0EsS0FBS2cxQixRQUFRLEtBQUs7QUFDMUQ7QUFDQSxnRkFBZ0Y7QUFDaEYseUNBQXlDO0FBQ3pDLFNBQVNzRixpQkFBaUJyc0IsTUFBTTtJQUM1QixJQUFJaGtCLElBQUlDLElBQUltTjtJQUNaLE9BQU8sQ0FBQ0EsS0FBSyxDQUFDbk4sS0FBSyxDQUFDRCxLQUFLZ2tCLE9BQU85UyxNQUFNLE1BQU0sUUFBUWxSLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3NXLEtBQUssTUFBTSxRQUFRclcsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHcXdDLElBQUksQ0FBQyxDQUFDdjZCLE9BQVMrNEIsZUFBZS80QixNQUFLLE1BQU8sUUFBUTNJLE9BQU8sS0FBSyxJQUFJQSxLQUFLO0FBQzFNO0FBQ0E7O0NBRUMsR0FDRCxTQUFTbWpDLCtCQUErQnZzQixNQUFNO0lBQzFDLElBQUloa0I7SUFDSixxREFBcUQ7SUFDckQsTUFBTXd3Qyw2QkFBNkIsRUFBRTtJQUNyQyxJQUFJLENBQUUsRUFBQ3h3QyxLQUFLZ2tCLFdBQVcsUUFBUUEsV0FBVyxLQUFLLElBQUksS0FBSyxJQUFJQSxPQUFPOVMsTUFBTSxNQUFNLFFBQVFsUixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdzVyxLQUFLLEdBQUc7UUFDdkgsT0FBT2s2QjtJQUNYO0lBQ0F4c0IsT0FBTzlTLE1BQU0sQ0FBQ29GLEtBQUssQ0FBQzAzQixPQUFPLENBQUMsQ0FBQ2o0QixNQUFNK087UUFDL0IsSUFBSWdxQixlQUFlLzRCLE9BQU87WUFDdEI7UUFDSjtRQUNBLE1BQU1rQyxhQUFhbEM7UUFDbkIsSUFBSWtDLFdBQVdqQyxvQkFBb0IsSUFDL0JpQyxXQUFXakMsb0JBQW9CLENBQUN6VSxNQUFNLEdBQUcsR0FBRztZQUM1Q2l2QywyQkFBMkJwc0MsSUFBSSxDQUFDMGdCO1FBQ3BDO0lBQ0o7SUFDQSxPQUFPMHJCO0FBQ1g7QUFDQTs7O0NBR0MsR0FDRCxTQUFTQyx1QkFBdUJ2L0IsTUFBTTtJQUNsQyxJQUFJbFI7SUFDSixPQUFPLENBQUUsRUFBQ0EsS0FBS2tSLFdBQVcsUUFBUUEsV0FBVyxLQUFLLElBQUksS0FBSyxJQUFJQSxPQUFPNCtCLHdCQUF3QixNQUFNLFFBQVE5dkMsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHMHdDLGlCQUFpQjtBQUM3SjtBQUVBOzs7O0NBSUMsR0FDRCxNQUFNQyxlQUFldndDO0lBbVdqQjs7Ozs7O0tBTUMsR0FDRHd3Qyw2QkFBNkI1c0IsTUFBTSxFQUFFO1FBQ2pDLElBQUlBLE9BQU85UyxNQUFNLElBQUk4UyxPQUFPOVMsTUFBTSxDQUFDMi9CLGNBQWMsRUFBRTtZQUMvQyxJQUFJLENBQUM3c0IsT0FBTzlTLE1BQU0sQ0FBQ2tGLGtCQUFrQixFQUFFO2dCQUNuQyxJQUFJeFYsT0FBT1MsSUFBSSxDQUFDMmlCLE9BQU85UyxNQUFNLENBQUMyL0IsY0FBYyxFQUFFcCtCLFFBQVEsQ0FBQyxZQUFZO29CQUMvRHVSLE9BQU85UyxNQUFNLENBQUNrRixrQkFBa0IsR0FBRzROLE9BQU85UyxNQUFNLENBQUMyL0IsY0FBYztvQkFDL0QsT0FBTzdzQixPQUFPOVMsTUFBTSxDQUFDMi9CLGNBQWM7Z0JBQ3ZDO1lBQ0o7UUFDSjtRQUNBO0lBQ0o7SUFDQTs7Ozs7S0FLQyxHQUNELE1BQU1DLDhCQUE4QjlzQixNQUFNLEVBQUU7UUFDeEMsSUFBSWhrQixJQUFJQyxJQUFJbU47UUFDWixNQUFNa0osUUFBUSxDQUFDdFcsS0FBS2drQixPQUFPOVMsTUFBTSxNQUFNLFFBQVFsUixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdzVyxLQUFLO1FBQ2hGLElBQUksQ0FBQ0EsT0FBTztZQUNSLE9BQU8wTjtRQUNYO1FBQ0EsTUFBTStzQixtQkFBbUIsTUFBTS9rQixRQUFRZ2xCLEdBQUcsQ0FBQzE2QixNQUFNOVQsR0FBRyxDQUFDLE9BQU91VDtZQUN4RCxJQUFJKzRCLGVBQWUvNEIsT0FBTztnQkFDdEIsTUFBTWc1QixlQUFlaDVCO2dCQUNyQixPQUFPLE1BQU1nNUIsYUFBYWg1QixJQUFJO1lBQ2xDO1lBQ0EsT0FBT0E7UUFDWDtRQUNBLE1BQU1rN0IsWUFBWTtZQUNkeitCLE9BQU93UixPQUFPeFIsS0FBSztZQUNuQjJiLFVBQVVuSyxPQUFPbUssUUFBUTtZQUN6QmpkLFFBQVF0USxPQUFPd0IsTUFBTSxDQUFDeEIsT0FBT3dCLE1BQU0sQ0FBQyxDQUFDLEdBQUc0aEIsT0FBTzlTLE1BQU0sR0FBRztnQkFBRW9GLE9BQU95NkI7WUFBaUI7UUFDdEY7UUFDQUUsVUFBVS8vQixNQUFNLENBQUNvRixLQUFLLEdBQUd5NkI7UUFDekIsSUFBSS9zQixPQUFPOVMsTUFBTSxJQUNiOFMsT0FBTzlTLE1BQU0sQ0FBQ29GLEtBQUssSUFDbkJxekIsZ0JBQWdCM2xCLE9BQU85UyxNQUFNLENBQUNvRixLQUFLLEdBQUc7WUFDdEMsTUFBTXZKLFVBQVUsQ0FBQ0ssS0FBSyxDQUFDbk4sS0FBSytqQixPQUFPOVMsTUFBTSxDQUFDdFIsV0FBVyxNQUFNLFFBQVFLLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzhNLE9BQU8sTUFBTSxRQUFRSyxPQUFPLEtBQUssSUFBSUEsS0FBSyxDQUFDO1lBQzFJLElBQUk4akMsYUFBYXR3QyxPQUFPd0IsTUFBTSxDQUFDLENBQUMsR0FBRzJLO1lBQ25DLElBQUluTSxPQUFPUyxJQUFJLENBQUM2dkMsWUFBWTN2QyxNQUFNLEtBQUssR0FBRztnQkFDdEMydkMsYUFBYSxJQUFJLENBQUMzK0IsU0FBUyxDQUFDKzBCLGlCQUFpQjtZQUNqRDtZQUNBdUMsa0JBQWtCcUg7WUFDbEJELFVBQVUvL0IsTUFBTSxDQUFDdFIsV0FBVyxHQUFHZ0IsT0FBT3dCLE1BQU0sQ0FBQ3hCLE9BQU93QixNQUFNLENBQUMsQ0FBQyxHQUFHNGhCLE9BQU85UyxNQUFNLENBQUN0UixXQUFXLEdBQUc7Z0JBQUVtTixTQUFTbWtDO1lBQVc7UUFDckg7UUFDQSxPQUFPRDtJQUNYO0lBQ0EsTUFBTUUsZ0JBQWdCbnRCLE1BQU0sRUFBRTtRQUMxQixJQUFJaGtCLElBQUlDLElBQUltTjtRQUNaLE1BQU1na0MsV0FBVyxJQUFJQztRQUNyQixLQUFLLE1BQU10N0IsUUFBUSxDQUFDOVYsS0FBSyxDQUFDRCxLQUFLZ2tCLE9BQU85UyxNQUFNLE1BQU0sUUFBUWxSLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3NXLEtBQUssTUFBTSxRQUFRclcsT0FBTyxLQUFLLElBQUlBLEtBQUssRUFBRSxDQUFFO1lBQzlILElBQUk2dUMsZUFBZS80QixPQUFPO2dCQUN0QixNQUFNZzVCLGVBQWVoNUI7Z0JBQ3JCLE1BQU11N0Isa0JBQWtCLE1BQU12QyxhQUFhaDVCLElBQUk7Z0JBQy9DLEtBQUssTUFBTXc3QixlQUFlLENBQUNua0MsS0FBS2trQyxnQkFBZ0J0N0Isb0JBQW9CLE1BQU0sUUFBUTVJLE9BQU8sS0FBSyxJQUFJQSxLQUFLLEVBQUUsQ0FBRTtvQkFDdkcsSUFBSSxDQUFDbWtDLFlBQVlybUMsSUFBSSxFQUFFO3dCQUNuQixNQUFNLElBQUloSyxNQUFNO29CQUNwQjtvQkFDQSxJQUFJa3dDLFNBQVNydEMsR0FBRyxDQUFDd3RDLFlBQVlybUMsSUFBSSxHQUFHO3dCQUNoQyxNQUFNLElBQUloSyxNQUFNLG9DQUFxRCxPQUFqQnF3QyxZQUFZcm1DLElBQUk7b0JBQ3hFO29CQUNBa21DLFNBQVNuTSxHQUFHLENBQUNzTSxZQUFZcm1DLElBQUksRUFBRTZqQztnQkFDbkM7WUFDSjtRQUNKO1FBQ0EsT0FBT3FDO0lBQ1g7SUFDQSxNQUFNSSxpQkFBaUJ4dEIsTUFBTSxFQUFFO1FBQzNCLElBQUloa0IsSUFBSUMsSUFBSW1OO1FBQ1osTUFBTXFrQyxpQkFBaUIsQ0FBQ3JrQyxLQUFLLENBQUNuTixLQUFLLENBQUNELEtBQUtna0IsT0FBTzlTLE1BQU0sTUFBTSxRQUFRbFIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHOHZDLHdCQUF3QixNQUFNLFFBQVE3dkMsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHaXdDLGtCQUFrQixNQUFNLFFBQVE5aUMsT0FBTyxLQUFLLElBQUlBLEtBQUt3aUM7UUFDdk4sSUFBSThCLHNCQUFzQjtRQUMxQixJQUFJQyxrQkFBa0I7UUFDdEIsTUFBTUMsY0FBYyxNQUFNLElBQUksQ0FBQ1QsZUFBZSxDQUFDbnRCO1FBQy9DLE9BQU8sU0FBVzZ0QixNQUFNLEVBQUVULFFBQVEsRUFBRXB0QixNQUFNO1lBQ3RDLElBQUloa0IsSUFBSUM7WUFDUixPQUFPb3JCLGlCQUFpQixJQUFJLEVBQUUyRCxXQUFXO2dCQUNyQyxJQUFJNWhCLElBQUk4aEIsS0FBSzdoQixJQUFJQztnQkFDakIsTUFBT3FrQyxrQkFBa0JGLGVBQWdCO29CQUNyQyxJQUFJQyxxQkFBcUI7d0JBQ3JCQzt3QkFDQUQsc0JBQXNCO29CQUMxQjtvQkFDQSxNQUFNSSxvQkFBb0IsTUFBTTFtQixRQUFReW1CLE9BQU9mLDZCQUE2QixDQUFDOXNCO29CQUM3RSxNQUFNelksV0FBVyxNQUFNNmYsUUFBUXltQixPQUFPRSw2QkFBNkIsQ0FBQ0Q7b0JBQ3BFLE1BQU05L0Isb0JBQW9CLEVBQUU7b0JBQzVCLE1BQU1nZ0MsbUJBQW1CLEVBQUU7b0JBQzNCLElBQUk7d0JBQ0EsSUFBSyxJQUFJemtDLEtBQUssTUFBTTBrQyxhQUFjL2lCLENBQUFBLE1BQU0sS0FBSyxHQUFHckMsY0FBY3RoQixTQUFRLEdBQUkybUMsY0FBY0EsZUFBZSxNQUFNOW1CLFFBQVE2bUIsV0FBV2h0QixJQUFJLEtBQUs3WCxLQUFLOGtDLGFBQWE5c0IsSUFBSSxFQUFFLENBQUNoWSxJQUFJRyxLQUFLLEtBQU07NEJBQzdLRCxLQUFLNGtDLGFBQWFseEMsS0FBSzs0QkFDdkJ1TSxLQUFLOzRCQUNMLE1BQU04aEIsUUFBUS9oQjs0QkFDZCxNQUFNLE1BQU04ZCxRQUFRaUU7NEJBQ3BCLElBQUlBLE1BQU0zaEIsVUFBVSxJQUFLLEVBQUMxTixLQUFLcXZCLE1BQU0zaEIsVUFBVSxDQUFDLEVBQUUsTUFBTSxRQUFRMU4sT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHMk4sT0FBTyxHQUFHO2dDQUNsR3FrQyxpQkFBaUI1dEMsSUFBSSxDQUFDaXJCLE1BQU0zaEIsVUFBVSxDQUFDLEVBQUUsQ0FBQ0MsT0FBTztnQ0FDakQsS0FBSyxNQUFNcEIsUUFBUSxDQUFDdE0sS0FBS292QixNQUFNM2hCLFVBQVUsQ0FBQyxFQUFFLENBQUNDLE9BQU8sQ0FBQ25DLEtBQUssTUFBTSxRQUFRdkwsT0FBTyxLQUFLLElBQUlBLEtBQUssRUFBRSxDQUFFO29DQUM3RixJQUFJMHhDLGtCQUFrQkYsa0JBQWtCbGxDLEtBQUtuQixZQUFZLEVBQUU7d0NBQ3ZELElBQUksQ0FBQ21CLEtBQUtuQixZQUFZLENBQUNGLElBQUksRUFBRTs0Q0FDekIsTUFBTSxJQUFJaEssTUFBTTt3Q0FDcEI7d0NBQ0EsSUFBSSxDQUFDa3dDLFNBQVNydEMsR0FBRyxDQUFDd0ksS0FBS25CLFlBQVksQ0FBQ0YsSUFBSSxHQUFHOzRDQUN2QyxNQUFNLElBQUloSyxNQUFNLHlJQUEwS3FMLE9BQWpDNmtDLFNBQVMvdkMsSUFBSSxJQUFHLG1CQUF3QyxPQUF2QmtMLEtBQUtuQixZQUFZLENBQUNGLElBQUk7d0NBQ3BOLE9BQ0s7NENBQ0QsTUFBTWluQyxnQkFBZ0IsTUFBTS9tQixRQUFRZ21CLFNBQy9CNXBCLEdBQUcsQ0FBQ2piLEtBQUtuQixZQUFZLENBQUNGLElBQUksRUFDMUI2L0IsUUFBUSxDQUFDO2dEQUFDeCtCLEtBQUtuQixZQUFZOzZDQUFDOzRDQUNqQzRHLGtCQUFrQjVOLElBQUksSUFBSSt0Qzt3Q0FDOUI7b0NBQ0o7Z0NBQ0o7NEJBQ0o7d0JBQ0o7b0JBQ0osRUFDQSxPQUFPN2lCLE9BQU87d0JBQUVKLE1BQU07NEJBQUV6c0IsT0FBTzZzQjt3QkFBTTtvQkFBRyxTQUNoQzt3QkFDSixJQUFJOzRCQUNBLElBQUksQ0FBQy9oQixNQUFNLENBQUNILE1BQU9DLENBQUFBLEtBQUs0a0MsV0FBVzVzQixNQUFNLEdBQUcsTUFBTStGLFFBQVEvZCxHQUFHdE0sSUFBSSxDQUFDa3hDO3dCQUN0RSxTQUNROzRCQUFFLElBQUkvaUIsS0FBSyxNQUFNQSxJQUFJenNCLEtBQUs7d0JBQUU7b0JBQ3hDO29CQUNBLElBQUl1UCxrQkFBa0J6USxNQUFNLEdBQUcsR0FBRzt3QkFDOUJtd0Msc0JBQXNCO3dCQUN0QixNQUFNVSxxQkFBcUIsSUFBSWpsQzt3QkFDL0JpbEMsbUJBQW1CMWtDLFVBQVUsR0FBRzs0QkFDNUI7Z0NBQ0lDLFNBQVM7b0NBQ0xsQixNQUFNO29DQUNOakIsT0FBT3dHO2dDQUNYOzRCQUNKO3lCQUNIO3dCQUNELE1BQU0sTUFBTW9aLFFBQVFnbkI7d0JBQ3BCLE1BQU1DLGNBQWMsRUFBRTt3QkFDdEJBLFlBQVlqdUMsSUFBSSxJQUFJNHRDO3dCQUNwQkssWUFBWWp1QyxJQUFJLENBQUM7NEJBQ2JxSSxNQUFNOzRCQUNOakIsT0FBT3dHO3dCQUNYO3dCQUNBLE1BQU1zZ0Msa0JBQWtCdCtCLFVBQVVnUSxPQUFPbUssUUFBUSxFQUFFRSxNQUFNLENBQUNna0I7d0JBQzFEcnVCLE9BQU9tSyxRQUFRLEdBQUdta0I7b0JBQ3RCLE9BQ0s7d0JBQ0Q7b0JBQ0o7Z0JBQ0o7WUFDSjtRQUNKLEVBQUcsSUFBSSxFQUFFVixhQUFhNXRCO0lBQzFCO0lBQ0EsTUFBTXV1Qix3QkFBd0J2dUIsTUFBTSxFQUFFO1FBQ2xDLElBQUloa0IsSUFBSUMsSUFBSW1OLElBQUlDO1FBQ2hCLElBQUk5QjtRQUNKLElBQUlxYSxPQUFPO1FBQ1gsSUFBSW1CLGNBQWMsQ0FBQztRQUNuQixJQUFJLElBQUksQ0FBQ3hVLFNBQVMsQ0FBQ0csVUFBVSxJQUFJO1lBQzdCLE1BQU1nVCxPQUFPNlQsa0NBQWtDLElBQUksQ0FBQ2huQixTQUFTLEVBQUV5UjtZQUMvRDRCLE9BQU92bEIsVUFBVSwyQkFBMkJxbEIsSUFBSSxDQUFDLE9BQU87WUFDeERxQixjQUFjckIsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJuYSxXQUFXLElBQUksQ0FBQ2dILFNBQVMsQ0FDcEJnVCxPQUFPLENBQUM7Z0JBQ1RLLE1BQU1BO2dCQUNObUIsYUFBYUE7Z0JBQ2JyQixNQUFNc0IsS0FBS0MsU0FBUyxDQUFDdkI7Z0JBQ3JCd0IsWUFBWTtnQkFDWnRuQixhQUFhLENBQUNJLEtBQUtna0IsT0FBTzlTLE1BQU0sTUFBTSxRQUFRbFIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSixXQUFXO2dCQUNyRnVuQixhQUFhLENBQUNsbkIsS0FBSytqQixPQUFPOVMsTUFBTSxNQUFNLFFBQVFqUixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdrbkIsV0FBVztZQUN6RixHQUNLQyxJQUFJLENBQUMsQ0FBQ0M7Z0JBQ1AsT0FBT0EsYUFBYXphLElBQUksR0FBR3dhLElBQUksQ0FBQyxDQUFDTztvQkFDN0IsTUFBTXBjLFdBQVdvYztvQkFDakJwYyxTQUFTNlksZUFBZSxHQUFHO3dCQUN2QnJYLFNBQVNzYSxhQUFhdGEsT0FBTztvQkFDakM7b0JBQ0EsT0FBT3hCO2dCQUNYO1lBQ0o7WUFDQSxPQUFPQSxTQUFTNmIsSUFBSSxDQUFDLENBQUMvWDtnQkFDbEIsTUFBTWlZLE9BQU9tUyxrQ0FBa0NwcUI7Z0JBQy9DLE1BQU11WSxZQUFZLElBQUl6YTtnQkFDdEJ2TSxPQUFPd0IsTUFBTSxDQUFDd2xCLFdBQVdOO2dCQUN6QixPQUFPTTtZQUNYO1FBQ0osT0FDSztZQUNELE1BQU1sQyxPQUFPNFQsaUNBQWlDLElBQUksQ0FBQy9tQixTQUFTLEVBQUV5UjtZQUM5RDRCLE9BQU92bEIsVUFBVSwyQkFBMkJxbEIsSUFBSSxDQUFDLE9BQU87WUFDeERxQixjQUFjckIsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJuYSxXQUFXLElBQUksQ0FBQ2dILFNBQVMsQ0FDcEJnVCxPQUFPLENBQUM7Z0JBQ1RLLE1BQU1BO2dCQUNObUIsYUFBYUE7Z0JBQ2JyQixNQUFNc0IsS0FBS0MsU0FBUyxDQUFDdkI7Z0JBQ3JCd0IsWUFBWTtnQkFDWnRuQixhQUFhLENBQUN3TixLQUFLNFcsT0FBTzlTLE1BQU0sTUFBTSxRQUFROUQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHeE4sV0FBVztnQkFDckZ1bkIsYUFBYSxDQUFDOVosS0FBSzJXLE9BQU85UyxNQUFNLE1BQU0sUUFBUTdELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzhaLFdBQVc7WUFDekYsR0FDS0MsSUFBSSxDQUFDLENBQUNDO2dCQUNQLE9BQU9BLGFBQWF6YSxJQUFJLEdBQUd3YSxJQUFJLENBQUMsQ0FBQ087b0JBQzdCLE1BQU1wYyxXQUFXb2M7b0JBQ2pCcGMsU0FBUzZZLGVBQWUsR0FBRzt3QkFDdkJyWCxTQUFTc2EsYUFBYXRhLE9BQU87b0JBQ2pDO29CQUNBLE9BQU94QjtnQkFDWDtZQUNKO1lBQ0EsT0FBT0EsU0FBUzZiLElBQUksQ0FBQyxDQUFDL1g7Z0JBQ2xCLE1BQU1pWSxPQUFPa1MsaUNBQWlDbnFCO2dCQUM5QyxNQUFNdVksWUFBWSxJQUFJemE7Z0JBQ3RCdk0sT0FBT3dCLE1BQU0sQ0FBQ3dsQixXQUFXTjtnQkFDekIsT0FBT007WUFDWDtRQUNKO0lBQ0o7SUFDQSxNQUFNbXFCLDhCQUE4Qi90QixNQUFNLEVBQUU7UUFDeEMsSUFBSWhrQixJQUFJQyxJQUFJbU4sSUFBSUM7UUFDaEIsSUFBSTlCO1FBQ0osSUFBSXFhLE9BQU87UUFDWCxJQUFJbUIsY0FBYyxDQUFDO1FBQ25CLElBQUksSUFBSSxDQUFDeFUsU0FBUyxDQUFDRyxVQUFVLElBQUk7WUFDN0IsTUFBTWdULE9BQU82VCxrQ0FBa0MsSUFBSSxDQUFDaG5CLFNBQVMsRUFBRXlSO1lBQy9ENEIsT0FBT3ZsQixVQUFVLHlDQUF5Q3FsQixJQUFJLENBQUMsT0FBTztZQUN0RXFCLGNBQWNyQixJQUFJLENBQUMsU0FBUztZQUM1QixPQUFPQSxJQUFJLENBQUMsT0FBTztZQUNuQixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQixNQUFNblQsWUFBWSxJQUFJLENBQUNBLFNBQVM7WUFDaENoSCxXQUFXZ0gsVUFBVXl5QixhQUFhLENBQUM7Z0JBQy9CcGYsTUFBTUE7Z0JBQ05tQixhQUFhQTtnQkFDYnJCLE1BQU1zQixLQUFLQyxTQUFTLENBQUN2QjtnQkFDckJ3QixZQUFZO2dCQUNadG5CLGFBQWEsQ0FBQ0ksS0FBS2drQixPQUFPOVMsTUFBTSxNQUFNLFFBQVFsUixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdKLFdBQVc7Z0JBQ3JGdW5CLGFBQWEsQ0FBQ2xuQixLQUFLK2pCLE9BQU85UyxNQUFNLE1BQU0sUUFBUWpSLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2tuQixXQUFXO1lBQ3pGO1lBQ0EsT0FBTzViLFNBQVM2YixJQUFJLENBQUMsU0FBVS9YLFdBQVc7Z0JBQ3RDLE9BQU9nYyxpQkFBaUIsSUFBSSxFQUFFMkQsV0FBVztvQkFDckMsSUFBSWh2QixJQUFJd3lDLEtBQUt2eUMsSUFBSW1OO29CQUNqQixJQUFJO3dCQUNBLElBQUssSUFBSUMsS0FBSyxNQUFNb2xDLGdCQUFnQjVsQixjQUFjeGQsY0FBY3FqQyxpQkFBaUJBLGtCQUFrQixNQUFNdG5CLFFBQVFxbkIsY0FBY3h0QixJQUFJLEtBQUtqbEIsS0FBSzB5QyxnQkFBZ0J0dEIsSUFBSSxFQUFFLENBQUNwbEIsSUFBSXFOLEtBQUssS0FBTTs0QkFDL0tELEtBQUtzbEMsZ0JBQWdCMXhDLEtBQUs7NEJBQzFCcU0sS0FBSzs0QkFDTCxNQUFNZ2lCLFFBQVFqaUI7NEJBQ2QsTUFBTWthLE9BQU9tUyxrQ0FBbUMsT0FBTXJPLFFBQVFpRSxNQUFNemlCLElBQUksR0FBRTs0QkFDMUUwYSxJQUFJLENBQUMsa0JBQWtCLEdBQUc7Z0NBQ3RCdmEsU0FBU3NpQixNQUFNdGlCLE9BQU87NEJBQzFCOzRCQUNBLE1BQU02YSxZQUFZLElBQUl6YTs0QkFDdEJ2TSxPQUFPd0IsTUFBTSxDQUFDd2xCLFdBQVdOOzRCQUN6QixNQUFNLE1BQU04RCxRQUFReEQ7d0JBQ3hCO29CQUNKLEVBQ0EsT0FBTytxQixPQUFPO3dCQUFFSCxNQUFNOzRCQUFFL3ZDLE9BQU9rd0M7d0JBQU07b0JBQUcsU0FDaEM7d0JBQ0osSUFBSTs0QkFDQSxJQUFJLENBQUN0bEMsTUFBTSxDQUFDck4sTUFBT0MsQ0FBQUEsS0FBS3d5QyxjQUFjcHRCLE1BQU0sR0FBRyxNQUFNK0YsUUFBUW5yQixHQUFHYyxJQUFJLENBQUMweEM7d0JBQ3pFLFNBQ1E7NEJBQUUsSUFBSUQsS0FBSyxNQUFNQSxJQUFJL3ZDLEtBQUs7d0JBQUU7b0JBQ3hDO2dCQUNKO1lBQ0o7UUFDSixPQUNLO1lBQ0QsTUFBTWlqQixPQUFPNFQsaUNBQWlDLElBQUksQ0FBQy9tQixTQUFTLEVBQUV5UjtZQUM5RDRCLE9BQU92bEIsVUFBVSx5Q0FBeUNxbEIsSUFBSSxDQUFDLE9BQU87WUFDdEVxQixjQUFjckIsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckIsTUFBTW5ULFlBQVksSUFBSSxDQUFDQSxTQUFTO1lBQ2hDaEgsV0FBV2dILFVBQVV5eUIsYUFBYSxDQUFDO2dCQUMvQnBmLE1BQU1BO2dCQUNObUIsYUFBYUE7Z0JBQ2JyQixNQUFNc0IsS0FBS0MsU0FBUyxDQUFDdkI7Z0JBQ3JCd0IsWUFBWTtnQkFDWnRuQixhQUFhLENBQUN3TixLQUFLNFcsT0FBTzlTLE1BQU0sTUFBTSxRQUFROUQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHeE4sV0FBVztnQkFDckZ1bkIsYUFBYSxDQUFDOVosS0FBSzJXLE9BQU85UyxNQUFNLE1BQU0sUUFBUTdELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzhaLFdBQVc7WUFDekY7WUFDQSxPQUFPNWIsU0FBUzZiLElBQUksQ0FBQyxTQUFVL1gsV0FBVztnQkFDdEMsT0FBT2djLGlCQUFpQixJQUFJLEVBQUUyRCxXQUFXO29CQUNyQyxJQUFJaHZCLElBQUk0eUMsS0FBSzN5QyxJQUFJbU47b0JBQ2pCLElBQUk7d0JBQ0EsSUFBSyxJQUFJQyxLQUFLLE1BQU13bEMsZ0JBQWdCaG1CLGNBQWN4ZCxjQUFjeWpDLGlCQUFpQkEsa0JBQWtCLE1BQU0xbkIsUUFBUXluQixjQUFjNXRCLElBQUksS0FBS2psQixLQUFLOHlDLGdCQUFnQjF0QixJQUFJLEVBQUUsQ0FBQ3BsQixJQUFJcU4sS0FBSyxLQUFNOzRCQUMvS0QsS0FBSzBsQyxnQkFBZ0I5eEMsS0FBSzs0QkFDMUJxTSxLQUFLOzRCQUNMLE1BQU1naUIsUUFBUWppQjs0QkFDZCxNQUFNa2EsT0FBT2tTLGlDQUFrQyxPQUFNcE8sUUFBUWlFLE1BQU16aUIsSUFBSSxHQUFFOzRCQUN6RTBhLElBQUksQ0FBQyxrQkFBa0IsR0FBRztnQ0FDdEJ2YSxTQUFTc2lCLE1BQU10aUIsT0FBTzs0QkFDMUI7NEJBQ0EsTUFBTTZhLFlBQVksSUFBSXphOzRCQUN0QnZNLE9BQU93QixNQUFNLENBQUN3bEIsV0FBV047NEJBQ3pCLE1BQU0sTUFBTThELFFBQVF4RDt3QkFDeEI7b0JBQ0osRUFDQSxPQUFPbXJCLE9BQU87d0JBQUVILE1BQU07NEJBQUVud0MsT0FBT3N3Qzt3QkFBTTtvQkFBRyxTQUNoQzt3QkFDSixJQUFJOzRCQUNBLElBQUksQ0FBQzFsQyxNQUFNLENBQUNyTixNQUFPQyxDQUFBQSxLQUFLNHlDLGNBQWN4dEIsTUFBTSxHQUFHLE1BQU0rRixRQUFRbnJCLEdBQUdjLElBQUksQ0FBQzh4Qzt3QkFDekUsU0FDUTs0QkFBRSxJQUFJRCxLQUFLLE1BQU1BLElBQUlud0MsS0FBSzt3QkFBRTtvQkFDeEM7Z0JBQ0o7WUFDSjtRQUNKO0lBQ0o7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FvQkMsR0FDRCxNQUFNdXdDLGFBQWFodkIsTUFBTSxFQUFFO1FBQ3ZCLElBQUloa0IsSUFBSUMsSUFBSW1OLElBQUlDO1FBQ2hCLElBQUk5QjtRQUNKLElBQUlxYSxPQUFPO1FBQ1gsSUFBSW1CLGNBQWMsQ0FBQztRQUNuQixJQUFJLElBQUksQ0FBQ3hVLFNBQVMsQ0FBQ0csVUFBVSxJQUFJO1lBQzdCLE1BQU1nVCxPQUFPMFMsK0JBQStCLElBQUksQ0FBQzdsQixTQUFTLEVBQUV5UjtZQUM1RDRCLE9BQU92bEIsVUFBVSxtQkFBbUJxbEIsSUFBSSxDQUFDLE9BQU87WUFDaERxQixjQUFjckIsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJuYSxXQUFXLElBQUksQ0FBQ2dILFNBQVMsQ0FDcEJnVCxPQUFPLENBQUM7Z0JBQ1RLLE1BQU1BO2dCQUNObUIsYUFBYUE7Z0JBQ2JyQixNQUFNc0IsS0FBS0MsU0FBUyxDQUFDdkI7Z0JBQ3JCd0IsWUFBWTtnQkFDWnRuQixhQUFhLENBQUNJLEtBQUtna0IsT0FBTzlTLE1BQU0sTUFBTSxRQUFRbFIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSixXQUFXO2dCQUNyRnVuQixhQUFhLENBQUNsbkIsS0FBSytqQixPQUFPOVMsTUFBTSxNQUFNLFFBQVFqUixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdrbkIsV0FBVztZQUN6RixHQUNLQyxJQUFJLENBQUMsQ0FBQ0M7Z0JBQ1AsT0FBT0EsYUFBYXphLElBQUksR0FBR3dhLElBQUksQ0FBQyxDQUFDTztvQkFDN0IsTUFBTXBjLFdBQVdvYztvQkFDakJwYyxTQUFTNlksZUFBZSxHQUFHO3dCQUN2QnJYLFNBQVNzYSxhQUFhdGEsT0FBTztvQkFDakM7b0JBQ0EsT0FBT3hCO2dCQUNYO1lBQ0o7WUFDQSxPQUFPQSxTQUFTNmIsSUFBSSxDQUFDLENBQUMvWDtnQkFDbEIsTUFBTWlZLE9BQU9pUiwrQkFBK0JscEI7Z0JBQzVDLE1BQU11WSxZQUFZLElBQUlwWjtnQkFDdEI1TixPQUFPd0IsTUFBTSxDQUFDd2xCLFdBQVdOO2dCQUN6QixPQUFPTTtZQUNYO1FBQ0osT0FDSztZQUNELE1BQU1sQyxPQUFPd1MsOEJBQThCLElBQUksQ0FBQzNsQixTQUFTLEVBQUV5UjtZQUMzRDRCLE9BQU92bEIsVUFBVSw4QkFBOEJxbEIsSUFBSSxDQUFDLE9BQU87WUFDM0RxQixjQUFjckIsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJuYSxXQUFXLElBQUksQ0FBQ2dILFNBQVMsQ0FDcEJnVCxPQUFPLENBQUM7Z0JBQ1RLLE1BQU1BO2dCQUNObUIsYUFBYUE7Z0JBQ2JyQixNQUFNc0IsS0FBS0MsU0FBUyxDQUFDdkI7Z0JBQ3JCd0IsWUFBWTtnQkFDWnRuQixhQUFhLENBQUN3TixLQUFLNFcsT0FBTzlTLE1BQU0sTUFBTSxRQUFROUQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHeE4sV0FBVztnQkFDckZ1bkIsYUFBYSxDQUFDOVosS0FBSzJXLE9BQU85UyxNQUFNLE1BQU0sUUFBUTdELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzhaLFdBQVc7WUFDekYsR0FDS0MsSUFBSSxDQUFDLENBQUNDO2dCQUNQLE9BQU9BLGFBQWF6YSxJQUFJLEdBQUd3YSxJQUFJLENBQUMsQ0FBQ087b0JBQzdCLE1BQU1wYyxXQUFXb2M7b0JBQ2pCcGMsU0FBUzZZLGVBQWUsR0FBRzt3QkFDdkJyWCxTQUFTc2EsYUFBYXRhLE9BQU87b0JBQ2pDO29CQUNBLE9BQU94QjtnQkFDWDtZQUNKO1lBQ0EsT0FBT0EsU0FBUzZiLElBQUksQ0FBQyxDQUFDL1g7Z0JBQ2xCLE1BQU1pWSxPQUFPK1EsOEJBQThCaHBCO2dCQUMzQyxNQUFNdVksWUFBWSxJQUFJcFo7Z0JBQ3RCNU4sT0FBT3dCLE1BQU0sQ0FBQ3dsQixXQUFXTjtnQkFDekIsT0FBT007WUFDWDtRQUNKO0lBQ0o7SUFDQTs7S0FFQyxHQUNELE1BQU1xckIsdUJBQXVCanZCLE1BQU0sRUFBRTtRQUNqQyxJQUFJaGtCLElBQUlDLElBQUltTixJQUFJQztRQUNoQixJQUFJOUI7UUFDSixJQUFJcWEsT0FBTztRQUNYLElBQUltQixjQUFjLENBQUM7UUFDbkIsSUFBSSxJQUFJLENBQUN4VSxTQUFTLENBQUNHLFVBQVUsSUFBSTtZQUM3QixNQUFNZ1QsT0FBT29VLGlDQUFpQyxJQUFJLENBQUN2bkIsU0FBUyxFQUFFeVI7WUFDOUQ0QixPQUFPdmxCLFVBQVUsbUJBQW1CcWxCLElBQUksQ0FBQyxPQUFPO1lBQ2hEcUIsY0FBY3JCLElBQUksQ0FBQyxTQUFTO1lBQzVCLE9BQU9BLElBQUksQ0FBQyxPQUFPO1lBQ25CLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCbmEsV0FBVyxJQUFJLENBQUNnSCxTQUFTLENBQ3BCZ1QsT0FBTyxDQUFDO2dCQUNUSyxNQUFNQTtnQkFDTm1CLGFBQWFBO2dCQUNickIsTUFBTXNCLEtBQUtDLFNBQVMsQ0FBQ3ZCO2dCQUNyQndCLFlBQVk7Z0JBQ1p0bkIsYUFBYSxDQUFDSSxLQUFLZ2tCLE9BQU85UyxNQUFNLE1BQU0sUUFBUWxSLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0osV0FBVztnQkFDckZ1bkIsYUFBYSxDQUFDbG5CLEtBQUsrakIsT0FBTzlTLE1BQU0sTUFBTSxRQUFRalIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHa25CLFdBQVc7WUFDekYsR0FDS0MsSUFBSSxDQUFDLENBQUNDO2dCQUNQLE9BQU9BLGFBQWF6YSxJQUFJLEdBQUd3YSxJQUFJLENBQUMsQ0FBQ087b0JBQzdCLE1BQU1wYyxXQUFXb2M7b0JBQ2pCcGMsU0FBUzZZLGVBQWUsR0FBRzt3QkFDdkJyWCxTQUFTc2EsYUFBYXRhLE9BQU87b0JBQ2pDO29CQUNBLE9BQU94QjtnQkFDWDtZQUNKO1lBQ0EsT0FBT0EsU0FBUzZiLElBQUksQ0FBQyxDQUFDL1g7Z0JBQ2xCLE1BQU1pWSxPQUFPNlMsaUNBQWlDOXFCO2dCQUM5QyxNQUFNdVksWUFBWSxJQUFJblo7Z0JBQ3RCN04sT0FBT3dCLE1BQU0sQ0FBQ3dsQixXQUFXTjtnQkFDekIsT0FBT007WUFDWDtRQUNKLE9BQ0s7WUFDRCxNQUFNbEMsT0FBT21VLGdDQUFnQyxJQUFJLENBQUN0bkIsU0FBUyxFQUFFeVI7WUFDN0Q0QixPQUFPdmxCLFVBQVUsbUJBQW1CcWxCLElBQUksQ0FBQyxPQUFPO1lBQ2hEcUIsY0FBY3JCLElBQUksQ0FBQyxTQUFTO1lBQzVCLE9BQU9BLElBQUksQ0FBQyxPQUFPO1lBQ25CLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCbmEsV0FBVyxJQUFJLENBQUNnSCxTQUFTLENBQ3BCZ1QsT0FBTyxDQUFDO2dCQUNUSyxNQUFNQTtnQkFDTm1CLGFBQWFBO2dCQUNickIsTUFBTXNCLEtBQUtDLFNBQVMsQ0FBQ3ZCO2dCQUNyQndCLFlBQVk7Z0JBQ1p0bkIsYUFBYSxDQUFDd04sS0FBSzRXLE9BQU85UyxNQUFNLE1BQU0sUUFBUTlELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3hOLFdBQVc7Z0JBQ3JGdW5CLGFBQWEsQ0FBQzlaLEtBQUsyVyxPQUFPOVMsTUFBTSxNQUFNLFFBQVE3RCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUc4WixXQUFXO1lBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQztnQkFDUCxPQUFPQSxhQUFhemEsSUFBSSxHQUFHd2EsSUFBSSxDQUFDLENBQUNPO29CQUM3QixNQUFNcGMsV0FBV29jO29CQUNqQnBjLFNBQVM2WSxlQUFlLEdBQUc7d0JBQ3ZCclgsU0FBU3NhLGFBQWF0YSxPQUFPO29CQUNqQztvQkFDQSxPQUFPeEI7Z0JBQ1g7WUFDSjtZQUNBLE9BQU9BLFNBQVM2YixJQUFJLENBQUMsQ0FBQy9YO2dCQUNsQixNQUFNaVksT0FBT3lTLGdDQUFnQzFxQjtnQkFDN0MsTUFBTXVZLFlBQVksSUFBSW5aO2dCQUN0QjdOLE9BQU93QixNQUFNLENBQUN3bEIsV0FBV047Z0JBQ3pCLE9BQU9NO1lBQ1g7UUFDSjtJQUNKO0lBQ0E7O0tBRUMsR0FDRCxNQUFNc3JCLGtCQUFrQmx2QixNQUFNLEVBQUU7UUFDNUIsSUFBSWhrQixJQUFJQztRQUNSLElBQUlzTDtRQUNKLElBQUlxYSxPQUFPO1FBQ1gsSUFBSW1CLGNBQWMsQ0FBQztRQUNuQixJQUFJLElBQUksQ0FBQ3hVLFNBQVMsQ0FBQ0csVUFBVSxJQUFJO1lBQzdCLE1BQU1nVCxPQUFPOFIsb0NBQW9DLElBQUksQ0FBQ2psQixTQUFTLEVBQUV5UjtZQUNqRTRCLE9BQU92bEIsVUFBVSxtQkFBbUJxbEIsSUFBSSxDQUFDLE9BQU87WUFDaERxQixjQUFjckIsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJuYSxXQUFXLElBQUksQ0FBQ2dILFNBQVMsQ0FDcEJnVCxPQUFPLENBQUM7Z0JBQ1RLLE1BQU1BO2dCQUNObUIsYUFBYUE7Z0JBQ2JyQixNQUFNc0IsS0FBS0MsU0FBUyxDQUFDdkI7Z0JBQ3JCd0IsWUFBWTtnQkFDWnRuQixhQUFhLENBQUNJLEtBQUtna0IsT0FBTzlTLE1BQU0sTUFBTSxRQUFRbFIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSixXQUFXO2dCQUNyRnVuQixhQUFhLENBQUNsbkIsS0FBSytqQixPQUFPOVMsTUFBTSxNQUFNLFFBQVFqUixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdrbkIsV0FBVztZQUN6RixHQUNLQyxJQUFJLENBQUMsQ0FBQ0M7Z0JBQ1AsT0FBT0EsYUFBYXphLElBQUksR0FBR3dhLElBQUksQ0FBQyxDQUFDTztvQkFDN0IsTUFBTXBjLFdBQVdvYztvQkFDakJwYyxTQUFTNlksZUFBZSxHQUFHO3dCQUN2QnJYLFNBQVNzYSxhQUFhdGEsT0FBTztvQkFDakM7b0JBQ0EsT0FBT3hCO2dCQUNYO1lBQ0o7WUFDQSxPQUFPQSxTQUFTNmIsSUFBSSxDQUFDLENBQUMvWDtnQkFDbEIsTUFBTWlZLE9BQU9zUSw0QkFBNEJ2b0I7Z0JBQ3pDLE1BQU11WSxZQUFZLElBQUlsWjtnQkFDdEI5TixPQUFPd0IsTUFBTSxDQUFDd2xCLFdBQVdOO2dCQUN6QixPQUFPTTtZQUNYO1FBQ0osT0FDSztZQUNELE1BQU0sSUFBSTFtQixNQUFNO1FBQ3BCO0lBQ0o7SUFDQTs7S0FFQyxHQUNELE1BQU1peUMscUJBQXFCbnZCLE1BQU0sRUFBRTtRQUMvQixJQUFJaGtCLElBQUlDO1FBQ1IsSUFBSXNMO1FBQ0osSUFBSXFhLE9BQU87UUFDWCxJQUFJbUIsY0FBYyxDQUFDO1FBQ25CLElBQUksSUFBSSxDQUFDeFUsU0FBUyxDQUFDRyxVQUFVLElBQUk7WUFDN0IsTUFBTWdULE9BQU9tYiwwQ0FBMEMsSUFBSSxDQUFDdHVCLFNBQVMsRUFBRXlSO1lBQ3ZFNEIsT0FBT3ZsQixVQUFVLG1CQUFtQnFsQixJQUFJLENBQUMsT0FBTztZQUNoRHFCLGNBQWNyQixJQUFJLENBQUMsU0FBUztZQUM1QixPQUFPQSxJQUFJLENBQUMsT0FBTztZQUNuQixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQm5hLFdBQVcsSUFBSSxDQUFDZ0gsU0FBUyxDQUNwQmdULE9BQU8sQ0FBQztnQkFDVEssTUFBTUE7Z0JBQ05tQixhQUFhQTtnQkFDYnJCLE1BQU1zQixLQUFLQyxTQUFTLENBQUN2QjtnQkFDckJ3QixZQUFZO2dCQUNadG5CLGFBQWEsQ0FBQ0ksS0FBS2drQixPQUFPOVMsTUFBTSxNQUFNLFFBQVFsUixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdKLFdBQVc7Z0JBQ3JGdW5CLGFBQWEsQ0FBQ2xuQixLQUFLK2pCLE9BQU85UyxNQUFNLE1BQU0sUUFBUWpSLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2tuQixXQUFXO1lBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQztnQkFDUCxPQUFPQSxhQUFhemEsSUFBSSxHQUFHd2EsSUFBSSxDQUFDLENBQUNPO29CQUM3QixNQUFNcGMsV0FBV29jO29CQUNqQnBjLFNBQVM2WSxlQUFlLEdBQUc7d0JBQ3ZCclgsU0FBU3NhLGFBQWF0YSxPQUFPO29CQUNqQztvQkFDQSxPQUFPeEI7Z0JBQ1g7WUFDSjtZQUNBLE9BQU9BLFNBQVM2YixJQUFJLENBQUMsQ0FBQy9YO2dCQUNsQixNQUFNaVksT0FBT3laLCtCQUErQjF4QjtnQkFDNUMsTUFBTXVZLFlBQVksSUFBSWpaO2dCQUN0Qi9OLE9BQU93QixNQUFNLENBQUN3bEIsV0FBV047Z0JBQ3pCLE9BQU9NO1lBQ1g7UUFDSixPQUNLO1lBQ0QsTUFBTSxJQUFJMW1CLE1BQU07UUFDcEI7SUFDSjtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBcUNDLEdBQ0QsTUFBTWt5QyxlQUFlcHZCLE1BQU0sRUFBRTtRQUN6QixJQUFJaGtCLElBQUlDO1FBQ1IsSUFBSXNMO1FBQ0osSUFBSXFhLE9BQU87UUFDWCxJQUFJbUIsY0FBYyxDQUFDO1FBQ25CLElBQUksSUFBSSxDQUFDeFUsU0FBUyxDQUFDRyxVQUFVLElBQUk7WUFDN0IsTUFBTWdULE9BQU9rWixpQ0FBaUMsSUFBSSxDQUFDcnNCLFNBQVMsRUFBRXlSO1lBQzlENEIsT0FBT3ZsQixVQUFVLG1CQUFtQnFsQixJQUFJLENBQUMsT0FBTztZQUNoRHFCLGNBQWNyQixJQUFJLENBQUMsU0FBUztZQUM1QixPQUFPQSxJQUFJLENBQUMsT0FBTztZQUNuQixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQm5hLFdBQVcsSUFBSSxDQUFDZ0gsU0FBUyxDQUNwQmdULE9BQU8sQ0FBQztnQkFDVEssTUFBTUE7Z0JBQ05tQixhQUFhQTtnQkFDYnJCLE1BQU1zQixLQUFLQyxTQUFTLENBQUN2QjtnQkFDckJ3QixZQUFZO2dCQUNadG5CLGFBQWEsQ0FBQ0ksS0FBS2drQixPQUFPOVMsTUFBTSxNQUFNLFFBQVFsUixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdKLFdBQVc7Z0JBQ3JGdW5CLGFBQWEsQ0FBQ2xuQixLQUFLK2pCLE9BQU85UyxNQUFNLE1BQU0sUUFBUWpSLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2tuQixXQUFXO1lBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQztnQkFDUCxPQUFPQSxhQUFhemEsSUFBSTtZQUM1QjtZQUNBLE9BQU9yQixTQUFTNmIsSUFBSSxDQUFDLENBQUMvWDtnQkFDbEIsTUFBTWlZLE9BQU93WCxpQ0FBaUN6dkI7Z0JBQzlDLE1BQU11WSxZQUFZLElBQUloWjtnQkFDdEJoTyxPQUFPd0IsTUFBTSxDQUFDd2xCLFdBQVdOO2dCQUN6QixPQUFPTTtZQUNYO1FBQ0osT0FDSztZQUNELE1BQU0sSUFBSTFtQixNQUFNO1FBQ3BCO0lBQ0o7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQW1CQyxHQUNELE1BQU1teUMsYUFBYXJ2QixNQUFNLEVBQUU7UUFDdkIsSUFBSWhrQixJQUFJQztRQUNSLElBQUlzTDtRQUNKLElBQUlxYSxPQUFPO1FBQ1gsSUFBSW1CLGNBQWMsQ0FBQztRQUNuQixJQUFJLElBQUksQ0FBQ3hVLFNBQVMsQ0FBQ0csVUFBVSxJQUFJO1lBQzdCLE1BQU1nVCxPQUFPc2EsK0JBQStCLElBQUksQ0FBQ3p0QixTQUFTLEVBQUV5UjtZQUM1RDRCLE9BQU92bEIsVUFBVSxtQkFBbUJxbEIsSUFBSSxDQUFDLE9BQU87WUFDaERxQixjQUFjckIsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJuYSxXQUFXLElBQUksQ0FBQ2dILFNBQVMsQ0FDcEJnVCxPQUFPLENBQUM7Z0JBQ1RLLE1BQU1BO2dCQUNObUIsYUFBYUE7Z0JBQ2JyQixNQUFNc0IsS0FBS0MsU0FBUyxDQUFDdkI7Z0JBQ3JCd0IsWUFBWTtnQkFDWnRuQixhQUFhLENBQUNJLEtBQUtna0IsT0FBTzlTLE1BQU0sTUFBTSxRQUFRbFIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSixXQUFXO2dCQUNyRnVuQixhQUFhLENBQUNsbkIsS0FBSytqQixPQUFPOVMsTUFBTSxNQUFNLFFBQVFqUixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdrbkIsV0FBVztZQUN6RixHQUNLQyxJQUFJLENBQUMsQ0FBQ0M7Z0JBQ1AsT0FBT0EsYUFBYXphLElBQUk7WUFDNUI7WUFDQSxPQUFPckIsU0FBUzZiLElBQUksQ0FBQyxDQUFDL1g7Z0JBQ2xCLE1BQU1pWSxPQUFPNFksK0JBQStCN3dCO2dCQUM1QyxNQUFNdVksWUFBWSxJQUFJL1k7Z0JBQ3RCak8sT0FBT3dCLE1BQU0sQ0FBQ3dsQixXQUFXTjtnQkFDekIsT0FBT007WUFDWDtRQUNKLE9BQ0s7WUFDRCxNQUFNLElBQUkxbUIsTUFBTTtRQUNwQjtJQUNKO0lBQ0E7Ozs7Ozs7S0FPQyxHQUNELE1BQU1zbUIsSUFBSXhELE1BQU0sRUFBRTtRQUNkLElBQUloa0IsSUFBSUMsSUFBSW1OLElBQUlDO1FBQ2hCLElBQUk5QjtRQUNKLElBQUlxYSxPQUFPO1FBQ1gsSUFBSW1CLGNBQWMsQ0FBQztRQUNuQixJQUFJLElBQUksQ0FBQ3hVLFNBQVMsQ0FBQ0csVUFBVSxJQUFJO1lBQzdCLE1BQU1nVCxPQUFPa1gsMkJBQTJCLElBQUksQ0FBQ3JxQixTQUFTLEVBQUV5UjtZQUN4RDRCLE9BQU92bEIsVUFBVSxVQUFVcWxCLElBQUksQ0FBQyxPQUFPO1lBQ3ZDcUIsY0FBY3JCLElBQUksQ0FBQyxTQUFTO1lBQzVCLE9BQU9BLElBQUksQ0FBQyxPQUFPO1lBQ25CLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCbmEsV0FBVyxJQUFJLENBQUNnSCxTQUFTLENBQ3BCZ1QsT0FBTyxDQUFDO2dCQUNUSyxNQUFNQTtnQkFDTm1CLGFBQWFBO2dCQUNickIsTUFBTXNCLEtBQUtDLFNBQVMsQ0FBQ3ZCO2dCQUNyQndCLFlBQVk7Z0JBQ1p0bkIsYUFBYSxDQUFDSSxLQUFLZ2tCLE9BQU85UyxNQUFNLE1BQU0sUUFBUWxSLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0osV0FBVztnQkFDckZ1bkIsYUFBYSxDQUFDbG5CLEtBQUsrakIsT0FBTzlTLE1BQU0sTUFBTSxRQUFRalIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHa25CLFdBQVc7WUFDekYsR0FDS0MsSUFBSSxDQUFDLENBQUNDO2dCQUNQLE9BQU9BLGFBQWF6YSxJQUFJO1lBQzVCO1lBQ0EsT0FBT3JCLFNBQVM2YixJQUFJLENBQUMsQ0FBQy9YO2dCQUNsQixNQUFNaVksT0FBT2tXLGdCQUFnQm51QjtnQkFDN0IsT0FBT2lZO1lBQ1g7UUFDSixPQUNLO1lBQ0QsTUFBTTVCLE9BQU9pWCwwQkFBMEIsSUFBSSxDQUFDcHFCLFNBQVMsRUFBRXlSO1lBQ3ZENEIsT0FBT3ZsQixVQUFVLFVBQVVxbEIsSUFBSSxDQUFDLE9BQU87WUFDdkNxQixjQUFjckIsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJuYSxXQUFXLElBQUksQ0FBQ2dILFNBQVMsQ0FDcEJnVCxPQUFPLENBQUM7Z0JBQ1RLLE1BQU1BO2dCQUNObUIsYUFBYUE7Z0JBQ2JyQixNQUFNc0IsS0FBS0MsU0FBUyxDQUFDdkI7Z0JBQ3JCd0IsWUFBWTtnQkFDWnRuQixhQUFhLENBQUN3TixLQUFLNFcsT0FBTzlTLE1BQU0sTUFBTSxRQUFROUQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHeE4sV0FBVztnQkFDckZ1bkIsYUFBYSxDQUFDOVosS0FBSzJXLE9BQU85UyxNQUFNLE1BQU0sUUFBUTdELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzhaLFdBQVc7WUFDekYsR0FDS0MsSUFBSSxDQUFDLENBQUNDO2dCQUNQLE9BQU9BLGFBQWF6YSxJQUFJO1lBQzVCO1lBQ0EsT0FBT3JCLFNBQVM2YixJQUFJLENBQUMsQ0FBQy9YO2dCQUNsQixNQUFNaVksT0FBT2dXLGVBQWVqdUI7Z0JBQzVCLE9BQU9pWTtZQUNYO1FBQ0o7SUFDSjtJQUNBLE1BQU1JLGFBQWExRCxNQUFNLEVBQUU7UUFDdkIsSUFBSWhrQixJQUFJQyxJQUFJbU4sSUFBSUM7UUFDaEIsSUFBSTlCO1FBQ0osSUFBSXFhLE9BQU87UUFDWCxJQUFJbUIsY0FBYyxDQUFDO1FBQ25CLElBQUksSUFBSSxDQUFDeFUsU0FBUyxDQUFDRyxVQUFVLElBQUk7WUFDN0IsTUFBTWdULE9BQU95WCw2QkFBNkIsSUFBSSxDQUFDNXFCLFNBQVMsRUFBRXlSO1lBQzFENEIsT0FBT3ZsQixVQUFVLGdCQUFnQnFsQixJQUFJLENBQUMsT0FBTztZQUM3Q3FCLGNBQWNyQixJQUFJLENBQUMsU0FBUztZQUM1QixPQUFPQSxJQUFJLENBQUMsT0FBTztZQUNuQixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQm5hLFdBQVcsSUFBSSxDQUFDZ0gsU0FBUyxDQUNwQmdULE9BQU8sQ0FBQztnQkFDVEssTUFBTUE7Z0JBQ05tQixhQUFhQTtnQkFDYnJCLE1BQU1zQixLQUFLQyxTQUFTLENBQUN2QjtnQkFDckJ3QixZQUFZO2dCQUNadG5CLGFBQWEsQ0FBQ0ksS0FBS2drQixPQUFPOVMsTUFBTSxNQUFNLFFBQVFsUixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdKLFdBQVc7Z0JBQ3JGdW5CLGFBQWEsQ0FBQ2xuQixLQUFLK2pCLE9BQU85UyxNQUFNLE1BQU0sUUFBUWpSLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2tuQixXQUFXO1lBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQztnQkFDUCxPQUFPQSxhQUFhemEsSUFBSSxHQUFHd2EsSUFBSSxDQUFDLENBQUNPO29CQUM3QixNQUFNcGMsV0FBV29jO29CQUNqQnBjLFNBQVM2WSxlQUFlLEdBQUc7d0JBQ3ZCclgsU0FBU3NhLGFBQWF0YSxPQUFPO29CQUNqQztvQkFDQSxPQUFPeEI7Z0JBQ1g7WUFDSjtZQUNBLE9BQU9BLFNBQVM2YixJQUFJLENBQUMsQ0FBQy9YO2dCQUNsQixNQUFNaVksT0FBT2lXLDZCQUE2Qmx1QjtnQkFDMUMsTUFBTXVZLFlBQVksSUFBSTlZO2dCQUN0QmxPLE9BQU93QixNQUFNLENBQUN3bEIsV0FBV047Z0JBQ3pCLE9BQU9NO1lBQ1g7UUFDSixPQUNLO1lBQ0QsTUFBTWxDLE9BQU93WCw0QkFBNEIsSUFBSSxDQUFDM3FCLFNBQVMsRUFBRXlSO1lBQ3pENEIsT0FBT3ZsQixVQUFVLGdCQUFnQnFsQixJQUFJLENBQUMsT0FBTztZQUM3Q3FCLGNBQWNyQixJQUFJLENBQUMsU0FBUztZQUM1QixPQUFPQSxJQUFJLENBQUMsT0FBTztZQUNuQixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQm5hLFdBQVcsSUFBSSxDQUFDZ0gsU0FBUyxDQUNwQmdULE9BQU8sQ0FBQztnQkFDVEssTUFBTUE7Z0JBQ05tQixhQUFhQTtnQkFDYnJCLE1BQU1zQixLQUFLQyxTQUFTLENBQUN2QjtnQkFDckJ3QixZQUFZO2dCQUNadG5CLGFBQWEsQ0FBQ3dOLEtBQUs0VyxPQUFPOVMsTUFBTSxNQUFNLFFBQVE5RCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUd4TixXQUFXO2dCQUNyRnVuQixhQUFhLENBQUM5WixLQUFLMlcsT0FBTzlTLE1BQU0sTUFBTSxRQUFRN0QsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHOFosV0FBVztZQUN6RixHQUNLQyxJQUFJLENBQUMsQ0FBQ0M7Z0JBQ1AsT0FBT0EsYUFBYXphLElBQUksR0FBR3dhLElBQUksQ0FBQyxDQUFDTztvQkFDN0IsTUFBTXBjLFdBQVdvYztvQkFDakJwYyxTQUFTNlksZUFBZSxHQUFHO3dCQUN2QnJYLFNBQVNzYSxhQUFhdGEsT0FBTztvQkFDakM7b0JBQ0EsT0FBT3hCO2dCQUNYO1lBQ0o7WUFDQSxPQUFPQSxTQUFTNmIsSUFBSSxDQUFDLENBQUMvWDtnQkFDbEIsTUFBTWlZLE9BQU84Viw0QkFBNEIvdEI7Z0JBQ3pDLE1BQU11WSxZQUFZLElBQUk5WTtnQkFDdEJsTyxPQUFPd0IsTUFBTSxDQUFDd2xCLFdBQVdOO2dCQUN6QixPQUFPTTtZQUNYO1FBQ0o7SUFDSjtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0tBZ0JDLEdBQ0QsTUFBTWlELE9BQU83RyxNQUFNLEVBQUU7UUFDakIsSUFBSWhrQixJQUFJQyxJQUFJbU4sSUFBSUM7UUFDaEIsSUFBSTlCO1FBQ0osSUFBSXFhLE9BQU87UUFDWCxJQUFJbUIsY0FBYyxDQUFDO1FBQ25CLElBQUksSUFBSSxDQUFDeFUsU0FBUyxDQUFDRyxVQUFVLElBQUk7WUFDN0IsTUFBTWdULE9BQU8rYSw4QkFBOEIsSUFBSSxDQUFDbHVCLFNBQVMsRUFBRXlSO1lBQzNENEIsT0FBT3ZsQixVQUFVLFdBQVdxbEIsSUFBSSxDQUFDLE9BQU87WUFDeENxQixjQUFjckIsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJuYSxXQUFXLElBQUksQ0FBQ2dILFNBQVMsQ0FDcEJnVCxPQUFPLENBQUM7Z0JBQ1RLLE1BQU1BO2dCQUNObUIsYUFBYUE7Z0JBQ2JyQixNQUFNc0IsS0FBS0MsU0FBUyxDQUFDdkI7Z0JBQ3JCd0IsWUFBWTtnQkFDWnRuQixhQUFhLENBQUNJLEtBQUtna0IsT0FBTzlTLE1BQU0sTUFBTSxRQUFRbFIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSixXQUFXO2dCQUNyRnVuQixhQUFhLENBQUNsbkIsS0FBSytqQixPQUFPOVMsTUFBTSxNQUFNLFFBQVFqUixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdrbkIsV0FBVztZQUN6RixHQUNLQyxJQUFJLENBQUMsQ0FBQ0M7Z0JBQ1AsT0FBT0EsYUFBYXphLElBQUk7WUFDNUI7WUFDQSxPQUFPckIsU0FBUzZiLElBQUksQ0FBQyxDQUFDL1g7Z0JBQ2xCLE1BQU1pWSxPQUFPa1csZ0JBQWdCbnVCO2dCQUM3QixPQUFPaVk7WUFDWDtRQUNKLE9BQ0s7WUFDRCxNQUFNNUIsT0FBTzhhLDZCQUE2QixJQUFJLENBQUNqdUIsU0FBUyxFQUFFeVI7WUFDMUQ0QixPQUFPdmxCLFVBQVUsVUFBVXFsQixJQUFJLENBQUMsT0FBTztZQUN2Q3FCLGNBQWNyQixJQUFJLENBQUMsU0FBUztZQUM1QixPQUFPQSxJQUFJLENBQUMsT0FBTztZQUNuQixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQm5hLFdBQVcsSUFBSSxDQUFDZ0gsU0FBUyxDQUNwQmdULE9BQU8sQ0FBQztnQkFDVEssTUFBTUE7Z0JBQ05tQixhQUFhQTtnQkFDYnJCLE1BQU1zQixLQUFLQyxTQUFTLENBQUN2QjtnQkFDckJ3QixZQUFZO2dCQUNadG5CLGFBQWEsQ0FBQ3dOLEtBQUs0VyxPQUFPOVMsTUFBTSxNQUFNLFFBQVE5RCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUd4TixXQUFXO2dCQUNyRnVuQixhQUFhLENBQUM5WixLQUFLMlcsT0FBTzlTLE1BQU0sTUFBTSxRQUFRN0QsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHOFosV0FBVztZQUN6RixHQUNLQyxJQUFJLENBQUMsQ0FBQ0M7Z0JBQ1AsT0FBT0EsYUFBYXphLElBQUk7WUFDNUI7WUFDQSxPQUFPckIsU0FBUzZiLElBQUksQ0FBQyxDQUFDL1g7Z0JBQ2xCLE1BQU1pWSxPQUFPZ1csZUFBZWp1QjtnQkFDNUIsT0FBT2lZO1lBQ1g7UUFDSjtJQUNKO0lBQ0E7Ozs7Ozs7Ozs7S0FVQyxHQUNELE1BQU1PLE9BQU83RCxNQUFNLEVBQUU7UUFDakIsSUFBSWhrQixJQUFJQyxJQUFJbU4sSUFBSUM7UUFDaEIsSUFBSTlCO1FBQ0osSUFBSXFhLE9BQU87UUFDWCxJQUFJbUIsY0FBYyxDQUFDO1FBQ25CLElBQUksSUFBSSxDQUFDeFUsU0FBUyxDQUFDRyxVQUFVLElBQUk7WUFDN0IsTUFBTWdULE9BQU8yUSw4QkFBOEIsSUFBSSxDQUFDOWpCLFNBQVMsRUFBRXlSO1lBQzNENEIsT0FBT3ZsQixVQUFVLFVBQVVxbEIsSUFBSSxDQUFDLE9BQU87WUFDdkNxQixjQUFjckIsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJuYSxXQUFXLElBQUksQ0FBQ2dILFNBQVMsQ0FDcEJnVCxPQUFPLENBQUM7Z0JBQ1RLLE1BQU1BO2dCQUNObUIsYUFBYUE7Z0JBQ2JyQixNQUFNc0IsS0FBS0MsU0FBUyxDQUFDdkI7Z0JBQ3JCd0IsWUFBWTtnQkFDWnRuQixhQUFhLENBQUNJLEtBQUtna0IsT0FBTzlTLE1BQU0sTUFBTSxRQUFRbFIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSixXQUFXO2dCQUNyRnVuQixhQUFhLENBQUNsbkIsS0FBSytqQixPQUFPOVMsTUFBTSxNQUFNLFFBQVFqUixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdrbkIsV0FBVztZQUN6RixHQUNLQyxJQUFJLENBQUMsQ0FBQ0M7Z0JBQ1AsT0FBT0EsYUFBYXphLElBQUksR0FBR3dhLElBQUksQ0FBQyxDQUFDTztvQkFDN0IsTUFBTXBjLFdBQVdvYztvQkFDakJwYyxTQUFTNlksZUFBZSxHQUFHO3dCQUN2QnJYLFNBQVNzYSxhQUFhdGEsT0FBTztvQkFDakM7b0JBQ0EsT0FBT3hCO2dCQUNYO1lBQ0o7WUFDQSxPQUFPQSxTQUFTNmIsSUFBSSxDQUFDLENBQUMvWDtnQkFDbEIsTUFBTWlZLE9BQU9pUCw4QkFBOEJsbkI7Z0JBQzNDLE1BQU11WSxZQUFZLElBQUk3WTtnQkFDdEJuTyxPQUFPd0IsTUFBTSxDQUFDd2xCLFdBQVdOO2dCQUN6QixPQUFPTTtZQUNYO1FBQ0osT0FDSztZQUNELE1BQU1sQyxPQUFPMFEsNkJBQTZCLElBQUksQ0FBQzdqQixTQUFTLEVBQUV5UjtZQUMxRDRCLE9BQU92bEIsVUFBVSxVQUFVcWxCLElBQUksQ0FBQyxPQUFPO1lBQ3ZDcUIsY0FBY3JCLElBQUksQ0FBQyxTQUFTO1lBQzVCLE9BQU9BLElBQUksQ0FBQyxPQUFPO1lBQ25CLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCbmEsV0FBVyxJQUFJLENBQUNnSCxTQUFTLENBQ3BCZ1QsT0FBTyxDQUFDO2dCQUNUSyxNQUFNQTtnQkFDTm1CLGFBQWFBO2dCQUNickIsTUFBTXNCLEtBQUtDLFNBQVMsQ0FBQ3ZCO2dCQUNyQndCLFlBQVk7Z0JBQ1p0bkIsYUFBYSxDQUFDd04sS0FBSzRXLE9BQU85UyxNQUFNLE1BQU0sUUFBUTlELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3hOLFdBQVc7Z0JBQ3JGdW5CLGFBQWEsQ0FBQzlaLEtBQUsyVyxPQUFPOVMsTUFBTSxNQUFNLFFBQVE3RCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUc4WixXQUFXO1lBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQztnQkFDUCxPQUFPQSxhQUFhemEsSUFBSSxHQUFHd2EsSUFBSSxDQUFDLENBQUNPO29CQUM3QixNQUFNcGMsV0FBV29jO29CQUNqQnBjLFNBQVM2WSxlQUFlLEdBQUc7d0JBQ3ZCclgsU0FBU3NhLGFBQWF0YSxPQUFPO29CQUNqQztvQkFDQSxPQUFPeEI7Z0JBQ1g7WUFDSjtZQUNBLE9BQU9BLFNBQVM2YixJQUFJLENBQUMsQ0FBQy9YO2dCQUNsQixNQUFNaVksT0FBT2dQLDZCQUE2QmpuQjtnQkFDMUMsTUFBTXVZLFlBQVksSUFBSTdZO2dCQUN0Qm5PLE9BQU93QixNQUFNLENBQUN3bEIsV0FBV047Z0JBQ3pCLE9BQU9NO1lBQ1g7UUFDSjtJQUNKO0lBQ0E7Ozs7Ozs7Ozs7Ozs7OztLQWVDLEdBQ0QsTUFBTTByQixZQUFZdHZCLE1BQU0sRUFBRTtRQUN0QixJQUFJaGtCLElBQUlDLElBQUltTixJQUFJQztRQUNoQixJQUFJOUI7UUFDSixJQUFJcWEsT0FBTztRQUNYLElBQUltQixjQUFjLENBQUM7UUFDbkIsSUFBSSxJQUFJLENBQUN4VSxTQUFTLENBQUNHLFVBQVUsSUFBSTtZQUM3QixNQUFNZ1QsT0FBT3NRLDhCQUE4QixJQUFJLENBQUN6akIsU0FBUyxFQUFFeVI7WUFDM0Q0QixPQUFPdmxCLFVBQVUsdUJBQXVCcWxCLElBQUksQ0FBQyxPQUFPO1lBQ3BEcUIsY0FBY3JCLElBQUksQ0FBQyxTQUFTO1lBQzVCLE9BQU9BLElBQUksQ0FBQyxPQUFPO1lBQ25CLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCbmEsV0FBVyxJQUFJLENBQUNnSCxTQUFTLENBQ3BCZ1QsT0FBTyxDQUFDO2dCQUNUSyxNQUFNQTtnQkFDTm1CLGFBQWFBO2dCQUNickIsTUFBTXNCLEtBQUtDLFNBQVMsQ0FBQ3ZCO2dCQUNyQndCLFlBQVk7Z0JBQ1p0bkIsYUFBYSxDQUFDSSxLQUFLZ2tCLE9BQU85UyxNQUFNLE1BQU0sUUFBUWxSLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0osV0FBVztnQkFDckZ1bkIsYUFBYSxDQUFDbG5CLEtBQUsrakIsT0FBTzlTLE1BQU0sTUFBTSxRQUFRalIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHa25CLFdBQVc7WUFDekYsR0FDS0MsSUFBSSxDQUFDLENBQUNDO2dCQUNQLE9BQU9BLGFBQWF6YSxJQUFJLEdBQUd3YSxJQUFJLENBQUMsQ0FBQ087b0JBQzdCLE1BQU1wYyxXQUFXb2M7b0JBQ2pCcGMsU0FBUzZZLGVBQWUsR0FBRzt3QkFDdkJyWCxTQUFTc2EsYUFBYXRhLE9BQU87b0JBQ2pDO29CQUNBLE9BQU94QjtnQkFDWDtZQUNKO1lBQ0EsT0FBT0EsU0FBUzZiLElBQUksQ0FBQyxDQUFDL1g7Z0JBQ2xCLE1BQU1pWSxPQUFPNk8sOEJBQThCOW1CO2dCQUMzQyxNQUFNdVksWUFBWSxJQUFJNVk7Z0JBQ3RCcE8sT0FBT3dCLE1BQU0sQ0FBQ3dsQixXQUFXTjtnQkFDekIsT0FBT007WUFDWDtRQUNKLE9BQ0s7WUFDRCxNQUFNbEMsT0FBT3FRLDZCQUE2QixJQUFJLENBQUN4akIsU0FBUyxFQUFFeVI7WUFDMUQ0QixPQUFPdmxCLFVBQVUsdUJBQXVCcWxCLElBQUksQ0FBQyxPQUFPO1lBQ3BEcUIsY0FBY3JCLElBQUksQ0FBQyxTQUFTO1lBQzVCLE9BQU9BLElBQUksQ0FBQyxPQUFPO1lBQ25CLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCbmEsV0FBVyxJQUFJLENBQUNnSCxTQUFTLENBQ3BCZ1QsT0FBTyxDQUFDO2dCQUNUSyxNQUFNQTtnQkFDTm1CLGFBQWFBO2dCQUNickIsTUFBTXNCLEtBQUtDLFNBQVMsQ0FBQ3ZCO2dCQUNyQndCLFlBQVk7Z0JBQ1p0bkIsYUFBYSxDQUFDd04sS0FBSzRXLE9BQU85UyxNQUFNLE1BQU0sUUFBUTlELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3hOLFdBQVc7Z0JBQ3JGdW5CLGFBQWEsQ0FBQzlaLEtBQUsyVyxPQUFPOVMsTUFBTSxNQUFNLFFBQVE3RCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUc4WixXQUFXO1lBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQztnQkFDUCxPQUFPQSxhQUFhemEsSUFBSSxHQUFHd2EsSUFBSSxDQUFDLENBQUNPO29CQUM3QixNQUFNcGMsV0FBV29jO29CQUNqQnBjLFNBQVM2WSxlQUFlLEdBQUc7d0JBQ3ZCclgsU0FBU3NhLGFBQWF0YSxPQUFPO29CQUNqQztvQkFDQSxPQUFPeEI7Z0JBQ1g7WUFDSjtZQUNBLE9BQU9BLFNBQVM2YixJQUFJLENBQUMsQ0FBQy9YO2dCQUNsQixNQUFNaVksT0FBTzJPLDZCQUE2QjVtQjtnQkFDMUMsTUFBTXVZLFlBQVksSUFBSTVZO2dCQUN0QnBPLE9BQU93QixNQUFNLENBQUN3bEIsV0FBV047Z0JBQ3pCLE9BQU9NO1lBQ1g7UUFDSjtJQUNKO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBaUJDLEdBQ0QsTUFBTTJyQixjQUFjdnZCLE1BQU0sRUFBRTtRQUN4QixJQUFJaGtCLElBQUlDO1FBQ1IsSUFBSXNMO1FBQ0osSUFBSXFhLE9BQU87UUFDWCxJQUFJbUIsY0FBYyxDQUFDO1FBQ25CLElBQUksSUFBSSxDQUFDeFUsU0FBUyxDQUFDRyxVQUFVLElBQUk7WUFDN0IsTUFBTWdULE9BQU9vUCxnQ0FBZ0MsSUFBSSxDQUFDdmlCLFNBQVMsRUFBRXlSO1lBQzdENEIsT0FBT3ZsQixVQUFVLHlCQUF5QnFsQixJQUFJLENBQUMsT0FBTztZQUN0RHFCLGNBQWNyQixJQUFJLENBQUMsU0FBUztZQUM1QixPQUFPQSxJQUFJLENBQUMsT0FBTztZQUNuQixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQm5hLFdBQVcsSUFBSSxDQUFDZ0gsU0FBUyxDQUNwQmdULE9BQU8sQ0FBQztnQkFDVEssTUFBTUE7Z0JBQ05tQixhQUFhQTtnQkFDYnJCLE1BQU1zQixLQUFLQyxTQUFTLENBQUN2QjtnQkFDckJ3QixZQUFZO2dCQUNadG5CLGFBQWEsQ0FBQ0ksS0FBS2drQixPQUFPOVMsTUFBTSxNQUFNLFFBQVFsUixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdKLFdBQVc7Z0JBQ3JGdW5CLGFBQWEsQ0FBQ2xuQixLQUFLK2pCLE9BQU85UyxNQUFNLE1BQU0sUUFBUWpSLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2tuQixXQUFXO1lBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQztnQkFDUCxPQUFPQSxhQUFhemEsSUFBSSxHQUFHd2EsSUFBSSxDQUFDLENBQUNPO29CQUM3QixNQUFNcGMsV0FBV29jO29CQUNqQnBjLFNBQVM2WSxlQUFlLEdBQUc7d0JBQ3ZCclgsU0FBU3NhLGFBQWF0YSxPQUFPO29CQUNqQztvQkFDQSxPQUFPeEI7Z0JBQ1g7WUFDSjtZQUNBLE9BQU9BLFNBQVM2YixJQUFJLENBQUMsQ0FBQy9YO2dCQUNsQixNQUFNaVksT0FBT3lOLGdDQUFnQzFsQjtnQkFDN0MsTUFBTXVZLFlBQVksSUFBSTNZO2dCQUN0QnJPLE9BQU93QixNQUFNLENBQUN3bEIsV0FBV047Z0JBQ3pCLE9BQU9NO1lBQ1g7UUFDSixPQUNLO1lBQ0QsTUFBTSxJQUFJMW1CLE1BQU07UUFDcEI7SUFDSjtJQUNBOztLQUVDLEdBQ0QsTUFBTXN5Qyx1QkFBdUJ4dkIsTUFBTSxFQUFFO1FBQ2pDLElBQUloa0IsSUFBSUMsSUFBSW1OLElBQUlDO1FBQ2hCLElBQUk5QjtRQUNKLElBQUlxYSxPQUFPO1FBQ1gsSUFBSW1CLGNBQWMsQ0FBQztRQUNuQixJQUFJLElBQUksQ0FBQ3hVLFNBQVMsQ0FBQ0csVUFBVSxJQUFJO1lBQzdCLE1BQU1nVCxPQUFPb1csaUNBQWlDLElBQUksQ0FBQ3ZwQixTQUFTLEVBQUV5UjtZQUM5RDRCLE9BQU92bEIsVUFBVSw4QkFBOEJxbEIsSUFBSSxDQUFDLE9BQU87WUFDM0RxQixjQUFjckIsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJuYSxXQUFXLElBQUksQ0FBQ2dILFNBQVMsQ0FDcEJnVCxPQUFPLENBQUM7Z0JBQ1RLLE1BQU1BO2dCQUNObUIsYUFBYUE7Z0JBQ2JyQixNQUFNc0IsS0FBS0MsU0FBUyxDQUFDdkI7Z0JBQ3JCd0IsWUFBWTtnQkFDWnRuQixhQUFhLENBQUNJLEtBQUtna0IsT0FBTzlTLE1BQU0sTUFBTSxRQUFRbFIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSixXQUFXO2dCQUNyRnVuQixhQUFhLENBQUNsbkIsS0FBSytqQixPQUFPOVMsTUFBTSxNQUFNLFFBQVFqUixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdrbkIsV0FBVztZQUN6RixHQUNLQyxJQUFJLENBQUMsQ0FBQ0M7Z0JBQ1AsT0FBT0EsYUFBYXphLElBQUk7WUFDNUI7WUFDQSxPQUFPckIsU0FBUzZiLElBQUksQ0FBQyxDQUFDL1g7Z0JBQ2xCLE1BQU1pWSxPQUFPaVUsa0NBQWtDbHNCO2dCQUMvQyxNQUFNdVksWUFBWSxJQUFJelk7Z0JBQ3RCdk8sT0FBT3dCLE1BQU0sQ0FBQ3dsQixXQUFXTjtnQkFDekIsT0FBT007WUFDWDtRQUNKLE9BQ0s7WUFDRCxNQUFNbEMsT0FBTytWLGdDQUFnQyxJQUFJLENBQUNscEIsU0FBUyxFQUFFeVI7WUFDN0Q0QixPQUFPdmxCLFVBQVUsOEJBQThCcWxCLElBQUksQ0FBQyxPQUFPO1lBQzNEcUIsY0FBY3JCLElBQUksQ0FBQyxTQUFTO1lBQzVCLE9BQU9BLElBQUksQ0FBQyxPQUFPO1lBQ25CLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCbmEsV0FBVyxJQUFJLENBQUNnSCxTQUFTLENBQ3BCZ1QsT0FBTyxDQUFDO2dCQUNUSyxNQUFNQTtnQkFDTm1CLGFBQWFBO2dCQUNickIsTUFBTXNCLEtBQUtDLFNBQVMsQ0FBQ3ZCO2dCQUNyQndCLFlBQVk7Z0JBQ1p0bkIsYUFBYSxDQUFDd04sS0FBSzRXLE9BQU85UyxNQUFNLE1BQU0sUUFBUTlELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3hOLFdBQVc7Z0JBQ3JGdW5CLGFBQWEsQ0FBQzlaLEtBQUsyVyxPQUFPOVMsTUFBTSxNQUFNLFFBQVE3RCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUc4WixXQUFXO1lBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQztnQkFDUCxPQUFPQSxhQUFhemEsSUFBSTtZQUM1QjtZQUNBLE9BQU9yQixTQUFTNmIsSUFBSSxDQUFDLENBQUMvWDtnQkFDbEIsTUFBTWlZLE9BQU8rVCxpQ0FBaUNoc0I7Z0JBQzlDLE1BQU11WSxZQUFZLElBQUl6WTtnQkFDdEJ2TyxPQUFPd0IsTUFBTSxDQUFDd2xCLFdBQVdOO2dCQUN6QixPQUFPTTtZQUNYO1FBQ0o7SUFDSjtJQTcrQ0E5YSxZQUFZeUYsU0FBUyxDQUFFO1FBQ25CLEtBQUs7UUFDTCxJQUFJLENBQUNBLFNBQVMsR0FBR0E7UUFDakI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7U0FxQ0MsR0FDRCxJQUFJLENBQUMyYixlQUFlLEdBQUcsT0FBT2xLO1lBQzFCLElBQUloa0IsSUFBSUMsSUFBSW1OLElBQUlDLElBQUlDO1lBQ3BCLE1BQU13a0Msb0JBQW9CLE1BQU0sSUFBSSxDQUFDaEIsNkJBQTZCLENBQUM5c0I7WUFDbkUsSUFBSSxDQUFDNHNCLDRCQUE0QixDQUFDNXNCO1lBQ2xDLElBQUksQ0FBQ3FzQixpQkFBaUJyc0IsV0FBVzZyQixpQkFBaUI3ckIsT0FBTzlTLE1BQU0sR0FBRztnQkFDOUQsT0FBTyxNQUFNLElBQUksQ0FBQ3FoQyx1QkFBdUIsQ0FBQ1Q7WUFDOUM7WUFDQSxNQUFNMkIsMEJBQTBCbEQsK0JBQStCdnNCO1lBQy9ELElBQUl5dkIsd0JBQXdCbHlDLE1BQU0sR0FBRyxHQUFHO2dCQUNwQyxNQUFNbXlDLG1CQUFtQkQsd0JBQ3BCanhDLEdBQUcsQ0FBQyxDQUFDc2lCLFFBQVUsU0FBZSxPQUFOQSxPQUFNLE1BQzlCNGUsSUFBSSxDQUFDO2dCQUNWLE1BQU0sSUFBSXhpQyxNQUFNLG1KQUFvSyxPQUFqQnd5QyxrQkFBaUI7WUFDeEw7WUFDQSxJQUFJbm9DO1lBQ0osSUFBSW9vQztZQUNKLE1BQU1ubEIsa0NBQWtDeGEsVUFBVTg5QixrQkFBa0IzakIsUUFBUTtZQUM1RSxNQUFNc2pCLGlCQUFpQixDQUFDcmtDLEtBQUssQ0FBQ25OLEtBQUssQ0FBQ0QsS0FBSzh4QyxrQkFBa0I1Z0MsTUFBTSxNQUFNLFFBQVFsUixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUc4dkMsd0JBQXdCLE1BQU0sUUFBUTd2QyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdpd0Msa0JBQWtCLE1BQU0sUUFBUTlpQyxPQUFPLEtBQUssSUFBSUEsS0FBS3dpQztZQUNsTyxJQUFJZ0UsY0FBYztZQUNsQixNQUFPQSxjQUFjbkMsZUFBZ0I7Z0JBQ2pDbG1DLFdBQVcsTUFBTSxJQUFJLENBQUNnbkMsdUJBQXVCLENBQUNUO2dCQUM5QyxJQUFJLENBQUN2bUMsU0FBUytDLGFBQWEsSUFBSS9DLFNBQVMrQyxhQUFhLENBQUMvTSxNQUFNLEtBQUssR0FBRztvQkFDaEU7Z0JBQ0o7Z0JBQ0EsTUFBTXN5QyxrQkFBa0J0b0MsU0FBU21DLFVBQVUsQ0FBQyxFQUFFLENBQUNDLE9BQU87Z0JBQ3RELE1BQU1tbUMsd0JBQXdCLEVBQUU7Z0JBQ2hDLEtBQUssTUFBTS85QixRQUFRLENBQUN6SSxLQUFLLENBQUNELEtBQUsyVyxPQUFPOVMsTUFBTSxNQUFNLFFBQVE3RCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdpSixLQUFLLE1BQU0sUUFBUWhKLE9BQU8sS0FBSyxJQUFJQSxLQUFLLEVBQUUsQ0FBRTtvQkFDOUgsSUFBSXdoQyxlQUFlLzRCLE9BQU87d0JBQ3RCLE1BQU1nNUIsZUFBZWg1Qjt3QkFDckIsTUFBTXZLLFFBQVEsTUFBTXVqQyxhQUFhaEUsUUFBUSxDQUFDeC9CLFNBQVMrQyxhQUFhO3dCQUNoRXdsQyxzQkFBc0IxdkMsSUFBSSxJQUFJb0g7b0JBQ2xDO2dCQUNKO2dCQUNBb29DO2dCQUNBRCwwQkFBMEI7b0JBQ3RCbG5DLE1BQU07b0JBQ05qQixPQUFPc29DO2dCQUNYO2dCQUNBaEMsa0JBQWtCM2pCLFFBQVEsR0FBR25hLFVBQVU4OUIsa0JBQWtCM2pCLFFBQVE7Z0JBQ2pFMmpCLGtCQUFrQjNqQixRQUFRLENBQUMvcEIsSUFBSSxDQUFDeXZDO2dCQUNoQy9CLGtCQUFrQjNqQixRQUFRLENBQUMvcEIsSUFBSSxDQUFDdXZDO2dCQUNoQyxJQUFJbEQsdUJBQXVCcUIsa0JBQWtCNWdDLE1BQU0sR0FBRztvQkFDbERzZCxnQ0FBZ0NwcUIsSUFBSSxDQUFDeXZDO29CQUNyQ3JsQixnQ0FBZ0NwcUIsSUFBSSxDQUFDdXZDO2dCQUN6QztZQUNKO1lBQ0EsSUFBSWxELHVCQUF1QnFCLGtCQUFrQjVnQyxNQUFNLEdBQUc7Z0JBQ2xEM0YsU0FBU2lqQiwrQkFBK0IsR0FDcENBO1lBQ1I7WUFDQSxPQUFPampCO1FBQ1g7UUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztTQXdDQyxHQUNELElBQUksQ0FBQ3NqQixxQkFBcUIsR0FBRyxPQUFPN0s7WUFDaEMsSUFBSWhrQixJQUFJQyxJQUFJbU4sSUFBSUMsSUFBSUM7WUFDcEIsSUFBSSxDQUFDc2pDLDRCQUE0QixDQUFDNXNCO1lBQ2xDLElBQUk2ckIsaUJBQWlCN3JCLE9BQU85UyxNQUFNLEdBQUc7Z0JBQ2pDLE1BQU00Z0Msb0JBQW9CLE1BQU0sSUFBSSxDQUFDaEIsNkJBQTZCLENBQUM5c0I7Z0JBQ25FLE9BQU8sTUFBTSxJQUFJLENBQUMrdEIsNkJBQTZCLENBQUNEO1lBQ3BEO1lBQ0EsTUFBTTJCLDBCQUEwQmxELCtCQUErQnZzQjtZQUMvRCxJQUFJeXZCLHdCQUF3Qmx5QyxNQUFNLEdBQUcsR0FBRztnQkFDcEMsTUFBTW15QyxtQkFBbUJELHdCQUNwQmp4QyxHQUFHLENBQUMsQ0FBQ3NpQixRQUFVLFNBQWUsT0FBTkEsT0FBTSxNQUM5QjRlLElBQUksQ0FBQztnQkFDVixNQUFNLElBQUl4aUMsTUFBTSwrQkFBZ0QsT0FBakJ3eUMsa0JBQWlCO1lBQ3BFO1lBQ0EseUVBQXlFO1lBQ3pFLDREQUE0RDtZQUM1RCxNQUFNSyxxQkFBcUIsQ0FBQzNtQyxLQUFLLENBQUNuTixLQUFLLENBQUNELEtBQUtna0IsV0FBVyxRQUFRQSxXQUFXLEtBQUssSUFBSSxLQUFLLElBQUlBLE9BQU85UyxNQUFNLE1BQU0sUUFBUWxSLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2cwQyxVQUFVLE1BQU0sUUFBUS96QyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdnMEMscUJBQXFCLE1BQU0sUUFBUTdtQyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUc4bUMsMkJBQTJCO1lBQ2xTLE1BQU1DLGFBQWEsQ0FBQzdtQyxLQUFLLENBQUNELEtBQUsyVyxXQUFXLFFBQVFBLFdBQVcsS0FBSyxJQUFJLEtBQUssSUFBSUEsT0FBTzlTLE1BQU0sTUFBTSxRQUFRN0QsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHeWlDLHdCQUF3QixNQUFNLFFBQVF4aUMsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHeWlDLE9BQU87WUFDL00sSUFBSWdFLHNCQUFzQixDQUFDSSxZQUFZO2dCQUNuQyxNQUFNLElBQUlqekMsTUFBTSwyRUFDWiwyRUFDQSxpRkFDQSxvRkFDQTtZQUNSO1lBQ0EsT0FBTyxNQUFNLElBQUksQ0FBQ3N3QyxnQkFBZ0IsQ0FBQ3h0QjtRQUN2QztRQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7U0FrQkMsR0FDRCxJQUFJLENBQUNvd0IsY0FBYyxHQUFHLE9BQU9wd0I7WUFDekIsT0FBTyxNQUFNLElBQUksQ0FBQ2l2QixzQkFBc0IsQ0FBQ2p2QixRQUFRb0QsSUFBSSxDQUFDLENBQUMvWDtnQkFDbkQsSUFBSXJQO2dCQUNKLElBQUlxMEM7Z0JBQ0osTUFBTUMsa0JBQWtCLEVBQUU7Z0JBQzFCLElBQUlqbEMsZ0JBQWdCLFFBQVFBLGdCQUFnQixLQUFLLElBQUksS0FBSyxJQUFJQSxZQUFZaWxDLGVBQWUsRUFBRTtvQkFDdkYsS0FBSyxNQUFNQyxrQkFBa0JsbEMsWUFBWWlsQyxlQUFlLENBQUU7d0JBQ3RELElBQUlDLGtCQUNDQSxDQUFBQSxtQkFBbUIsUUFBUUEsbUJBQW1CLEtBQUssSUFBSSxLQUFLLElBQUlBLGVBQWVDLGdCQUFnQixLQUNoRyxDQUFDLENBQUN4MEMsS0FBS3UwQyxtQkFBbUIsUUFBUUEsbUJBQW1CLEtBQUssSUFBSSxLQUFLLElBQUlBLGVBQWVDLGdCQUFnQixNQUFNLFFBQVF4MEMsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHeTBDLFdBQVcsTUFBTSxtQkFBbUI7NEJBQ3BMSixpQ0FBaUNFLG1CQUFtQixRQUFRQSxtQkFBbUIsS0FBSyxJQUFJLEtBQUssSUFBSUEsZUFBZUMsZ0JBQWdCO3dCQUNwSSxPQUNLOzRCQUNERixnQkFBZ0Jsd0MsSUFBSSxDQUFDbXdDO3dCQUN6QjtvQkFDSjtnQkFDSjtnQkFDQSxJQUFJaHBDO2dCQUNKLElBQUk4b0MsZ0NBQWdDO29CQUNoQzlvQyxXQUFXO3dCQUNQK29DLGlCQUFpQkE7d0JBQ2pCRCxnQ0FBZ0NBO3dCQUNoQ2p3QixpQkFBaUIvVSxZQUFZK1UsZUFBZTtvQkFDaEQ7Z0JBQ0osT0FDSztvQkFDRDdZLFdBQVc7d0JBQ1Arb0MsaUJBQWlCQTt3QkFDakJsd0IsaUJBQWlCL1UsWUFBWStVLGVBQWU7b0JBQ2hEO2dCQUNKO2dCQUNBLE9BQU83WTtZQUNYO1FBQ0o7UUFDQSxJQUFJLENBQUN1YyxJQUFJLEdBQUcsT0FBTzlEO1lBQ2YsSUFBSWhrQjtZQUNKLE1BQU0wMEMsZ0JBQWdCO2dCQUNsQkMsV0FBVztZQUNmO1lBQ0EsTUFBTUMsZUFBZWgwQyxPQUFPd0IsTUFBTSxDQUFDeEIsT0FBT3dCLE1BQU0sQ0FBQyxDQUFDLEdBQUdzeUMsZ0JBQWdCMXdCLFdBQVcsUUFBUUEsV0FBVyxLQUFLLElBQUksS0FBSyxJQUFJQSxPQUFPOVMsTUFBTTtZQUNsSSxNQUFNMmpDLGVBQWU7Z0JBQ2pCM2pDLFFBQVEwakM7WUFDWjtZQUNBLElBQUksSUFBSSxDQUFDcmlDLFNBQVMsQ0FBQ0csVUFBVSxJQUFJO2dCQUM3QixJQUFJLENBQUNtaUMsYUFBYTNqQyxNQUFNLENBQUN5akMsU0FBUyxFQUFFO29CQUNoQyxJQUFJLENBQUMzMEMsS0FBSzYwQyxhQUFhM2pDLE1BQU0sTUFBTSxRQUFRbFIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHNEQsTUFBTSxFQUFFO3dCQUMzRSxNQUFNLElBQUkxQyxNQUFNO29CQUNwQixPQUNLO3dCQUNEMnpDLGFBQWEzakMsTUFBTSxDQUFDdE4sTUFBTSxHQUFHO29CQUNqQztnQkFDSjtZQUNKO1lBQ0EsT0FBTyxJQUFJa2dCLE1BQU1ELFVBQVVpeEIsaUJBQWlCLEVBQUUsQ0FBQzlzQixJQUFNLElBQUksQ0FBQ04sWUFBWSxDQUFDTSxJQUFJLE1BQU0sSUFBSSxDQUFDTixZQUFZLENBQUNtdEIsZUFBZUE7UUFDdEg7UUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztTQW1CQyxHQUNELElBQUksQ0FBQ0UsU0FBUyxHQUFHLE9BQU8vd0I7WUFDcEIsTUFBTU8saUJBQWlCO2dCQUNuQi9SLE9BQU93UixPQUFPeFIsS0FBSztnQkFDbkJ3aUMsUUFBUWh4QixPQUFPZ3hCLE1BQU07Z0JBQ3JCQyxpQkFBaUIsRUFBRTtnQkFDbkIvakMsUUFBUThTLE9BQU85UyxNQUFNO1lBQ3pCO1lBQ0EsSUFBSThTLE9BQU9peEIsZUFBZSxFQUFFO2dCQUN4QixJQUFJanhCLE9BQU9peEIsZUFBZSxFQUFFO29CQUN4QjF3QixlQUFlMHdCLGVBQWUsR0FBR2p4QixPQUFPaXhCLGVBQWUsQ0FBQ3p5QyxHQUFHLENBQUMsQ0FBQzB5QyxNQUFRQSxJQUFJdmtDLG1CQUFtQjtnQkFDaEc7WUFDSjtZQUNBLE9BQU8sTUFBTSxJQUFJLENBQUN1aUMsaUJBQWlCLENBQUMzdUI7UUFDeEM7UUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztTQW1CQyxHQUNELElBQUksQ0FBQzR3QixZQUFZLEdBQUcsT0FBT254QjtZQUN2QixJQUFJb3hCLFlBQVk7Z0JBQ1pDLGdCQUFnQjtnQkFDaEJDLE1BQU07WUFDVjtZQUNBLElBQUl0eEIsT0FBTzlTLE1BQU0sRUFBRTtnQkFDZmtrQyxZQUFZeDBDLE9BQU93QixNQUFNLENBQUN4QixPQUFPd0IsTUFBTSxDQUFDLENBQUMsR0FBR2d6QyxZQUFZcHhCLE9BQU85UyxNQUFNO1lBQ3pFO1lBQ0EsTUFBTXFrQyxZQUFZO2dCQUNkL2lDLE9BQU93UixPQUFPeFIsS0FBSztnQkFDbkJnakMsT0FBT3h4QixPQUFPd3hCLEtBQUs7Z0JBQ25CQyxlQUFlenhCLE9BQU95eEIsYUFBYTtnQkFDbkN2a0MsUUFBUWtrQztZQUNaO1lBQ0EsT0FBTyxNQUFNLElBQUksQ0FBQ2pDLG9CQUFvQixDQUFDb0M7UUFDM0M7UUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1NBd0JDLEdBQ0QsSUFBSSxDQUFDRyxjQUFjLEdBQUcsT0FBTzF4QjtZQUN6QixJQUFJaGtCLElBQUlDLElBQUltTixJQUFJQyxJQUFJQyxJQUFJQztZQUN4QixJQUFJLENBQUN5VyxPQUFPZ3hCLE1BQU0sSUFBSWh4QixPQUFPd3hCLEtBQUssSUFBSXh4QixPQUFPM00sS0FBSyxLQUFLMk0sT0FBT3FsQixNQUFNLEVBQUU7Z0JBQ2xFLE1BQU0sSUFBSW5vQyxNQUFNO1lBQ3BCO1lBQ0EsMkNBQTJDO1lBQzNDLElBQUksQ0FBQyxJQUFJLENBQUNxUixTQUFTLENBQUNHLFVBQVUsSUFBSTtnQkFDOUIsSUFBSSxDQUFDLENBQUMxUyxLQUFLZ2tCLE9BQU8zTSxLQUFLLE1BQU0sUUFBUXJYLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3dLLEdBQUcsS0FBTSxFQUFDdkssS0FBSytqQixPQUFPM00sS0FBSyxNQUFNLFFBQVFwWCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUcwMUMsVUFBVSxHQUFHO29CQUMvSTN4QixPQUFPM00sS0FBSyxHQUFHO3dCQUNYN00sS0FBS3daLE9BQU8zTSxLQUFLLENBQUM3TSxHQUFHO3dCQUNyQkgsVUFBVTJaLE9BQU8zTSxLQUFLLENBQUNoTixRQUFRO29CQUNuQztnQkFDSixPQUNLLElBQUksQ0FBQyxDQUFDZ0QsS0FBSyxDQUFDRCxLQUFLNFcsT0FBT3FsQixNQUFNLE1BQU0sUUFBUWo4QixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdpSyxLQUFLLE1BQU0sUUFBUWhLLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzdDLEdBQUcsS0FDMUgsRUFBQytDLEtBQUssQ0FBQ0QsS0FBSzBXLE9BQU9xbEIsTUFBTSxNQUFNLFFBQVEvN0IsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHK0osS0FBSyxNQUFNLFFBQVE5SixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdvb0MsVUFBVSxHQUFHO29CQUNoSTN4QixPQUFPcWxCLE1BQU0sQ0FBQ2h5QixLQUFLLEdBQUc7d0JBQ2xCN00sS0FBS3daLE9BQU9xbEIsTUFBTSxDQUFDaHlCLEtBQUssQ0FBQzdNLEdBQUc7d0JBQzVCSCxVQUFVMlosT0FBT3FsQixNQUFNLENBQUNoeUIsS0FBSyxDQUFDaE4sUUFBUTtvQkFDMUM7Z0JBQ0o7WUFDSjtZQUNBLE9BQU8sTUFBTSxJQUFJLENBQUNtcEMsc0JBQXNCLENBQUN4dkI7UUFDN0M7SUFDSjtBQTZvQ0o7QUFFQTs7OztDQUlDLEdBQ0QsTUFBTTR4QixtQkFBbUJ4MUM7SUFLckI7Ozs7O0tBS0MsR0FDRCxNQUFNeTFDLG1CQUFtQjMvQixVQUFVLEVBQUU7UUFDakMsTUFBTTNHLFlBQVkyRyxXQUFXM0csU0FBUztRQUN0QyxNQUFNMkIsU0FBU2dGLFdBQVdoRixNQUFNO1FBQ2hDLElBQUkzQixVQUFVckUsSUFBSSxLQUFLOUwsYUFBYW1RLFVBQVVyRSxJQUFJLEtBQUssSUFBSTtZQUN2RCxNQUFNLElBQUloSyxNQUFNO1FBQ3BCO1FBQ0EsSUFBSSxJQUFJLENBQUNxUixTQUFTLENBQUNHLFVBQVUsSUFBSTtZQUM3QixNQUFNNkQsZUFBZWhILFVBQVVyRSxJQUFJLENBQUNqSSxLQUFLLENBQUMsZUFBZSxDQUFDLEVBQUU7WUFDNUQsSUFBSXJELGNBQWNSO1lBQ2xCLElBQUk4UixVQUFVLGlCQUFpQkEsUUFBUTtnQkFDbkN0UixjQUFjc1IsT0FBT3RSLFdBQVc7WUFDcEM7WUFDQSxNQUFNazJDLGVBQWUsTUFBTSxJQUFJLENBQUNDLG1DQUFtQyxDQUFDO2dCQUNoRUMsZUFBZXptQyxVQUFVckUsSUFBSTtnQkFDN0JxTCxjQUFjQTtnQkFDZHJGLFFBQVE7b0JBQUV0UixhQUFhQTtnQkFBWTtZQUN2QztZQUNBLE9BQU8yUCxVQUFVSCxnQkFBZ0IsQ0FBQztnQkFDOUJDLGFBQWF5bUM7Z0JBQ2J4bUMsYUFBYTtZQUNqQjtRQUNKLE9BQ0s7WUFDRCxNQUFNd21DLGVBQWUsTUFBTSxJQUFJLENBQUNHLDBCQUEwQixDQUFDO2dCQUN2REQsZUFBZXptQyxVQUFVckUsSUFBSTtnQkFDN0JnRyxRQUFRQTtZQUNaO1lBQ0EsT0FBTzNCLFVBQVVILGdCQUFnQixDQUFDO2dCQUM5QkMsYUFBYXltQztnQkFDYnhtQyxhQUFhO1lBQ2pCO1FBQ0o7SUFDSjtJQUNBOzs7OztLQUtDLEdBQ0QsTUFBTWtZLElBQUl0UixVQUFVLEVBQUU7UUFDbEIsTUFBTTNHLFlBQVkyRyxXQUFXM0csU0FBUztRQUN0QyxNQUFNMkIsU0FBU2dGLFdBQVdoRixNQUFNO1FBQ2hDLElBQUkzQixVQUFVckUsSUFBSSxLQUFLOUwsYUFBYW1RLFVBQVVyRSxJQUFJLEtBQUssSUFBSTtZQUN2RCxNQUFNLElBQUloSyxNQUFNO1FBQ3BCO1FBQ0EsSUFBSSxJQUFJLENBQUNxUixTQUFTLENBQUNHLFVBQVUsSUFBSTtZQUM3QixNQUFNNkQsZUFBZWhILFVBQVVyRSxJQUFJLENBQUNqSSxLQUFLLENBQUMsZUFBZSxDQUFDLEVBQUU7WUFDNUQsSUFBSXJELGNBQWNSO1lBQ2xCLElBQUk4UixVQUFVLGlCQUFpQkEsUUFBUTtnQkFDbkN0UixjQUFjc1IsT0FBT3RSLFdBQVc7WUFDcEM7WUFDQSxNQUFNazJDLGVBQWUsTUFBTSxJQUFJLENBQUNDLG1DQUFtQyxDQUFDO2dCQUNoRUMsZUFBZXptQyxVQUFVckUsSUFBSTtnQkFDN0JxTCxjQUFjQTtnQkFDZHJGLFFBQVE7b0JBQUV0UixhQUFhQTtnQkFBWTtZQUN2QztZQUNBLE9BQU8yUCxVQUFVSCxnQkFBZ0IsQ0FBQztnQkFDOUJDLGFBQWF5bUM7Z0JBQ2J4bUMsYUFBYTtZQUNqQjtRQUNKLE9BQ0s7WUFDRCxNQUFNd21DLGVBQWUsTUFBTSxJQUFJLENBQUNHLDBCQUEwQixDQUFDO2dCQUN2REQsZUFBZXptQyxVQUFVckUsSUFBSTtnQkFDN0JnRyxRQUFRQTtZQUNaO1lBQ0EsT0FBTzNCLFVBQVVILGdCQUFnQixDQUFDO2dCQUM5QkMsYUFBYXltQztnQkFDYnhtQyxhQUFhO1lBQ2pCO1FBQ0o7SUFDSjtJQUNBLE1BQU0ybUMsMkJBQTJCanlCLE1BQU0sRUFBRTtRQUNyQyxJQUFJaGtCLElBQUlDLElBQUltTixJQUFJQztRQUNoQixJQUFJOUI7UUFDSixJQUFJcWEsT0FBTztRQUNYLElBQUltQixjQUFjLENBQUM7UUFDbkIsSUFBSSxJQUFJLENBQUN4VSxTQUFTLENBQUNHLFVBQVUsSUFBSTtZQUM3QixNQUFNZ1QsT0FBTzNmLCtCQUErQmllO1lBQzVDNEIsT0FBT3ZsQixVQUFVLG1CQUFtQnFsQixJQUFJLENBQUMsT0FBTztZQUNoRHFCLGNBQWNyQixJQUFJLENBQUMsU0FBUztZQUM1QixPQUFPQSxJQUFJLENBQUMsT0FBTztZQUNuQixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQm5hLFdBQVcsSUFBSSxDQUFDZ0gsU0FBUyxDQUNwQmdULE9BQU8sQ0FBQztnQkFDVEssTUFBTUE7Z0JBQ05tQixhQUFhQTtnQkFDYnJCLE1BQU1zQixLQUFLQyxTQUFTLENBQUN2QjtnQkFDckJ3QixZQUFZO2dCQUNadG5CLGFBQWEsQ0FBQ0ksS0FBS2drQixPQUFPOVMsTUFBTSxNQUFNLFFBQVFsUixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdKLFdBQVc7Z0JBQ3JGdW5CLGFBQWEsQ0FBQ2xuQixLQUFLK2pCLE9BQU85UyxNQUFNLE1BQU0sUUFBUWpSLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2tuQixXQUFXO1lBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQztnQkFDUCxPQUFPQSxhQUFhemEsSUFBSTtZQUM1QjtZQUNBLE9BQU9yQjtRQUNYLE9BQ0s7WUFDRCxNQUFNbWEsT0FBTzVmLDhCQUE4QmtlO1lBQzNDNEIsT0FBT3ZsQixVQUFVLG1CQUFtQnFsQixJQUFJLENBQUMsT0FBTztZQUNoRHFCLGNBQWNyQixJQUFJLENBQUMsU0FBUztZQUM1QixPQUFPQSxJQUFJLENBQUMsT0FBTztZQUNuQixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQm5hLFdBQVcsSUFBSSxDQUFDZ0gsU0FBUyxDQUNwQmdULE9BQU8sQ0FBQztnQkFDVEssTUFBTUE7Z0JBQ05tQixhQUFhQTtnQkFDYnJCLE1BQU1zQixLQUFLQyxTQUFTLENBQUN2QjtnQkFDckJ3QixZQUFZO2dCQUNadG5CLGFBQWEsQ0FBQ3dOLEtBQUs0VyxPQUFPOVMsTUFBTSxNQUFNLFFBQVE5RCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUd4TixXQUFXO2dCQUNyRnVuQixhQUFhLENBQUM5WixLQUFLMlcsT0FBTzlTLE1BQU0sTUFBTSxRQUFRN0QsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHOFosV0FBVztZQUN6RixHQUNLQyxJQUFJLENBQUMsQ0FBQ0M7Z0JBQ1AsT0FBT0EsYUFBYXphLElBQUk7WUFDNUI7WUFDQSxPQUFPckI7UUFDWDtJQUNKO0lBQ0EsTUFBTXdxQyxvQ0FBb0MveEIsTUFBTSxFQUFFO1FBQzlDLElBQUloa0IsSUFBSUM7UUFDUixJQUFJc0w7UUFDSixJQUFJcWEsT0FBTztRQUNYLElBQUltQixjQUFjLENBQUM7UUFDbkIsSUFBSSxJQUFJLENBQUN4VSxTQUFTLENBQUNHLFVBQVUsSUFBSTtZQUM3QixNQUFNZ1QsT0FBT25oQix3Q0FBd0N5ZjtZQUNyRDRCLE9BQU92bEIsVUFBVSx3Q0FBd0NxbEIsSUFBSSxDQUFDLE9BQU87WUFDckVxQixjQUFjckIsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJuYSxXQUFXLElBQUksQ0FBQ2dILFNBQVMsQ0FDcEJnVCxPQUFPLENBQUM7Z0JBQ1RLLE1BQU1BO2dCQUNObUIsYUFBYUE7Z0JBQ2JyQixNQUFNc0IsS0FBS0MsU0FBUyxDQUFDdkI7Z0JBQ3JCd0IsWUFBWTtnQkFDWnRuQixhQUFhLENBQUNJLEtBQUtna0IsT0FBTzlTLE1BQU0sTUFBTSxRQUFRbFIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSixXQUFXO2dCQUNyRnVuQixhQUFhLENBQUNsbkIsS0FBSytqQixPQUFPOVMsTUFBTSxNQUFNLFFBQVFqUixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdrbkIsV0FBVztZQUN6RixHQUNLQyxJQUFJLENBQUMsQ0FBQ0M7Z0JBQ1AsT0FBT0EsYUFBYXphLElBQUk7WUFDNUI7WUFDQSxPQUFPckI7UUFDWCxPQUNLO1lBQ0QsTUFBTSxJQUFJckssTUFBTTtRQUNwQjtJQUNKO0lBNUpBNEwsWUFBWXlGLFNBQVMsQ0FBRTtRQUNuQixLQUFLO1FBQ0wsSUFBSSxDQUFDQSxTQUFTLEdBQUdBO0lBQ3JCO0FBMEpKO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVMyakMsWUFBWTF4QyxVQUFVO0lBQzNCLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNeVgsV0FBVzVaLGVBQWVrQyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJMFgsWUFBWSxNQUFNO1FBQ2xCL2EsZUFBZXNELFVBQVU7WUFBQztTQUFPLEVBQUV5WDtJQUN2QztJQUNBLElBQUk1WixlQUFla0MsWUFBWTtRQUFDO0tBQWMsTUFBTXBGLFdBQVc7UUFDM0QsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE1BQU11RixlQUFlbkUsZUFBZWtDLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlpQyxnQkFBZ0IsTUFBTTtRQUN0QnRGLGVBQWVzRCxVQUFVO1lBQUM7U0FBVyxFQUFFZ0M7SUFDM0M7SUFDQSxPQUFPaEM7QUFDWDtBQUNBLFNBQVMweEMsZUFBZTN4QyxVQUFVO0lBQzlCLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNMFksWUFBWTdhLGVBQWVrQyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJMlksYUFBYSxNQUFNO1FBQ25CLElBQUk3WCxrQkFBa0I2WDtRQUN0QixJQUFJeGIsTUFBTUMsT0FBTyxDQUFDMEQsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQjlDLEdBQUcsQ0FBQyxDQUFDa0I7Z0JBQ25DLE9BQU8weUMsWUFBWTF5QztZQUN2QjtRQUNKO1FBQ0F2QyxlQUFlc0QsVUFBVTtZQUFDO1NBQVEsRUFBRWE7SUFDeEM7SUFDQSxNQUFNK1gsV0FBVy9hLGVBQWVrQyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJNlksWUFBWSxNQUFNO1FBQ2xCbGMsZUFBZXNELFVBQVU7WUFBQztTQUFPLEVBQUU0WTtJQUN2QztJQUNBLE9BQU81WTtBQUNYO0FBQ0EsU0FBUzR4Qyw2QkFBNkI5akMsU0FBUyxFQUFFL04sVUFBVSxFQUFFK1ksWUFBWTtJQUNyRSxNQUFNOVksV0FBVyxDQUFDO0lBQ2xCLE1BQU0rakIsaUJBQWlCbG1CLGVBQWVrQyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJK1ksaUJBQWlCbmUsYUFBYW9wQixrQkFBa0IsTUFBTTtRQUN0RHJuQixlQUFlb2MsY0FBYztZQUFDO1NBQWEsRUFBRWlMO0lBQ2pEO0lBQ0EsTUFBTTh0QiwyQkFBMkJoMEMsZUFBZWtDLFlBQVk7UUFDeEQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhazNDLDRCQUE0QixNQUFNO1FBQ2hFbjFDLGVBQWVvYyxjQUFjO1lBQUM7U0FBdUIsRUFBRSs0QjtJQUMzRDtJQUNBLE1BQU1DLFdBQVdqMEMsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUkrWSxpQkFBaUJuZSxhQUFhbTNDLFlBQVksTUFBTTtRQUNoRHAxQyxlQUFlb2MsY0FBYztZQUFDO1NBQU8sRUFBRWc1QjtJQUMzQztJQUNBLE1BQU1DLDZCQUE2QmwwQyxlQUFla0MsWUFBWTtRQUMxRDtLQUNIO0lBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWFvM0MsOEJBQThCLE1BQU07UUFDbEVyMUMsZUFBZW9jLGNBQWM7WUFBQztTQUEyQixFQUFFazVCLDhCQUE4QmxrQyxXQUFXaWtDO0lBQ3hHO0lBQ0EsTUFBTUUsMkJBQTJCcDBDLGVBQWVrQyxZQUFZO1FBQ3hEO0tBQ0g7SUFDRCxJQUFJK1ksaUJBQWlCbmUsYUFBYXMzQyw0QkFBNEIsTUFBTTtRQUNoRXYxQyxlQUFlb2MsY0FBYztZQUFDO1NBQVksRUFBRW01QjtJQUNoRDtJQUNBLE9BQU9qeUM7QUFDWDtBQUNBLFNBQVNreUMsaUNBQWlDcGtDLFNBQVMsRUFBRS9OLFVBQVU7SUFDM0QsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1pWixhQUFhcGIsZUFBZWtDLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlrWixjQUFjLE1BQU07UUFDcEJ2YyxlQUFlc0QsVUFBVTtZQUFDO1NBQVMsRUFBRTR4Qyw2QkFBNkI5akMsV0FBV21MLFlBQVlqWjtJQUM3RjtJQUNBLE9BQU9BO0FBQ1g7QUFDQSxTQUFTbXlDLGdCQUFnQnB5QyxVQUFVO0lBQy9CLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixJQUFJbkMsZUFBZWtDLFlBQVk7UUFBQztLQUFjLE1BQU1wRixXQUFXO1FBQzNELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxNQUFNd2QsY0FBY3BjLGVBQWVrQyxZQUFZO1FBQUM7S0FBVTtJQUMxRCxJQUFJa2EsZUFBZSxNQUFNO1FBQ3JCdmQsZUFBZXNELFVBQVU7WUFBQztTQUFVLEVBQUVpYTtJQUMxQztJQUNBLE1BQU1qWSxlQUFlbkUsZUFBZWtDLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlpQyxnQkFBZ0IsTUFBTTtRQUN0QnRGLGVBQWVzRCxVQUFVO1lBQUM7U0FBVyxFQUFFZ0M7SUFDM0M7SUFDQSxPQUFPaEM7QUFDWDtBQUNBLFNBQVNveUMsb0JBQW9CcnlDLFVBQVU7SUFDbkMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1tYSxTQUFTdGMsZUFBZWtDLFlBQVk7UUFBQztLQUFLO0lBQ2hELElBQUlvYSxVQUFVLE1BQU07UUFDaEJ6ZCxlQUFlc0QsVUFBVTtZQUFDO1NBQUssRUFBRW1hO0lBQ3JDO0lBQ0EsTUFBTUMsV0FBV3ZjLGVBQWVrQyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJcWEsWUFBWSxNQUFNO1FBQ2xCMWQsZUFBZXNELFVBQVU7WUFBQztTQUFPLEVBQUVvYTtJQUN2QztJQUNBLE1BQU1oYSxXQUFXdkMsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlLLFlBQVksTUFBTTtRQUNsQjFELGVBQWVzRCxVQUFVO1lBQUM7U0FBTyxFQUFFSTtJQUN2QztJQUNBLElBQUl2QyxlQUFla0MsWUFBWTtRQUFDO0tBQWMsTUFBTXBGLFdBQVc7UUFDM0QsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLElBQUlvQixlQUFla0MsWUFBWTtRQUFDO0tBQWUsTUFBTXBGLFdBQVc7UUFDNUQsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE9BQU91RDtBQUNYO0FBQ0EsU0FBU3F5QyxrQkFBa0J0eUMsVUFBVTtJQUNqQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsSUFBSW5DLGVBQWVrQyxZQUFZO1FBQUM7S0FBYSxNQUFNcEYsV0FBVztRQUMxRCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTXFnQixtQkFBbUJqZixlQUFla0MsWUFBWTtRQUFDO0tBQWU7SUFDcEUsSUFBSStjLG9CQUFvQixNQUFNO1FBQzFCcGdCLGVBQWVzRCxVQUFVO1lBQUM7U0FBZSxFQUFFOGM7SUFDL0M7SUFDQSxPQUFPOWM7QUFDWDtBQUNBLFNBQVNzeUMsb0JBQW9CdnlDLFVBQVU7SUFDbkMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLElBQUluQyxlQUFla0MsWUFBWTtRQUFDO0tBQWlCLE1BQU1wRixXQUFXO1FBQzlELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxJQUFJb0IsZUFBZWtDLFlBQVk7UUFBQztLQUFxQixNQUFNcEYsV0FBVztRQUNsRSxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTXVnQixzQkFBc0JuZixlQUFla0MsWUFBWTtRQUNuRDtLQUNIO0lBQ0QsSUFBSWlkLHVCQUF1QixNQUFNO1FBQzdCdGdCLGVBQWVzRCxVQUFVO1lBQUM7U0FBa0IsRUFBRWdkO0lBQ2xEO0lBQ0EsT0FBT2hkO0FBQ1g7QUFDQSxTQUFTdXlDLHlCQUF5Qnh5QyxVQUFVLEVBQUUrWSxZQUFZO0lBQ3RELE1BQU05WSxXQUFXLENBQUM7SUFDbEIsTUFBTW90Qix1QkFBdUJ2dkIsZUFBZWtDLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFheXlCLHdCQUF3QixNQUFNO1FBQzVEMXdCLGVBQWVvYyxjQUFjO1lBQUM7WUFBUztTQUFtQixFQUFFc1U7SUFDaEU7SUFDQSxNQUFNclIseUJBQXlCbGUsZUFBZWtDLFlBQVk7UUFDdEQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhb2hCLDBCQUEwQixNQUFNO1FBQzlEcmYsZUFBZW9jLGNBQWM7WUFBQztZQUFTO1lBQW9CO1NBQXFCLEVBQUVpRDtJQUN0RjtJQUNBLE1BQU1yQixrQkFBa0I3YyxlQUFla0MsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSStZLGlCQUFpQm5lLGFBQWErZixtQkFBbUIsTUFBTTtRQUN2RGhlLGVBQWVvYyxjQUFjO1lBQUM7WUFBUztZQUFvQjtTQUFjLEVBQUU0QjtJQUMvRTtJQUNBLE1BQU1DLFdBQVc5YyxlQUFla0MsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSStZLGlCQUFpQm5lLGFBQWFnZ0IsWUFBWSxNQUFNO1FBQ2hEamUsZUFBZW9jLGNBQWM7WUFBQztZQUFTO1lBQW9CO1NBQU8sRUFBRTZCO0lBQ3hFO0lBQ0EsTUFBTUMsV0FBVy9jLGVBQWVrQyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJK1ksaUJBQWlCbmUsYUFBYWlnQixZQUFZLE1BQU07UUFDaERsZSxlQUFlb2MsY0FBYztZQUFDO1lBQVM7WUFBb0I7U0FBTyxFQUFFOEI7SUFDeEU7SUFDQSxNQUFNRSxzQkFBc0JqZCxlQUFla0MsWUFBWTtRQUNuRDtLQUNIO0lBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWFtZ0IsdUJBQXVCLE1BQU07UUFDM0RwZSxlQUFlb2MsY0FBYztZQUFDO1lBQVM7WUFBb0I7U0FBa0IsRUFBRWdDO0lBQ25GO0lBQ0EsTUFBTWtCLHNCQUFzQm5lLGVBQWVrQyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJK1ksaUJBQWlCbmUsYUFBYXFoQix1QkFBdUIsTUFBTTtRQUMzRHRmLGVBQWVvYyxjQUFjO1lBQUM7WUFBUztZQUFvQjtTQUFrQixFQUFFa0Q7SUFDbkY7SUFDQSxNQUFNWixXQUFXdmQsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUkrWSxpQkFBaUJuZSxhQUFheWdCLFlBQVksTUFBTTtRQUNoRDFlLGVBQWVvYyxjQUFjO1lBQUM7WUFBUztZQUFvQjtTQUFPLEVBQUVzQztJQUN4RTtJQUNBLE1BQU1hLG1CQUFtQnBlLGVBQWVrQyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJK1ksaUJBQWlCbmUsYUFBYXNoQixvQkFBb0IsTUFBTTtRQUN4RHZmLGVBQWVvYyxjQUFjO1lBQUM7WUFBUztZQUFvQjtTQUFlLEVBQUUxSCxrQkFBa0I2SztJQUNsRztJQUNBLE1BQU1DLHFCQUFxQnJlLGVBQWVrQyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJK1ksaUJBQWlCbmUsYUFBYXVoQixzQkFBc0IsTUFBTTtRQUMxRHhmLGVBQWVvYyxjQUFjO1lBQUM7WUFBUztZQUFvQjtTQUFpQixFQUFFb0Q7SUFDbEY7SUFDQSxNQUFNNFEsNEJBQTRCanZCLGVBQWVrQyxZQUFZO1FBQ3pEO0tBQ0g7SUFDRCxJQUFJK1ksaUJBQWlCbmUsYUFBYW15Qiw2QkFBNkIsTUFBTTtRQUNqRXB3QixlQUFlb2MsY0FBYztZQUFDO1lBQVM7WUFBb0I7U0FBd0IsRUFBRWdVO0lBQ3pGO0lBQ0EsTUFBTXJTLHdCQUF3QjVjLGVBQWVrQyxZQUFZO1FBQ3JEO0tBQ0g7SUFDRCxJQUFJK1ksaUJBQWlCbmUsYUFBYThmLHlCQUF5QixNQUFNO1FBQzdEL2QsZUFBZW9jLGNBQWM7WUFBQztZQUFTO1NBQW9CLEVBQUU0NEIsZUFBZXRpQyxTQUFTcUw7SUFDekY7SUFDQSxNQUFNaUIsWUFBWTdkLGVBQWVrQyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJK1ksaUJBQWlCbmUsYUFBYStnQixhQUFhLE1BQU07UUFDakQsSUFBSTdhLGtCQUFrQitRLE9BQU84SjtRQUM3QixJQUFJeGUsTUFBTUMsT0FBTyxDQUFDMEQsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQjlDLEdBQUcsQ0FBQyxDQUFDa0I7Z0JBQ25DLE9BQU91ekMsWUFBWW5oQyxNQUFNcFM7WUFDN0I7UUFDSjtRQUNBdkMsZUFBZW9jLGNBQWM7WUFBQztZQUFTO1NBQVEsRUFBRWpZO0lBQ3JEO0lBQ0EsTUFBTXlzQix3QkFBd0J6dkIsZUFBZWtDLFlBQVk7UUFDckQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhMnlCLHlCQUF5QixNQUFNO1FBQzdENXdCLGVBQWVvYyxjQUFjO1lBQUM7WUFBUztTQUFvQixFQUFFMjVCLCtCQUErQm5sQjtJQUNoRztJQUNBLE1BQU1FLDhCQUE4QjN2QixlQUFla0MsWUFBWTtRQUMzRDtLQUNIO0lBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWE2eUIsK0JBQStCLE1BQU07UUFDbkU5d0IsZUFBZW9jLGNBQWM7WUFBQztZQUFTO1NBQTBCLEVBQUUwVTtJQUN2RTtJQUNBLE1BQU1DLCtCQUErQjV2QixlQUFla0MsWUFBWTtRQUM1RDtLQUNIO0lBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWE4eUIsZ0NBQWdDLE1BQU07UUFDcEUvd0IsZUFBZW9jLGNBQWM7WUFBQztZQUFTO1NBQTJCLEVBQUUyVTtJQUN4RTtJQUNBLE1BQU1DLDBCQUEwQjd2QixlQUFla0MsWUFBWTtRQUN2RDtLQUNIO0lBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWEreUIsMkJBQTJCLE1BQU07UUFDL0RoeEIsZUFBZW9jLGNBQWM7WUFBQztZQUFTO1NBQXNCLEVBQUU0VTtJQUNuRTtJQUNBLE1BQU1DLCtCQUErQjl2QixlQUFla0MsWUFBWTtRQUM1RDtLQUNIO0lBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWFnekIsZ0NBQWdDLE1BQU07UUFDcEVqeEIsZUFBZW9jLGNBQWM7WUFBQztZQUFTO1NBQTJCLEVBQUU2VTtJQUN4RTtJQUNBLE1BQU1DLGtCQUFrQi92QixlQUFla0MsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSStZLGlCQUFpQm5lLGFBQWFpekIsbUJBQW1CLE1BQU07UUFDdkRseEIsZUFBZW9jLGNBQWM7WUFBQztZQUFTO1NBQWMsRUFBRThVO0lBQzNEO0lBQ0EsT0FBTzV0QjtBQUNYO0FBQ0EsU0FBU2d5Qyw4QkFBOEJsa0MsU0FBUyxFQUFFL04sVUFBVTtJQUN4RCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTTZXLFlBQVloWixlQUFla0MsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSThXLGFBQWEsTUFBTTtRQUNuQm5hLGVBQWVzRCxVQUFVO1lBQUM7WUFBUztTQUFRLEVBQUU2TixPQUFPQyxXQUFXK0k7SUFDbkU7SUFDQSxNQUFNb0MsYUFBYXBiLGVBQWVrQyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJa1osY0FBYyxNQUFNO1FBQ3BCdmMsZUFBZXNELFVBQVU7WUFBQztTQUFTLEVBQUV1eUMseUJBQXlCdDVCLFlBQVlqWjtJQUM5RTtJQUNBLE9BQU9BO0FBQ1g7QUFDQSxTQUFTMnhDLFlBQVk1eEMsVUFBVTtJQUMzQixNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTWdjLHNCQUFzQm5lLGVBQWVrQyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJaWMsdUJBQXVCLE1BQU07UUFDN0J0ZixlQUFlc0QsVUFBVTtZQUFDO1NBQWtCLEVBQUVnYztJQUNsRDtJQUNBLE1BQU04QiwwQkFBMEJqZ0IsZUFBZWtDLFlBQVk7UUFDdkQ7S0FDSDtJQUNELElBQUkrZCwyQkFBMkIsTUFBTTtRQUNqQ3BoQixlQUFlc0QsVUFBVTtZQUFDO1NBQXNCLEVBQUU4ZDtJQUN0RDtJQUNBLE1BQU1DLHFCQUFxQmxnQixlQUFla0MsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSWdlLHNCQUFzQixNQUFNO1FBQzVCcmhCLGVBQWVzRCxVQUFVO1lBQUM7U0FBaUIsRUFBRStkO0lBQ2pEO0lBQ0EsTUFBTUMsZUFBZW5nQixlQUFla0MsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSWllLGdCQUFnQixNQUFNO1FBQ3RCdGhCLGVBQWVzRCxVQUFVO1lBQUM7U0FBVyxFQUFFbXlDLGdCQUFnQm4wQjtJQUMzRDtJQUNBLE1BQU1DLG1CQUFtQnBnQixlQUFla0MsWUFBWTtRQUFDO0tBQWU7SUFDcEUsSUFBSWtlLG9CQUFvQixNQUFNO1FBQzFCdmhCLGVBQWVzRCxVQUFVO1lBQUM7U0FBZSxFQUFFb3lDLG9CQUFvQm4wQjtJQUNuRTtJQUNBLE1BQU1DLHVCQUF1QnJnQixlQUFla0MsWUFBWTtRQUNwRDtLQUNIO0lBQ0QsSUFBSW1lLHdCQUF3QixNQUFNO1FBQzlCeGhCLGVBQWVzRCxVQUFVO1lBQUM7U0FBbUIsRUFBRWtlO0lBQ25EO0lBQ0EsTUFBTUMsaUJBQWlCdGdCLGVBQWVrQyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJb2Usa0JBQWtCLE1BQU07UUFDeEJ6aEIsZUFBZXNELFVBQVU7WUFBQztTQUFhLEVBQUV5eEMsWUFBWXR6QjtJQUN6RDtJQUNBLE1BQU1DLFdBQVd2Z0IsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlxZSxZQUFZLE1BQU07UUFDbEIxaEIsZUFBZXNELFVBQVU7WUFBQztTQUFPLEVBQUVvZTtJQUN2QztJQUNBLE1BQU1DLGNBQWN4Z0IsZUFBZWtDLFlBQVk7UUFBQztLQUFVO0lBQzFELElBQUlzZSxlQUFlLE1BQU07UUFDckIzaEIsZUFBZXNELFVBQVU7WUFBQztTQUFVLEVBQUVxZTtJQUMxQztJQUNBLE1BQU1DLHVCQUF1QnpnQixlQUFla0MsWUFBWTtRQUNwRDtLQUNIO0lBQ0QsSUFBSXVlLHdCQUF3QixNQUFNO1FBQzlCNWhCLGVBQWVzRCxVQUFVO1lBQUM7U0FBbUIsRUFBRXNlO0lBQ25EO0lBQ0EsTUFBTUMsb0JBQW9CMWdCLGVBQWVrQyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJd2UscUJBQXFCLE1BQU07UUFDM0I3aEIsZUFBZXNELFVBQVU7WUFBQztTQUFnQixFQUFFdWU7SUFDaEQ7SUFDQSxPQUFPdmU7QUFDWDtBQUNBLFNBQVN5eUMsK0JBQStCMXlDLFVBQVU7SUFDOUMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1vdkIsYUFBYXZ4QixlQUFla0MsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSXF2QixjQUFjLE1BQU07UUFDcEIxeUIsZUFBZXNELFVBQVU7WUFBQztTQUFTLEVBQUVvdkI7SUFDekM7SUFDQSxJQUFJdnhCLGVBQWVrQyxZQUFZO1FBQUM7S0FBYyxNQUFNcEYsV0FBVztRQUMzRCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsT0FBT3VEO0FBQ1g7QUFDQSxTQUFTd3lDLFlBQVl6eUMsVUFBVTtJQUMzQixNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTTRlLDJCQUEyQi9nQixlQUFla0MsWUFBWTtRQUN4RDtLQUNIO0lBQ0QsSUFBSTZlLDRCQUE0QixNQUFNO1FBQ2xDLElBQUkvZCxrQkFBa0IrZDtRQUN0QixJQUFJMWhCLE1BQU1DLE9BQU8sQ0FBQzBELGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0I5QyxHQUFHLENBQUMsQ0FBQ2tCO2dCQUNuQyxPQUFPQTtZQUNYO1FBQ0o7UUFDQXZDLGVBQWVzRCxVQUFVO1lBQUM7U0FBdUIsRUFBRWE7SUFDdkQ7SUFDQSxJQUFJaEQsZUFBZWtDLFlBQVk7UUFBQztLQUFZLE1BQU1wRixXQUFXO1FBQ3pELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxNQUFNb2lCLDRCQUE0QmhoQixlQUFla0MsWUFBWTtRQUN6RDtLQUNIO0lBQ0QsSUFBSThlLDZCQUE2QixNQUFNO1FBQ25DbmlCLGVBQWVzRCxVQUFVO1lBQUM7U0FBd0IsRUFBRTZlO0lBQ3hEO0lBQ0EsTUFBTUMsa0JBQWtCamhCLGVBQWVrQyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJK2UsbUJBQW1CLE1BQU07UUFDekJwaUIsZUFBZXNELFVBQVU7WUFBQztTQUFjLEVBQUU4ZTtJQUM5QztJQUNBLE1BQU1DLGlCQUFpQmxoQixlQUFla0MsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSWdmLGtCQUFrQixNQUFNO1FBQ3hCcmlCLGVBQWVzRCxVQUFVO1lBQUM7U0FBYSxFQUFFK2U7SUFDN0M7SUFDQSxNQUFNQyxvQkFBb0JuaEIsZUFBZWtDLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUlpZixxQkFBcUIsTUFBTTtRQUMzQnRpQixlQUFlc0QsVUFBVTtZQUFDO1NBQWdCLEVBQUVnZjtJQUNoRDtJQUNBLElBQUluaEIsZUFBZWtDLFlBQVk7UUFBQztLQUFzQixNQUFNcEYsV0FBVztRQUNuRSxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTXdpQixpQkFBaUJwaEIsZUFBZWtDLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUlrZixrQkFBa0IsTUFBTTtRQUN4QnZpQixlQUFlc0QsVUFBVTtZQUFDO1NBQWEsRUFBRXF5QyxrQkFBa0JwekI7SUFDL0Q7SUFDQSxNQUFNQyxtQkFBbUJyaEIsZUFBZWtDLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUltZixvQkFBb0IsTUFBTTtRQUMxQnhpQixlQUFlc0QsVUFBVTtZQUFDO1NBQWUsRUFBRXN5QyxvQkFBb0JwekI7SUFDbkU7SUFDQSxNQUFNQyxpQkFBaUJ0aEIsZUFBZWtDLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUlvZixrQkFBa0IsTUFBTTtRQUN4QnppQixlQUFlc0QsVUFBVTtZQUFDO1NBQWEsRUFBRW1mO0lBQzdDO0lBQ0EsT0FBT25mO0FBQ1g7QUFFQTs7OztDQUlDLEdBQ0Q7Ozs7O0NBS0MsR0FDRCxTQUFTMHlDLGNBQWN6SyxLQUFLO0lBQ3hCLE1BQU0wSyxTQUFTLEVBQUU7SUFDakIsSUFBSyxNQUFNejJDLE9BQU8rckMsTUFBTztRQUNyQixJQUFJOXJDLE9BQU9DLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUMyckMsT0FBTy9yQyxNQUFNO1lBQ2xELE1BQU1LLFFBQVEwckMsS0FBSyxDQUFDL3JDLElBQUk7WUFDeEIsK0RBQStEO1lBQy9ELElBQUksT0FBT0ssVUFBVSxZQUNqQkEsU0FBUyxRQUNUSixPQUFPUyxJQUFJLENBQUNMLE9BQU9PLE1BQU0sR0FBRyxHQUFHO2dCQUMvQixNQUFNODFDLFFBQVF6MkMsT0FBT1MsSUFBSSxDQUFDTCxPQUFPd0IsR0FBRyxDQUFDLENBQUM4MEMsS0FBTyxHQUFVQSxPQUFQMzJDLEtBQUksS0FBTSxPQUFIMjJDO2dCQUN2REYsT0FBT2h6QyxJQUFJLElBQUlpekM7WUFDbkIsT0FDSztnQkFDREQsT0FBT2h6QyxJQUFJLENBQUN6RCxNQUFNLFlBQVk7WUFDbEM7UUFDSjtJQUNKO0lBQ0EsT0FBT3kyQyxPQUFPMVQsSUFBSSxDQUFDO0FBQ3ZCO0FBQ0E7Ozs7O0NBS0MsR0FDRCxTQUFTNlQsNkJBQTZCcnhCLFdBQVcsRUFBRWhWLE1BQU07SUFDckQsd0VBQXdFO0lBQ3hFLElBQUlzbUMseUJBQXlCO0lBQzdCLE1BQU1DLGdDQUFnQ3Z4QixXQUFXLENBQUMsMkJBQTJCO0lBQzdFLElBQUksT0FBT3V4QixrQ0FBa0MsWUFDekNBLGtDQUFrQyxRQUNsQyxXQUFXQSwrQkFBK0I7UUFDMUMsMkVBQTJFO1FBQzNFLFlBQVk7UUFDWixNQUFNQyxhQUFhRCw4QkFDZC9LLEtBQUs7UUFDVixJQUFJLE9BQU9nTCxlQUFlLFlBQVlBLGVBQWUsTUFBTTtZQUN2RCwyQkFBMkI7WUFDM0J4eEIsV0FBVyxDQUFDLDJCQUEyQixHQUFHd3hCO1lBQzFDRix5QkFBeUJFO1FBQzdCLE9BQ0s7WUFDRCx3RUFBd0U7WUFDeEUsMENBQTBDO1lBQzFDLE9BQU94eEIsV0FBVyxDQUFDLDJCQUEyQjtRQUNsRDtJQUNKLE9BQ0ssSUFBSXV4QixrQ0FBa0NyNEMsV0FBVztRQUNsRCw0REFBNEQ7UUFDNUQsMENBQTBDO1FBQzFDLE9BQU84bUIsV0FBVyxDQUFDLDJCQUEyQjtJQUNsRDtJQUNBLE1BQU15eEIsdUJBQXVCenhCLFdBQVcsQ0FBQyxZQUFZO0lBQ3JELGdDQUFnQztJQUNoQyxJQUFJc3hCLHdCQUF3QjtRQUN4QixNQUFNSSx3QkFBd0JULGNBQWNLO1FBQzVDLElBQUk3MUMsTUFBTUMsT0FBTyxDQUFDc1AsV0FBVyxRQUFRQSxXQUFXLEtBQUssSUFBSSxLQUFLLElBQUlBLE9BQU8ybUMsb0JBQW9CLEtBQ3pGLENBQUMzbUMsV0FBVyxRQUFRQSxXQUFXLEtBQUssSUFBSSxLQUFLLElBQUlBLE9BQU8ybUMsb0JBQW9CLENBQUN0MkMsTUFBTSxNQUFNLEdBQUc7WUFDNUYsd0VBQXdFO1lBQ3hFLGNBQWM7WUFDZCxJQUFJcTJDLHVCQUF1QjtnQkFDdkIsbUNBQW1DO2dCQUNuQzF4QixXQUFXLENBQUMsWUFBWSxHQUFHMHhCO1lBQy9CLE9BQ0s7Z0JBQ0QsT0FBTzF4QixXQUFXLENBQUMsWUFBWSxFQUFFLG1DQUFtQztZQUNwRSxpQ0FBaUM7WUFDckM7UUFDSixPQUNLLElBQUksQ0FBQ2hWLFdBQVcsUUFBUUEsV0FBVyxLQUFLLElBQUksS0FBSyxJQUFJQSxPQUFPMm1DLG9CQUFvQixLQUNqRjNtQyxPQUFPMm1DLG9CQUFvQixDQUFDdDJDLE1BQU0sR0FBRyxLQUNyQ28yQyx5QkFBeUIsUUFDekJoMkMsTUFBTUMsT0FBTyxDQUFDKzFDLHlCQUNkQSxxQkFBcUJwMkMsTUFBTSxHQUFHLEdBQUc7WUFDakMsMERBQTBEO1lBQzFELDBCQUEwQjtZQUMxQixNQUFNdTJDLHlCQUF5QjtnQkFDM0I7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7YUFDSDtZQUNELElBQUlDLDhCQUE4QixFQUFFO1lBQ3BDLElBQUlKLHFCQUFxQnAyQyxNQUFNLEdBQUcsR0FBRztnQkFDakN3MkMsOEJBQThCSixxQkFBcUJuMUMsR0FBRyxDQUFDLENBQUM2MEM7b0JBQ3BELElBQUlTLHVCQUF1QnJsQyxRQUFRLENBQUM0a0MsUUFBUTt3QkFDeEMsT0FBTyxvQkFBMEIsT0FBTkE7b0JBQy9CO29CQUNBLE9BQU9BLE9BQU8scUNBQXFDO2dCQUNuRCx5QkFBeUI7Z0JBQzdCO1lBQ0o7WUFDQSxNQUFNVyxpQkFBaUIsRUFBRTtZQUN6QixJQUFJSix1QkFBdUI7Z0JBQ3ZCSSxlQUFlNXpDLElBQUksQ0FBQ3d6QztZQUN4QjtZQUNBLElBQUlHLDRCQUE0QngyQyxNQUFNLEdBQUcsR0FBRztnQkFDeEN5MkMsZUFBZTV6QyxJQUFJLElBQUkyekM7WUFDM0I7WUFDQSxJQUFJQyxlQUFlejJDLE1BQU0sR0FBRyxHQUFHO2dCQUMzQjJrQixXQUFXLENBQUMsWUFBWSxHQUFHOHhCLGVBQWV0VSxJQUFJLENBQUM7WUFDbkQsT0FDSztnQkFDRCw2REFBNkQ7Z0JBQzdELHFCQUFxQjtnQkFDckIsT0FBT3hkLFdBQVcsQ0FBQyxZQUFZO1lBQ25DO1FBQ0osT0FDSztZQUNELDBFQUEwRTtZQUMxRSxzREFBc0Q7WUFDdEQsaURBQWlEO1lBQ2pELHFEQUFxRDtZQUNyRCxxRUFBcUU7WUFDckUsT0FBT0EsV0FBVyxDQUFDLFlBQVk7UUFDbkM7SUFDSixPQUNLO1FBQ0QsOERBQThEO1FBQzlELHdDQUF3QztRQUN4QyxJQUFJeXhCLHlCQUF5QixRQUN6QmgyQyxNQUFNQyxPQUFPLENBQUMrMUMseUJBQ2RBLHFCQUFxQnAyQyxNQUFNLEdBQUcsR0FBRztZQUNqQyxvRUFBb0U7WUFDcEUseUNBQXlDO1lBQ3pDMmtCLFdBQVcsQ0FBQyxZQUFZLEdBQUd5eEIscUJBQXFCalUsSUFBSSxDQUFDO1FBQ3pELE9BQ0s7WUFDRCxPQUFPeGQsV0FBVyxDQUFDLFlBQVk7UUFDbkM7SUFDSjtJQUNBLE9BQU9BO0FBQ1g7QUFDQSxNQUFNK3hCLGVBQWU3M0M7SUFLakI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FrRkMsR0FDRCxNQUFNNm5CLE9BQU9qRSxNQUFNLEVBQUU7UUFDakIsSUFBSWhrQixJQUFJQztRQUNSLElBQUlzTDtRQUNKLElBQUlxYSxPQUFPO1FBQ1gsSUFBSW1CLGNBQWMsQ0FBQztRQUNuQixJQUFJLElBQUksQ0FBQ3hVLFNBQVMsQ0FBQ0csVUFBVSxJQUFJO1lBQzdCLE1BQU0sSUFBSXhSLE1BQU07UUFDcEIsT0FDSztZQUNELE1BQU13a0IsT0FBT2l4QixpQ0FBaUMsSUFBSSxDQUFDcGtDLFNBQVMsRUFBRXlSO1lBQzlENEIsT0FBT3ZsQixVQUFVLGVBQWVxbEIsSUFBSSxDQUFDLE9BQU87WUFDNUNxQixjQUFjckIsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckIsTUFBTXd5QixrQkFBa0JYLDZCQUE2Qjd4QixNQUFNMUIsT0FBTzlTLE1BQU07WUFDeEUzRixXQUFXLElBQUksQ0FBQ2dILFNBQVMsQ0FDcEJnVCxPQUFPLENBQUM7Z0JBQ1RLLE1BQU1BO2dCQUNObUIsYUFBYUE7Z0JBQ2JyQixNQUFNc0IsS0FBS0MsU0FBUyxDQUFDaXhCO2dCQUNyQmh4QixZQUFZO2dCQUNadG5CLGFBQWEsQ0FBQ0ksS0FBS2drQixPQUFPOVMsTUFBTSxNQUFNLFFBQVFsUixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdKLFdBQVc7Z0JBQ3JGdW5CLGFBQWEsQ0FBQ2xuQixLQUFLK2pCLE9BQU85UyxNQUFNLE1BQU0sUUFBUWpSLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2tuQixXQUFXO1lBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQztnQkFDUCxPQUFPQSxhQUFhemEsSUFBSTtZQUM1QjtZQUNBLE9BQU9yQixTQUFTNmIsSUFBSSxDQUFDLENBQUNFO2dCQUNsQixPQUFPQTtZQUNYO1FBQ0o7SUFDSjtJQXZIQXhhLFlBQVl5RixTQUFTLENBQUU7UUFDbkIsS0FBSztRQUNMLElBQUksQ0FBQ0EsU0FBUyxHQUFHQTtJQUNyQjtBQXFISjtBQUVBOzs7O0NBSUMsR0FDRCxpRUFBaUU7QUFDakUsU0FBUzRsQyw0QkFBNEIzekMsVUFBVSxFQUFFK1ksWUFBWTtJQUN6RCxNQUFNOVksV0FBVyxDQUFDO0lBQ2xCLE1BQU0wOEIsWUFBWTcrQixlQUFla0MsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSStZLGlCQUFpQm5lLGFBQWEraEMsYUFBYSxNQUFNO1FBQ2pEaGdDLGVBQWVvYyxjQUFjO1lBQUM7WUFBVTtTQUFRLEVBQUU0akI7SUFDdEQ7SUFDQSxPQUFPMThCO0FBQ1g7QUFDQSxTQUFTMnpDLGdDQUFnQzV6QyxVQUFVO0lBQy9DLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNSSxXQUFXdkMsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlLLFlBQVksTUFBTTtRQUNsQjFELGVBQWVzRCxVQUFVO1lBQUM7WUFBUTtTQUFPLEVBQUVJO0lBQy9DO0lBQ0EsTUFBTTZZLGFBQWFwYixlQUFla0MsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSWtaLGNBQWMsTUFBTTtRQUNwQnk2Qiw0QkFBNEJ6NkIsWUFBWWpaO0lBQzVDO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLFNBQVM0ekMsNkJBQTZCN3pDLFVBQVU7SUFDNUMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1JLFdBQVd2QyxlQUFla0MsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSUssWUFBWSxNQUFNO1FBQ2xCMUQsZUFBZXNELFVBQVU7WUFBQztZQUFRO1NBQU8sRUFBRUk7SUFDL0M7SUFDQSxPQUFPSjtBQUNYO0FBQ0EsU0FBUzZ6QywyQkFBMkI5ekMsVUFBVSxFQUFFK1ksWUFBWTtJQUN4RCxNQUFNOVksV0FBVyxDQUFDO0lBQ2xCLE1BQU1vZCxlQUFldmYsZUFBZWtDLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUkrWSxpQkFBaUJuZSxhQUFheWlCLGdCQUFnQixNQUFNO1FBQ3BEMWdCLGVBQWVvYyxjQUFjO1lBQUM7WUFBVTtTQUFXLEVBQUVzRTtJQUN6RDtJQUNBLE1BQU1DLGdCQUFnQnhmLGVBQWVrQyxZQUFZO1FBQUM7S0FBWTtJQUM5RCxJQUFJK1ksaUJBQWlCbmUsYUFBYTBpQixpQkFBaUIsTUFBTTtRQUNyRDNnQixlQUFlb2MsY0FBYztZQUFDO1lBQVU7U0FBWSxFQUFFdUU7SUFDMUQ7SUFDQSxPQUFPcmQ7QUFDWDtBQUNBLFNBQVM4ekMsK0JBQStCL3pDLFVBQVU7SUFDOUMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU0wQixhQUFhN0QsZUFBZWtDLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUkyQixjQUFjLE1BQU07UUFDcEJoRixlQUFlc0QsVUFBVTtZQUFDO1lBQVE7U0FBUyxFQUFFMEI7SUFDakQ7SUFDQSxNQUFNdVgsYUFBYXBiLGVBQWVrQyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJa1osY0FBYyxNQUFNO1FBQ3BCNDZCLDJCQUEyQjU2QixZQUFZalo7SUFDM0M7SUFDQSxPQUFPQTtBQUNYO0FBQ0EsU0FBUyt6QywrQkFBK0JoMEMsVUFBVTtJQUM5QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXlCLHNCQUFzQjVELGVBQWVrQyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJMEIsdUJBQXVCLE1BQU07UUFDN0IvRSxlQUFlc0QsVUFBVTtZQUFDO1NBQWtCLEVBQUV5QjtJQUNsRDtJQUNBLE1BQU1rYyxvQkFBb0I5ZixlQUFla0MsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSTRkLHFCQUFxQixNQUFNO1FBQzNCamhCLGVBQWVzRCxVQUFVO1lBQUM7U0FBZ0IsRUFBRTJkO0lBQ2hEO0lBQ0EsTUFBTXEyQixnQkFBZ0JuMkMsZUFBZWtDLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUlpMEMsaUJBQWlCLE1BQU07UUFDdkIsSUFBSW56QyxrQkFBa0JtekM7UUFDdEIsSUFBSTkyQyxNQUFNQyxPQUFPLENBQUMwRCxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCOUMsR0FBRyxDQUFDLENBQUNrQjtnQkFDbkMsT0FBT0E7WUFDWDtRQUNKO1FBQ0F2QyxlQUFlc0QsVUFBVTtZQUFDO1NBQVksRUFBRWE7SUFDNUM7SUFDQSxPQUFPYjtBQUNYO0FBRUE7Ozs7Q0FJQyxHQUNELE1BQU1pMEMsa0JBQWtCdDRDO0lBc0JwQjs7Ozs7S0FLQyxHQUNELE1BQU1vbkIsSUFBSXhELE1BQU0sRUFBRTtRQUNkLElBQUloa0IsSUFBSUM7UUFDUixJQUFJc0w7UUFDSixJQUFJcWEsT0FBTztRQUNYLElBQUltQixjQUFjLENBQUM7UUFDbkIsSUFBSSxJQUFJLENBQUN4VSxTQUFTLENBQUNHLFVBQVUsSUFBSTtZQUM3QixNQUFNLElBQUl4UixNQUFNO1FBQ3BCLE9BQ0s7WUFDRCxNQUFNd2tCLE9BQU8yeUIsNkJBQTZCcjBCO1lBQzFDNEIsT0FBT3ZsQixVQUFVLFVBQVVxbEIsSUFBSSxDQUFDLE9BQU87WUFDdkNxQixjQUFjckIsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJuYSxXQUFXLElBQUksQ0FBQ2dILFNBQVMsQ0FDcEJnVCxPQUFPLENBQUM7Z0JBQ1RLLE1BQU1BO2dCQUNObUIsYUFBYUE7Z0JBQ2JyQixNQUFNc0IsS0FBS0MsU0FBUyxDQUFDdkI7Z0JBQ3JCd0IsWUFBWTtnQkFDWnRuQixhQUFhLENBQUNJLEtBQUtna0IsT0FBTzlTLE1BQU0sTUFBTSxRQUFRbFIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSixXQUFXO2dCQUNyRnVuQixhQUFhLENBQUNsbkIsS0FBSytqQixPQUFPOVMsTUFBTSxNQUFNLFFBQVFqUixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdrbkIsV0FBVztZQUN6RixHQUNLQyxJQUFJLENBQUMsQ0FBQ0M7Z0JBQ1AsT0FBT0EsYUFBYXphLElBQUk7WUFDNUI7WUFDQSxPQUFPckIsU0FBUzZiLElBQUksQ0FBQyxDQUFDRTtnQkFDbEIsT0FBT0E7WUFDWDtRQUNKO0lBQ0o7SUFDQTs7OztLQUlDLEdBQ0QsTUFBTU8sT0FBTzdELE1BQU0sRUFBRTtRQUNqQixJQUFJaGtCLElBQUlDO1FBQ1IsSUFBSTJsQixPQUFPO1FBQ1gsSUFBSW1CLGNBQWMsQ0FBQztRQUNuQixJQUFJLElBQUksQ0FBQ3hVLFNBQVMsQ0FBQ0csVUFBVSxJQUFJO1lBQzdCLE1BQU0sSUFBSXhSLE1BQU07UUFDcEIsT0FDSztZQUNELE1BQU13a0IsT0FBTzB5QixnQ0FBZ0NwMEI7WUFDN0M0QixPQUFPdmxCLFVBQVUsVUFBVXFsQixJQUFJLENBQUMsT0FBTztZQUN2Q3FCLGNBQWNyQixJQUFJLENBQUMsU0FBUztZQUM1QixPQUFPQSxJQUFJLENBQUMsT0FBTztZQUNuQixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQixNQUFNLElBQUksQ0FBQ25ULFNBQVMsQ0FBQ2dULE9BQU8sQ0FBQztnQkFDekJLLE1BQU1BO2dCQUNObUIsYUFBYUE7Z0JBQ2JyQixNQUFNc0IsS0FBS0MsU0FBUyxDQUFDdkI7Z0JBQ3JCd0IsWUFBWTtnQkFDWnRuQixhQUFhLENBQUNJLEtBQUtna0IsT0FBTzlTLE1BQU0sTUFBTSxRQUFRbFIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSixXQUFXO2dCQUNyRnVuQixhQUFhLENBQUNsbkIsS0FBSytqQixPQUFPOVMsTUFBTSxNQUFNLFFBQVFqUixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdrbkIsV0FBVztZQUN6RjtRQUNKO0lBQ0o7SUFDQSxNQUFNTyxhQUFhMUQsTUFBTSxFQUFFO1FBQ3ZCLElBQUloa0IsSUFBSUM7UUFDUixJQUFJc0w7UUFDSixJQUFJcWEsT0FBTztRQUNYLElBQUltQixjQUFjLENBQUM7UUFDbkIsSUFBSSxJQUFJLENBQUN4VSxTQUFTLENBQUNHLFVBQVUsSUFBSTtZQUM3QixNQUFNLElBQUl4UixNQUFNO1FBQ3BCLE9BQ0s7WUFDRCxNQUFNd2tCLE9BQU82eUIsK0JBQStCdjBCO1lBQzVDNEIsT0FBT3ZsQixVQUFVLHNCQUFzQnFsQixJQUFJLENBQUMsT0FBTztZQUNuRHFCLGNBQWNyQixJQUFJLENBQUMsU0FBUztZQUM1QixPQUFPQSxJQUFJLENBQUMsT0FBTztZQUNuQixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQm5hLFdBQVcsSUFBSSxDQUFDZ0gsU0FBUyxDQUNwQmdULE9BQU8sQ0FBQztnQkFDVEssTUFBTUE7Z0JBQ05tQixhQUFhQTtnQkFDYnJCLE1BQU1zQixLQUFLQyxTQUFTLENBQUN2QjtnQkFDckJ3QixZQUFZO2dCQUNadG5CLGFBQWEsQ0FBQ0ksS0FBS2drQixPQUFPOVMsTUFBTSxNQUFNLFFBQVFsUixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdKLFdBQVc7Z0JBQ3JGdW5CLGFBQWEsQ0FBQ2xuQixLQUFLK2pCLE9BQU85UyxNQUFNLE1BQU0sUUFBUWpSLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2tuQixXQUFXO1lBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQztnQkFDUCxPQUFPQSxhQUFhemEsSUFBSTtZQUM1QjtZQUNBLE9BQU9yQixTQUFTNmIsSUFBSSxDQUFDLENBQUMvWDtnQkFDbEIsTUFBTWlZLE9BQU9reEIsK0JBQStCbnBDO2dCQUM1QyxNQUFNdVksWUFBWSxJQUFJL1g7Z0JBQ3RCalAsT0FBT3dCLE1BQU0sQ0FBQ3dsQixXQUFXTjtnQkFDekIsT0FBT007WUFDWDtRQUNKO0lBQ0o7SUF2SEE5YSxZQUFZeUYsU0FBUyxDQUFFO1FBQ25CLEtBQUs7UUFDTCxJQUFJLENBQUNBLFNBQVMsR0FBR0E7UUFDakI7Ozs7Ozs7Ozs7Ozs7U0FhQyxHQUNELElBQUksQ0FBQ3VWLElBQUksR0FBRyxPQUFPOUQ7WUFDZixPQUFPLElBQUlGLE1BQU1ELFVBQVU4MEIsb0JBQW9CLEVBQUUsQ0FBQzN3QixJQUFNLElBQUksQ0FBQ04sWUFBWSxDQUFDO29CQUFFa3hCLFFBQVE1MEIsT0FBTzQwQixNQUFNO29CQUFFMW5DLFFBQVE4VyxFQUFFOVcsTUFBTTtnQkFBQyxJQUFJLE1BQU0sSUFBSSxDQUFDd1csWUFBWSxDQUFDMUQsU0FBU0E7UUFDN0o7SUFDSjtBQW9HSjtBQUVBOzs7O0NBSUMsR0FDRCxNQUFNNjBCLHlCQUF5Qno0QztJQXVCM0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBbUNDLEdBQ0QsTUFBTXFvQyx3QkFBd0J6a0IsTUFBTSxFQUFFO1FBQ2xDLElBQUksSUFBSSxDQUFDelIsU0FBUyxDQUFDRyxVQUFVLElBQUk7WUFDN0IsTUFBTSxJQUFJeFIsTUFBTTtRQUNwQjtRQUNBLE9BQU8sSUFBSSxDQUFDcVIsU0FBUyxDQUFDZzJCLDJCQUEyQixDQUFDdmtCLE9BQU93a0IsbUJBQW1CLEVBQUV4a0IsT0FBTzBNLElBQUksRUFBRTFNLE9BQU85UyxNQUFNO0lBQzVHO0lBQ0E7Ozs7O0tBS0MsR0FDRCxNQUFNK1csT0FBT2pFLE1BQU0sRUFBRTtRQUNqQixJQUFJaGtCLElBQUlDO1FBQ1IsSUFBSXNMO1FBQ0osSUFBSXFhLE9BQU87UUFDWCxJQUFJbUIsY0FBYyxDQUFDO1FBQ25CLElBQUksSUFBSSxDQUFDeFUsU0FBUyxDQUFDRyxVQUFVLElBQUk7WUFDN0IsTUFBTSxJQUFJeFIsTUFBTTtRQUNwQixPQUNLO1lBQ0QsTUFBTXdrQixPQUFPdWIsdUNBQXVDamQ7WUFDcEQ0QixPQUFPdmxCLFVBQVUsb0JBQW9CcWxCLElBQUksQ0FBQyxPQUFPO1lBQ2pEcUIsY0FBY3JCLElBQUksQ0FBQyxTQUFTO1lBQzVCLE9BQU9BLElBQUksQ0FBQyxPQUFPO1lBQ25CLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCbmEsV0FBVyxJQUFJLENBQUNnSCxTQUFTLENBQ3BCZ1QsT0FBTyxDQUFDO2dCQUNUSyxNQUFNQTtnQkFDTm1CLGFBQWFBO2dCQUNickIsTUFBTXNCLEtBQUtDLFNBQVMsQ0FBQ3ZCO2dCQUNyQndCLFlBQVk7Z0JBQ1p0bkIsYUFBYSxDQUFDSSxLQUFLZ2tCLE9BQU85UyxNQUFNLE1BQU0sUUFBUWxSLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0osV0FBVztnQkFDckZ1bkIsYUFBYSxDQUFDbG5CLEtBQUsrakIsT0FBTzlTLE1BQU0sTUFBTSxRQUFRalIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHa25CLFdBQVc7WUFDekYsR0FDS0MsSUFBSSxDQUFDLENBQUNDO2dCQUNQLE9BQU9BLGFBQWF6YSxJQUFJO1lBQzVCO1lBQ0EsT0FBT3JCLFNBQVM2YixJQUFJLENBQUMsQ0FBQ0U7Z0JBQ2xCLE9BQU9BO1lBQ1g7UUFDSjtJQUNKO0lBQ0E7Ozs7O0tBS0MsR0FDRCxNQUFNRSxJQUFJeEQsTUFBTSxFQUFFO1FBQ2QsSUFBSWhrQixJQUFJQztRQUNSLElBQUlzTDtRQUNKLElBQUlxYSxPQUFPO1FBQ1gsSUFBSW1CLGNBQWMsQ0FBQztRQUNuQixJQUFJLElBQUksQ0FBQ3hVLFNBQVMsQ0FBQ0csVUFBVSxJQUFJO1lBQzdCLE1BQU0sSUFBSXhSLE1BQU07UUFDcEIsT0FDSztZQUNELE1BQU13a0IsT0FBTzJiLG9DQUFvQ3JkO1lBQ2pENEIsT0FBT3ZsQixVQUFVLFVBQVVxbEIsSUFBSSxDQUFDLE9BQU87WUFDdkNxQixjQUFjckIsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJuYSxXQUFXLElBQUksQ0FBQ2dILFNBQVMsQ0FDcEJnVCxPQUFPLENBQUM7Z0JBQ1RLLE1BQU1BO2dCQUNObUIsYUFBYUE7Z0JBQ2JyQixNQUFNc0IsS0FBS0MsU0FBUyxDQUFDdkI7Z0JBQ3JCd0IsWUFBWTtnQkFDWnRuQixhQUFhLENBQUNJLEtBQUtna0IsT0FBTzlTLE1BQU0sTUFBTSxRQUFRbFIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSixXQUFXO2dCQUNyRnVuQixhQUFhLENBQUNsbkIsS0FBSytqQixPQUFPOVMsTUFBTSxNQUFNLFFBQVFqUixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdrbkIsV0FBVztZQUN6RixHQUNLQyxJQUFJLENBQUMsQ0FBQ0M7Z0JBQ1AsT0FBT0EsYUFBYXphLElBQUk7WUFDNUI7WUFDQSxPQUFPckIsU0FBUzZiLElBQUksQ0FBQyxDQUFDRTtnQkFDbEIsT0FBT0E7WUFDWDtRQUNKO0lBQ0o7SUFDQTs7OztLQUlDLEdBQ0QsTUFBTU8sT0FBTzdELE1BQU0sRUFBRTtRQUNqQixJQUFJaGtCLElBQUlDO1FBQ1IsSUFBSTJsQixPQUFPO1FBQ1gsSUFBSW1CLGNBQWMsQ0FBQztRQUNuQixJQUFJLElBQUksQ0FBQ3hVLFNBQVMsQ0FBQ0csVUFBVSxJQUFJO1lBQzdCLE1BQU0sSUFBSXhSLE1BQU07UUFDcEIsT0FDSztZQUNELE1BQU13a0IsT0FBTzBiLHVDQUF1Q3BkO1lBQ3BENEIsT0FBT3ZsQixVQUFVLFVBQVVxbEIsSUFBSSxDQUFDLE9BQU87WUFDdkNxQixjQUFjckIsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckIsTUFBTSxJQUFJLENBQUNuVCxTQUFTLENBQUNnVCxPQUFPLENBQUM7Z0JBQ3pCSyxNQUFNQTtnQkFDTm1CLGFBQWFBO2dCQUNickIsTUFBTXNCLEtBQUtDLFNBQVMsQ0FBQ3ZCO2dCQUNyQndCLFlBQVk7Z0JBQ1p0bkIsYUFBYSxDQUFDSSxLQUFLZ2tCLE9BQU85UyxNQUFNLE1BQU0sUUFBUWxSLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0osV0FBVztnQkFDckZ1bkIsYUFBYSxDQUFDbG5CLEtBQUsrakIsT0FBTzlTLE1BQU0sTUFBTSxRQUFRalIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHa25CLFdBQVc7WUFDekY7UUFDSjtJQUNKO0lBQ0EsTUFBTU8sYUFBYTFELE1BQU0sRUFBRTtRQUN2QixJQUFJaGtCLElBQUlDO1FBQ1IsSUFBSXNMO1FBQ0osSUFBSXFhLE9BQU87UUFDWCxJQUFJbUIsY0FBYyxDQUFDO1FBQ25CLElBQUksSUFBSSxDQUFDeFUsU0FBUyxDQUFDRyxVQUFVLElBQUk7WUFDN0IsTUFBTSxJQUFJeFIsTUFBTTtRQUNwQixPQUNLO1lBQ0QsTUFBTXdrQixPQUFPb2Msc0NBQXNDOWQ7WUFDbkQ0QixPQUFPdmxCLFVBQVUsb0JBQW9CcWxCLElBQUksQ0FBQyxPQUFPO1lBQ2pEcUIsY0FBY3JCLElBQUksQ0FBQyxTQUFTO1lBQzVCLE9BQU9BLElBQUksQ0FBQyxPQUFPO1lBQ25CLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCbmEsV0FBVyxJQUFJLENBQUNnSCxTQUFTLENBQ3BCZ1QsT0FBTyxDQUFDO2dCQUNUSyxNQUFNQTtnQkFDTm1CLGFBQWFBO2dCQUNickIsTUFBTXNCLEtBQUtDLFNBQVMsQ0FBQ3ZCO2dCQUNyQndCLFlBQVk7Z0JBQ1p0bkIsYUFBYSxDQUFDSSxLQUFLZ2tCLE9BQU85UyxNQUFNLE1BQU0sUUFBUWxSLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0osV0FBVztnQkFDckZ1bkIsYUFBYSxDQUFDbG5CLEtBQUsrakIsT0FBTzlTLE1BQU0sTUFBTSxRQUFRalIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHa25CLFdBQVc7WUFDekYsR0FDS0MsSUFBSSxDQUFDLENBQUNDO2dCQUNQLE9BQU9BLGFBQWF6YSxJQUFJO1lBQzVCO1lBQ0EsT0FBT3JCLFNBQVM2YixJQUFJLENBQUMsQ0FBQy9YO2dCQUNsQixNQUFNaVksT0FBT3lhLHNDQUFzQzF5QjtnQkFDbkQsTUFBTXVZLFlBQVksSUFBSTlYO2dCQUN0QmxQLE9BQU93QixNQUFNLENBQUN3bEIsV0FBV047Z0JBQ3pCLE9BQU9NO1lBQ1g7UUFDSjtJQUNKO0lBQ0EsTUFBTWt4QixnQ0FBZ0M5MEIsTUFBTSxFQUFFO1FBQzFDLElBQUloa0IsSUFBSUM7UUFDUixJQUFJc0w7UUFDSixJQUFJcWEsT0FBTztRQUNYLElBQUltQixjQUFjLENBQUM7UUFDbkIsSUFBSSxJQUFJLENBQUN4VSxTQUFTLENBQUNHLFVBQVUsSUFBSTtZQUM3QixNQUFNLElBQUl4UixNQUFNO1FBQ3BCLE9BQ0s7WUFDRCxNQUFNd2tCLE9BQU93Yyx5Q0FBeUNsZTtZQUN0RDRCLE9BQU92bEIsVUFBVSxrRUFBa0VxbEIsSUFBSSxDQUFDLE9BQU87WUFDL0ZxQixjQUFjckIsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJuYSxXQUFXLElBQUksQ0FBQ2dILFNBQVMsQ0FDcEJnVCxPQUFPLENBQUM7Z0JBQ1RLLE1BQU1BO2dCQUNObUIsYUFBYUE7Z0JBQ2JyQixNQUFNc0IsS0FBS0MsU0FBUyxDQUFDdkI7Z0JBQ3JCd0IsWUFBWTtnQkFDWnRuQixhQUFhLENBQUNJLEtBQUtna0IsT0FBTzlTLE1BQU0sTUFBTSxRQUFRbFIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSixXQUFXO2dCQUNyRnVuQixhQUFhLENBQUNsbkIsS0FBSytqQixPQUFPOVMsTUFBTSxNQUFNLFFBQVFqUixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdrbkIsV0FBVztZQUN6RixHQUNLQyxJQUFJLENBQUMsQ0FBQ0M7Z0JBQ1AsT0FBT0EsYUFBYXphLElBQUk7WUFDNUI7WUFDQSxPQUFPckIsU0FBUzZiLElBQUksQ0FBQyxDQUFDL1g7Z0JBQ2xCLE1BQU1pWSxPQUFPNmEsa0RBQWtEOXlCO2dCQUMvRCxNQUFNdVksWUFBWSxJQUFJN1g7Z0JBQ3RCblAsT0FBT3dCLE1BQU0sQ0FBQ3dsQixXQUFXTjtnQkFDekIsT0FBT007WUFDWDtRQUNKO0lBQ0o7SUFDQTs7Ozs7OztLQU9DLEdBQ0QsTUFBTW14QixXQUFXLzBCLE1BQU0sRUFBRTtRQUNyQixJQUFJaGtCLElBQUlDO1FBQ1IsSUFBSXNMO1FBQ0osSUFBSXFhLE9BQU87UUFDWCxJQUFJbUIsY0FBYyxDQUFDO1FBQ25CLElBQUksSUFBSSxDQUFDeFUsU0FBUyxDQUFDRyxVQUFVLElBQUk7WUFDN0IsTUFBTSxJQUFJeFIsTUFBTTtRQUNwQixPQUNLO1lBQ0QsTUFBTXdrQixPQUFPaWMsNEJBQTRCM2Q7WUFDekM0QixPQUFPdmxCLFVBQVUsdUNBQXVDcWxCLElBQUksQ0FBQyxPQUFPO1lBQ3BFcUIsY0FBY3JCLElBQUksQ0FBQyxTQUFTO1lBQzVCLE9BQU9BLElBQUksQ0FBQyxPQUFPO1lBQ25CLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCbmEsV0FBVyxJQUFJLENBQUNnSCxTQUFTLENBQ3BCZ1QsT0FBTyxDQUFDO2dCQUNUSyxNQUFNQTtnQkFDTm1CLGFBQWFBO2dCQUNickIsTUFBTXNCLEtBQUtDLFNBQVMsQ0FBQ3ZCO2dCQUNyQndCLFlBQVk7Z0JBQ1p0bkIsYUFBYSxDQUFDSSxLQUFLZ2tCLE9BQU85UyxNQUFNLE1BQU0sUUFBUWxSLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0osV0FBVztnQkFDckZ1bkIsYUFBYSxDQUFDbG5CLEtBQUsrakIsT0FBTzlTLE1BQU0sTUFBTSxRQUFRalIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHa25CLFdBQVc7WUFDekYsR0FDS0MsSUFBSSxDQUFDLENBQUNDO2dCQUNQLE9BQU9BLGFBQWF6YSxJQUFJO1lBQzVCO1lBQ0EsT0FBT3JCLFNBQVM2YixJQUFJLENBQUMsQ0FBQy9YO2dCQUNsQixNQUFNaVksT0FBT21hLDZCQUE2QnB5QjtnQkFDMUMsTUFBTXVZLFlBQVksSUFBSTNYO2dCQUN0QnJQLE9BQU93QixNQUFNLENBQUN3bEIsV0FBV047Z0JBQ3pCLE9BQU9NO1lBQ1g7UUFDSjtJQUNKO0lBblJBOWEsWUFBWXlGLFNBQVMsRUFBRXltQyxZQUFZLElBQUlOLFVBQVVubUMsVUFBVSxDQUFFOztRQUN6RCxLQUFLO1FBQ0wsSUFBSSxDQUFDQSxTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ3ltQyxTQUFTLEdBQUdBO1FBQ2pCOzs7Ozs7Ozs7Ozs7O1NBYUMsR0FDRCxJQUFJLENBQUNseEIsSUFBSSxHQUFHO2dCQUFPOUQsMEVBQVMsQ0FBQztZQUN6QixPQUFPLElBQUlGLE1BQU1ELFVBQVVvMUIsNkJBQTZCLEVBQUUsQ0FBQ2p4QixJQUFNLE1BQUtOLFlBQVksQ0FBQ00sSUFBSSxNQUFNLE1BQUtOLFlBQVksQ0FBQzFELFNBQVNBO1FBQzVIO0lBQ0o7QUErUEo7QUFFQTs7OztDQUlDLEdBQ0QsaUVBQWlFO0FBQ2pFLFNBQVNrMUIsaUNBQWlDMTBDLFVBQVUsRUFBRTIwQyxXQUFXO0lBQzdELE1BQU0xMEMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1JLFdBQVd2QyxlQUFla0MsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSUssWUFBWSxNQUFNO1FBQ2xCMUQsZUFBZXNELFVBQVU7WUFBQztZQUFRO1NBQU8sRUFBRUk7SUFDL0M7SUFDQSxPQUFPSjtBQUNYO0FBQ0EsU0FBUzIwQyxrQ0FBa0M1MEMsVUFBVSxFQUFFMjBDLFdBQVc7SUFDOUQsTUFBTTEwQyxXQUFXLENBQUM7SUFDbEIsTUFBTUksV0FBV3ZDLGVBQWVrQyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJSyxZQUFZLE1BQU07UUFDbEIxRCxlQUFlc0QsVUFBVTtZQUFDO1lBQVE7U0FBTyxFQUFFSTtJQUMvQztJQUNBLE9BQU9KO0FBQ1g7QUFDQSxTQUFTNDBDLGlDQUFpQzcwQyxVQUFVLEVBQUUyMEMsV0FBVztJQUM3RCxNQUFNMTBDLFdBQVcsQ0FBQztJQUNsQixNQUFNeUIsc0JBQXNCNUQsZUFBZWtDLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUkwQix1QkFBdUIsTUFBTTtRQUM3Qi9FLGVBQWVzRCxVQUFVO1lBQUM7U0FBa0IsRUFBRXlCO0lBQ2xEO0lBQ0EsT0FBT3pCO0FBQ1g7QUFDQSxTQUFTNjBDLGtDQUFrQzkwQyxVQUFVLEVBQUUyMEMsV0FBVztJQUM5RCxNQUFNMTBDLFdBQVcsQ0FBQztJQUNsQixNQUFNeUIsc0JBQXNCNUQsZUFBZWtDLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUkwQix1QkFBdUIsTUFBTTtRQUM3Qi9FLGVBQWVzRCxVQUFVO1lBQUM7U0FBa0IsRUFBRXlCO0lBQ2xEO0lBQ0EsT0FBT3pCO0FBQ1g7QUFDQSxTQUFTODBDLDZCQUE2Qi8wQyxVQUFVLEVBQUUrWSxZQUFZLEVBQUU0N0IsV0FBVztJQUN2RSxNQUFNMTBDLFdBQVcsQ0FBQztJQUNsQixJQUFJbkMsZUFBZWtDLFlBQVk7UUFBQztLQUFvQixNQUFNcEYsV0FBVztRQUNqRSxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTXM0Qyw0QkFBNEJsM0MsZUFBZWtDLFlBQVk7UUFDekQ7S0FDSDtJQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhbzZDLDZCQUE2QixNQUFNO1FBQ2pFcjRDLGVBQWVvYyxjQUFjO1lBQUM7U0FBYyxFQUFFaThCO0lBQ2xEO0lBQ0EsSUFBSWwzQyxlQUFla0MsWUFBWTtRQUFDO0tBQWMsTUFBTXBGLFdBQVc7UUFDM0QsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE1BQU11NEMsaUJBQWlCbjNDLGVBQWVrQyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJK1ksaUJBQWlCbmUsYUFBYXE2QyxrQkFBa0IsTUFBTTtRQUN0RHQ0QyxlQUFlb2MsY0FBYztZQUFDO1lBQWM7WUFBbUI7U0FBYSxFQUFFazhCO0lBQ2xGO0lBQ0EsTUFBTUMsNkJBQTZCcDNDLGVBQWVrQyxZQUFZO1FBQzFEO0tBQ0g7SUFDRCxJQUFJazFDLDhCQUE4QixNQUFNO1FBQ3BDdjRDLGVBQWVzRCxVQUFVO1lBQUM7WUFBYztZQUFtQjtTQUF5QixFQUFFaTFDO0lBQzFGO0lBQ0EsSUFBSXAzQyxlQUFla0MsWUFBWTtRQUFDO0tBQTJCLE1BQ3ZEcEYsV0FBVztRQUNYLE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxJQUFJb0IsZUFBZWtDLFlBQVk7UUFBQztLQUE0QixNQUN4RHBGLFdBQVc7UUFDWCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsSUFBSW9CLGVBQWVrQyxZQUFZO1FBQUM7S0FBYyxNQUFNcEYsV0FBVztRQUMzRCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTXk0QyxnQkFBZ0JyM0MsZUFBZWtDLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUkrWSxpQkFBaUJuZSxhQUFhdTZDLGlCQUFpQixNQUFNO1FBQ3JEeDRDLGVBQWVvYyxjQUFjO1lBQUM7WUFBYztZQUFtQjtTQUFZLEVBQUVvOEI7SUFDakY7SUFDQSxNQUFNQyxtQkFBbUJ0M0MsZUFBZWtDLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUkrWSxpQkFBaUJuZSxhQUFhdzZDLG9CQUFvQixNQUFNO1FBQ3hEejRDLGVBQWVvYyxjQUFjO1lBQUM7WUFBYztZQUFtQjtTQUFlLEVBQUVxOEI7SUFDcEY7SUFDQSxJQUFJdDNDLGVBQWVrQyxZQUFZO1FBQUM7S0FBUyxNQUFNcEYsV0FBVztRQUN0RCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsSUFBSW9CLGVBQWVrQyxZQUFZO1FBQUM7S0FBTyxNQUFNcEYsV0FBVztRQUNwRCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsT0FBT3VEO0FBQ1g7QUFDQSxTQUFTbzFDLDhCQUE4QnIxQyxVQUFVLEVBQUUrWSxZQUFZLEVBQUV1OEIsVUFBVTtJQUN2RSxNQUFNcjFDLFdBQVcsQ0FBQztJQUNsQixJQUFJczFDLGlDQUFpQ3ozQyxlQUFldzNDLFlBQVk7UUFDNUQ7UUFDQTtLQUNIO0lBQ0QsSUFBSUMsbUNBQW1DMzZDLFdBQVc7UUFDOUMyNkMsaUNBQWlDO0lBQ3JDO0lBQ0EsSUFBSUEsbUNBQW1DLDBCQUEwQjtRQUM3RCxNQUFNQyx3QkFBd0IxM0MsZUFBZWtDLFlBQVk7WUFDckQ7U0FDSDtRQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhNDZDLHlCQUF5QixNQUFNO1lBQzdENzRDLGVBQWVvYyxjQUFjO2dCQUFDO2FBQXVCLEVBQUUwOEIsZ0NBQWdDRDtRQUMzRjtJQUNKLE9BQ0ssSUFBSUQsbUNBQW1DLHFCQUFxQjtRQUM3RCxNQUFNQyx3QkFBd0IxM0MsZUFBZWtDLFlBQVk7WUFDckQ7U0FDSDtRQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhNDZDLHlCQUF5QixNQUFNO1lBQzdENzRDLGVBQWVvYyxjQUFjO2dCQUFDO2FBQTZCLEVBQUUwOEIsZ0NBQWdDRDtRQUNqRztJQUNKO0lBQ0EsTUFBTVIsNEJBQTRCbDNDLGVBQWVrQyxZQUFZO1FBQ3pEO0tBQ0g7SUFDRCxJQUFJK1ksaUJBQWlCbmUsYUFBYW82Qyw2QkFBNkIsTUFBTTtRQUNqRXI0QyxlQUFlb2MsY0FBYztZQUFDO1NBQXdCLEVBQUVpOEI7SUFDNUQ7SUFDQSxNQUFNaHdCLGtCQUFrQmxuQixlQUFla0MsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSStZLGlCQUFpQm5lLGFBQWFvcUIsbUJBQW1CLE1BQU07UUFDdkRyb0IsZUFBZW9jLGNBQWM7WUFBQztTQUFjLEVBQUVpTTtJQUNsRDtJQUNBLElBQUkwd0IsMEJBQTBCNTNDLGVBQWV3M0MsWUFBWTtRQUNyRDtRQUNBO0tBQ0g7SUFDRCxJQUFJSSw0QkFBNEI5NkMsV0FBVztRQUN2Qzg2QywwQkFBMEI7SUFDOUI7SUFDQSxJQUFJQSw0QkFBNEIsMEJBQTBCO1FBQ3RELE1BQU1ULGlCQUFpQm4zQyxlQUFla0MsWUFBWTtZQUFDO1NBQWE7UUFDaEUsSUFBSStZLGlCQUFpQm5lLGFBQWFxNkMsa0JBQWtCLE1BQU07WUFDdER0NEMsZUFBZW9jLGNBQWM7Z0JBQUM7Z0JBQXdCO2dCQUFtQjthQUFhLEVBQUVrOEI7UUFDNUY7SUFDSixPQUNLLElBQUlTLDRCQUE0QixxQkFBcUI7UUFDdEQsTUFBTVQsaUJBQWlCbjNDLGVBQWVrQyxZQUFZO1lBQUM7U0FBYTtRQUNoRSxJQUFJK1ksaUJBQWlCbmUsYUFBYXE2QyxrQkFBa0IsTUFBTTtZQUN0RHQ0QyxlQUFlb2MsY0FBYztnQkFBQztnQkFBOEI7Z0JBQW1CO2FBQWEsRUFBRWs4QjtRQUNsRztJQUNKO0lBQ0EsSUFBSVUsc0NBQXNDNzNDLGVBQWV3M0MsWUFBWTtRQUNqRTtRQUNBO0tBQ0g7SUFDRCxJQUFJSyx3Q0FBd0MvNkMsV0FBVztRQUNuRCs2QyxzQ0FBc0M7SUFDMUM7SUFDQSxJQUFJQSx3Q0FBd0MsMEJBQTBCO1FBQ2xFLE1BQU1ULDZCQUE2QnAzQyxlQUFla0MsWUFBWTtZQUMxRDtTQUNIO1FBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWFzNkMsOEJBQThCLE1BQU07WUFDbEV2NEMsZUFBZW9jLGNBQWM7Z0JBQUM7Z0JBQXdCO2dCQUFtQjthQUF5QixFQUFFbThCO1FBQ3hHO0lBQ0osT0FDSyxJQUFJUyx3Q0FBd0MscUJBQXFCO1FBQ2xFLE1BQU1ULDZCQUE2QnAzQyxlQUFla0MsWUFBWTtZQUMxRDtTQUNIO1FBQ0QsSUFBSStZLGlCQUFpQm5lLGFBQWFzNkMsOEJBQThCLE1BQU07WUFDbEV2NEMsZUFBZW9jLGNBQWM7Z0JBQ3pCO2dCQUNBO2dCQUNBO2FBQ0gsRUFBRW04QjtRQUNQO0lBQ0o7SUFDQSxJQUFJVSx3Q0FBd0M5M0MsZUFBZXczQyxZQUFZO1FBQUM7UUFBVTtLQUFTO0lBQzNGLElBQUlNLDBDQUEwQ2g3QyxXQUFXO1FBQ3JEZzdDLHdDQUF3QztJQUM1QztJQUNBLElBQUlBLDBDQUEwQywwQkFBMEI7UUFDcEUsTUFBTUMsK0JBQStCLzNDLGVBQWVrQyxZQUFZO1lBQzVEO1NBQ0g7UUFDRCxJQUFJK1ksaUJBQWlCbmUsYUFBYWk3QyxnQ0FBZ0MsTUFBTTtZQUNwRWw1QyxlQUFlb2MsY0FBYztnQkFBQztnQkFBd0I7YUFBMkIsRUFBRTg4QjtRQUN2RjtJQUNKLE9BQ0ssSUFBSUQsMENBQTBDLHFCQUFxQjtRQUNwRSxNQUFNQywrQkFBK0IvM0MsZUFBZWtDLFlBQVk7WUFDNUQ7U0FDSDtRQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhaTdDLGdDQUFnQyxNQUFNO1lBQ3BFbDVDLGVBQWVvYyxjQUFjO2dCQUFDO2dCQUE4QjthQUEyQixFQUFFODhCO1FBQzdGO0lBQ0o7SUFDQSxJQUFJQywyQkFBMkJoNEMsZUFBZXczQyxZQUFZO1FBQ3REO1FBQ0E7S0FDSDtJQUNELElBQUlRLDZCQUE2Qmw3QyxXQUFXO1FBQ3hDazdDLDJCQUEyQjtJQUMvQjtJQUNBLElBQUlBLDZCQUE2QiwwQkFBMEI7UUFDdkQsTUFBTUMsa0JBQWtCajRDLGVBQWVrQyxZQUFZO1lBQUM7U0FBYztRQUNsRSxJQUFJK1ksaUJBQWlCbmUsYUFBYW03QyxtQkFBbUIsTUFBTTtZQUN2RHA1QyxlQUFlb2MsY0FBYztnQkFBQztnQkFBd0I7Z0JBQW1CO2FBQWMsRUFBRWc5QjtRQUM3RjtJQUNKLE9BQ0ssSUFBSUQsNkJBQTZCLHFCQUFxQjtRQUN2RCxNQUFNQyxrQkFBa0JqNEMsZUFBZWtDLFlBQVk7WUFBQztTQUFjO1FBQ2xFLElBQUkrWSxpQkFBaUJuZSxhQUFhbTdDLG1CQUFtQixNQUFNO1lBQ3ZEcDVDLGVBQWVvYyxjQUFjO2dCQUFDO2dCQUE4QjtnQkFBbUI7YUFBYyxFQUFFZzlCO1FBQ25HO0lBQ0o7SUFDQSxJQUFJajRDLGVBQWVrQyxZQUFZO1FBQUM7S0FBWSxNQUFNcEYsV0FBVztRQUN6RCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsSUFBSW9CLGVBQWVrQyxZQUFZO1FBQUM7S0FBZSxNQUFNcEYsV0FBVztRQUM1RCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTW0yQixhQUFhLzBCLGVBQWVrQyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJK1ksaUJBQWlCbmUsYUFBYWk0QixjQUFjLE1BQU07UUFDbERsMkIsZUFBZW9jLGNBQWM7WUFBQztTQUFTLEVBQUU4WjtJQUM3QztJQUNBLE1BQU1takIsV0FBV2w0QyxlQUFla0MsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSStZLGlCQUFpQm5lLGFBQWFvN0MsWUFBWSxNQUFNO1FBQ2hEcjVDLGVBQWVvYyxjQUFjO1lBQUM7WUFBOEI7WUFBbUI7U0FBTyxFQUFFaTlCO0lBQzVGO0lBQ0EsT0FBTy8xQztBQUNYO0FBQ0EsU0FBU2cyQyx3Q0FBd0NqMkMsVUFBVSxFQUFFczFDLFVBQVU7SUFDbkUsTUFBTXIxQyxXQUFXLENBQUM7SUFDbEIsTUFBTTQ3QixnQkFBZ0IvOUIsZUFBZWtDLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUk2N0IsaUJBQWlCLE1BQU07UUFDdkJsL0IsZUFBZXNELFVBQVU7WUFBQztTQUFZLEVBQUU0N0I7SUFDNUM7SUFDQSxNQUFNcWEsb0JBQW9CcDRDLGVBQWVrQyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJazJDLHFCQUFxQixNQUFNO1FBQzNCdjVDLGVBQWVzRCxVQUFVO1lBQUM7U0FBZ0IsRUFBRWkyQztJQUNoRDtJQUNBLE1BQU1DLHNCQUFzQnI0QyxlQUFla0MsWUFBWTtRQUNuRDtLQUNIO0lBQ0QsSUFBSW0yQyx1QkFBdUIsTUFBTTtRQUM3QkMscUJBQXFCRDtJQUN6QjtJQUNBLE1BQU1qOUIsYUFBYXBiLGVBQWVrQyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJa1osY0FBYyxNQUFNO1FBQ3BCNjdCLDZCQUE2Qjc3QixZQUFZalo7SUFDN0M7SUFDQSxPQUFPQTtBQUNYO0FBQ0EsU0FBU28yQyx5Q0FBeUNyMkMsVUFBVSxFQUFFczFDLFVBQVU7SUFDcEUsTUFBTXIxQyxXQUFXLENBQUM7SUFDbEIsTUFBTTQ3QixnQkFBZ0IvOUIsZUFBZWtDLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUk2N0IsaUJBQWlCLE1BQU07UUFDdkJsL0IsZUFBZXNELFVBQVU7WUFBQztTQUFZLEVBQUU0N0I7SUFDNUM7SUFDQSxNQUFNcWEsb0JBQW9CcDRDLGVBQWVrQyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJazJDLHFCQUFxQixNQUFNO1FBQzNCdjVDLGVBQWVzRCxVQUFVO1lBQUM7U0FBZ0IsRUFBRWkyQztJQUNoRDtJQUNBLE1BQU1DLHNCQUFzQnI0QyxlQUFla0MsWUFBWTtRQUNuRDtLQUNIO0lBQ0QsSUFBSW0yQyx1QkFBdUIsTUFBTTtRQUM3Qkcsc0JBQXNCSCxxQkFBcUJsMkMsVUFBVXExQztJQUN6RDtJQUNBLE1BQU1wOEIsYUFBYXBiLGVBQWVrQyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJa1osY0FBYyxNQUFNO1FBQ3BCbThCLDhCQUE4Qm44QixZQUFZalosVUFBVXExQztJQUN4RDtJQUNBLE9BQU9yMUM7QUFDWDtBQUNBLFNBQVNzMkMsOEJBQThCdjJDLFVBQVUsRUFBRTIwQyxXQUFXO0lBQzFELE1BQU0xMEMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1JLFdBQVd2QyxlQUFla0MsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSUssWUFBWSxNQUFNO1FBQ2xCMUQsZUFBZXNELFVBQVU7WUFBQztZQUFRO1NBQU8sRUFBRUk7SUFDL0M7SUFDQSxPQUFPSjtBQUNYO0FBQ0EsU0FBU3UyQywrQkFBK0J4MkMsVUFBVSxFQUFFMjBDLFdBQVc7SUFDM0QsTUFBTTEwQyxXQUFXLENBQUM7SUFDbEIsTUFBTUksV0FBV3ZDLGVBQWVrQyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJSyxZQUFZLE1BQU07UUFDbEIxRCxlQUFlc0QsVUFBVTtZQUFDO1lBQVE7U0FBTyxFQUFFSTtJQUMvQztJQUNBLE9BQU9KO0FBQ1g7QUFDQSxTQUFTdzJDLDRCQUE0QnoyQyxVQUFVLEVBQUUrWSxZQUFZLEVBQUU0N0IsV0FBVztJQUN0RSxNQUFNMTBDLFdBQVcsQ0FBQztJQUNsQixNQUFNb2QsZUFBZXZmLGVBQWVrQyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJK1ksaUJBQWlCbmUsYUFBYXlpQixnQkFBZ0IsTUFBTTtRQUNwRDFnQixlQUFlb2MsY0FBYztZQUFDO1lBQVU7U0FBVyxFQUFFc0U7SUFDekQ7SUFDQSxNQUFNQyxnQkFBZ0J4ZixlQUFla0MsWUFBWTtRQUFDO0tBQVk7SUFDOUQsSUFBSStZLGlCQUFpQm5lLGFBQWEwaUIsaUJBQWlCLE1BQU07UUFDckQzZ0IsZUFBZW9jLGNBQWM7WUFBQztZQUFVO1NBQVksRUFBRXVFO0lBQzFEO0lBQ0EsTUFBTUUsYUFBYTFmLGVBQWVrQyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJK1ksaUJBQWlCbmUsYUFBYTRpQixjQUFjLE1BQU07UUFDbEQ3Z0IsZUFBZW9jLGNBQWM7WUFBQztZQUFVO1NBQVMsRUFBRXlFO0lBQ3ZEO0lBQ0EsT0FBT3ZkO0FBQ1g7QUFDQSxTQUFTeTJDLDZCQUE2QjEyQyxVQUFVLEVBQUUrWSxZQUFZLEVBQUU0N0IsV0FBVztJQUN2RSxNQUFNMTBDLFdBQVcsQ0FBQztJQUNsQixNQUFNb2QsZUFBZXZmLGVBQWVrQyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJK1ksaUJBQWlCbmUsYUFBYXlpQixnQkFBZ0IsTUFBTTtRQUNwRDFnQixlQUFlb2MsY0FBYztZQUFDO1lBQVU7U0FBVyxFQUFFc0U7SUFDekQ7SUFDQSxNQUFNQyxnQkFBZ0J4ZixlQUFla0MsWUFBWTtRQUFDO0tBQVk7SUFDOUQsSUFBSStZLGlCQUFpQm5lLGFBQWEwaUIsaUJBQWlCLE1BQU07UUFDckQzZ0IsZUFBZW9jLGNBQWM7WUFBQztZQUFVO1NBQVksRUFBRXVFO0lBQzFEO0lBQ0EsTUFBTUUsYUFBYTFmLGVBQWVrQyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJK1ksaUJBQWlCbmUsYUFBYTRpQixjQUFjLE1BQU07UUFDbEQ3Z0IsZUFBZW9jLGNBQWM7WUFBQztZQUFVO1NBQVMsRUFBRXlFO0lBQ3ZEO0lBQ0EsT0FBT3ZkO0FBQ1g7QUFDQSxTQUFTMDJDLGdDQUFnQzMyQyxVQUFVLEVBQUVzMUMsVUFBVTtJQUMzRCxNQUFNcjFDLFdBQVcsQ0FBQztJQUNsQixNQUFNaVosYUFBYXBiLGVBQWVrQyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJa1osY0FBYyxNQUFNO1FBQ3BCdTlCLDRCQUE0QnY5QixZQUFZalo7SUFDNUM7SUFDQSxPQUFPQTtBQUNYO0FBQ0EsU0FBUzIyQyxpQ0FBaUM1MkMsVUFBVSxFQUFFczFDLFVBQVU7SUFDNUQsTUFBTXIxQyxXQUFXLENBQUM7SUFDbEIsTUFBTWlaLGFBQWFwYixlQUFla0MsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSWtaLGNBQWMsTUFBTTtRQUNwQnc5Qiw2QkFBNkJ4OUIsWUFBWWpaO0lBQzdDO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLFNBQVM0MkMsZ0NBQWdDNzJDLFVBQVUsRUFBRXMxQyxVQUFVO0lBQzNELE1BQU1yMUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU15QixzQkFBc0I1RCxlQUFla0MsWUFBWTtRQUNuRDtLQUNIO0lBQ0QsSUFBSTBCLHVCQUF1QixNQUFNO1FBQzdCL0UsZUFBZXNELFVBQVU7WUFBQztTQUFrQixFQUFFeUI7SUFDbEQ7SUFDQSxNQUFNa2Msb0JBQW9COWYsZUFBZWtDLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUk0ZCxxQkFBcUIsTUFBTTtRQUMzQmpoQixlQUFlc0QsVUFBVTtZQUFDO1NBQWdCLEVBQUUyZDtJQUNoRDtJQUNBLE1BQU1rNUIsaUJBQWlCaDVDLGVBQWVrQyxZQUFZO1FBQUM7S0FBYztJQUNqRSxJQUFJODJDLGtCQUFrQixNQUFNO1FBQ3hCLElBQUloMkMsa0JBQWtCZzJDO1FBQ3RCLElBQUkzNUMsTUFBTUMsT0FBTyxDQUFDMEQsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQjlDLEdBQUcsQ0FBQyxDQUFDa0I7Z0JBQ25DLE9BQU82M0MsbUJBQW1CNzNDO1lBQzlCO1FBQ0o7UUFDQXZDLGVBQWVzRCxVQUFVO1lBQUM7U0FBYSxFQUFFYTtJQUM3QztJQUNBLE9BQU9iO0FBQ1g7QUFDQSxTQUFTKzJDLGlDQUFpQ2gzQyxVQUFVLEVBQUVzMUMsVUFBVTtJQUM1RCxNQUFNcjFDLFdBQVcsQ0FBQztJQUNsQixNQUFNeUIsc0JBQXNCNUQsZUFBZWtDLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUkwQix1QkFBdUIsTUFBTTtRQUM3Qi9FLGVBQWVzRCxVQUFVO1lBQUM7U0FBa0IsRUFBRXlCO0lBQ2xEO0lBQ0EsTUFBTWtjLG9CQUFvQjlmLGVBQWVrQyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJNGQscUJBQXFCLE1BQU07UUFDM0JqaEIsZUFBZXNELFVBQVU7WUFBQztTQUFnQixFQUFFMmQ7SUFDaEQ7SUFDQSxNQUFNazVCLGlCQUFpQmg1QyxlQUFla0MsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSTgyQyxrQkFBa0IsTUFBTTtRQUN4QixJQUFJaDJDLGtCQUFrQmcyQztRQUN0QixJQUFJMzVDLE1BQU1DLE9BQU8sQ0FBQzBELGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0I5QyxHQUFHLENBQUMsQ0FBQ2tCO2dCQUNuQyxPQUFPKzNDLG9CQUFvQi8zQztZQUMvQjtRQUNKO1FBQ0F2QyxlQUFlc0QsVUFBVTtZQUFDO1NBQWEsRUFBRWE7SUFDN0M7SUFDQSxPQUFPYjtBQUNYO0FBQ0EsU0FBU2kzQyxvQkFBb0JsM0MsVUFBVSxFQUFFMjBDLFdBQVc7SUFDaEQsTUFBTTEwQyxXQUFXLENBQUM7SUFDbEIsTUFBTTZXLFlBQVloWixlQUFla0MsWUFBWTtRQUFDO0tBQU87SUFDckQsSUFBSThXLGFBQWEsTUFBTTtRQUNuQm5hLGVBQWVzRCxVQUFVO1lBQUM7U0FBUSxFQUFFNlc7SUFDeEM7SUFDQSxNQUFNcWdDLGVBQWVyNUMsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3hELElBQUltM0MsZ0JBQWdCLE1BQU07UUFDdEJ4NkMsZUFBZXNELFVBQVU7WUFBQztTQUFXLEVBQUVrM0M7SUFDM0M7SUFDQSxPQUFPbDNDO0FBQ1g7QUFDQSxTQUFTbTJDLHFCQUFxQnAyQyxVQUFVLEVBQUUyMEMsV0FBVztJQUNqRCxNQUFNMTBDLFdBQVcsQ0FBQztJQUNsQixJQUFJbkMsZUFBZWtDLFlBQVk7UUFBQztLQUFTLE1BQU1wRixXQUFXO1FBQ3RELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxJQUFJb0IsZUFBZWtDLFlBQVk7UUFBQztLQUF3QixNQUFNcEYsV0FBVztRQUNyRSxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTTA2QyxlQUFldDVDLGVBQWVrQyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJbzNDLGdCQUFnQixNQUFNO1FBQ3RCLElBQUl0MkMsa0JBQWtCczJDO1FBQ3RCLElBQUlqNkMsTUFBTUMsT0FBTyxDQUFDMEQsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQjlDLEdBQUcsQ0FBQyxDQUFDa0I7Z0JBQ25DLE9BQU9BO1lBQ1g7UUFDSjtRQUNBdkMsZUFBZXNELFVBQVU7WUFBQztZQUFZO1NBQVcsRUFBRWE7SUFDdkQ7SUFDQSxPQUFPYjtBQUNYO0FBQ0EsU0FBU3EyQyxzQkFBc0J0MkMsVUFBVSxFQUFFK1ksWUFBWSxFQUFFdThCLFVBQVU7SUFDL0QsTUFBTXIxQyxXQUFXLENBQUM7SUFDbEIsSUFBSW8zQyxzQkFBc0J2NUMsZUFBZXczQyxZQUFZO1FBQ2pEO1FBQ0E7S0FDSDtJQUNELElBQUkrQix3QkFBd0J6OEMsV0FBVztRQUNuQ3k4QyxzQkFBc0I7SUFDMUI7SUFDQSxJQUFJQSx3QkFBd0IsMEJBQTBCO1FBQ2xELE1BQU1oaEMsYUFBYXZZLGVBQWVrQyxZQUFZO1lBQUM7U0FBUztRQUN4RCxJQUFJK1ksaUJBQWlCbmUsYUFBYXliLGNBQWMsTUFBTTtZQUNsRDFaLGVBQWVvYyxjQUFjO2dCQUFDO2dCQUF3QjthQUFxQixFQUFFMUM7UUFDakY7SUFDSixPQUNLLElBQUlnaEMsd0JBQXdCLHFCQUFxQjtRQUNsRCxNQUFNaGhDLGFBQWF2WSxlQUFla0MsWUFBWTtZQUFDO1NBQVM7UUFDeEQsSUFBSStZLGlCQUFpQm5lLGFBQWF5YixjQUFjLE1BQU07WUFDbEQxWixlQUFlb2MsY0FBYztnQkFBQztnQkFBOEI7YUFBcUIsRUFBRTFDO1FBQ3ZGO0lBQ0o7SUFDQSxJQUFJaWhDLHFDQUFxQ3g1QyxlQUFldzNDLFlBQVk7UUFDaEU7UUFDQTtLQUNIO0lBQ0QsSUFBSWdDLHVDQUF1QzE4QyxXQUFXO1FBQ2xEMDhDLHFDQUFxQztJQUN6QztJQUNBLElBQUlBLHVDQUF1QywwQkFBMEI7UUFDakUsTUFBTUMsNEJBQTRCejVDLGVBQWVrQyxZQUFZO1lBQ3pEO1NBQ0g7UUFDRCxJQUFJK1ksaUJBQWlCbmUsYUFBYTI4Qyw2QkFBNkIsTUFBTTtZQUNqRTU2QyxlQUFlb2MsY0FBYztnQkFBQztnQkFBd0I7YUFBcUIsRUFBRXcrQjtRQUNqRjtJQUNKLE9BQ0ssSUFBSUQsdUNBQXVDLHFCQUFxQjtRQUNqRSxNQUFNQyw0QkFBNEJ6NUMsZUFBZWtDLFlBQVk7WUFDekQ7U0FDSDtRQUNELElBQUkrWSxpQkFBaUJuZSxhQUFhMjhDLDZCQUE2QixNQUFNO1lBQ2pFNTZDLGVBQWVvYyxjQUFjO2dCQUFDO2dCQUE4QjthQUFxQixFQUFFdytCO1FBQ3ZGO0lBQ0o7SUFDQSxJQUFJejVDLGVBQWVrQyxZQUFZO1FBQUM7S0FBVyxNQUFNcEYsV0FBVztRQUN4RCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsT0FBT3VEO0FBQ1g7QUFDQSxTQUFTODJDLG1CQUFtQi8yQyxVQUFVLEVBQUVzMUMsVUFBVTtJQUM5QyxNQUFNcjFDLFdBQVcsQ0FBQztJQUNsQixNQUFNeUIsc0JBQXNCNUQsZUFBZWtDLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUkwQix1QkFBdUIsTUFBTTtRQUM3Qi9FLGVBQWVzRCxVQUFVO1lBQUM7U0FBa0IsRUFBRXlCO0lBQ2xEO0lBQ0EsTUFBTXJCLFdBQVd2QyxlQUFla0MsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSUssWUFBWSxNQUFNO1FBQ2xCMUQsZUFBZXNELFVBQVU7WUFBQztTQUFPLEVBQUVJO0lBQ3ZDO0lBQ0EsTUFBTXFXLFlBQVk1WSxlQUFla0MsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSTBXLGFBQWEsTUFBTTtRQUNuQi9aLGVBQWVzRCxVQUFVO1lBQUM7U0FBUSxFQUFFb1MsaUJBQWlCcUU7SUFDekQ7SUFDQSxNQUFNQyxpQkFBaUI3WSxlQUFla0MsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSTJXLGtCQUFrQixNQUFNO1FBQ3hCaGEsZUFBZXNELFVBQVU7WUFBQztTQUFhLEVBQUUwVztJQUM3QztJQUNBLE1BQU1NLGdCQUFnQm5aLGVBQWVrQyxZQUFZO1FBQzdDO1FBQ0E7S0FDSDtJQUNELElBQUlpWCxpQkFBaUIsTUFBTTtRQUN2QnRhLGVBQWVzRCxVQUFVO1lBQUM7U0FBWSxFQUFFZ1g7SUFDNUM7SUFDQSxNQUFNTCxjQUFjOVksZUFBZWtDLFlBQVk7UUFDM0M7UUFDQTtLQUNIO0lBQ0QsSUFBSTRXLGVBQWUsTUFBTTtRQUNyQmphLGVBQWVzRCxVQUFVO1lBQUM7U0FBVSxFQUFFMlc7SUFDMUM7SUFDQSxNQUFNQyxpQkFBaUIvWSxlQUFla0MsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSTZXLGtCQUFrQixNQUFNO1FBQ3hCbGEsZUFBZXNELFVBQVU7WUFBQztTQUFhLEVBQUU0VztJQUM3QztJQUNBLE1BQU1tTyxrQkFBa0JsbkIsZUFBZWtDLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUlnbEIsbUJBQW1CLE1BQU07UUFDekJyb0IsZUFBZXNELFVBQVU7WUFBQztTQUFjLEVBQUUra0I7SUFDOUM7SUFDQSxNQUFNNlcsZ0JBQWdCLzlCLGVBQWVrQyxZQUFZO1FBQUM7S0FBWTtJQUM5RCxJQUFJNjdCLGlCQUFpQixNQUFNO1FBQ3ZCbC9CLGVBQWVzRCxVQUFVO1lBQUM7U0FBWSxFQUFFNDdCO0lBQzVDO0lBQ0EsTUFBTTJiLGlCQUFpQjE1QyxlQUFla0MsWUFBWTtRQUFDO0tBQVE7SUFDM0QsSUFBSXczQyxrQkFBa0IsTUFBTTtRQUN4Qjc2QyxlQUFlc0QsVUFBVTtZQUFDO1NBQWEsRUFBRWkzQyxvQkFBb0JNO0lBQ2pFO0lBQ0EsT0FBT3YzQztBQUNYO0FBQ0EsU0FBU2czQyxvQkFBb0JqM0MsVUFBVSxFQUFFMjBDLFdBQVc7SUFDaEQsTUFBTTEwQyxXQUFXLENBQUM7SUFDbEIsTUFBTXlCLHNCQUFzQjVELGVBQWVrQyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJMEIsdUJBQXVCLE1BQU07UUFDN0IvRSxlQUFlc0QsVUFBVTtZQUFDO1NBQWtCLEVBQUV5QjtJQUNsRDtJQUNBLE1BQU1yQixXQUFXdkMsZUFBZWtDLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlLLFlBQVksTUFBTTtRQUNsQjFELGVBQWVzRCxVQUFVO1lBQUM7U0FBTyxFQUFFSTtJQUN2QztJQUNBLE1BQU1xVyxZQUFZNVksZUFBZWtDLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUkwVyxhQUFhLE1BQU07UUFDbkIvWixlQUFlc0QsVUFBVTtZQUFDO1NBQVEsRUFBRW9TLGlCQUFpQnFFO0lBQ3pEO0lBQ0EsTUFBTUMsaUJBQWlCN1ksZUFBZWtDLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUkyVyxrQkFBa0IsTUFBTTtRQUN4QmhhLGVBQWVzRCxVQUFVO1lBQUM7U0FBYSxFQUFFMFc7SUFDN0M7SUFDQSxNQUFNTSxnQkFBZ0JuWixlQUFla0MsWUFBWTtRQUFDO0tBQVk7SUFDOUQsSUFBSWlYLGlCQUFpQixNQUFNO1FBQ3ZCdGEsZUFBZXNELFVBQVU7WUFBQztTQUFZLEVBQUVnWDtJQUM1QztJQUNBLE1BQU1MLGNBQWM5WSxlQUFla0MsWUFBWTtRQUFDO0tBQVU7SUFDMUQsSUFBSTRXLGVBQWUsTUFBTTtRQUNyQmphLGVBQWVzRCxVQUFVO1lBQUM7U0FBVSxFQUFFMlc7SUFDMUM7SUFDQSxNQUFNQyxpQkFBaUIvWSxlQUFla0MsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSTZXLGtCQUFrQixNQUFNO1FBQ3hCbGEsZUFBZXNELFVBQVU7WUFBQztTQUFhLEVBQUU0VztJQUM3QztJQUNBLE1BQU1yVyxZQUFZMUMsZUFBZWtDLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUlRLGFBQWEsTUFBTTtRQUNuQjdELGVBQWVzRCxVQUFVO1lBQUM7U0FBUSxFQUFFTztJQUN4QztJQUNBLE1BQU13a0Isa0JBQWtCbG5CLGVBQWVrQyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJZ2xCLG1CQUFtQixNQUFNO1FBQ3pCcm9CLGVBQWVzRCxVQUFVO1lBQUM7U0FBYyxFQUFFK2tCO0lBQzlDO0lBQ0EsTUFBTTZXLGdCQUFnQi85QixlQUFla0MsWUFBWTtRQUFDO0tBQVk7SUFDOUQsSUFBSTY3QixpQkFBaUIsTUFBTTtRQUN2QmwvQixlQUFlc0QsVUFBVTtZQUFDO1NBQVksRUFBRTQ3QjtJQUM1QztJQUNBLE1BQU0yYixpQkFBaUIxNUMsZUFBZWtDLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUl3M0Msa0JBQWtCLE1BQU07UUFDeEI3NkMsZUFBZXNELFVBQVU7WUFBQztTQUFhLEVBQUV1M0M7SUFDN0M7SUFDQSxNQUFNdEIsb0JBQW9CcDRDLGVBQWVrQyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJazJDLHFCQUFxQixNQUFNO1FBQzNCdjVDLGVBQWVzRCxVQUFVO1lBQUM7U0FBZ0IsRUFBRWkyQztJQUNoRDtJQUNBLE1BQU11QiwyQkFBMkIzNUMsZUFBZWtDLFlBQVk7UUFDeEQ7S0FDSDtJQUNELElBQUl5M0MsNEJBQTRCLE1BQU07UUFDbEM5NkMsZUFBZXNELFVBQVU7WUFBQztTQUF1QixFQUFFdzNDO0lBQ3ZEO0lBQ0EsTUFBTUMsaUNBQWlDNTVDLGVBQWVrQyxZQUFZO1FBQzlEO0tBQ0g7SUFDRCxJQUFJMDNDLGtDQUFrQyxNQUFNO1FBQ3hDLzZDLGVBQWVzRCxVQUFVO1lBQUM7U0FBNkIsRUFBRXkzQztJQUM3RDtJQUNBLE1BQU1DLHNCQUFzQjc1QyxlQUFla0MsWUFBWTtRQUNuRDtLQUNIO0lBQ0QsSUFBSTIzQyx1QkFBdUIsTUFBTTtRQUM3Qmg3QyxlQUFlc0QsVUFBVTtZQUFDO1NBQWtCLEVBQUUwM0M7SUFDbEQ7SUFDQSxNQUFNQyxxQkFBcUI5NUMsZUFBZWtDLFlBQVk7UUFDbEQ7S0FDSDtJQUNELElBQUk0M0Msc0JBQXNCLE1BQU07UUFDNUJqN0MsZUFBZXNELFVBQVU7WUFBQztTQUFpQixFQUFFMjNDO0lBQ2pEO0lBQ0EsTUFBTUMsNkJBQTZCLzVDLGVBQWVrQyxZQUFZO1FBQzFEO0tBQ0g7SUFDRCxJQUFJNjNDLDhCQUE4QixNQUFNO1FBQ3BDbDdDLGVBQWVzRCxVQUFVO1lBQUM7U0FBeUIsRUFBRTQzQztJQUN6RDtJQUNBLE1BQU1DLHNCQUFzQmg2QyxlQUFla0MsWUFBWTtRQUNuRDtLQUNIO0lBQ0QsSUFBSTgzQyx1QkFBdUIsTUFBTTtRQUM3Qm43QyxlQUFlc0QsVUFBVTtZQUFDO1NBQWtCLEVBQUU2M0M7SUFDbEQ7SUFDQSxNQUFNQyxpQkFBaUJqNkMsZUFBZWtDLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUkrM0Msa0JBQWtCLE1BQU07UUFDeEJwN0MsZUFBZXNELFVBQVU7WUFBQztTQUFhLEVBQUU4M0M7SUFDN0M7SUFDQSxNQUFNbGxCLGFBQWEvMEIsZUFBZWtDLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUk2eUIsY0FBYyxNQUFNO1FBQ3BCbDJCLGVBQWVzRCxVQUFVO1lBQUM7U0FBUyxFQUFFNHlCO0lBQ3pDO0lBQ0EsTUFBTW1sQixnQkFBZ0JsNkMsZUFBZWtDLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUlnNEMsaUJBQWlCLE1BQU07UUFDdkJyN0MsZUFBZXNELFVBQVU7WUFBQztTQUFZLEVBQUUrM0M7SUFDNUM7SUFDQSxNQUFNQyxrQkFBa0JuNkMsZUFBZWtDLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUlpNEMsbUJBQW1CLE1BQU07UUFDekJ0N0MsZUFBZXNELFVBQVU7WUFBQztTQUFjLEVBQUVnNEM7SUFDOUM7SUFDQSxNQUFNQyxxQkFBcUJwNkMsZUFBZWtDLFlBQVk7UUFDbEQ7S0FDSDtJQUNELElBQUlrNEMsc0JBQXNCLE1BQU07UUFDNUJ2N0MsZUFBZXNELFVBQVU7WUFBQztTQUFpQixFQUFFaTRDO0lBQ2pEO0lBQ0EsTUFBTWxELDRCQUE0QmwzQyxlQUFla0MsWUFBWTtRQUN6RDtLQUNIO0lBQ0QsSUFBSWcxQyw2QkFBNkIsTUFBTTtRQUNuQ3I0QyxlQUFlc0QsVUFBVTtZQUFDO1NBQXdCLEVBQUUrMEM7SUFDeEQ7SUFDQSxNQUFNbUQsb0JBQW9CcjZDLGVBQWVrQyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJbTRDLHFCQUFxQixNQUFNO1FBQzNCeDdDLGVBQWVzRCxVQUFVO1lBQUM7U0FBZ0IsRUFBRWs0QztJQUNoRDtJQUNBLE9BQU9sNEM7QUFDWDtBQUNBLFNBQVNtNEMseUJBQXlCcDRDLFVBQVUsRUFBRTIwQyxXQUFXO0lBQ3JELE1BQU0xMEMsV0FBVyxDQUFDO0lBQ2xCLE1BQU15QixzQkFBc0I1RCxlQUFla0MsWUFBWTtRQUNuRDtLQUNIO0lBQ0QsSUFBSTBCLHVCQUF1QixNQUFNO1FBQzdCL0UsZUFBZXNELFVBQVU7WUFBQztTQUFrQixFQUFFeUI7SUFDbEQ7SUFDQSxNQUFNckIsV0FBV3ZDLGVBQWVrQyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJSyxZQUFZLE1BQU07UUFDbEIxRCxlQUFlc0QsVUFBVTtZQUFDO1NBQU8sRUFBRUk7SUFDdkM7SUFDQSxNQUFNQyxlQUFleEMsZUFBZWtDLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlNLGdCQUFnQixNQUFNO1FBQ3RCM0QsZUFBZXNELFVBQVU7WUFBQztTQUFXLEVBQUVLO0lBQzNDO0lBQ0EsTUFBTUMsV0FBV3pDLGVBQWVrQyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJTyxZQUFZLE1BQU07UUFDbEI1RCxlQUFlc0QsVUFBVTtZQUFDO1NBQU8sRUFBRU07SUFDdkM7SUFDQSxNQUFNQyxZQUFZMUMsZUFBZWtDLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUlRLGFBQWEsTUFBTTtRQUNuQjdELGVBQWVzRCxVQUFVO1lBQUM7U0FBUSxFQUFFTztJQUN4QztJQUNBLE9BQU9QO0FBQ1g7QUFDQSxTQUFTdzFDLGdDQUFnQ3oxQyxVQUFVLEVBQUUyMEMsV0FBVztJQUM1RCxNQUFNMTBDLFdBQVcsQ0FBQztJQUNsQixNQUFNb1csYUFBYXZZLGVBQWVrQyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJcVcsY0FBYyxNQUFNO1FBQ3BCMVosZUFBZXNELFVBQVU7WUFBQztTQUF1QixFQUFFb1c7SUFDdkQ7SUFDQSxNQUFNa2hDLDRCQUE0Qno1QyxlQUFla0MsWUFBWTtRQUN6RDtLQUNIO0lBQ0QsSUFBSXUzQyw2QkFBNkIsTUFBTTtRQUNuQzU2QyxlQUFlc0QsVUFBVTtZQUFDO1NBQXVCLEVBQUVzM0M7SUFDdkQ7SUFDQSxPQUFPdDNDO0FBQ1g7QUFFQTs7OztDQUlDLEdBQ0QsTUFBTW80QyxnQkFBZ0J6OEM7SUFpRmxCLE1BQU0wOEMsWUFBWTk0QixNQUFNLEVBQUU7UUFDdEIsSUFBSWhrQixJQUFJQyxJQUFJbU4sSUFBSUM7UUFDaEIsSUFBSTlCO1FBQ0osSUFBSXFhLE9BQU87UUFDWCxJQUFJbUIsY0FBYyxDQUFDO1FBQ25CLElBQUksSUFBSSxDQUFDeFUsU0FBUyxDQUFDRyxVQUFVLElBQUk7WUFDN0IsTUFBTWdULE9BQU9zMUIsK0JBQStCaDNCO1lBQzVDNEIsT0FBT3ZsQixVQUFVLFVBQVVxbEIsSUFBSSxDQUFDLE9BQU87WUFDdkNxQixjQUFjckIsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJuYSxXQUFXLElBQUksQ0FBQ2dILFNBQVMsQ0FDcEJnVCxPQUFPLENBQUM7Z0JBQ1RLLE1BQU1BO2dCQUNObUIsYUFBYUE7Z0JBQ2JyQixNQUFNc0IsS0FBS0MsU0FBUyxDQUFDdkI7Z0JBQ3JCd0IsWUFBWTtnQkFDWnRuQixhQUFhLENBQUNJLEtBQUtna0IsT0FBTzlTLE1BQU0sTUFBTSxRQUFRbFIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSixXQUFXO2dCQUNyRnVuQixhQUFhLENBQUNsbkIsS0FBSytqQixPQUFPOVMsTUFBTSxNQUFNLFFBQVFqUixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdrbkIsV0FBVztZQUN6RixHQUNLQyxJQUFJLENBQUMsQ0FBQ0M7Z0JBQ1AsT0FBT0EsYUFBYXphLElBQUksR0FBR3dhLElBQUksQ0FBQyxDQUFDTztvQkFDN0IsTUFBTXBjLFdBQVdvYztvQkFDakJwYyxTQUFTNlksZUFBZSxHQUFHO3dCQUN2QnJYLFNBQVNzYSxhQUFhdGEsT0FBTztvQkFDakM7b0JBQ0EsT0FBT3hCO2dCQUNYO1lBQ0o7WUFDQSxPQUFPQSxTQUFTNmIsSUFBSSxDQUFDLENBQUMvWDtnQkFDbEIsTUFBTWlZLE9BQU9tMEIsb0JBQW9CcHNDO2dCQUNqQyxPQUFPaVk7WUFDWDtRQUNKLE9BQ0s7WUFDRCxNQUFNNUIsT0FBT3ExQiw4QkFBOEIvMkI7WUFDM0M0QixPQUFPdmxCLFVBQVUsVUFBVXFsQixJQUFJLENBQUMsT0FBTztZQUN2Q3FCLGNBQWNyQixJQUFJLENBQUMsU0FBUztZQUM1QixPQUFPQSxJQUFJLENBQUMsT0FBTztZQUNuQixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQm5hLFdBQVcsSUFBSSxDQUFDZ0gsU0FBUyxDQUNwQmdULE9BQU8sQ0FBQztnQkFDVEssTUFBTUE7Z0JBQ05tQixhQUFhQTtnQkFDYnJCLE1BQU1zQixLQUFLQyxTQUFTLENBQUN2QjtnQkFDckJ3QixZQUFZO2dCQUNadG5CLGFBQWEsQ0FBQ3dOLEtBQUs0VyxPQUFPOVMsTUFBTSxNQUFNLFFBQVE5RCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUd4TixXQUFXO2dCQUNyRnVuQixhQUFhLENBQUM5WixLQUFLMlcsT0FBTzlTLE1BQU0sTUFBTSxRQUFRN0QsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHOFosV0FBVztZQUN6RixHQUNLQyxJQUFJLENBQUMsQ0FBQ0M7Z0JBQ1AsT0FBT0EsYUFBYXphLElBQUksR0FBR3dhLElBQUksQ0FBQyxDQUFDTztvQkFDN0IsTUFBTXBjLFdBQVdvYztvQkFDakJwYyxTQUFTNlksZUFBZSxHQUFHO3dCQUN2QnJYLFNBQVNzYSxhQUFhdGEsT0FBTztvQkFDakM7b0JBQ0EsT0FBT3hCO2dCQUNYO1lBQ0o7WUFDQSxPQUFPQSxTQUFTNmIsSUFBSSxDQUFDLENBQUMvWDtnQkFDbEIsTUFBTWlZLE9BQU9pMEIsbUJBQW1CbHNDO2dCQUNoQyxPQUFPaVk7WUFDWDtRQUNKO0lBQ0o7SUFDQSxNQUFNSSxhQUFhMUQsTUFBTSxFQUFFO1FBQ3ZCLElBQUloa0IsSUFBSUMsSUFBSW1OLElBQUlDO1FBQ2hCLElBQUk5QjtRQUNKLElBQUlxYSxPQUFPO1FBQ1gsSUFBSW1CLGNBQWMsQ0FBQztRQUNuQixJQUFJLElBQUksQ0FBQ3hVLFNBQVMsQ0FBQ0csVUFBVSxJQUFJO1lBQzdCLE1BQU1nVCxPQUFPMDFCLGlDQUFpQ3AzQjtZQUM5QzRCLE9BQU92bEIsVUFBVSxjQUFjcWxCLElBQUksQ0FBQyxPQUFPO1lBQzNDcUIsY0FBY3JCLElBQUksQ0FBQyxTQUFTO1lBQzVCLE9BQU9BLElBQUksQ0FBQyxPQUFPO1lBQ25CLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCbmEsV0FBVyxJQUFJLENBQUNnSCxTQUFTLENBQ3BCZ1QsT0FBTyxDQUFDO2dCQUNUSyxNQUFNQTtnQkFDTm1CLGFBQWFBO2dCQUNickIsTUFBTXNCLEtBQUtDLFNBQVMsQ0FBQ3ZCO2dCQUNyQndCLFlBQVk7Z0JBQ1p0bkIsYUFBYSxDQUFDSSxLQUFLZ2tCLE9BQU85UyxNQUFNLE1BQU0sUUFBUWxSLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0osV0FBVztnQkFDckZ1bkIsYUFBYSxDQUFDbG5CLEtBQUsrakIsT0FBTzlTLE1BQU0sTUFBTSxRQUFRalIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHa25CLFdBQVc7WUFDekYsR0FDS0MsSUFBSSxDQUFDLENBQUNDO2dCQUNQLE9BQU9BLGFBQWF6YSxJQUFJLEdBQUd3YSxJQUFJLENBQUMsQ0FBQ087b0JBQzdCLE1BQU1wYyxXQUFXb2M7b0JBQ2pCcGMsU0FBUzZZLGVBQWUsR0FBRzt3QkFDdkJyWCxTQUFTc2EsYUFBYXRhLE9BQU87b0JBQ2pDO29CQUNBLE9BQU94QjtnQkFDWDtZQUNKO1lBQ0EsT0FBT0EsU0FBUzZiLElBQUksQ0FBQyxDQUFDL1g7Z0JBQ2xCLE1BQU1pWSxPQUFPazBCLGlDQUFpQ25zQztnQkFDOUMsTUFBTXVZLFlBQVksSUFBSW5ZO2dCQUN0QjdPLE9BQU93QixNQUFNLENBQUN3bEIsV0FBV047Z0JBQ3pCLE9BQU9NO1lBQ1g7UUFDSixPQUNLO1lBQ0QsTUFBTWxDLE9BQU95MUIsZ0NBQWdDbjNCO1lBQzdDNEIsT0FBT3ZsQixVQUFVLGVBQWVxbEIsSUFBSSxDQUFDLE9BQU87WUFDNUNxQixjQUFjckIsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJuYSxXQUFXLElBQUksQ0FBQ2dILFNBQVMsQ0FDcEJnVCxPQUFPLENBQUM7Z0JBQ1RLLE1BQU1BO2dCQUNObUIsYUFBYUE7Z0JBQ2JyQixNQUFNc0IsS0FBS0MsU0FBUyxDQUFDdkI7Z0JBQ3JCd0IsWUFBWTtnQkFDWnRuQixhQUFhLENBQUN3TixLQUFLNFcsT0FBTzlTLE1BQU0sTUFBTSxRQUFROUQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHeE4sV0FBVztnQkFDckZ1bkIsYUFBYSxDQUFDOVosS0FBSzJXLE9BQU85UyxNQUFNLE1BQU0sUUFBUTdELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzhaLFdBQVc7WUFDekYsR0FDS0MsSUFBSSxDQUFDLENBQUNDO2dCQUNQLE9BQU9BLGFBQWF6YSxJQUFJLEdBQUd3YSxJQUFJLENBQUMsQ0FBQ087b0JBQzdCLE1BQU1wYyxXQUFXb2M7b0JBQ2pCcGMsU0FBUzZZLGVBQWUsR0FBRzt3QkFDdkJyWCxTQUFTc2EsYUFBYXRhLE9BQU87b0JBQ2pDO29CQUNBLE9BQU94QjtnQkFDWDtZQUNKO1lBQ0EsT0FBT0EsU0FBUzZiLElBQUksQ0FBQyxDQUFDL1g7Z0JBQ2xCLE1BQU1pWSxPQUFPK3pCLGdDQUFnQ2hzQztnQkFDN0MsTUFBTXVZLFlBQVksSUFBSW5ZO2dCQUN0QjdPLE9BQU93QixNQUFNLENBQUN3bEIsV0FBV047Z0JBQ3pCLE9BQU9NO1lBQ1g7UUFDSjtJQUNKO0lBQ0E7Ozs7Ozs7Ozs7S0FVQyxHQUNELE1BQU1ILE9BQU96RCxNQUFNLEVBQUU7UUFDakIsSUFBSWhrQixJQUFJQyxJQUFJbU4sSUFBSUM7UUFDaEIsSUFBSTlCO1FBQ0osSUFBSXFhLE9BQU87UUFDWCxJQUFJbUIsY0FBYyxDQUFDO1FBQ25CLElBQUksSUFBSSxDQUFDeFUsU0FBUyxDQUFDRyxVQUFVLElBQUk7WUFDN0IsTUFBTWdULE9BQU8wekIsa0NBQWtDcDFCO1lBQy9DNEIsT0FBT3ZsQixVQUFVLGlCQUFpQnFsQixJQUFJLENBQUMsT0FBTztZQUM5Q3FCLGNBQWNyQixJQUFJLENBQUMsU0FBUztZQUM1QixPQUFPQSxJQUFJLENBQUMsT0FBTztZQUNuQixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQm5hLFdBQVcsSUFBSSxDQUFDZ0gsU0FBUyxDQUNwQmdULE9BQU8sQ0FBQztnQkFDVEssTUFBTUE7Z0JBQ05tQixhQUFhQTtnQkFDYnJCLE1BQU1zQixLQUFLQyxTQUFTLENBQUN2QjtnQkFDckJ3QixZQUFZO2dCQUNadG5CLGFBQWEsQ0FBQ0ksS0FBS2drQixPQUFPOVMsTUFBTSxNQUFNLFFBQVFsUixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdKLFdBQVc7Z0JBQ3JGdW5CLGFBQWEsQ0FBQ2xuQixLQUFLK2pCLE9BQU85UyxNQUFNLE1BQU0sUUFBUWpSLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2tuQixXQUFXO1lBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQztnQkFDUCxPQUFPQSxhQUFhemEsSUFBSSxHQUFHd2EsSUFBSSxDQUFDLENBQUNPO29CQUM3QixNQUFNcGMsV0FBV29jO29CQUNqQnBjLFNBQVM2WSxlQUFlLEdBQUc7d0JBQ3ZCclgsU0FBU3NhLGFBQWF0YSxPQUFPO29CQUNqQztvQkFDQSxPQUFPeEI7Z0JBQ1g7WUFDSjtZQUNBLE9BQU9BLFNBQVM2YixJQUFJLENBQUMsQ0FBQy9YO2dCQUNsQixNQUFNaVksT0FBT2d5QixrQ0FBa0NqcUM7Z0JBQy9DLE1BQU11WSxZQUFZLElBQUlsWTtnQkFDdEI5TyxPQUFPd0IsTUFBTSxDQUFDd2xCLFdBQVdOO2dCQUN6QixPQUFPTTtZQUNYO1FBQ0osT0FDSztZQUNELE1BQU1sQyxPQUFPd3pCLGlDQUFpQ2wxQjtZQUM5QzRCLE9BQU92bEIsVUFBVSxpQkFBaUJxbEIsSUFBSSxDQUFDLE9BQU87WUFDOUNxQixjQUFjckIsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJuYSxXQUFXLElBQUksQ0FBQ2dILFNBQVMsQ0FDcEJnVCxPQUFPLENBQUM7Z0JBQ1RLLE1BQU1BO2dCQUNObUIsYUFBYUE7Z0JBQ2JyQixNQUFNc0IsS0FBS0MsU0FBUyxDQUFDdkI7Z0JBQ3JCd0IsWUFBWTtnQkFDWnRuQixhQUFhLENBQUN3TixLQUFLNFcsT0FBTzlTLE1BQU0sTUFBTSxRQUFROUQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHeE4sV0FBVztnQkFDckZ1bkIsYUFBYSxDQUFDOVosS0FBSzJXLE9BQU85UyxNQUFNLE1BQU0sUUFBUTdELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzhaLFdBQVc7WUFDekYsR0FDS0MsSUFBSSxDQUFDLENBQUNDO2dCQUNQLE9BQU9BLGFBQWF6YSxJQUFJLEdBQUd3YSxJQUFJLENBQUMsQ0FBQ087b0JBQzdCLE1BQU1wYyxXQUFXb2M7b0JBQ2pCcGMsU0FBUzZZLGVBQWUsR0FBRzt3QkFDdkJyWCxTQUFTc2EsYUFBYXRhLE9BQU87b0JBQ2pDO29CQUNBLE9BQU94QjtnQkFDWDtZQUNKO1lBQ0EsT0FBT0EsU0FBUzZiLElBQUksQ0FBQyxDQUFDL1g7Z0JBQ2xCLE1BQU1pWSxPQUFPK3hCLGlDQUFpQ2hxQztnQkFDOUMsTUFBTXVZLFlBQVksSUFBSWxZO2dCQUN0QjlPLE9BQU93QixNQUFNLENBQUN3bEIsV0FBV047Z0JBQ3pCLE9BQU9NO1lBQ1g7UUFDSjtJQUNKO0lBQ0EsTUFBTW0xQixhQUFhLzRCLE1BQU0sRUFBRTtRQUN2QixJQUFJaGtCLElBQUlDO1FBQ1IsSUFBSXNMO1FBQ0osSUFBSXFhLE9BQU87UUFDWCxJQUFJbUIsY0FBYyxDQUFDO1FBQ25CLElBQUksSUFBSSxDQUFDeFUsU0FBUyxDQUFDRyxVQUFVLElBQUk7WUFDN0IsTUFBTWdULE9BQU9tMUIseUNBQXlDNzJCLFFBQVFBO1lBQzlENEIsT0FBT3ZsQixVQUFVLGNBQWNxbEIsSUFBSSxDQUFDLE9BQU87WUFDM0NxQixjQUFjckIsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJuYSxXQUFXLElBQUksQ0FBQ2dILFNBQVMsQ0FDcEJnVCxPQUFPLENBQUM7Z0JBQ1RLLE1BQU1BO2dCQUNObUIsYUFBYUE7Z0JBQ2JyQixNQUFNc0IsS0FBS0MsU0FBUyxDQUFDdkI7Z0JBQ3JCd0IsWUFBWTtnQkFDWnRuQixhQUFhLENBQUNJLEtBQUtna0IsT0FBTzlTLE1BQU0sTUFBTSxRQUFRbFIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSixXQUFXO2dCQUNyRnVuQixhQUFhLENBQUNsbkIsS0FBSytqQixPQUFPOVMsTUFBTSxNQUFNLFFBQVFqUixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdrbkIsV0FBVztZQUN6RixHQUNLQyxJQUFJLENBQUMsQ0FBQ0M7Z0JBQ1AsT0FBT0EsYUFBYXphLElBQUksR0FBR3dhLElBQUksQ0FBQyxDQUFDTztvQkFDN0IsTUFBTXBjLFdBQVdvYztvQkFDakJwYyxTQUFTNlksZUFBZSxHQUFHO3dCQUN2QnJYLFNBQVNzYSxhQUFhdGEsT0FBTztvQkFDakM7b0JBQ0EsT0FBT3hCO2dCQUNYO1lBQ0o7WUFDQSxPQUFPQSxTQUFTNmIsSUFBSSxDQUFDLENBQUMvWDtnQkFDbEIsTUFBTWlZLE9BQU9tMEIsb0JBQW9CcHNDO2dCQUNqQyxPQUFPaVk7WUFDWDtRQUNKLE9BQ0s7WUFDRCxNQUFNLElBQUlwbUIsTUFBTTtRQUNwQjtJQUNKO0lBQ0EsTUFBTTg3QyxrQkFBa0JoNUIsTUFBTSxFQUFFO1FBQzVCLElBQUloa0IsSUFBSUM7UUFDUixJQUFJc0w7UUFDSixJQUFJcWEsT0FBTztRQUNYLElBQUltQixjQUFjLENBQUM7UUFDbkIsSUFBSSxJQUFJLENBQUN4VSxTQUFTLENBQUNHLFVBQVUsSUFBSTtZQUM3QixNQUFNLElBQUl4UixNQUFNO1FBQ3BCLE9BQ0s7WUFDRCxNQUFNd2tCLE9BQU8rMEIsd0NBQXdDejJCO1lBQ3JENEIsT0FBT3ZsQixVQUFVLGVBQWVxbEIsSUFBSSxDQUFDLE9BQU87WUFDNUNxQixjQUFjckIsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJuYSxXQUFXLElBQUksQ0FBQ2dILFNBQVMsQ0FDcEJnVCxPQUFPLENBQUM7Z0JBQ1RLLE1BQU1BO2dCQUNObUIsYUFBYUE7Z0JBQ2JyQixNQUFNc0IsS0FBS0MsU0FBUyxDQUFDdkI7Z0JBQ3JCd0IsWUFBWTtnQkFDWnRuQixhQUFhLENBQUNJLEtBQUtna0IsT0FBTzlTLE1BQU0sTUFBTSxRQUFRbFIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSixXQUFXO2dCQUNyRnVuQixhQUFhLENBQUNsbkIsS0FBSytqQixPQUFPOVMsTUFBTSxNQUFNLFFBQVFqUixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdrbkIsV0FBVztZQUN6RixHQUNLQyxJQUFJLENBQUMsQ0FBQ0M7Z0JBQ1AsT0FBT0EsYUFBYXphLElBQUksR0FBR3dhLElBQUksQ0FBQyxDQUFDTztvQkFDN0IsTUFBTXBjLFdBQVdvYztvQkFDakJwYyxTQUFTNlksZUFBZSxHQUFHO3dCQUN2QnJYLFNBQVNzYSxhQUFhdGEsT0FBTztvQkFDakM7b0JBQ0EsT0FBT3hCO2dCQUNYO1lBQ0o7WUFDQSxPQUFPQSxTQUFTNmIsSUFBSSxDQUFDLENBQUMvWDtnQkFDbEIsTUFBTWlZLE9BQU9zMUIseUJBQXlCdnRDO2dCQUN0QyxPQUFPaVk7WUFDWDtRQUNKO0lBQ0o7SUE5V0F4YSxZQUFZeUYsU0FBUyxDQUFFOztRQUNuQixLQUFLO1FBQ0wsSUFBSSxDQUFDQSxTQUFTLEdBQUdBO1FBQ2pCOzs7Ozs7Ozs7Ozs7O1NBYUMsR0FDRCxJQUFJLENBQUN1VixJQUFJLEdBQUc7Z0JBQU85RCwwRUFBUyxDQUFDO1lBQ3pCLE9BQU8sSUFBSUYsTUFBTUQsVUFBVW81QixzQkFBc0IsRUFBRSxDQUFDajFCLElBQU0sTUFBS04sWUFBWSxDQUFDTSxJQUFJLE1BQU0sTUFBS04sWUFBWSxDQUFDMUQsU0FBU0E7UUFDckg7UUFDQTs7Ozs7Ozs7U0FRQyxHQUNELElBQUksQ0FBQ3dELEdBQUcsR0FBRyxPQUFPeEQ7WUFDZCxPQUFPLE1BQU0sSUFBSSxDQUFDODRCLFdBQVcsQ0FBQzk0QjtRQUNsQztRQUNBOzs7Ozs7OztTQVFDLEdBQ0QsSUFBSSxDQUFDazVCLElBQUksR0FBRyxPQUFPbDVCO1lBQ2YsSUFBSWhrQjtZQUNKLElBQUksSUFBSSxDQUFDdVMsU0FBUyxDQUFDRyxVQUFVLElBQUk7Z0JBQzdCLElBQUlzUixPQUFPbTVCLFNBQVMsQ0FBQ3I1QyxVQUFVLENBQUMsY0FBYztvQkFDMUMsTUFBTXM1QyxnQkFBZ0I7d0JBQ2xCQyxnQkFBZ0JyNUIsT0FBT201QixTQUFTO29CQUNwQztvQkFDQSxJQUFJLENBQUNuOUMsS0FBS2drQixPQUFPOVMsTUFBTSxNQUFNLFFBQVFsUixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdzOUMseUJBQXlCLEVBQUU7d0JBQ3hGRixjQUFjRyxZQUFZLEdBQUd2NUIsT0FBTzlTLE1BQU0sQ0FBQ29zQyx5QkFBeUI7b0JBQ3hFO29CQUNBLE1BQU1FLGdCQUFnQjU4QyxPQUFPd0IsTUFBTSxDQUFDeEIsT0FBT3dCLE1BQU0sQ0FBQyxDQUFDLEdBQUc0aEIsU0FBUzt3QkFBRW81QixlQUFlQTtvQkFBYztvQkFDOUZJLGNBQWNMLFNBQVMsR0FBRy85QztvQkFDMUIsT0FBTyxNQUFNLElBQUksQ0FBQzI5QyxZQUFZLENBQUNTO2dCQUNuQyxPQUNLO29CQUNELE1BQU1BLGdCQUFnQjU4QyxPQUFPd0IsTUFBTSxDQUFDLENBQUMsR0FBRzRoQjtvQkFDeEMsT0FBTyxNQUFNLElBQUksQ0FBQys0QixZQUFZLENBQUNTO2dCQUNuQztZQUNKLE9BQ0s7Z0JBQ0QsTUFBTUEsZ0JBQWdCNThDLE9BQU93QixNQUFNLENBQUMsQ0FBQyxHQUFHNGhCO2dCQUN4QyxNQUFNelUsWUFBWSxNQUFNLElBQUksQ0FBQ3l0QyxpQkFBaUIsQ0FBQ1E7Z0JBQy9DLElBQUlILGlCQUFpQjtnQkFDckIsSUFBSTl0QyxTQUFTLENBQUMsV0FBVyxLQUFLblEsYUFDMUJtUSxTQUFTLENBQUMsV0FBVyxDQUFDLGFBQWEsS0FBS25RLFdBQVc7b0JBQ25EaStDLGlCQUFpQjl0QyxTQUFTLENBQUMsV0FBVyxDQUFDLGFBQWE7Z0JBQ3hELE9BQ0ssSUFBSUEsU0FBUyxDQUFDLE9BQU8sS0FBS25RLGFBQzNCbVEsU0FBUyxDQUFDLE9BQU8sQ0FBQ2tELFFBQVEsQ0FBQyxpQkFBaUI7b0JBQzVDNHFDLGlCQUFpQjl0QyxTQUFTLENBQUMsT0FBTyxDQUFDdE0sS0FBSyxDQUFDLGVBQWUsQ0FBQyxFQUFFO2dCQUMvRDtnQkFDQSxNQUFNdzZDLFlBQVk7b0JBQ2R2eUMsTUFBTW15QztvQkFDTmpqQyxPQUFPblMsU0FBU3kxQyxnQkFBZ0I7Z0JBQ3BDO2dCQUNBLE9BQU9EO1lBQ1g7UUFDSjtJQUNKO0FBZ1NKO0FBRUE7Ozs7Q0FJQyxHQUNELE1BQU1FO0lBQ0YsTUFBTWh0QixTQUFTaXRCLE9BQU8sRUFBRUMsVUFBVSxFQUFFO1FBQ2hDLE1BQU0sSUFBSTM4QyxNQUFNO0lBQ3BCO0FBQ0o7QUFFQSxNQUFNNDhDLGlCQUFpQixPQUFPLE9BQU8sR0FBRyxRQUFRO0FBQ2hELE1BQU1DLGtCQUFrQjtBQUN4QixNQUFNQyx5QkFBeUI7QUFDL0IsTUFBTUMsbUJBQW1CO0FBQ3pCLE1BQU1DLG9DQUFvQztBQUMxQyxlQUFlQyxXQUFXenRCLElBQUksRUFBRTJYLFNBQVMsRUFBRTkxQixTQUFTO0lBQ2hELElBQUl2UztJQUNKLE1BQU11TCxXQUFXLE1BQU02eUMsbUJBQW1CMXRCLE1BQU0yWCxXQUFXOTFCO0lBQzNELE1BQU04ckMsZUFBZ0IsTUFBTzl5QyxDQUFBQSxhQUFhLFFBQVFBLGFBQWEsS0FBSyxJQUFJLEtBQUssSUFBSUEsU0FBU3FCLElBQUksRUFBQztJQUMvRixJQUFJLENBQUMsQ0FBQzVNLEtBQUt1TCxhQUFhLFFBQVFBLGFBQWEsS0FBSyxJQUFJLEtBQUssSUFBSUEsU0FBU3dCLE9BQU8sTUFBTSxRQUFRL00sT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxFQUFFLENBQUNrK0Msa0NBQWtDLE1BQU0sU0FBUztRQUN0SyxNQUFNLElBQUloOUMsTUFBTTtJQUNwQjtJQUNBLE9BQU9tOUMsWUFBWSxDQUFDLE9BQU87QUFDL0I7QUFDQSxlQUFlQyw0QkFBNEI1dEIsSUFBSSxFQUFFMlgsU0FBUyxFQUFFOTFCLFNBQVM7SUFDakUsSUFBSXZTO0lBQ0osTUFBTXVMLFdBQVcsTUFBTTZ5QyxtQkFBbUIxdEIsTUFBTTJYLFdBQVc5MUI7SUFDM0QsTUFBTThyQyxlQUFnQixNQUFPOXlDLENBQUFBLGFBQWEsUUFBUUEsYUFBYSxLQUFLLElBQUksS0FBSyxJQUFJQSxTQUFTcUIsSUFBSSxFQUFDO0lBQy9GLElBQUksQ0FBQyxDQUFDNU0sS0FBS3VMLGFBQWEsUUFBUUEsYUFBYSxLQUFLLElBQUksS0FBSyxJQUFJQSxTQUFTd0IsT0FBTyxNQUFNLFFBQVEvTSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEVBQUUsQ0FBQ2srQyxrQ0FBa0MsTUFBTSxTQUFTO1FBQ3RLLE1BQU0sSUFBSWg5QyxNQUFNO0lBQ3BCO0lBQ0EsTUFBTW9tQixPQUFPamhCLDBDQUEwQ2c0QztJQUN2RCxNQUFNejJCLFlBQVksSUFBSXZWO0lBQ3RCelIsT0FBT3dCLE1BQU0sQ0FBQ3dsQixXQUFXTjtJQUN6QixPQUFPTTtBQUNYO0FBQ0EsZUFBZXcyQixtQkFBbUIxdEIsSUFBSSxFQUFFMlgsU0FBUyxFQUFFOTFCLFNBQVM7SUFDeEQsSUFBSXZTLElBQUlDO0lBQ1IsSUFBSXMrQyxXQUFXO0lBQ2YsSUFBSUMsU0FBUztJQUNiLElBQUlqekMsV0FBVyxJQUFJb0IsYUFBYSxJQUFJdTZCO0lBQ3BDLElBQUl1WCxnQkFBZ0I7SUFDcEJGLFdBQVc3dEIsS0FBSzBYLElBQUk7SUFDcEIsTUFBT29XLFNBQVNELFNBQVU7UUFDdEIsTUFBTUcsWUFBWWhYLEtBQUtpWCxHQUFHLENBQUNiLGdCQUFnQlMsV0FBV0M7UUFDdEQsTUFBTW52QixRQUFRcUIsS0FBS2h2QixLQUFLLENBQUM4OEMsUUFBUUEsU0FBU0U7UUFDMUMsSUFBSUYsU0FBU0UsYUFBYUgsVUFBVTtZQUNoQ0UsaUJBQWlCO1FBQ3JCO1FBQ0EsSUFBSUcsYUFBYTtRQUNqQixJQUFJQyxpQkFBaUJiO1FBQ3JCLE1BQU9ZLGFBQWFiLGdCQUFpQjtZQUNqQ3h5QyxXQUFXLE1BQU1nSCxVQUFVZ1QsT0FBTyxDQUFDO2dCQUMvQkssTUFBTTtnQkFDTkYsTUFBTTJKO2dCQUNObkksWUFBWTtnQkFDWnRuQixhQUFhO29CQUNUeWpDLFlBQVk7b0JBQ1puakMsU0FBU21vQztvQkFDVHQ3QixTQUFTO3dCQUNMLHlCQUF5QjB4Qzt3QkFDekIsd0JBQXdCeDlDLE9BQU91OUM7d0JBQy9CLGtCQUFrQnY5QyxPQUFPeTlDO29CQUM3QjtnQkFDSjtZQUNKO1lBQ0EsSUFBSSxDQUFDMStDLEtBQUt1TCxhQUFhLFFBQVFBLGFBQWEsS0FBSyxJQUFJLEtBQUssSUFBSUEsU0FBU3dCLE9BQU8sTUFBTSxRQUFRL00sT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxFQUFFLENBQUNrK0Msa0NBQWtDLEVBQUU7Z0JBQ3hKO1lBQ0o7WUFDQVU7WUFDQSxNQUFNRSxNQUFNRDtZQUNaQSxpQkFBaUJBLGlCQUFpQlo7UUFDdEM7UUFDQU8sVUFBVUU7UUFDVix1RUFBdUU7UUFDdkUsMEJBQTBCO1FBQzFCLElBQUksQ0FBQyxDQUFDeitDLEtBQUtzTCxhQUFhLFFBQVFBLGFBQWEsS0FBSyxJQUFJLEtBQUssSUFBSUEsU0FBU3dCLE9BQU8sTUFBTSxRQUFROU0sT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxFQUFFLENBQUNpK0Msa0NBQWtDLE1BQU0sVUFBVTtZQUN2SztRQUNKO1FBQ0EsdUVBQXVFO1FBQ3ZFLDZDQUE2QztRQUM3QyxJQUFJSyxZQUFZQyxRQUFRO1lBQ3BCLE1BQU0sSUFBSXQ5QyxNQUFNO1FBQ3BCO0lBQ0o7SUFDQSxPQUFPcUs7QUFDWDtBQUNBLGVBQWV3ekMsWUFBWXJ1QixJQUFJO0lBQzNCLE1BQU11WCxXQUFXO1FBQUVHLE1BQU0xWCxLQUFLMFgsSUFBSTtRQUFFM3pCLE1BQU1pYyxLQUFLamMsSUFBSTtJQUFDO0lBQ3BELE9BQU93ekI7QUFDWDtBQUNBLFNBQVM2VyxNQUFNRSxFQUFFO0lBQ2IsT0FBTyxJQUFJaHpCLFFBQVEsQ0FBQ2l6QixpQkFBbUJ6WixXQUFXeVosZ0JBQWdCRDtBQUN0RTtBQUVBLE1BQU1FO0lBQ0YsTUFBTTF1QixPQUFPRSxJQUFJLEVBQUUyWCxTQUFTLEVBQUU5MUIsU0FBUyxFQUFFO1FBQ3JDLElBQUksT0FBT21lLFNBQVMsVUFBVTtZQUMxQixNQUFNLElBQUl4dkIsTUFBTTtRQUNwQjtRQUNBLE9BQU8sTUFBTWk5QyxXQUFXenRCLE1BQU0yWCxXQUFXOTFCO0lBQzdDO0lBQ0EsTUFBTWsyQix3QkFBd0IvWCxJQUFJLEVBQUUyWCxTQUFTLEVBQUU5MUIsU0FBUyxFQUFFO1FBQ3RELElBQUksT0FBT21lLFNBQVMsVUFBVTtZQUMxQixNQUFNLElBQUl4dkIsTUFBTTtRQUNwQjtRQUNBLE9BQU8sTUFBTW85Qyw0QkFBNEI1dEIsTUFBTTJYLFdBQVc5MUI7SUFDOUQ7SUFDQSxNQUFNMjFCLEtBQUt4WCxJQUFJLEVBQUU7UUFDYixJQUFJLE9BQU9BLFNBQVMsVUFBVTtZQUMxQixNQUFNLElBQUl4dkIsTUFBTTtRQUNwQixPQUNLO1lBQ0QsT0FBTyxNQUFNNjlDLFlBQVlydUI7UUFDN0I7SUFDSjtBQUNKO0FBRUE7Ozs7Q0FJQyxHQUNELE1BQU15dUI7SUFDRmwzQixPQUFPaWMsR0FBRyxFQUFFbjNCLE9BQU8sRUFBRWsvQixTQUFTLEVBQUU7UUFDNUIsT0FBTyxJQUFJbVQsaUJBQWlCbGIsS0FBS24zQixTQUFTay9CO0lBQzlDO0FBQ0o7QUFDQSxNQUFNbVQ7SUFNRnhULFVBQVU7UUFDTixJQUFJLENBQUN5VCxFQUFFLEdBQUcsSUFBSUMsVUFBVSxJQUFJLENBQUNwYixHQUFHO1FBQ2hDLElBQUksQ0FBQ21iLEVBQUUsQ0FBQ2pULE1BQU0sR0FBRyxJQUFJLENBQUNILFNBQVMsQ0FBQ0csTUFBTTtRQUN0QyxJQUFJLENBQUNpVCxFQUFFLENBQUNoVCxPQUFPLEdBQUcsSUFBSSxDQUFDSixTQUFTLENBQUNJLE9BQU87UUFDeEMsSUFBSSxDQUFDZ1QsRUFBRSxDQUFDL1MsT0FBTyxHQUFHLElBQUksQ0FBQ0wsU0FBUyxDQUFDSyxPQUFPO1FBQ3hDLElBQUksQ0FBQytTLEVBQUUsQ0FBQzdULFNBQVMsR0FBRyxJQUFJLENBQUNTLFNBQVMsQ0FBQ1QsU0FBUztJQUNoRDtJQUNBb0IsS0FBSzVmLE9BQU8sRUFBRTtRQUNWLElBQUksSUFBSSxDQUFDcXlCLEVBQUUsS0FBS2pnRCxXQUFXO1lBQ3ZCLE1BQU0sSUFBSThCLE1BQU07UUFDcEI7UUFDQSxJQUFJLENBQUNtK0MsRUFBRSxDQUFDelMsSUFBSSxDQUFDNWY7SUFDakI7SUFDQThnQixRQUFRO1FBQ0osSUFBSSxJQUFJLENBQUN1UixFQUFFLEtBQUtqZ0QsV0FBVztZQUN2QixNQUFNLElBQUk4QixNQUFNO1FBQ3BCO1FBQ0EsSUFBSSxDQUFDbStDLEVBQUUsQ0FBQ3ZSLEtBQUs7SUFDakI7SUF2QkFoaEMsWUFBWW8zQixHQUFHLEVBQUVuM0IsT0FBTyxFQUFFay9CLFNBQVMsQ0FBRTtRQUNqQyxJQUFJLENBQUMvSCxHQUFHLEdBQUdBO1FBQ1gsSUFBSSxDQUFDbjNCLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNrL0IsU0FBUyxHQUFHQTtJQUNyQjtBQW9CSjtBQUVBOzs7O0NBSUMsR0FDRCxNQUFNc1Qsd0JBQXdCO0FBQzlCLDRFQUE0RTtBQUM1RSxNQUFNQztJQUlGLDZEQUE2RDtJQUM3RCxNQUFNM1gsZUFBZTk2QixPQUFPLEVBQUVtM0IsR0FBRyxFQUFFO1FBQy9CLElBQUluM0IsUUFBUXlhLEdBQUcsQ0FBQyszQiwyQkFBMkIsTUFBTTtZQUM3QztRQUNKO1FBQ0EsSUFBSSxJQUFJLENBQUNwYyxNQUFNLENBQUNyL0IsVUFBVSxDQUFDLGlCQUFpQjtZQUN4QyxNQUFNLElBQUk1QyxNQUFNO1FBQ3BCO1FBQ0Esb0NBQW9DO1FBQ3BDLElBQUksQ0FBQyxJQUFJLENBQUNpaUMsTUFBTSxFQUFFO1lBQ2QsTUFBTSxJQUFJamlDLE1BQU07UUFDcEI7UUFDQTZMLFFBQVEwM0IsTUFBTSxDQUFDOGEsdUJBQXVCLElBQUksQ0FBQ3BjLE1BQU07SUFDckQ7SUFoQkFyMkIsWUFBWXEyQixNQUFNLENBQUU7UUFDaEIsSUFBSSxDQUFDQSxNQUFNLEdBQUdBO0lBQ2xCO0FBZUo7QUFFQTs7OztDQUlDLEdBQ0QsTUFBTXNjLHdCQUF3QjtBQUM5Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FtQ0MsR0FDRCxNQUFNQztJQUNGNXlDLFlBQVk2aUIsT0FBTyxDQUFFO1FBQ2pCLElBQUkzdkI7UUFDSixJQUFJMnZCLFFBQVF3VCxNQUFNLElBQUksTUFBTTtZQUN4QixNQUFNLElBQUlqaUMsTUFBTTtRQUNwQjtRQUNBLHVEQUF1RDtRQUN2RCxJQUFJeXVCLFFBQVFxVCxPQUFPLElBQUlyVCxRQUFRc1QsUUFBUSxFQUFFO1lBQ3JDLE1BQU0sSUFBSS9oQyxNQUFNO1FBQ3BCO1FBQ0EsSUFBSSxDQUFDckIsUUFBUSxHQUFHLENBQUNHLEtBQUsydkIsUUFBUTl2QixRQUFRLE1BQU0sUUFBUUcsT0FBTyxLQUFLLElBQUlBLEtBQUs7UUFDekUsSUFBSSxDQUFDbWpDLE1BQU0sR0FBR3hULFFBQVF3VCxNQUFNO1FBQzVCLE1BQU1qakMsVUFBVVAsV0FBV2d3QixRQUFRL3ZCLFdBQVcsRUFBRSt2QixRQUFROXZCLFFBQVEsRUFDaEUsc0JBQXNCLEdBQUdULFdBQ3pCLHNCQUFzQixHQUFHQTtRQUN6QixJQUFJYyxTQUFTO1lBQ1QsSUFBSXl2QixRQUFRL3ZCLFdBQVcsRUFBRTtnQkFDckIrdkIsUUFBUS92QixXQUFXLENBQUNNLE9BQU8sR0FBR0E7WUFDbEMsT0FDSztnQkFDRHl2QixRQUFRL3ZCLFdBQVcsR0FBRztvQkFBRU0sU0FBU0E7Z0JBQVE7WUFDN0M7UUFDSjtRQUNBLElBQUksQ0FBQ21qQyxVQUFVLEdBQUcxVCxRQUFRMFQsVUFBVTtRQUNwQyxJQUFJLENBQUN6akMsV0FBVyxHQUFHK3ZCLFFBQVEvdkIsV0FBVztRQUN0QyxNQUFNZ29DLE9BQU8sSUFBSTRYLFFBQVEsSUFBSSxDQUFDcmMsTUFBTTtRQUNwQyxJQUFJLENBQUM1d0IsU0FBUyxHQUFHLElBQUlzd0IsVUFBVTtZQUMzQitFLE1BQU1BO1lBQ052RSxZQUFZLElBQUksQ0FBQ0EsVUFBVTtZQUMzQkYsUUFBUSxJQUFJLENBQUNBLE1BQU07WUFDbkJ0akMsVUFBVSxJQUFJLENBQUNBLFFBQVE7WUFDdkJELGFBQWEsSUFBSSxDQUFDQSxXQUFXO1lBQzdCNG5DLGdCQUFnQmlZLHdCQUF3QjtZQUN4Q3pYLFVBQVUsSUFBSWtYO1lBQ2R4VyxZQUFZLElBQUlpVjtRQUNwQjtRQUNBLElBQUksQ0FBQzlMLE1BQU0sR0FBRyxJQUFJbEIsT0FBTyxJQUFJLENBQUNwK0IsU0FBUztRQUN2QyxJQUFJLENBQUNvdEMsSUFBSSxHQUFHLElBQUl0UixLQUFLLElBQUksQ0FBQzk3QixTQUFTLEVBQUVxMUIsTUFBTSxJQUFJdVg7UUFDL0MsSUFBSSxDQUFDUyxPQUFPLEdBQUcsSUFBSXA2QixRQUFRLElBQUksQ0FBQ2pULFNBQVM7UUFDekMsSUFBSSxDQUFDc3RDLEtBQUssR0FBRyxJQUFJbnlCLE1BQU0sSUFBSSxDQUFDbWtCLE1BQU0sRUFBRSxJQUFJLENBQUN0L0IsU0FBUztRQUNsRCxJQUFJLENBQUN1dEMsTUFBTSxHQUFHLElBQUlsMUIsT0FBTyxJQUFJLENBQUNyWSxTQUFTO1FBQ3ZDLElBQUksQ0FBQ3d0QyxLQUFLLEdBQUcsSUFBSXh2QixNQUFNLElBQUksQ0FBQ2hlLFNBQVM7UUFDckMsSUFBSSxDQUFDeXRDLFVBQVUsR0FBRyxJQUFJcEssV0FBVyxJQUFJLENBQUNyakMsU0FBUztRQUMvQyxJQUFJLENBQUMwdEMsVUFBVSxHQUFHLElBQUloSSxPQUFPLElBQUksQ0FBQzFsQyxTQUFTO1FBQzNDLElBQUksQ0FBQzJ0QyxPQUFPLEdBQUcsSUFBSXJELFFBQVEsSUFBSSxDQUFDdHFDLFNBQVM7UUFDekMsSUFBSSxDQUFDNHRDLGdCQUFnQixHQUFHLElBQUl0SCxpQkFBaUIsSUFBSSxDQUFDdG1DLFNBQVM7SUFDL0Q7QUFDSjtBQUU0L0UsQ0FDNS9FLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9nZW5haS9kaXN0L3dlYi9pbmRleC5tanM/MWVkZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5sZXQgX2RlZmF1bHRCYXNlR2VtaW5pVXJsID0gdW5kZWZpbmVkO1xubGV0IF9kZWZhdWx0QmFzZVZlcnRleFVybCA9IHVuZGVmaW5lZDtcbi8qKlxuICogT3ZlcnJpZGVzIHRoZSBiYXNlIFVSTHMgZm9yIHRoZSBHZW1pbmkgQVBJIGFuZCBWZXJ0ZXggQUkgQVBJLlxuICpcbiAqIEByZW1hcmtzIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIGNhbGxlZCBiZWZvcmUgaW5pdGlhbGl6aW5nIHRoZSBTREsuIElmIHRoZVxuICogYmFzZSBVUkxzIGFyZSBzZXQgYWZ0ZXIgaW5pdGlhbGl6aW5nIHRoZSBTREssIHRoZSBiYXNlIFVSTHMgd2lsbCBub3QgYmVcbiAqIHVwZGF0ZWQuIEJhc2UgVVJMcyBwcm92aWRlZCBpbiB0aGUgSHR0cE9wdGlvbnMgd2lsbCBhbHNvIHRha2UgcHJlY2VkZW5jZSBvdmVyXG4gKiBVUkxzIHNldCBoZXJlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHtHb29nbGVHZW5BSSwgc2V0RGVmYXVsdEJhc2VVcmxzfSBmcm9tICdAZ29vZ2xlL2dlbmFpJztcbiAqIC8vIE92ZXJyaWRlIHRoZSBiYXNlIFVSTCBmb3IgdGhlIEdlbWluaSBBUEkuXG4gKiBzZXREZWZhdWx0QmFzZVVybHMoe2dlbWluaVVybDonaHR0cHM6Ly9nZW1pbmkuZ29vZ2xlLmNvbSd9KTtcbiAqXG4gKiAvLyBPdmVycmlkZSB0aGUgYmFzZSBVUkwgZm9yIHRoZSBWZXJ0ZXggQUkgQVBJLlxuICogc2V0RGVmYXVsdEJhc2VVcmxzKHt2ZXJ0ZXhVcmw6ICdodHRwczovL3ZlcnRleGFpLmdvb2dsZWFwaXMuY29tJ30pO1xuICpcbiAqIGNvbnN0IGFpID0gbmV3IEdvb2dsZUdlbkFJKHthcGlLZXk6ICdHRU1JTklfQVBJX0tFWSd9KTtcbiAqIGBgYFxuICovXG5mdW5jdGlvbiBzZXREZWZhdWx0QmFzZVVybHMoYmFzZVVybFBhcmFtcykge1xuICAgIF9kZWZhdWx0QmFzZUdlbWluaVVybCA9IGJhc2VVcmxQYXJhbXMuZ2VtaW5pVXJsO1xuICAgIF9kZWZhdWx0QmFzZVZlcnRleFVybCA9IGJhc2VVcmxQYXJhbXMudmVydGV4VXJsO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkZWZhdWx0IGJhc2UgVVJMcyBmb3IgdGhlIEdlbWluaSBBUEkgYW5kIFZlcnRleCBBSSBBUEkuXG4gKi9cbmZ1bmN0aW9uIGdldERlZmF1bHRCYXNlVXJscygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZW1pbmlVcmw6IF9kZWZhdWx0QmFzZUdlbWluaVVybCxcbiAgICAgICAgdmVydGV4VXJsOiBfZGVmYXVsdEJhc2VWZXJ0ZXhVcmwsXG4gICAgfTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgZGVmYXVsdCBiYXNlIFVSTCBiYXNlZCBvbiB0aGUgZm9sbG93aW5nIHByaW9yaXR5OlxuICogICAxLiBCYXNlIFVSTHMgc2V0IHZpYSBIdHRwT3B0aW9ucy5cbiAqICAgMi4gQmFzZSBVUkxzIHNldCB2aWEgdGhlIGxhdGVzdCBjYWxsIHRvIHNldERlZmF1bHRCYXNlVXJscy5cbiAqICAgMy4gQmFzZSBVUkxzIHNldCB2aWEgZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICovXG5mdW5jdGlvbiBnZXRCYXNlVXJsKGh0dHBPcHRpb25zLCB2ZXJ0ZXhhaSwgdmVydGV4QmFzZVVybEZyb21FbnYsIGdlbWluaUJhc2VVcmxGcm9tRW52KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAoIShodHRwT3B0aW9ucyA9PT0gbnVsbCB8fCBodHRwT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaHR0cE9wdGlvbnMuYmFzZVVybCkpIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdEJhc2VVcmxzID0gZ2V0RGVmYXVsdEJhc2VVcmxzKCk7XG4gICAgICAgIGlmICh2ZXJ0ZXhhaSkge1xuICAgICAgICAgICAgcmV0dXJuIChfYSA9IGRlZmF1bHRCYXNlVXJscy52ZXJ0ZXhVcmwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZlcnRleEJhc2VVcmxGcm9tRW52O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIChfYiA9IGRlZmF1bHRCYXNlVXJscy5nZW1pbmlVcmwpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGdlbWluaUJhc2VVcmxGcm9tRW52O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBodHRwT3B0aW9ucy5iYXNlVXJsO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBCYXNlTW9kdWxlIHtcbn1cbmZ1bmN0aW9uIGZvcm1hdE1hcCh0ZW1wbGF0ZVN0cmluZywgdmFsdWVNYXApIHtcbiAgICAvLyBVc2UgYSByZWd1bGFyIGV4cHJlc3Npb24gdG8gZmluZCBhbGwgcGxhY2Vob2xkZXJzIGluIHRoZSB0ZW1wbGF0ZSBzdHJpbmdcbiAgICBjb25zdCByZWdleCA9IC9cXHsoW159XSspXFx9L2c7XG4gICAgLy8gUmVwbGFjZSBlYWNoIHBsYWNlaG9sZGVyIHdpdGggaXRzIGNvcnJlc3BvbmRpbmcgdmFsdWUgZnJvbSB0aGUgdmFsdWVNYXBcbiAgICByZXR1cm4gdGVtcGxhdGVTdHJpbmcucmVwbGFjZShyZWdleCwgKG1hdGNoLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZU1hcCwga2V5KSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZU1hcFtrZXldO1xuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgdmFsdWUgdG8gYSBzdHJpbmcgaWYgaXQncyBub3QgYSBzdHJpbmcgYWxyZWFkeVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwgPyBTdHJpbmcodmFsdWUpIDogJyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgbWlzc2luZyBrZXlzXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleSAnJHtrZXl9JyBub3QgZm91bmQgaW4gdmFsdWVNYXAuYCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHNldFZhbHVlQnlQYXRoKGRhdGEsIGtleXMsIHZhbHVlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAoa2V5LmVuZHNXaXRoKCdbXScpKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlOYW1lID0ga2V5LnNsaWNlKDAsIC0yKTtcbiAgICAgICAgICAgIGlmICghKGtleU5hbWUgaW4gZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtrZXlOYW1lXSA9IEFycmF5LmZyb20oeyBsZW5ndGg6IHZhbHVlLmxlbmd0aCB9LCAoKSA9PiAoe30pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVmFsdWUgbXVzdCBiZSBhIGxpc3QgZ2l2ZW4gYW4gYXJyYXkgcGF0aCAke2tleX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhW2tleU5hbWVdKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5RGF0YSA9IGRhdGFba2V5TmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYXJyYXlEYXRhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnRyeSA9IGFycmF5RGF0YVtqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKGVudHJ5LCBrZXlzLnNsaWNlKGkgKyAxKSwgdmFsdWVbal0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGQgb2YgYXJyYXlEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChkLCBrZXlzLnNsaWNlKGkgKyAxKSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleS5lbmRzV2l0aCgnWzBdJykpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleU5hbWUgPSBrZXkuc2xpY2UoMCwgLTMpO1xuICAgICAgICAgICAgaWYgKCEoa2V5TmFtZSBpbiBkYXRhKSkge1xuICAgICAgICAgICAgICAgIGRhdGFba2V5TmFtZV0gPSBbe31dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXJyYXlEYXRhID0gZGF0YVtrZXlOYW1lXTtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKGFycmF5RGF0YVswXSwga2V5cy5zbGljZShpICsgMSksIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGFba2V5XSB8fCB0eXBlb2YgZGF0YVtrZXldICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZGF0YVtrZXldID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZGF0YSA9IGRhdGFba2V5XTtcbiAgICB9XG4gICAgY29uc3Qga2V5VG9TZXQgPSBrZXlzW2tleXMubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgZXhpc3RpbmdEYXRhID0gZGF0YVtrZXlUb1NldF07XG4gICAgaWYgKGV4aXN0aW5nRGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghdmFsdWUgfHxcbiAgICAgICAgICAgICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09PSBleGlzdGluZ0RhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGV4aXN0aW5nRGF0YSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIGV4aXN0aW5nRGF0YSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oZXhpc3RpbmdEYXRhLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBzZXQgdmFsdWUgZm9yIGFuIGV4aXN0aW5nIGtleS4gS2V5OiAke2tleVRvU2V0fWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoa2V5VG9TZXQgPT09ICdfc2VsZicgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHZhbHVlICE9PSBudWxsICYmXG4gICAgICAgICAgICAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlQXNSZWNvcmQgPSB2YWx1ZTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oZGF0YSwgdmFsdWVBc1JlY29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhW2tleVRvU2V0XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0VmFsdWVCeVBhdGgoZGF0YSwga2V5cywgZGVmYXVsdFZhbHVlID0gdW5kZWZpbmVkKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAxICYmIGtleXNbMF0gPT09ICdfc2VsZicpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0JyB8fCBkYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBpZiAoa2V5LmVuZHNXaXRoKCdbXScpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5TmFtZSA9IGtleS5zbGljZSgwLCAtMik7XG4gICAgICAgICAgICAgICAgaWYgKGtleU5hbWUgaW4gZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcnJheURhdGEgPSBkYXRhW2tleU5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXlEYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlEYXRhLm1hcCgoZCkgPT4gZ2V0VmFsdWVCeVBhdGgoZCwga2V5cy5zbGljZShpICsgMSksIGRlZmF1bHRWYWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZGF0YVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cbi8qKlxuICogTW92ZXMgdmFsdWVzIGZyb20gc291cmNlIHBhdGhzIHRvIGRlc3RpbmF0aW9uIHBhdGhzLlxuICpcbiAqIEV4YW1wbGVzOlxuICogICBtb3ZlVmFsdWVCeVBhdGgoXG4gKiAgICAgeydyZXF1ZXN0cyc6IFt7J2NvbnRlbnQnOiB2MX0sIHsnY29udGVudCc6IHYyfV19LFxuICogICAgIHsncmVxdWVzdHNbXS4qJzogJ3JlcXVlc3RzW10ucmVxdWVzdC4qJ31cbiAqICAgKVxuICogICAgIC0+IHsncmVxdWVzdHMnOiBbeydyZXF1ZXN0Jzogeydjb250ZW50JzogdjF9fSwgeydyZXF1ZXN0Jzogeydjb250ZW50JzogdjJ9fV19XG4gKi9cbmZ1bmN0aW9uIG1vdmVWYWx1ZUJ5UGF0aChkYXRhLCBwYXRocykge1xuICAgIGZvciAoY29uc3QgW3NvdXJjZVBhdGgsIGRlc3RQYXRoXSBvZiBPYmplY3QuZW50cmllcyhwYXRocykpIHtcbiAgICAgICAgY29uc3Qgc291cmNlS2V5cyA9IHNvdXJjZVBhdGguc3BsaXQoJy4nKTtcbiAgICAgICAgY29uc3QgZGVzdEtleXMgPSBkZXN0UGF0aC5zcGxpdCgnLicpO1xuICAgICAgICAvLyBEZXRlcm1pbmUga2V5cyB0byBleGNsdWRlIGZyb20gd2lsZGNhcmQgdG8gYXZvaWQgY3ljbGljIHJlZmVyZW5jZXNcbiAgICAgICAgY29uc3QgZXhjbHVkZUtleXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGxldCB3aWxkY2FyZElkeCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2VLZXlzW2ldID09PSAnKicpIHtcbiAgICAgICAgICAgICAgICB3aWxkY2FyZElkeCA9IGk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpbGRjYXJkSWR4ICE9PSAtMSAmJiBkZXN0S2V5cy5sZW5ndGggPiB3aWxkY2FyZElkeCkge1xuICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgaW50ZXJtZWRpYXRlIGtleSBiZXR3ZWVuIHNvdXJjZSBhbmQgZGVzdCBwYXRoc1xuICAgICAgICAgICAgLy8gRXhhbXBsZTogc291cmNlPVsncmVxdWVzdHNbXScsICcqJ10sIGRlc3Q9WydyZXF1ZXN0c1tdJywgJ3JlcXVlc3QnLCAnKiddXG4gICAgICAgICAgICAvLyBXZSB3YW50IHRvIGV4Y2x1ZGUgJ3JlcXVlc3QnXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gd2lsZGNhcmRJZHg7IGkgPCBkZXN0S2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGRlc3RLZXlzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICcqJyAmJiAha2V5LmVuZHNXaXRoKCdbXScpICYmICFrZXkuZW5kc1dpdGgoJ1swXScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVLZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfbW92ZVZhbHVlUmVjdXJzaXZlKGRhdGEsIHNvdXJjZUtleXMsIGRlc3RLZXlzLCAwLCBleGNsdWRlS2V5cyk7XG4gICAgfVxufVxuLyoqXG4gKiBSZWN1cnNpdmVseSBtb3ZlcyB2YWx1ZXMgZnJvbSBzb3VyY2UgcGF0aCB0byBkZXN0aW5hdGlvbiBwYXRoLlxuICovXG5mdW5jdGlvbiBfbW92ZVZhbHVlUmVjdXJzaXZlKGRhdGEsIHNvdXJjZUtleXMsIGRlc3RLZXlzLCBrZXlJZHgsIGV4Y2x1ZGVLZXlzKSB7XG4gICAgaWYgKGtleUlkeCA+PSBzb3VyY2VLZXlzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcgfHwgZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IHNvdXJjZUtleXNba2V5SWR4XTtcbiAgICBpZiAoa2V5LmVuZHNXaXRoKCdbXScpKSB7XG4gICAgICAgIGNvbnN0IGtleU5hbWUgPSBrZXkuc2xpY2UoMCwgLTIpO1xuICAgICAgICBjb25zdCBkYXRhUmVjb3JkID0gZGF0YTtcbiAgICAgICAgaWYgKGtleU5hbWUgaW4gZGF0YVJlY29yZCAmJiBBcnJheS5pc0FycmF5KGRhdGFSZWNvcmRba2V5TmFtZV0pKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgZGF0YVJlY29yZFtrZXlOYW1lXSkge1xuICAgICAgICAgICAgICAgIF9tb3ZlVmFsdWVSZWN1cnNpdmUoaXRlbSwgc291cmNlS2V5cywgZGVzdEtleXMsIGtleUlkeCArIDEsIGV4Y2x1ZGVLZXlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChrZXkgPT09ICcqJykge1xuICAgICAgICAvLyB3aWxkY2FyZCAtIG1vdmUgYWxsIGZpZWxkc1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmIGRhdGEgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFSZWNvcmQgPSBkYXRhO1xuICAgICAgICAgICAgY29uc3Qga2V5c1RvTW92ZSA9IE9iamVjdC5rZXlzKGRhdGFSZWNvcmQpLmZpbHRlcigoaykgPT4gIWsuc3RhcnRzV2l0aCgnXycpICYmICFleGNsdWRlS2V5cy5oYXMoaykpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVzVG9Nb3ZlID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGsgb2Yga2V5c1RvTW92ZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlc1RvTW92ZVtrXSA9IGRhdGFSZWNvcmRba107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXQgdmFsdWVzIGF0IGRlc3RpbmF0aW9uXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZXNUb01vdmUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RGVzdEtleXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRrIG9mIGRlc3RLZXlzLnNsaWNlKGtleUlkeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRrID09PSAnKicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0Rlc3RLZXlzLnB1c2goayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdEZXN0S2V5cy5wdXNoKGRrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChkYXRhUmVjb3JkLCBuZXdEZXN0S2V5cywgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGsgb2Yga2V5c1RvTW92ZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBkYXRhUmVjb3JkW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBOYXZpZ2F0ZSB0byBuZXh0IGxldmVsXG4gICAgICAgIGNvbnN0IGRhdGFSZWNvcmQgPSBkYXRhO1xuICAgICAgICBpZiAoa2V5IGluIGRhdGFSZWNvcmQpIHtcbiAgICAgICAgICAgIF9tb3ZlVmFsdWVSZWN1cnNpdmUoZGF0YVJlY29yZFtrZXldLCBzb3VyY2VLZXlzLCBkZXN0S2V5cywga2V5SWR4ICsgMSwgZXhjbHVkZUtleXMpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5mdW5jdGlvbiB0Qnl0ZXMkMShmcm9tQnl0ZXMpIHtcbiAgICBpZiAodHlwZW9mIGZyb21CeXRlcyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmcm9tSW1hZ2VCeXRlcyBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuICAgIC8vIFRPRE8oYi8zODkxMzM5MTQpOiBSZW1vdmUgZHVtbXkgYnl0ZXMgY29udmVydGVyLlxuICAgIHJldHVybiBmcm9tQnl0ZXM7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8vIENvZGUgZ2VuZXJhdGVkIGJ5IHRoZSBHb29nbGUgR2VuIEFJIFNESyBnZW5lcmF0b3IgRE8gTk9UIEVESVQuXG5mdW5jdGlvbiBmZXRjaFByZWRpY3RPcGVyYXRpb25QYXJhbWV0ZXJzVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU9wZXJhdGlvbk5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvcGVyYXRpb25OYW1lJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU9wZXJhdGlvbk5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydvcGVyYXRpb25OYW1lJ10sIGZyb21PcGVyYXRpb25OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc291cmNlTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzb3VyY2VOYW1lJ10pO1xuICAgIGlmIChmcm9tUmVzb3VyY2VOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdyZXNvdXJjZU5hbWUnXSwgZnJvbVJlc291cmNlTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uRnJvbU1sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0YWRhdGEnXSk7XG4gICAgaWYgKGZyb21NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21ldGFkYXRhJ10sIGZyb21NZXRhZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Eb25lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkb25lJ10pO1xuICAgIGlmIChmcm9tRG9uZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RvbmUnXSwgZnJvbURvbmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXJyb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vycm9yJ10pO1xuICAgIGlmIChmcm9tRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlcnJvciddLCBmcm9tRXJyb3IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZScsXG4gICAgICAgICdnZW5lcmF0ZVZpZGVvUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCBnZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlRnJvbU1sZGV2JDEoZnJvbVJlc3BvbnNlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uRnJvbVZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJ10pO1xuICAgIGlmIChmcm9tTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZXRhZGF0YSddLCBmcm9tTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRG9uZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZG9uZSddKTtcbiAgICBpZiAoZnJvbURvbmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkb25lJ10sIGZyb21Eb25lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgZnJvbUVycm9yKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZSddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2UnXSwgZ2VuZXJhdGVWaWRlb3NSZXNwb25zZUZyb21WZXJ0ZXgkMShmcm9tUmVzcG9uc2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVWaWRlb3NSZXNwb25zZUZyb21NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21HZW5lcmF0ZWRWaWRlb3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnZW5lcmF0ZWRTYW1wbGVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdlbmVyYXRlZFZpZGVvcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tR2VuZXJhdGVkVmlkZW9zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlZFZpZGVvRnJvbU1sZGV2JDEoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0ZWRWaWRlb3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JhaU1lZGlhRmlsdGVyZWRDb3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyYWlNZWRpYUZpbHRlcmVkQ291bnQnXSwgZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JhaU1lZGlhRmlsdGVyZWRSZWFzb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMnXSwgZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVWaWRlb3NSZXNwb25zZUZyb21WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2VuZXJhdGVkVmlkZW9zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2aWRlb3MnXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0ZWRWaWRlb3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUdlbmVyYXRlZFZpZGVvcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRWaWRlb0Zyb21WZXJ0ZXgkMShpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRlZFZpZGVvcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmFpTWVkaWFGaWx0ZXJlZENvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JhaU1lZGlhRmlsdGVyZWRDb3VudCddLCBmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyYWlNZWRpYUZpbHRlcmVkUmVhc29ucyddLCBmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZWRWaWRlb0Zyb21NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21WaWRlbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmlkZW8nXSk7XG4gICAgaWYgKGZyb21WaWRlbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvJ10sIHZpZGVvRnJvbU1sZGV2JDEoZnJvbVZpZGVvKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlZFZpZGVvRnJvbVZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21WaWRlbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21WaWRlbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvJ10sIHZpZGVvRnJvbVZlcnRleCQxKGZyb21WaWRlbykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZXRPcGVyYXRpb25QYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tT3BlcmF0aW9uTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ29wZXJhdGlvbk5hbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tT3BlcmF0aW9uTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnb3BlcmF0aW9uTmFtZSddLCBmcm9tT3BlcmF0aW9uTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdldE9wZXJhdGlvblBhcmFtZXRlcnNUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tT3BlcmF0aW9uTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ29wZXJhdGlvbk5hbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tT3BlcmF0aW9uTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnb3BlcmF0aW9uTmFtZSddLCBmcm9tT3BlcmF0aW9uTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGltcG9ydEZpbGVPcGVyYXRpb25Gcm9tTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWV0YWRhdGEnXSwgZnJvbU1ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvbmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RvbmUnXSk7XG4gICAgaWYgKGZyb21Eb25lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9uZSddLCBmcm9tRG9uZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZyb21FcnJvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2UnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlJ10sIGltcG9ydEZpbGVSZXNwb25zZUZyb21NbGRldiQxKGZyb21SZXNwb25zZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbXBvcnRGaWxlUmVzcG9uc2VGcm9tTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFyZW50J10pO1xuICAgIGlmIChmcm9tUGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFyZW50J10sIGZyb21QYXJlbnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRG9jdW1lbnROYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkb2N1bWVudE5hbWUnXSk7XG4gICAgaWYgKGZyb21Eb2N1bWVudE5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkb2N1bWVudE5hbWUnXSwgZnJvbURvY3VtZW50TmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlT3BlcmF0aW9uRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJ10pO1xuICAgIGlmIChmcm9tTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZXRhZGF0YSddLCBmcm9tTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRG9uZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZG9uZSddKTtcbiAgICBpZiAoZnJvbURvbmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkb25lJ10sIGZyb21Eb25lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgZnJvbUVycm9yKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZSddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2UnXSwgdXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVSZXNwb25zZUZyb21NbGRldihmcm9tUmVzcG9uc2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFyZW50J10pO1xuICAgIGlmIChmcm9tUGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFyZW50J10sIGZyb21QYXJlbnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRG9jdW1lbnROYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkb2N1bWVudE5hbWUnXSk7XG4gICAgaWYgKGZyb21Eb2N1bWVudE5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkb2N1bWVudE5hbWUnXSwgZnJvbURvY3VtZW50TmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvRnJvbU1sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXJpJ10pO1xuICAgIGlmIChmcm9tVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJpJ10sIGZyb21VcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW9CeXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5jb2RlZFZpZGVvJ10pO1xuICAgIGlmIChmcm9tVmlkZW9CeXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvQnl0ZXMnXSwgdEJ5dGVzJDEoZnJvbVZpZGVvQnl0ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmNvZGluZyddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdmlkZW9Gcm9tVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2NzVXJpJ10pO1xuICAgIGlmIChmcm9tVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJpJ10sIGZyb21VcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW9CeXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2J5dGVzQmFzZTY0RW5jb2RlZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WaWRlb0J5dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW9CeXRlcyddLCB0Qnl0ZXMkMShmcm9tVmlkZW9CeXRlcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8qKiBPdXRjb21lIG9mIHRoZSBjb2RlIGV4ZWN1dGlvbi4gKi9cbnZhciBPdXRjb21lO1xuKGZ1bmN0aW9uIChPdXRjb21lKSB7XG4gICAgLyoqXG4gICAgICogVW5zcGVjaWZpZWQgc3RhdHVzLiBUaGlzIHZhbHVlIHNob3VsZCBub3QgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBPdXRjb21lW1wiT1VUQ09NRV9VTlNQRUNJRklFRFwiXSA9IFwiT1VUQ09NRV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIENvZGUgZXhlY3V0aW9uIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuXG4gICAgICovXG4gICAgT3V0Y29tZVtcIk9VVENPTUVfT0tcIl0gPSBcIk9VVENPTUVfT0tcIjtcbiAgICAvKipcbiAgICAgKiBDb2RlIGV4ZWN1dGlvbiBmaW5pc2hlZCBidXQgd2l0aCBhIGZhaWx1cmUuIGBzdGRlcnJgIHNob3VsZCBjb250YWluIHRoZSByZWFzb24uXG4gICAgICovXG4gICAgT3V0Y29tZVtcIk9VVENPTUVfRkFJTEVEXCJdID0gXCJPVVRDT01FX0ZBSUxFRFwiO1xuICAgIC8qKlxuICAgICAqIENvZGUgZXhlY3V0aW9uIHJhbiBmb3IgdG9vIGxvbmcsIGFuZCB3YXMgY2FuY2VsbGVkLiBUaGVyZSBtYXkgb3IgbWF5IG5vdCBiZSBhIHBhcnRpYWwgb3V0cHV0IHByZXNlbnQuXG4gICAgICovXG4gICAgT3V0Y29tZVtcIk9VVENPTUVfREVBRExJTkVfRVhDRUVERURcIl0gPSBcIk9VVENPTUVfREVBRExJTkVfRVhDRUVERURcIjtcbn0pKE91dGNvbWUgfHwgKE91dGNvbWUgPSB7fSkpO1xuLyoqIFByb2dyYW1taW5nIGxhbmd1YWdlIG9mIHRoZSBgY29kZWAuICovXG52YXIgTGFuZ3VhZ2U7XG4oZnVuY3Rpb24gKExhbmd1YWdlKSB7XG4gICAgLyoqXG4gICAgICogVW5zcGVjaWZpZWQgbGFuZ3VhZ2UuIFRoaXMgdmFsdWUgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICAgICAqL1xuICAgIExhbmd1YWdlW1wiTEFOR1VBR0VfVU5TUEVDSUZJRURcIl0gPSBcIkxBTkdVQUdFX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogUHl0aG9uID49IDMuMTAsIHdpdGggbnVtcHkgYW5kIHNpbXB5IGF2YWlsYWJsZS5cbiAgICAgKi9cbiAgICBMYW5ndWFnZVtcIlBZVEhPTlwiXSA9IFwiUFlUSE9OXCI7XG59KShMYW5ndWFnZSB8fCAoTGFuZ3VhZ2UgPSB7fSkpO1xuLyoqIFNwZWNpZmllcyBob3cgdGhlIHJlc3BvbnNlIHNob3VsZCBiZSBzY2hlZHVsZWQgaW4gdGhlIGNvbnZlcnNhdGlvbi4gKi9cbnZhciBGdW5jdGlvblJlc3BvbnNlU2NoZWR1bGluZztcbihmdW5jdGlvbiAoRnVuY3Rpb25SZXNwb25zZVNjaGVkdWxpbmcpIHtcbiAgICAvKipcbiAgICAgKiBUaGlzIHZhbHVlIGlzIHVudXNlZC5cbiAgICAgKi9cbiAgICBGdW5jdGlvblJlc3BvbnNlU2NoZWR1bGluZ1tcIlNDSEVEVUxJTkdfVU5TUEVDSUZJRURcIl0gPSBcIlNDSEVEVUxJTkdfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBPbmx5IGFkZCB0aGUgcmVzdWx0IHRvIHRoZSBjb252ZXJzYXRpb24gY29udGV4dCwgZG8gbm90IGludGVycnVwdCBvciB0cmlnZ2VyIGdlbmVyYXRpb24uXG4gICAgICovXG4gICAgRnVuY3Rpb25SZXNwb25zZVNjaGVkdWxpbmdbXCJTSUxFTlRcIl0gPSBcIlNJTEVOVFwiO1xuICAgIC8qKlxuICAgICAqIEFkZCB0aGUgcmVzdWx0IHRvIHRoZSBjb252ZXJzYXRpb24gY29udGV4dCwgYW5kIHByb21wdCB0byBnZW5lcmF0ZSBvdXRwdXQgd2l0aG91dCBpbnRlcnJ1cHRpbmcgb25nb2luZyBnZW5lcmF0aW9uLlxuICAgICAqL1xuICAgIEZ1bmN0aW9uUmVzcG9uc2VTY2hlZHVsaW5nW1wiV0hFTl9JRExFXCJdID0gXCJXSEVOX0lETEVcIjtcbiAgICAvKipcbiAgICAgKiBBZGQgdGhlIHJlc3VsdCB0byB0aGUgY29udmVyc2F0aW9uIGNvbnRleHQsIGludGVycnVwdCBvbmdvaW5nIGdlbmVyYXRpb24gYW5kIHByb21wdCB0byBnZW5lcmF0ZSBvdXRwdXQuXG4gICAgICovXG4gICAgRnVuY3Rpb25SZXNwb25zZVNjaGVkdWxpbmdbXCJJTlRFUlJVUFRcIl0gPSBcIklOVEVSUlVQVFwiO1xufSkoRnVuY3Rpb25SZXNwb25zZVNjaGVkdWxpbmcgfHwgKEZ1bmN0aW9uUmVzcG9uc2VTY2hlZHVsaW5nID0ge30pKTtcbi8qKiBUaGUgdHlwZSBvZiB0aGUgZGF0YS4gKi9cbnZhciBUeXBlO1xuKGZ1bmN0aW9uIChUeXBlKSB7XG4gICAgLyoqXG4gICAgICogTm90IHNwZWNpZmllZCwgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICAgICAqL1xuICAgIFR5cGVbXCJUWVBFX1VOU1BFQ0lGSUVEXCJdID0gXCJUWVBFX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogT3BlbkFQSSBzdHJpbmcgdHlwZVxuICAgICAqL1xuICAgIFR5cGVbXCJTVFJJTkdcIl0gPSBcIlNUUklOR1wiO1xuICAgIC8qKlxuICAgICAqIE9wZW5BUEkgbnVtYmVyIHR5cGVcbiAgICAgKi9cbiAgICBUeXBlW1wiTlVNQkVSXCJdID0gXCJOVU1CRVJcIjtcbiAgICAvKipcbiAgICAgKiBPcGVuQVBJIGludGVnZXIgdHlwZVxuICAgICAqL1xuICAgIFR5cGVbXCJJTlRFR0VSXCJdID0gXCJJTlRFR0VSXCI7XG4gICAgLyoqXG4gICAgICogT3BlbkFQSSBib29sZWFuIHR5cGVcbiAgICAgKi9cbiAgICBUeXBlW1wiQk9PTEVBTlwiXSA9IFwiQk9PTEVBTlwiO1xuICAgIC8qKlxuICAgICAqIE9wZW5BUEkgYXJyYXkgdHlwZVxuICAgICAqL1xuICAgIFR5cGVbXCJBUlJBWVwiXSA9IFwiQVJSQVlcIjtcbiAgICAvKipcbiAgICAgKiBPcGVuQVBJIG9iamVjdCB0eXBlXG4gICAgICovXG4gICAgVHlwZVtcIk9CSkVDVFwiXSA9IFwiT0JKRUNUXCI7XG4gICAgLyoqXG4gICAgICogTnVsbCB0eXBlXG4gICAgICovXG4gICAgVHlwZVtcIk5VTExcIl0gPSBcIk5VTExcIjtcbn0pKFR5cGUgfHwgKFR5cGUgPSB7fSkpO1xuLyoqIFRoZSBtb2RlIG9mIHRoZSBwcmVkaWN0b3IgdG8gYmUgdXNlZCBpbiBkeW5hbWljIHJldHJpZXZhbC4gKi9cbnZhciBNb2RlO1xuKGZ1bmN0aW9uIChNb2RlKSB7XG4gICAgLyoqXG4gICAgICogQWx3YXlzIHRyaWdnZXIgcmV0cmlldmFsLlxuICAgICAqL1xuICAgIE1vZGVbXCJNT0RFX1VOU1BFQ0lGSUVEXCJdID0gXCJNT0RFX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogUnVuIHJldHJpZXZhbCBvbmx5IHdoZW4gc3lzdGVtIGRlY2lkZXMgaXQgaXMgbmVjZXNzYXJ5LlxuICAgICAqL1xuICAgIE1vZGVbXCJNT0RFX0RZTkFNSUNcIl0gPSBcIk1PREVfRFlOQU1JQ1wiO1xufSkoTW9kZSB8fCAoTW9kZSA9IHt9KSk7XG4vKiogVGhlIEFQSSBzcGVjIHRoYXQgdGhlIGV4dGVybmFsIEFQSSBpbXBsZW1lbnRzLiBUaGlzIGVudW0gaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLiAqL1xudmFyIEFwaVNwZWM7XG4oZnVuY3Rpb24gKEFwaVNwZWMpIHtcbiAgICAvKipcbiAgICAgKiBVbnNwZWNpZmllZCBBUEkgc3BlYy4gVGhpcyB2YWx1ZSBzaG91bGQgbm90IGJlIHVzZWQuXG4gICAgICovXG4gICAgQXBpU3BlY1tcIkFQSV9TUEVDX1VOU1BFQ0lGSUVEXCJdID0gXCJBUElfU1BFQ19VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFNpbXBsZSBzZWFyY2ggQVBJIHNwZWMuXG4gICAgICovXG4gICAgQXBpU3BlY1tcIlNJTVBMRV9TRUFSQ0hcIl0gPSBcIlNJTVBMRV9TRUFSQ0hcIjtcbiAgICAvKipcbiAgICAgKiBFbGFzdGljIHNlYXJjaCBBUEkgc3BlYy5cbiAgICAgKi9cbiAgICBBcGlTcGVjW1wiRUxBU1RJQ19TRUFSQ0hcIl0gPSBcIkVMQVNUSUNfU0VBUkNIXCI7XG59KShBcGlTcGVjIHx8IChBcGlTcGVjID0ge30pKTtcbi8qKiBUeXBlIG9mIGF1dGggc2NoZW1lLiBUaGlzIGVudW0gaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLiAqL1xudmFyIEF1dGhUeXBlO1xuKGZ1bmN0aW9uIChBdXRoVHlwZSkge1xuICAgIEF1dGhUeXBlW1wiQVVUSF9UWVBFX1VOU1BFQ0lGSUVEXCJdID0gXCJBVVRIX1RZUEVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBObyBBdXRoLlxuICAgICAqL1xuICAgIEF1dGhUeXBlW1wiTk9fQVVUSFwiXSA9IFwiTk9fQVVUSFwiO1xuICAgIC8qKlxuICAgICAqIEFQSSBLZXkgQXV0aC5cbiAgICAgKi9cbiAgICBBdXRoVHlwZVtcIkFQSV9LRVlfQVVUSFwiXSA9IFwiQVBJX0tFWV9BVVRIXCI7XG4gICAgLyoqXG4gICAgICogSFRUUCBCYXNpYyBBdXRoLlxuICAgICAqL1xuICAgIEF1dGhUeXBlW1wiSFRUUF9CQVNJQ19BVVRIXCJdID0gXCJIVFRQX0JBU0lDX0FVVEhcIjtcbiAgICAvKipcbiAgICAgKiBHb29nbGUgU2VydmljZSBBY2NvdW50IEF1dGguXG4gICAgICovXG4gICAgQXV0aFR5cGVbXCJHT09HTEVfU0VSVklDRV9BQ0NPVU5UX0FVVEhcIl0gPSBcIkdPT0dMRV9TRVJWSUNFX0FDQ09VTlRfQVVUSFwiO1xuICAgIC8qKlxuICAgICAqIE9BdXRoIGF1dGguXG4gICAgICovXG4gICAgQXV0aFR5cGVbXCJPQVVUSFwiXSA9IFwiT0FVVEhcIjtcbiAgICAvKipcbiAgICAgKiBPcGVuSUQgQ29ubmVjdCAoT0lEQykgQXV0aC5cbiAgICAgKi9cbiAgICBBdXRoVHlwZVtcIk9JRENfQVVUSFwiXSA9IFwiT0lEQ19BVVRIXCI7XG59KShBdXRoVHlwZSB8fCAoQXV0aFR5cGUgPSB7fSkpO1xuLyoqIFRoZSBsb2NhdGlvbiBvZiB0aGUgQVBJIGtleS4gVGhpcyBlbnVtIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4gKi9cbnZhciBIdHRwRWxlbWVudExvY2F0aW9uO1xuKGZ1bmN0aW9uIChIdHRwRWxlbWVudExvY2F0aW9uKSB7XG4gICAgSHR0cEVsZW1lbnRMb2NhdGlvbltcIkhUVFBfSU5fVU5TUEVDSUZJRURcIl0gPSBcIkhUVFBfSU5fVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBFbGVtZW50IGlzIGluIHRoZSBIVFRQIHJlcXVlc3QgcXVlcnkuXG4gICAgICovXG4gICAgSHR0cEVsZW1lbnRMb2NhdGlvbltcIkhUVFBfSU5fUVVFUllcIl0gPSBcIkhUVFBfSU5fUVVFUllcIjtcbiAgICAvKipcbiAgICAgKiBFbGVtZW50IGlzIGluIHRoZSBIVFRQIHJlcXVlc3QgaGVhZGVyLlxuICAgICAqL1xuICAgIEh0dHBFbGVtZW50TG9jYXRpb25bXCJIVFRQX0lOX0hFQURFUlwiXSA9IFwiSFRUUF9JTl9IRUFERVJcIjtcbiAgICAvKipcbiAgICAgKiBFbGVtZW50IGlzIGluIHRoZSBIVFRQIHJlcXVlc3QgcGF0aC5cbiAgICAgKi9cbiAgICBIdHRwRWxlbWVudExvY2F0aW9uW1wiSFRUUF9JTl9QQVRIXCJdID0gXCJIVFRQX0lOX1BBVEhcIjtcbiAgICAvKipcbiAgICAgKiBFbGVtZW50IGlzIGluIHRoZSBIVFRQIHJlcXVlc3QgYm9keS5cbiAgICAgKi9cbiAgICBIdHRwRWxlbWVudExvY2F0aW9uW1wiSFRUUF9JTl9CT0RZXCJdID0gXCJIVFRQX0lOX0JPRFlcIjtcbiAgICAvKipcbiAgICAgKiBFbGVtZW50IGlzIGluIHRoZSBIVFRQIHJlcXVlc3QgY29va2llLlxuICAgICAqL1xuICAgIEh0dHBFbGVtZW50TG9jYXRpb25bXCJIVFRQX0lOX0NPT0tJRVwiXSA9IFwiSFRUUF9JTl9DT09LSUVcIjtcbn0pKEh0dHBFbGVtZW50TG9jYXRpb24gfHwgKEh0dHBFbGVtZW50TG9jYXRpb24gPSB7fSkpO1xuLyoqIFNpdGVzIHdpdGggY29uZmlkZW5jZSBsZXZlbCBjaG9zZW4gJiBhYm92ZSB0aGlzIHZhbHVlIHdpbGwgYmUgYmxvY2tlZCBmcm9tIHRoZSBzZWFyY2ggcmVzdWx0cy4gVGhpcyBlbnVtIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4gKi9cbnZhciBQaGlzaEJsb2NrVGhyZXNob2xkO1xuKGZ1bmN0aW9uIChQaGlzaEJsb2NrVGhyZXNob2xkKSB7XG4gICAgLyoqXG4gICAgICogRGVmYXVsdHMgdG8gdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgUGhpc2hCbG9ja1RocmVzaG9sZFtcIlBISVNIX0JMT0NLX1RIUkVTSE9MRF9VTlNQRUNJRklFRFwiXSA9IFwiUEhJU0hfQkxPQ0tfVEhSRVNIT0xEX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogQmxvY2tzIExvdyBhbmQgYWJvdmUgY29uZmlkZW5jZSBVUkwgdGhhdCBpcyByaXNreS5cbiAgICAgKi9cbiAgICBQaGlzaEJsb2NrVGhyZXNob2xkW1wiQkxPQ0tfTE9XX0FORF9BQk9WRVwiXSA9IFwiQkxPQ0tfTE9XX0FORF9BQk9WRVwiO1xuICAgIC8qKlxuICAgICAqIEJsb2NrcyBNZWRpdW0gYW5kIGFib3ZlIGNvbmZpZGVuY2UgVVJMIHRoYXQgaXMgcmlza3kuXG4gICAgICovXG4gICAgUGhpc2hCbG9ja1RocmVzaG9sZFtcIkJMT0NLX01FRElVTV9BTkRfQUJPVkVcIl0gPSBcIkJMT0NLX01FRElVTV9BTkRfQUJPVkVcIjtcbiAgICAvKipcbiAgICAgKiBCbG9ja3MgSGlnaCBhbmQgYWJvdmUgY29uZmlkZW5jZSBVUkwgdGhhdCBpcyByaXNreS5cbiAgICAgKi9cbiAgICBQaGlzaEJsb2NrVGhyZXNob2xkW1wiQkxPQ0tfSElHSF9BTkRfQUJPVkVcIl0gPSBcIkJMT0NLX0hJR0hfQU5EX0FCT1ZFXCI7XG4gICAgLyoqXG4gICAgICogQmxvY2tzIEhpZ2hlciBhbmQgYWJvdmUgY29uZmlkZW5jZSBVUkwgdGhhdCBpcyByaXNreS5cbiAgICAgKi9cbiAgICBQaGlzaEJsb2NrVGhyZXNob2xkW1wiQkxPQ0tfSElHSEVSX0FORF9BQk9WRVwiXSA9IFwiQkxPQ0tfSElHSEVSX0FORF9BQk9WRVwiO1xuICAgIC8qKlxuICAgICAqIEJsb2NrcyBWZXJ5IGhpZ2ggYW5kIGFib3ZlIGNvbmZpZGVuY2UgVVJMIHRoYXQgaXMgcmlza3kuXG4gICAgICovXG4gICAgUGhpc2hCbG9ja1RocmVzaG9sZFtcIkJMT0NLX1ZFUllfSElHSF9BTkRfQUJPVkVcIl0gPSBcIkJMT0NLX1ZFUllfSElHSF9BTkRfQUJPVkVcIjtcbiAgICAvKipcbiAgICAgKiBCbG9ja3MgRXh0cmVtZWx5IGhpZ2ggY29uZmlkZW5jZSBVUkwgdGhhdCBpcyByaXNreS5cbiAgICAgKi9cbiAgICBQaGlzaEJsb2NrVGhyZXNob2xkW1wiQkxPQ0tfT05MWV9FWFRSRU1FTFlfSElHSFwiXSA9IFwiQkxPQ0tfT05MWV9FWFRSRU1FTFlfSElHSFwiO1xufSkoUGhpc2hCbG9ja1RocmVzaG9sZCB8fCAoUGhpc2hCbG9ja1RocmVzaG9sZCA9IHt9KSk7XG4vKiogVGhlIGxldmVsIG9mIHRob3VnaHRzIHRva2VucyB0aGF0IHRoZSBtb2RlbCBzaG91bGQgZ2VuZXJhdGUuICovXG52YXIgVGhpbmtpbmdMZXZlbDtcbihmdW5jdGlvbiAoVGhpbmtpbmdMZXZlbCkge1xuICAgIC8qKlxuICAgICAqIERlZmF1bHQgdmFsdWUuXG4gICAgICovXG4gICAgVGhpbmtpbmdMZXZlbFtcIlRISU5LSU5HX0xFVkVMX1VOU1BFQ0lGSUVEXCJdID0gXCJUSElOS0lOR19MRVZFTF9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIExvdyB0aGlua2luZyBsZXZlbC5cbiAgICAgKi9cbiAgICBUaGlua2luZ0xldmVsW1wiTE9XXCJdID0gXCJMT1dcIjtcbiAgICAvKipcbiAgICAgKiBIaWdoIHRoaW5raW5nIGxldmVsLlxuICAgICAqL1xuICAgIFRoaW5raW5nTGV2ZWxbXCJISUdIXCJdID0gXCJISUdIXCI7XG59KShUaGlua2luZ0xldmVsIHx8IChUaGlua2luZ0xldmVsID0ge30pKTtcbi8qKiBIYXJtIGNhdGVnb3J5LiAqL1xudmFyIEhhcm1DYXRlZ29yeTtcbihmdW5jdGlvbiAoSGFybUNhdGVnb3J5KSB7XG4gICAgLyoqXG4gICAgICogVGhlIGhhcm0gY2F0ZWdvcnkgaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgSGFybUNhdGVnb3J5W1wiSEFSTV9DQVRFR09SWV9VTlNQRUNJRklFRFwiXSA9IFwiSEFSTV9DQVRFR09SWV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGNhdGVnb3J5IGlzIGhhcmFzc21lbnQuXG4gICAgICovXG4gICAgSGFybUNhdGVnb3J5W1wiSEFSTV9DQVRFR09SWV9IQVJBU1NNRU5UXCJdID0gXCJIQVJNX0NBVEVHT1JZX0hBUkFTU01FTlRcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgaGFybSBjYXRlZ29yeSBpcyBoYXRlIHNwZWVjaC5cbiAgICAgKi9cbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX0hBVEVfU1BFRUNIXCJdID0gXCJIQVJNX0NBVEVHT1JZX0hBVEVfU1BFRUNIXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGhhcm0gY2F0ZWdvcnkgaXMgc2V4dWFsbHkgZXhwbGljaXQgY29udGVudC5cbiAgICAgKi9cbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX1NFWFVBTExZX0VYUExJQ0lUXCJdID0gXCJIQVJNX0NBVEVHT1JZX1NFWFVBTExZX0VYUExJQ0lUXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGhhcm0gY2F0ZWdvcnkgaXMgZGFuZ2Vyb3VzIGNvbnRlbnQuXG4gICAgICovXG4gICAgSGFybUNhdGVnb3J5W1wiSEFSTV9DQVRFR09SWV9EQU5HRVJPVVNfQ09OVEVOVFwiXSA9IFwiSEFSTV9DQVRFR09SWV9EQU5HRVJPVVNfQ09OVEVOVFwiO1xuICAgIC8qKlxuICAgICAqIERlcHJlY2F0ZWQ6IEVsZWN0aW9uIGZpbHRlciBpcyBub3QgbG9uZ2VyIHN1cHBvcnRlZC4gVGhlIGhhcm0gY2F0ZWdvcnkgaXMgY2l2aWMgaW50ZWdyaXR5LlxuICAgICAqL1xuICAgIEhhcm1DYXRlZ29yeVtcIkhBUk1fQ0FURUdPUllfQ0lWSUNfSU5URUdSSVRZXCJdID0gXCJIQVJNX0NBVEVHT1JZX0NJVklDX0lOVEVHUklUWVwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGNhdGVnb3J5IGlzIGltYWdlIGhhdGUuIFRoaXMgZW51bSB2YWx1ZSBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuXG4gICAgICovXG4gICAgSGFybUNhdGVnb3J5W1wiSEFSTV9DQVRFR09SWV9JTUFHRV9IQVRFXCJdID0gXCJIQVJNX0NBVEVHT1JZX0lNQUdFX0hBVEVcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgaGFybSBjYXRlZ29yeSBpcyBpbWFnZSBkYW5nZXJvdXMgY29udGVudC4gVGhpcyBlbnVtIHZhbHVlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS5cbiAgICAgKi9cbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX0lNQUdFX0RBTkdFUk9VU19DT05URU5UXCJdID0gXCJIQVJNX0NBVEVHT1JZX0lNQUdFX0RBTkdFUk9VU19DT05URU5UXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGhhcm0gY2F0ZWdvcnkgaXMgaW1hZ2UgaGFyYXNzbWVudC4gVGhpcyBlbnVtIHZhbHVlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS5cbiAgICAgKi9cbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX0lNQUdFX0hBUkFTU01FTlRcIl0gPSBcIkhBUk1fQ0FURUdPUllfSU1BR0VfSEFSQVNTTUVOVFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGNhdGVnb3J5IGlzIGltYWdlIHNleHVhbGx5IGV4cGxpY2l0IGNvbnRlbnQuIFRoaXMgZW51bSB2YWx1ZSBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuXG4gICAgICovXG4gICAgSGFybUNhdGVnb3J5W1wiSEFSTV9DQVRFR09SWV9JTUFHRV9TRVhVQUxMWV9FWFBMSUNJVFwiXSA9IFwiSEFSTV9DQVRFR09SWV9JTUFHRV9TRVhVQUxMWV9FWFBMSUNJVFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGNhdGVnb3J5IGlzIGZvciBqYWlsYnJlYWsgcHJvbXB0cy4gVGhpcyBlbnVtIHZhbHVlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS5cbiAgICAgKi9cbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX0pBSUxCUkVBS1wiXSA9IFwiSEFSTV9DQVRFR09SWV9KQUlMQlJFQUtcIjtcbn0pKEhhcm1DYXRlZ29yeSB8fCAoSGFybUNhdGVnb3J5ID0ge30pKTtcbi8qKiBTcGVjaWZ5IGlmIHRoZSB0aHJlc2hvbGQgaXMgdXNlZCBmb3IgcHJvYmFiaWxpdHkgb3Igc2V2ZXJpdHkgc2NvcmUuIElmIG5vdCBzcGVjaWZpZWQsIHRoZSB0aHJlc2hvbGQgaXMgdXNlZCBmb3IgcHJvYmFiaWxpdHkgc2NvcmUuIFRoaXMgZW51bSBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuICovXG52YXIgSGFybUJsb2NrTWV0aG9kO1xuKGZ1bmN0aW9uIChIYXJtQmxvY2tNZXRob2QpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgaGFybSBibG9jayBtZXRob2QgaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgSGFybUJsb2NrTWV0aG9kW1wiSEFSTV9CTE9DS19NRVRIT0RfVU5TUEVDSUZJRURcIl0gPSBcIkhBUk1fQkxPQ0tfTUVUSE9EX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGhhcm0gYmxvY2sgbWV0aG9kIHVzZXMgYm90aCBwcm9iYWJpbGl0eSBhbmQgc2V2ZXJpdHkgc2NvcmVzLlxuICAgICAqL1xuICAgIEhhcm1CbG9ja01ldGhvZFtcIlNFVkVSSVRZXCJdID0gXCJTRVZFUklUWVwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGJsb2NrIG1ldGhvZCB1c2VzIHRoZSBwcm9iYWJpbGl0eSBzY29yZS5cbiAgICAgKi9cbiAgICBIYXJtQmxvY2tNZXRob2RbXCJQUk9CQUJJTElUWVwiXSA9IFwiUFJPQkFCSUxJVFlcIjtcbn0pKEhhcm1CbG9ja01ldGhvZCB8fCAoSGFybUJsb2NrTWV0aG9kID0ge30pKTtcbi8qKiBUaGUgaGFybSBibG9jayB0aHJlc2hvbGQuICovXG52YXIgSGFybUJsb2NrVGhyZXNob2xkO1xuKGZ1bmN0aW9uIChIYXJtQmxvY2tUaHJlc2hvbGQpIHtcbiAgICAvKipcbiAgICAgKiBVbnNwZWNpZmllZCBoYXJtIGJsb2NrIHRocmVzaG9sZC5cbiAgICAgKi9cbiAgICBIYXJtQmxvY2tUaHJlc2hvbGRbXCJIQVJNX0JMT0NLX1RIUkVTSE9MRF9VTlNQRUNJRklFRFwiXSA9IFwiSEFSTV9CTE9DS19USFJFU0hPTERfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBCbG9jayBsb3cgdGhyZXNob2xkIGFuZCBhYm92ZSAoaS5lLiBibG9jayBtb3JlKS5cbiAgICAgKi9cbiAgICBIYXJtQmxvY2tUaHJlc2hvbGRbXCJCTE9DS19MT1dfQU5EX0FCT1ZFXCJdID0gXCJCTE9DS19MT1dfQU5EX0FCT1ZFXCI7XG4gICAgLyoqXG4gICAgICogQmxvY2sgbWVkaXVtIHRocmVzaG9sZCBhbmQgYWJvdmUuXG4gICAgICovXG4gICAgSGFybUJsb2NrVGhyZXNob2xkW1wiQkxPQ0tfTUVESVVNX0FORF9BQk9WRVwiXSA9IFwiQkxPQ0tfTUVESVVNX0FORF9BQk9WRVwiO1xuICAgIC8qKlxuICAgICAqIEJsb2NrIG9ubHkgaGlnaCB0aHJlc2hvbGQgKGkuZS4gYmxvY2sgbGVzcykuXG4gICAgICovXG4gICAgSGFybUJsb2NrVGhyZXNob2xkW1wiQkxPQ0tfT05MWV9ISUdIXCJdID0gXCJCTE9DS19PTkxZX0hJR0hcIjtcbiAgICAvKipcbiAgICAgKiBCbG9jayBub25lLlxuICAgICAqL1xuICAgIEhhcm1CbG9ja1RocmVzaG9sZFtcIkJMT0NLX05PTkVcIl0gPSBcIkJMT0NLX05PTkVcIjtcbiAgICAvKipcbiAgICAgKiBUdXJuIG9mZiB0aGUgc2FmZXR5IGZpbHRlci5cbiAgICAgKi9cbiAgICBIYXJtQmxvY2tUaHJlc2hvbGRbXCJPRkZcIl0gPSBcIk9GRlwiO1xufSkoSGFybUJsb2NrVGhyZXNob2xkIHx8IChIYXJtQmxvY2tUaHJlc2hvbGQgPSB7fSkpO1xuLyoqIE91dHB1dCBvbmx5LiBUaGUgcmVhc29uIHdoeSB0aGUgbW9kZWwgc3RvcHBlZCBnZW5lcmF0aW5nIHRva2Vucy5cblxuSWYgZW1wdHksIHRoZSBtb2RlbCBoYXMgbm90IHN0b3BwZWQgZ2VuZXJhdGluZyB0aGUgdG9rZW5zLiAqL1xudmFyIEZpbmlzaFJlYXNvbjtcbihmdW5jdGlvbiAoRmluaXNoUmVhc29uKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGZpbmlzaCByZWFzb24gaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiRklOSVNIX1JFQVNPTl9VTlNQRUNJRklFRFwiXSA9IFwiRklOSVNIX1JFQVNPTl9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFRva2VuIGdlbmVyYXRpb24gcmVhY2hlZCBhIG5hdHVyYWwgc3RvcHBpbmcgcG9pbnQgb3IgYSBjb25maWd1cmVkIHN0b3Agc2VxdWVuY2UuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiU1RPUFwiXSA9IFwiU1RPUFwiO1xuICAgIC8qKlxuICAgICAqIFRva2VuIGdlbmVyYXRpb24gcmVhY2hlZCB0aGUgY29uZmlndXJlZCBtYXhpbXVtIG91dHB1dCB0b2tlbnMuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiTUFYX1RPS0VOU1wiXSA9IFwiTUFYX1RPS0VOU1wiO1xuICAgIC8qKlxuICAgICAqIFRva2VuIGdlbmVyYXRpb24gc3RvcHBlZCBiZWNhdXNlIHRoZSBjb250ZW50IHBvdGVudGlhbGx5IGNvbnRhaW5zIHNhZmV0eSB2aW9sYXRpb25zLiBOT1RFOiBXaGVuIHN0cmVhbWluZywgW2NvbnRlbnRdW10gaXMgZW1wdHkgaWYgY29udGVudCBmaWx0ZXJzIGJsb2NrcyB0aGUgb3V0cHV0LlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIlNBRkVUWVwiXSA9IFwiU0FGRVRZXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHRva2VuIGdlbmVyYXRpb24gc3RvcHBlZCBiZWNhdXNlIG9mIHBvdGVudGlhbCByZWNpdGF0aW9uLlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIlJFQ0lUQVRJT05cIl0gPSBcIlJFQ0lUQVRJT05cIjtcbiAgICAvKipcbiAgICAgKiBUaGUgdG9rZW4gZ2VuZXJhdGlvbiBzdG9wcGVkIGJlY2F1c2Ugb2YgdXNpbmcgYW4gdW5zdXBwb3J0ZWQgbGFuZ3VhZ2UuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiTEFOR1VBR0VcIl0gPSBcIkxBTkdVQUdFXCI7XG4gICAgLyoqXG4gICAgICogQWxsIG90aGVyIHJlYXNvbnMgdGhhdCBzdG9wcGVkIHRoZSB0b2tlbiBnZW5lcmF0aW9uLlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIk9USEVSXCJdID0gXCJPVEhFUlwiO1xuICAgIC8qKlxuICAgICAqIFRva2VuIGdlbmVyYXRpb24gc3RvcHBlZCBiZWNhdXNlIHRoZSBjb250ZW50IGNvbnRhaW5zIGZvcmJpZGRlbiB0ZXJtcy5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJCTE9DS0xJU1RcIl0gPSBcIkJMT0NLTElTVFwiO1xuICAgIC8qKlxuICAgICAqIFRva2VuIGdlbmVyYXRpb24gc3RvcHBlZCBmb3IgcG90ZW50aWFsbHkgY29udGFpbmluZyBwcm9oaWJpdGVkIGNvbnRlbnQuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiUFJPSElCSVRFRF9DT05URU5UXCJdID0gXCJQUk9ISUJJVEVEX0NPTlRFTlRcIjtcbiAgICAvKipcbiAgICAgKiBUb2tlbiBnZW5lcmF0aW9uIHN0b3BwZWQgYmVjYXVzZSB0aGUgY29udGVudCBwb3RlbnRpYWxseSBjb250YWlucyBTZW5zaXRpdmUgUGVyc29uYWxseSBJZGVudGlmaWFibGUgSW5mb3JtYXRpb24gKFNQSUkpLlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIlNQSUlcIl0gPSBcIlNQSUlcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgZnVuY3Rpb24gY2FsbCBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsIGlzIGludmFsaWQuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiTUFMRk9STUVEX0ZVTkNUSU9OX0NBTExcIl0gPSBcIk1BTEZPUk1FRF9GVU5DVElPTl9DQUxMXCI7XG4gICAgLyoqXG4gICAgICogVG9rZW4gZ2VuZXJhdGlvbiBzdG9wcGVkIGJlY2F1c2UgZ2VuZXJhdGVkIGltYWdlcyBoYXZlIHNhZmV0eSB2aW9sYXRpb25zLlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIklNQUdFX1NBRkVUWVwiXSA9IFwiSU1BR0VfU0FGRVRZXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHRvb2wgY2FsbCBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsIGlzIGludmFsaWQuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiVU5FWFBFQ1RFRF9UT09MX0NBTExcIl0gPSBcIlVORVhQRUNURURfVE9PTF9DQUxMXCI7XG4gICAgLyoqXG4gICAgICogSW1hZ2UgZ2VuZXJhdGlvbiBzdG9wcGVkIGJlY2F1c2UgdGhlIGdlbmVyYXRlZCBpbWFnZXMgaGF2ZSBwcm9oaWJpdGVkIGNvbnRlbnQuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiSU1BR0VfUFJPSElCSVRFRF9DT05URU5UXCJdID0gXCJJTUFHRV9QUk9ISUJJVEVEX0NPTlRFTlRcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgbW9kZWwgd2FzIGV4cGVjdGVkIHRvIGdlbmVyYXRlIGFuIGltYWdlLCBidXQgbm9uZSB3YXMgZ2VuZXJhdGVkLlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIk5PX0lNQUdFXCJdID0gXCJOT19JTUFHRVwiO1xufSkoRmluaXNoUmVhc29uIHx8IChGaW5pc2hSZWFzb24gPSB7fSkpO1xuLyoqIE91dHB1dCBvbmx5LiBIYXJtIHByb2JhYmlsaXR5IGxldmVscyBpbiB0aGUgY29udGVudC4gKi9cbnZhciBIYXJtUHJvYmFiaWxpdHk7XG4oZnVuY3Rpb24gKEhhcm1Qcm9iYWJpbGl0eSkge1xuICAgIC8qKlxuICAgICAqIEhhcm0gcHJvYmFiaWxpdHkgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgSGFybVByb2JhYmlsaXR5W1wiSEFSTV9QUk9CQUJJTElUWV9VTlNQRUNJRklFRFwiXSA9IFwiSEFSTV9QUk9CQUJJTElUWV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIE5lZ2xpZ2libGUgbGV2ZWwgb2YgaGFybS5cbiAgICAgKi9cbiAgICBIYXJtUHJvYmFiaWxpdHlbXCJORUdMSUdJQkxFXCJdID0gXCJORUdMSUdJQkxFXCI7XG4gICAgLyoqXG4gICAgICogTG93IGxldmVsIG9mIGhhcm0uXG4gICAgICovXG4gICAgSGFybVByb2JhYmlsaXR5W1wiTE9XXCJdID0gXCJMT1dcIjtcbiAgICAvKipcbiAgICAgKiBNZWRpdW0gbGV2ZWwgb2YgaGFybS5cbiAgICAgKi9cbiAgICBIYXJtUHJvYmFiaWxpdHlbXCJNRURJVU1cIl0gPSBcIk1FRElVTVwiO1xuICAgIC8qKlxuICAgICAqIEhpZ2ggbGV2ZWwgb2YgaGFybS5cbiAgICAgKi9cbiAgICBIYXJtUHJvYmFiaWxpdHlbXCJISUdIXCJdID0gXCJISUdIXCI7XG59KShIYXJtUHJvYmFiaWxpdHkgfHwgKEhhcm1Qcm9iYWJpbGl0eSA9IHt9KSk7XG4vKiogT3V0cHV0IG9ubHkuIEhhcm0gc2V2ZXJpdHkgbGV2ZWxzIGluIHRoZSBjb250ZW50LiBUaGlzIGVudW0gaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLiAqL1xudmFyIEhhcm1TZXZlcml0eTtcbihmdW5jdGlvbiAoSGFybVNldmVyaXR5KSB7XG4gICAgLyoqXG4gICAgICogSGFybSBzZXZlcml0eSB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBIYXJtU2V2ZXJpdHlbXCJIQVJNX1NFVkVSSVRZX1VOU1BFQ0lGSUVEXCJdID0gXCJIQVJNX1NFVkVSSVRZX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogTmVnbGlnaWJsZSBsZXZlbCBvZiBoYXJtIHNldmVyaXR5LlxuICAgICAqL1xuICAgIEhhcm1TZXZlcml0eVtcIkhBUk1fU0VWRVJJVFlfTkVHTElHSUJMRVwiXSA9IFwiSEFSTV9TRVZFUklUWV9ORUdMSUdJQkxFXCI7XG4gICAgLyoqXG4gICAgICogTG93IGxldmVsIG9mIGhhcm0gc2V2ZXJpdHkuXG4gICAgICovXG4gICAgSGFybVNldmVyaXR5W1wiSEFSTV9TRVZFUklUWV9MT1dcIl0gPSBcIkhBUk1fU0VWRVJJVFlfTE9XXCI7XG4gICAgLyoqXG4gICAgICogTWVkaXVtIGxldmVsIG9mIGhhcm0gc2V2ZXJpdHkuXG4gICAgICovXG4gICAgSGFybVNldmVyaXR5W1wiSEFSTV9TRVZFUklUWV9NRURJVU1cIl0gPSBcIkhBUk1fU0VWRVJJVFlfTUVESVVNXCI7XG4gICAgLyoqXG4gICAgICogSGlnaCBsZXZlbCBvZiBoYXJtIHNldmVyaXR5LlxuICAgICAqL1xuICAgIEhhcm1TZXZlcml0eVtcIkhBUk1fU0VWRVJJVFlfSElHSFwiXSA9IFwiSEFSTV9TRVZFUklUWV9ISUdIXCI7XG59KShIYXJtU2V2ZXJpdHkgfHwgKEhhcm1TZXZlcml0eSA9IHt9KSk7XG4vKiogU3RhdHVzIG9mIHRoZSB1cmwgcmV0cmlldmFsLiAqL1xudmFyIFVybFJldHJpZXZhbFN0YXR1cztcbihmdW5jdGlvbiAoVXJsUmV0cmlldmFsU3RhdHVzKSB7XG4gICAgLyoqXG4gICAgICogRGVmYXVsdCB2YWx1ZS4gVGhpcyB2YWx1ZSBpcyB1bnVzZWQuXG4gICAgICovXG4gICAgVXJsUmV0cmlldmFsU3RhdHVzW1wiVVJMX1JFVFJJRVZBTF9TVEFUVVNfVU5TUEVDSUZJRURcIl0gPSBcIlVSTF9SRVRSSUVWQUxfU1RBVFVTX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogVXJsIHJldHJpZXZhbCBpcyBzdWNjZXNzZnVsLlxuICAgICAqL1xuICAgIFVybFJldHJpZXZhbFN0YXR1c1tcIlVSTF9SRVRSSUVWQUxfU1RBVFVTX1NVQ0NFU1NcIl0gPSBcIlVSTF9SRVRSSUVWQUxfU1RBVFVTX1NVQ0NFU1NcIjtcbiAgICAvKipcbiAgICAgKiBVcmwgcmV0cmlldmFsIGlzIGZhaWxlZCBkdWUgdG8gZXJyb3IuXG4gICAgICovXG4gICAgVXJsUmV0cmlldmFsU3RhdHVzW1wiVVJMX1JFVFJJRVZBTF9TVEFUVVNfRVJST1JcIl0gPSBcIlVSTF9SRVRSSUVWQUxfU1RBVFVTX0VSUk9SXCI7XG4gICAgLyoqXG4gICAgICogVXJsIHJldHJpZXZhbCBpcyBmYWlsZWQgYmVjYXVzZSB0aGUgY29udGVudCBpcyBiZWhpbmQgcGF5d2FsbC4gVGhpcyBlbnVtIHZhbHVlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLlxuICAgICAqL1xuICAgIFVybFJldHJpZXZhbFN0YXR1c1tcIlVSTF9SRVRSSUVWQUxfU1RBVFVTX1BBWVdBTExcIl0gPSBcIlVSTF9SRVRSSUVWQUxfU1RBVFVTX1BBWVdBTExcIjtcbiAgICAvKipcbiAgICAgKiBVcmwgcmV0cmlldmFsIGlzIGZhaWxlZCBiZWNhdXNlIHRoZSBjb250ZW50IGlzIHVuc2FmZS4gVGhpcyBlbnVtIHZhbHVlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLlxuICAgICAqL1xuICAgIFVybFJldHJpZXZhbFN0YXR1c1tcIlVSTF9SRVRSSUVWQUxfU1RBVFVTX1VOU0FGRVwiXSA9IFwiVVJMX1JFVFJJRVZBTF9TVEFUVVNfVU5TQUZFXCI7XG59KShVcmxSZXRyaWV2YWxTdGF0dXMgfHwgKFVybFJldHJpZXZhbFN0YXR1cyA9IHt9KSk7XG4vKiogT3V0cHV0IG9ubHkuIFRoZSByZWFzb24gd2h5IHRoZSBwcm9tcHQgd2FzIGJsb2NrZWQuICovXG52YXIgQmxvY2tlZFJlYXNvbjtcbihmdW5jdGlvbiAoQmxvY2tlZFJlYXNvbikge1xuICAgIC8qKlxuICAgICAqIFRoZSBibG9ja2VkIHJlYXNvbiBpcyB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBCbG9ja2VkUmVhc29uW1wiQkxPQ0tFRF9SRUFTT05fVU5TUEVDSUZJRURcIl0gPSBcIkJMT0NLRURfUkVBU09OX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHByb21wdCB3YXMgYmxvY2tlZCBmb3Igc2FmZXR5IHJlYXNvbnMuXG4gICAgICovXG4gICAgQmxvY2tlZFJlYXNvbltcIlNBRkVUWVwiXSA9IFwiU0FGRVRZXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHByb21wdCB3YXMgYmxvY2tlZCBmb3Igb3RoZXIgcmVhc29ucy4gRm9yIGV4YW1wbGUsIGl0IG1heSBiZSBkdWUgdG8gdGhlIHByb21wdCdzIGxhbmd1YWdlLCBvciBiZWNhdXNlIGl0IGNvbnRhaW5zIG90aGVyIGhhcm1mdWwgY29udGVudC5cbiAgICAgKi9cbiAgICBCbG9ja2VkUmVhc29uW1wiT1RIRVJcIl0gPSBcIk9USEVSXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHByb21wdCB3YXMgYmxvY2tlZCBiZWNhdXNlIGl0IGNvbnRhaW5zIGEgdGVybSBmcm9tIHRoZSB0ZXJtaW5vbG9neSBibG9ja2xpc3QuXG4gICAgICovXG4gICAgQmxvY2tlZFJlYXNvbltcIkJMT0NLTElTVFwiXSA9IFwiQkxPQ0tMSVNUXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHByb21wdCB3YXMgYmxvY2tlZCBiZWNhdXNlIGl0IGNvbnRhaW5zIHByb2hpYml0ZWQgY29udGVudC5cbiAgICAgKi9cbiAgICBCbG9ja2VkUmVhc29uW1wiUFJPSElCSVRFRF9DT05URU5UXCJdID0gXCJQUk9ISUJJVEVEX0NPTlRFTlRcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJvbXB0IHdhcyBibG9ja2VkIGJlY2F1c2UgaXQgY29udGFpbnMgY29udGVudCB0aGF0IGlzIHVuc2FmZSBmb3IgaW1hZ2UgZ2VuZXJhdGlvbi5cbiAgICAgKi9cbiAgICBCbG9ja2VkUmVhc29uW1wiSU1BR0VfU0FGRVRZXCJdID0gXCJJTUFHRV9TQUZFVFlcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJvbXB0IHdhcyBibG9ja2VkIGJ5IE1vZGVsIEFybW9yLiBUaGlzIGVudW0gdmFsdWUgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLlxuICAgICAqL1xuICAgIEJsb2NrZWRSZWFzb25bXCJNT0RFTF9BUk1PUlwiXSA9IFwiTU9ERUxfQVJNT1JcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJvbXB0IHdhcyBibG9ja2VkIGFzIGEgamFpbGJyZWFrIGF0dGVtcHQuIFRoaXMgZW51bSB2YWx1ZSBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuXG4gICAgICovXG4gICAgQmxvY2tlZFJlYXNvbltcIkpBSUxCUkVBS1wiXSA9IFwiSkFJTEJSRUFLXCI7XG59KShCbG9ja2VkUmVhc29uIHx8IChCbG9ja2VkUmVhc29uID0ge30pKTtcbi8qKiBPdXRwdXQgb25seS4gVGhlIHRyYWZmaWMgdHlwZSBmb3IgdGhpcyByZXF1ZXN0LiBUaGlzIGVudW0gaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLiAqL1xudmFyIFRyYWZmaWNUeXBlO1xuKGZ1bmN0aW9uIChUcmFmZmljVHlwZSkge1xuICAgIC8qKlxuICAgICAqIFVuc3BlY2lmaWVkIHJlcXVlc3QgdHJhZmZpYyB0eXBlLlxuICAgICAqL1xuICAgIFRyYWZmaWNUeXBlW1wiVFJBRkZJQ19UWVBFX1VOU1BFQ0lGSUVEXCJdID0gXCJUUkFGRklDX1RZUEVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgcmVxdWVzdCB3YXMgcHJvY2Vzc2VkIHVzaW5nIFBheS1Bcy1Zb3UtR28gcXVvdGEuXG4gICAgICovXG4gICAgVHJhZmZpY1R5cGVbXCJPTl9ERU1BTkRcIl0gPSBcIk9OX0RFTUFORFwiO1xuICAgIC8qKlxuICAgICAqIFR5cGUgZm9yIFByb3Zpc2lvbmVkIFRocm91Z2hwdXQgdHJhZmZpYy5cbiAgICAgKi9cbiAgICBUcmFmZmljVHlwZVtcIlBST1ZJU0lPTkVEX1RIUk9VR0hQVVRcIl0gPSBcIlBST1ZJU0lPTkVEX1RIUk9VR0hQVVRcIjtcbn0pKFRyYWZmaWNUeXBlIHx8IChUcmFmZmljVHlwZSA9IHt9KSk7XG4vKiogU2VydmVyIGNvbnRlbnQgbW9kYWxpdGllcy4gKi9cbnZhciBNb2RhbGl0eTtcbihmdW5jdGlvbiAoTW9kYWxpdHkpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbW9kYWxpdHkgaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgTW9kYWxpdHlbXCJNT0RBTElUWV9VTlNQRUNJRklFRFwiXSA9IFwiTU9EQUxJVFlfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhlIG1vZGVsIHNob3VsZCByZXR1cm4gdGV4dFxuICAgICAqL1xuICAgIE1vZGFsaXR5W1wiVEVYVFwiXSA9IFwiVEVYVFwiO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGUgbW9kZWwgc2hvdWxkIHJldHVybiBpbWFnZXMuXG4gICAgICovXG4gICAgTW9kYWxpdHlbXCJJTUFHRVwiXSA9IFwiSU1BR0VcIjtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhlIG1vZGVsIHNob3VsZCByZXR1cm4gYXVkaW8uXG4gICAgICovXG4gICAgTW9kYWxpdHlbXCJBVURJT1wiXSA9IFwiQVVESU9cIjtcbn0pKE1vZGFsaXR5IHx8IChNb2RhbGl0eSA9IHt9KSk7XG4vKiogVGhlIG1lZGlhIHJlc29sdXRpb24gdG8gdXNlLiAqL1xudmFyIE1lZGlhUmVzb2x1dGlvbjtcbihmdW5jdGlvbiAoTWVkaWFSZXNvbHV0aW9uKSB7XG4gICAgLyoqXG4gICAgICogTWVkaWEgcmVzb2x1dGlvbiBoYXMgbm90IGJlZW4gc2V0XG4gICAgICovXG4gICAgTWVkaWFSZXNvbHV0aW9uW1wiTUVESUFfUkVTT0xVVElPTl9VTlNQRUNJRklFRFwiXSA9IFwiTUVESUFfUkVTT0xVVElPTl9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIE1lZGlhIHJlc29sdXRpb24gc2V0IHRvIGxvdyAoNjQgdG9rZW5zKS5cbiAgICAgKi9cbiAgICBNZWRpYVJlc29sdXRpb25bXCJNRURJQV9SRVNPTFVUSU9OX0xPV1wiXSA9IFwiTUVESUFfUkVTT0xVVElPTl9MT1dcIjtcbiAgICAvKipcbiAgICAgKiBNZWRpYSByZXNvbHV0aW9uIHNldCB0byBtZWRpdW0gKDI1NiB0b2tlbnMpLlxuICAgICAqL1xuICAgIE1lZGlhUmVzb2x1dGlvbltcIk1FRElBX1JFU09MVVRJT05fTUVESVVNXCJdID0gXCJNRURJQV9SRVNPTFVUSU9OX01FRElVTVwiO1xuICAgIC8qKlxuICAgICAqIE1lZGlhIHJlc29sdXRpb24gc2V0IHRvIGhpZ2ggKHpvb21lZCByZWZyYW1pbmcgd2l0aCAyNTYgdG9rZW5zKS5cbiAgICAgKi9cbiAgICBNZWRpYVJlc29sdXRpb25bXCJNRURJQV9SRVNPTFVUSU9OX0hJR0hcIl0gPSBcIk1FRElBX1JFU09MVVRJT05fSElHSFwiO1xufSkoTWVkaWFSZXNvbHV0aW9uIHx8IChNZWRpYVJlc29sdXRpb24gPSB7fSkpO1xuLyoqIFR1bmluZyBtb2RlLiBUaGlzIGVudW0gaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLiAqL1xudmFyIFR1bmluZ01vZGU7XG4oZnVuY3Rpb24gKFR1bmluZ01vZGUpIHtcbiAgICAvKipcbiAgICAgKiBUdW5pbmcgbW9kZSBpcyB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBUdW5pbmdNb2RlW1wiVFVOSU5HX01PREVfVU5TUEVDSUZJRURcIl0gPSBcIlRVTklOR19NT0RFX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogRnVsbCBmaW5lLXR1bmluZyBtb2RlLlxuICAgICAqL1xuICAgIFR1bmluZ01vZGVbXCJUVU5JTkdfTU9ERV9GVUxMXCJdID0gXCJUVU5JTkdfTU9ERV9GVUxMXCI7XG4gICAgLyoqXG4gICAgICogUEVGVCBhZGFwdGVyIHR1bmluZyBtb2RlLlxuICAgICAqL1xuICAgIFR1bmluZ01vZGVbXCJUVU5JTkdfTU9ERV9QRUZUX0FEQVBURVJcIl0gPSBcIlRVTklOR19NT0RFX1BFRlRfQURBUFRFUlwiO1xufSkoVHVuaW5nTW9kZSB8fCAoVHVuaW5nTW9kZSA9IHt9KSk7XG4vKiogQWRhcHRlciBzaXplIGZvciB0dW5pbmcuIFRoaXMgZW51bSBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuICovXG52YXIgQWRhcHRlclNpemU7XG4oZnVuY3Rpb24gKEFkYXB0ZXJTaXplKSB7XG4gICAgLyoqXG4gICAgICogQWRhcHRlciBzaXplIGlzIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIEFkYXB0ZXJTaXplW1wiQURBUFRFUl9TSVpFX1VOU1BFQ0lGSUVEXCJdID0gXCJBREFQVEVSX1NJWkVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBBZGFwdGVyIHNpemUgMS5cbiAgICAgKi9cbiAgICBBZGFwdGVyU2l6ZVtcIkFEQVBURVJfU0laRV9PTkVcIl0gPSBcIkFEQVBURVJfU0laRV9PTkVcIjtcbiAgICAvKipcbiAgICAgKiBBZGFwdGVyIHNpemUgMi5cbiAgICAgKi9cbiAgICBBZGFwdGVyU2l6ZVtcIkFEQVBURVJfU0laRV9UV09cIl0gPSBcIkFEQVBURVJfU0laRV9UV09cIjtcbiAgICAvKipcbiAgICAgKiBBZGFwdGVyIHNpemUgNC5cbiAgICAgKi9cbiAgICBBZGFwdGVyU2l6ZVtcIkFEQVBURVJfU0laRV9GT1VSXCJdID0gXCJBREFQVEVSX1NJWkVfRk9VUlwiO1xuICAgIC8qKlxuICAgICAqIEFkYXB0ZXIgc2l6ZSA4LlxuICAgICAqL1xuICAgIEFkYXB0ZXJTaXplW1wiQURBUFRFUl9TSVpFX0VJR0hUXCJdID0gXCJBREFQVEVSX1NJWkVfRUlHSFRcIjtcbiAgICAvKipcbiAgICAgKiBBZGFwdGVyIHNpemUgMTYuXG4gICAgICovXG4gICAgQWRhcHRlclNpemVbXCJBREFQVEVSX1NJWkVfU0lYVEVFTlwiXSA9IFwiQURBUFRFUl9TSVpFX1NJWFRFRU5cIjtcbiAgICAvKipcbiAgICAgKiBBZGFwdGVyIHNpemUgMzIuXG4gICAgICovXG4gICAgQWRhcHRlclNpemVbXCJBREFQVEVSX1NJWkVfVEhJUlRZX1RXT1wiXSA9IFwiQURBUFRFUl9TSVpFX1RISVJUWV9UV09cIjtcbn0pKEFkYXB0ZXJTaXplIHx8IChBZGFwdGVyU2l6ZSA9IHt9KSk7XG4vKiogSm9iIHN0YXRlLiAqL1xudmFyIEpvYlN0YXRlO1xuKGZ1bmN0aW9uIChKb2JTdGF0ZSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBqb2Igc3RhdGUgaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgSm9iU3RhdGVbXCJKT0JfU1RBVEVfVU5TUEVDSUZJRURcIl0gPSBcIkpPQl9TVEFURV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBqb2IgaGFzIGJlZW4ganVzdCBjcmVhdGVkIG9yIHJlc3VtZWQgYW5kIHByb2Nlc3NpbmcgaGFzIG5vdCB5ZXQgYmVndW4uXG4gICAgICovXG4gICAgSm9iU3RhdGVbXCJKT0JfU1RBVEVfUVVFVUVEXCJdID0gXCJKT0JfU1RBVEVfUVVFVUVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHNlcnZpY2UgaXMgcHJlcGFyaW5nIHRvIHJ1biB0aGUgam9iLlxuICAgICAqL1xuICAgIEpvYlN0YXRlW1wiSk9CX1NUQVRFX1BFTkRJTkdcIl0gPSBcIkpPQl9TVEFURV9QRU5ESU5HXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGpvYiBpcyBpbiBwcm9ncmVzcy5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9SVU5OSU5HXCJdID0gXCJKT0JfU1RBVEVfUlVOTklOR1wiO1xuICAgIC8qKlxuICAgICAqIFRoZSBqb2IgY29tcGxldGVkIHN1Y2Nlc3NmdWxseS5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9TVUNDRUVERURcIl0gPSBcIkpPQl9TVEFURV9TVUNDRUVERURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIGZhaWxlZC5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9GQUlMRURcIl0gPSBcIkpPQl9TVEFURV9GQUlMRURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIGlzIGJlaW5nIGNhbmNlbGxlZC4gRnJvbSB0aGlzIHN0YXRlIHRoZSBqb2IgbWF5IG9ubHkgZ28gdG8gZWl0aGVyIGBKT0JfU1RBVEVfU1VDQ0VFREVEYCwgYEpPQl9TVEFURV9GQUlMRURgIG9yIGBKT0JfU1RBVEVfQ0FOQ0VMTEVEYC5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9DQU5DRUxMSU5HXCJdID0gXCJKT0JfU1RBVEVfQ0FOQ0VMTElOR1wiO1xuICAgIC8qKlxuICAgICAqIFRoZSBqb2IgaGFzIGJlZW4gY2FuY2VsbGVkLlxuICAgICAqL1xuICAgIEpvYlN0YXRlW1wiSk9CX1NUQVRFX0NBTkNFTExFRFwiXSA9IFwiSk9CX1NUQVRFX0NBTkNFTExFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBqb2IgaGFzIGJlZW4gc3RvcHBlZCwgYW5kIGNhbiBiZSByZXN1bWVkLlxuICAgICAqL1xuICAgIEpvYlN0YXRlW1wiSk9CX1NUQVRFX1BBVVNFRFwiXSA9IFwiSk9CX1NUQVRFX1BBVVNFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBqb2IgaGFzIGV4cGlyZWQuXG4gICAgICovXG4gICAgSm9iU3RhdGVbXCJKT0JfU1RBVEVfRVhQSVJFRFwiXSA9IFwiSk9CX1NUQVRFX0VYUElSRURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIGlzIGJlaW5nIHVwZGF0ZWQuIE9ubHkgam9icyBpbiB0aGUgYEpPQl9TVEFURV9SVU5OSU5HYCBzdGF0ZSBjYW4gYmUgdXBkYXRlZC4gQWZ0ZXIgdXBkYXRpbmcsIHRoZSBqb2IgZ29lcyBiYWNrIHRvIHRoZSBgSk9CX1NUQVRFX1JVTk5JTkdgIHN0YXRlLlxuICAgICAqL1xuICAgIEpvYlN0YXRlW1wiSk9CX1NUQVRFX1VQREFUSU5HXCJdID0gXCJKT0JfU1RBVEVfVVBEQVRJTkdcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIGlzIHBhcnRpYWxseSBzdWNjZWVkZWQsIHNvbWUgcmVzdWx0cyBtYXkgYmUgbWlzc2luZyBkdWUgdG8gZXJyb3JzLlxuICAgICAqL1xuICAgIEpvYlN0YXRlW1wiSk9CX1NUQVRFX1BBUlRJQUxMWV9TVUNDRUVERURcIl0gPSBcIkpPQl9TVEFURV9QQVJUSUFMTFlfU1VDQ0VFREVEXCI7XG59KShKb2JTdGF0ZSB8fCAoSm9iU3RhdGUgPSB7fSkpO1xuLyoqIFRoZSB0dW5pbmcgdGFzay4gRWl0aGVyIEkyViBvciBUMlYuIFRoaXMgZW51bSBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuICovXG52YXIgVHVuaW5nVGFzaztcbihmdW5jdGlvbiAoVHVuaW5nVGFzaykge1xuICAgIC8qKlxuICAgICAqIERlZmF1bHQgdmFsdWUuIFRoaXMgdmFsdWUgaXMgdW51c2VkLlxuICAgICAqL1xuICAgIFR1bmluZ1Rhc2tbXCJUVU5JTkdfVEFTS19VTlNQRUNJRklFRFwiXSA9IFwiVFVOSU5HX1RBU0tfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBUdW5pbmcgdGFzayBmb3IgaW1hZ2UgdG8gdmlkZW8uXG4gICAgICovXG4gICAgVHVuaW5nVGFza1tcIlRVTklOR19UQVNLX0kyVlwiXSA9IFwiVFVOSU5HX1RBU0tfSTJWXCI7XG4gICAgLyoqXG4gICAgICogVHVuaW5nIHRhc2sgZm9yIHRleHQgdG8gdmlkZW8uXG4gICAgICovXG4gICAgVHVuaW5nVGFza1tcIlRVTklOR19UQVNLX1QyVlwiXSA9IFwiVFVOSU5HX1RBU0tfVDJWXCI7XG4gICAgLyoqXG4gICAgICogVHVuaW5nIHRhc2sgZm9yIHJlZmVyZW5jZSB0byB2aWRlby5cbiAgICAgKi9cbiAgICBUdW5pbmdUYXNrW1wiVFVOSU5HX1RBU0tfUjJWXCJdID0gXCJUVU5JTkdfVEFTS19SMlZcIjtcbn0pKFR1bmluZ1Rhc2sgfHwgKFR1bmluZ1Rhc2sgPSB7fSkpO1xuLyoqIFRoZSB0b2tlbml6YXRpb24gcXVhbGl0eSB1c2VkIGZvciBnaXZlbiBtZWRpYS4gKi9cbnZhciBQYXJ0TWVkaWFSZXNvbHV0aW9uTGV2ZWw7XG4oZnVuY3Rpb24gKFBhcnRNZWRpYVJlc29sdXRpb25MZXZlbCkge1xuICAgIC8qKlxuICAgICAqIE1lZGlhIHJlc29sdXRpb24gaGFzIG5vdCBiZWVuIHNldC5cbiAgICAgKi9cbiAgICBQYXJ0TWVkaWFSZXNvbHV0aW9uTGV2ZWxbXCJNRURJQV9SRVNPTFVUSU9OX1VOU1BFQ0lGSUVEXCJdID0gXCJNRURJQV9SRVNPTFVUSU9OX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogTWVkaWEgcmVzb2x1dGlvbiBzZXQgdG8gbG93LlxuICAgICAqL1xuICAgIFBhcnRNZWRpYVJlc29sdXRpb25MZXZlbFtcIk1FRElBX1JFU09MVVRJT05fTE9XXCJdID0gXCJNRURJQV9SRVNPTFVUSU9OX0xPV1wiO1xuICAgIC8qKlxuICAgICAqIE1lZGlhIHJlc29sdXRpb24gc2V0IHRvIG1lZGl1bS5cbiAgICAgKi9cbiAgICBQYXJ0TWVkaWFSZXNvbHV0aW9uTGV2ZWxbXCJNRURJQV9SRVNPTFVUSU9OX01FRElVTVwiXSA9IFwiTUVESUFfUkVTT0xVVElPTl9NRURJVU1cIjtcbiAgICAvKipcbiAgICAgKiBNZWRpYSByZXNvbHV0aW9uIHNldCB0byBoaWdoLlxuICAgICAqL1xuICAgIFBhcnRNZWRpYVJlc29sdXRpb25MZXZlbFtcIk1FRElBX1JFU09MVVRJT05fSElHSFwiXSA9IFwiTUVESUFfUkVTT0xVVElPTl9ISUdIXCI7XG59KShQYXJ0TWVkaWFSZXNvbHV0aW9uTGV2ZWwgfHwgKFBhcnRNZWRpYVJlc29sdXRpb25MZXZlbCA9IHt9KSk7XG4vKiogT3B0aW9ucyBmb3IgZmVhdHVyZSBzZWxlY3Rpb24gcHJlZmVyZW5jZS4gKi9cbnZhciBGZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZTtcbihmdW5jdGlvbiAoRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2UpIHtcbiAgICBGZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZVtcIkZFQVRVUkVfU0VMRUNUSU9OX1BSRUZFUkVOQ0VfVU5TUEVDSUZJRURcIl0gPSBcIkZFQVRVUkVfU0VMRUNUSU9OX1BSRUZFUkVOQ0VfVU5TUEVDSUZJRURcIjtcbiAgICBGZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZVtcIlBSSU9SSVRJWkVfUVVBTElUWVwiXSA9IFwiUFJJT1JJVElaRV9RVUFMSVRZXCI7XG4gICAgRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2VbXCJCQUxBTkNFRFwiXSA9IFwiQkFMQU5DRURcIjtcbiAgICBGZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZVtcIlBSSU9SSVRJWkVfQ09TVFwiXSA9IFwiUFJJT1JJVElaRV9DT1NUXCI7XG59KShGZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZSB8fCAoRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2UgPSB7fSkpO1xuLyoqIERlZmluZXMgdGhlIGZ1bmN0aW9uIGJlaGF2aW9yLiBEZWZhdWx0cyB0byBgQkxPQ0tJTkdgLiAqL1xudmFyIEJlaGF2aW9yO1xuKGZ1bmN0aW9uIChCZWhhdmlvcikge1xuICAgIC8qKlxuICAgICAqIFRoaXMgdmFsdWUgaXMgdW51c2VkLlxuICAgICAqL1xuICAgIEJlaGF2aW9yW1wiVU5TUEVDSUZJRURcIl0gPSBcIlVOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogSWYgc2V0LCB0aGUgc3lzdGVtIHdpbGwgd2FpdCB0byByZWNlaXZlIHRoZSBmdW5jdGlvbiByZXNwb25zZSBiZWZvcmUgY29udGludWluZyB0aGUgY29udmVyc2F0aW9uLlxuICAgICAqL1xuICAgIEJlaGF2aW9yW1wiQkxPQ0tJTkdcIl0gPSBcIkJMT0NLSU5HXCI7XG4gICAgLyoqXG4gICAgICogSWYgc2V0LCB0aGUgc3lzdGVtIHdpbGwgbm90IHdhaXQgdG8gcmVjZWl2ZSB0aGUgZnVuY3Rpb24gcmVzcG9uc2UuIEluc3RlYWQsIGl0IHdpbGwgYXR0ZW1wdCB0byBoYW5kbGUgZnVuY3Rpb24gcmVzcG9uc2VzIGFzIHRoZXkgYmVjb21lIGF2YWlsYWJsZSB3aGlsZSBtYWludGFpbmluZyB0aGUgY29udmVyc2F0aW9uIGJldHdlZW4gdGhlIHVzZXIgYW5kIHRoZSBtb2RlbC5cbiAgICAgKi9cbiAgICBCZWhhdmlvcltcIk5PTl9CTE9DS0lOR1wiXSA9IFwiTk9OX0JMT0NLSU5HXCI7XG59KShCZWhhdmlvciB8fCAoQmVoYXZpb3IgPSB7fSkpO1xuLyoqIENvbmZpZyBmb3IgdGhlIGR5bmFtaWMgcmV0cmlldmFsIGNvbmZpZyBtb2RlLiAqL1xudmFyIER5bmFtaWNSZXRyaWV2YWxDb25maWdNb2RlO1xuKGZ1bmN0aW9uIChEeW5hbWljUmV0cmlldmFsQ29uZmlnTW9kZSkge1xuICAgIC8qKlxuICAgICAqIEFsd2F5cyB0cmlnZ2VyIHJldHJpZXZhbC5cbiAgICAgKi9cbiAgICBEeW5hbWljUmV0cmlldmFsQ29uZmlnTW9kZVtcIk1PREVfVU5TUEVDSUZJRURcIl0gPSBcIk1PREVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBSdW4gcmV0cmlldmFsIG9ubHkgd2hlbiBzeXN0ZW0gZGVjaWRlcyBpdCBpcyBuZWNlc3NhcnkuXG4gICAgICovXG4gICAgRHluYW1pY1JldHJpZXZhbENvbmZpZ01vZGVbXCJNT0RFX0RZTkFNSUNcIl0gPSBcIk1PREVfRFlOQU1JQ1wiO1xufSkoRHluYW1pY1JldHJpZXZhbENvbmZpZ01vZGUgfHwgKER5bmFtaWNSZXRyaWV2YWxDb25maWdNb2RlID0ge30pKTtcbi8qKiBUaGUgZW52aXJvbm1lbnQgYmVpbmcgb3BlcmF0ZWQuICovXG52YXIgRW52aXJvbm1lbnQ7XG4oZnVuY3Rpb24gKEVudmlyb25tZW50KSB7XG4gICAgLyoqXG4gICAgICogRGVmYXVsdHMgdG8gYnJvd3Nlci5cbiAgICAgKi9cbiAgICBFbnZpcm9ubWVudFtcIkVOVklST05NRU5UX1VOU1BFQ0lGSUVEXCJdID0gXCJFTlZJUk9OTUVOVF9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIE9wZXJhdGVzIGluIGEgd2ViIGJyb3dzZXIuXG4gICAgICovXG4gICAgRW52aXJvbm1lbnRbXCJFTlZJUk9OTUVOVF9CUk9XU0VSXCJdID0gXCJFTlZJUk9OTUVOVF9CUk9XU0VSXCI7XG59KShFbnZpcm9ubWVudCB8fCAoRW52aXJvbm1lbnQgPSB7fSkpO1xuLyoqIENvbmZpZyBmb3IgdGhlIGZ1bmN0aW9uIGNhbGxpbmcgY29uZmlnIG1vZGUuICovXG52YXIgRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZTtcbihmdW5jdGlvbiAoRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBmdW5jdGlvbiBjYWxsaW5nIGNvbmZpZyBtb2RlIGlzIHVuc3BlY2lmaWVkLiBTaG91bGQgbm90IGJlIHVzZWQuXG4gICAgICovXG4gICAgRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZVtcIk1PREVfVU5TUEVDSUZJRURcIl0gPSBcIk1PREVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IG1vZGVsIGJlaGF2aW9yLCBtb2RlbCBkZWNpZGVzIHRvIHByZWRpY3QgZWl0aGVyIGZ1bmN0aW9uIGNhbGxzIG9yIG5hdHVyYWwgbGFuZ3VhZ2UgcmVzcG9uc2UuXG4gICAgICovXG4gICAgRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZVtcIkFVVE9cIl0gPSBcIkFVVE9cIjtcbiAgICAvKipcbiAgICAgKiBNb2RlbCBpcyBjb25zdHJhaW5lZCB0byBhbHdheXMgcHJlZGljdGluZyBmdW5jdGlvbiBjYWxscyBvbmx5LiBJZiBcImFsbG93ZWRfZnVuY3Rpb25fbmFtZXNcIiBhcmUgc2V0LCB0aGUgcHJlZGljdGVkIGZ1bmN0aW9uIGNhbGxzIHdpbGwgYmUgbGltaXRlZCB0byBhbnkgb25lIG9mIFwiYWxsb3dlZF9mdW5jdGlvbl9uYW1lc1wiLCBlbHNlIHRoZSBwcmVkaWN0ZWQgZnVuY3Rpb24gY2FsbHMgd2lsbCBiZSBhbnkgb25lIG9mIHRoZSBwcm92aWRlZCBcImZ1bmN0aW9uX2RlY2xhcmF0aW9uc1wiLlxuICAgICAqL1xuICAgIEZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ01vZGVbXCJBTllcIl0gPSBcIkFOWVwiO1xuICAgIC8qKlxuICAgICAqIE1vZGVsIHdpbGwgbm90IHByZWRpY3QgYW55IGZ1bmN0aW9uIGNhbGxzLiBNb2RlbCBiZWhhdmlvciBpcyBzYW1lIGFzIHdoZW4gbm90IHBhc3NpbmcgYW55IGZ1bmN0aW9uIGRlY2xhcmF0aW9ucy5cbiAgICAgKi9cbiAgICBGdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlW1wiTk9ORVwiXSA9IFwiTk9ORVwiO1xuICAgIC8qKlxuICAgICAqIE1vZGVsIGRlY2lkZXMgdG8gcHJlZGljdCBlaXRoZXIgYSBmdW5jdGlvbiBjYWxsIG9yIGEgbmF0dXJhbCBsYW5ndWFnZSByZXNwb25zZSwgYnV0IHdpbGwgdmFsaWRhdGUgZnVuY3Rpb24gY2FsbHMgd2l0aCBjb25zdHJhaW5lZCBkZWNvZGluZy4gSWYgXCJhbGxvd2VkX2Z1bmN0aW9uX25hbWVzXCIgYXJlIHNldCwgdGhlIHByZWRpY3RlZCBmdW5jdGlvbiBjYWxsIHdpbGwgYmUgbGltaXRlZCB0byBhbnkgb25lIG9mIFwiYWxsb3dlZF9mdW5jdGlvbl9uYW1lc1wiLCBlbHNlIHRoZSBwcmVkaWN0ZWQgZnVuY3Rpb24gY2FsbCB3aWxsIGJlIGFueSBvbmUgb2YgdGhlIHByb3ZpZGVkIFwiZnVuY3Rpb25fZGVjbGFyYXRpb25zXCIuXG4gICAgICovXG4gICAgRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZVtcIlZBTElEQVRFRFwiXSA9IFwiVkFMSURBVEVEXCI7XG59KShGdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlIHx8IChGdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlID0ge30pKTtcbi8qKiBFbnVtIHRoYXQgY29udHJvbHMgdGhlIHNhZmV0eSBmaWx0ZXIgbGV2ZWwgZm9yIG9iamVjdGlvbmFibGUgY29udGVudC4gKi9cbnZhciBTYWZldHlGaWx0ZXJMZXZlbDtcbihmdW5jdGlvbiAoU2FmZXR5RmlsdGVyTGV2ZWwpIHtcbiAgICBTYWZldHlGaWx0ZXJMZXZlbFtcIkJMT0NLX0xPV19BTkRfQUJPVkVcIl0gPSBcIkJMT0NLX0xPV19BTkRfQUJPVkVcIjtcbiAgICBTYWZldHlGaWx0ZXJMZXZlbFtcIkJMT0NLX01FRElVTV9BTkRfQUJPVkVcIl0gPSBcIkJMT0NLX01FRElVTV9BTkRfQUJPVkVcIjtcbiAgICBTYWZldHlGaWx0ZXJMZXZlbFtcIkJMT0NLX09OTFlfSElHSFwiXSA9IFwiQkxPQ0tfT05MWV9ISUdIXCI7XG4gICAgU2FmZXR5RmlsdGVyTGV2ZWxbXCJCTE9DS19OT05FXCJdID0gXCJCTE9DS19OT05FXCI7XG59KShTYWZldHlGaWx0ZXJMZXZlbCB8fCAoU2FmZXR5RmlsdGVyTGV2ZWwgPSB7fSkpO1xuLyoqIEVudW0gdGhhdCBjb250cm9scyB0aGUgZ2VuZXJhdGlvbiBvZiBwZW9wbGUuICovXG52YXIgUGVyc29uR2VuZXJhdGlvbjtcbihmdW5jdGlvbiAoUGVyc29uR2VuZXJhdGlvbikge1xuICAgIC8qKlxuICAgICAqIEJsb2NrIGdlbmVyYXRpb24gb2YgaW1hZ2VzIG9mIHBlb3BsZS5cbiAgICAgKi9cbiAgICBQZXJzb25HZW5lcmF0aW9uW1wiRE9OVF9BTExPV1wiXSA9IFwiRE9OVF9BTExPV1wiO1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGltYWdlcyBvZiBhZHVsdHMsIGJ1dCBub3QgY2hpbGRyZW4uXG4gICAgICovXG4gICAgUGVyc29uR2VuZXJhdGlvbltcIkFMTE9XX0FEVUxUXCJdID0gXCJBTExPV19BRFVMVFwiO1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGltYWdlcyB0aGF0IGluY2x1ZGUgYWR1bHRzIGFuZCBjaGlsZHJlbi5cbiAgICAgKi9cbiAgICBQZXJzb25HZW5lcmF0aW9uW1wiQUxMT1dfQUxMXCJdID0gXCJBTExPV19BTExcIjtcbn0pKFBlcnNvbkdlbmVyYXRpb24gfHwgKFBlcnNvbkdlbmVyYXRpb24gPSB7fSkpO1xuLyoqIEVudW0gdGhhdCBzcGVjaWZpZXMgdGhlIGxhbmd1YWdlIG9mIHRoZSB0ZXh0IGluIHRoZSBwcm9tcHQuICovXG52YXIgSW1hZ2VQcm9tcHRMYW5ndWFnZTtcbihmdW5jdGlvbiAoSW1hZ2VQcm9tcHRMYW5ndWFnZSkge1xuICAgIC8qKlxuICAgICAqIEF1dG8tZGV0ZWN0IHRoZSBsYW5ndWFnZS5cbiAgICAgKi9cbiAgICBJbWFnZVByb21wdExhbmd1YWdlW1wiYXV0b1wiXSA9IFwiYXV0b1wiO1xuICAgIC8qKlxuICAgICAqIEVuZ2xpc2hcbiAgICAgKi9cbiAgICBJbWFnZVByb21wdExhbmd1YWdlW1wiZW5cIl0gPSBcImVuXCI7XG4gICAgLyoqXG4gICAgICogSmFwYW5lc2VcbiAgICAgKi9cbiAgICBJbWFnZVByb21wdExhbmd1YWdlW1wiamFcIl0gPSBcImphXCI7XG4gICAgLyoqXG4gICAgICogS29yZWFuXG4gICAgICovXG4gICAgSW1hZ2VQcm9tcHRMYW5ndWFnZVtcImtvXCJdID0gXCJrb1wiO1xuICAgIC8qKlxuICAgICAqIEhpbmRpXG4gICAgICovXG4gICAgSW1hZ2VQcm9tcHRMYW5ndWFnZVtcImhpXCJdID0gXCJoaVwiO1xuICAgIC8qKlxuICAgICAqIENoaW5lc2VcbiAgICAgKi9cbiAgICBJbWFnZVByb21wdExhbmd1YWdlW1wiemhcIl0gPSBcInpoXCI7XG4gICAgLyoqXG4gICAgICogUG9ydHVndWVzZVxuICAgICAqL1xuICAgIEltYWdlUHJvbXB0TGFuZ3VhZ2VbXCJwdFwiXSA9IFwicHRcIjtcbiAgICAvKipcbiAgICAgKiBTcGFuaXNoXG4gICAgICovXG4gICAgSW1hZ2VQcm9tcHRMYW5ndWFnZVtcImVzXCJdID0gXCJlc1wiO1xufSkoSW1hZ2VQcm9tcHRMYW5ndWFnZSB8fCAoSW1hZ2VQcm9tcHRMYW5ndWFnZSA9IHt9KSk7XG4vKiogRW51bSByZXByZXNlbnRpbmcgdGhlIG1hc2sgbW9kZSBvZiBhIG1hc2sgcmVmZXJlbmNlIGltYWdlLiAqL1xudmFyIE1hc2tSZWZlcmVuY2VNb2RlO1xuKGZ1bmN0aW9uIChNYXNrUmVmZXJlbmNlTW9kZSkge1xuICAgIE1hc2tSZWZlcmVuY2VNb2RlW1wiTUFTS19NT0RFX0RFRkFVTFRcIl0gPSBcIk1BU0tfTU9ERV9ERUZBVUxUXCI7XG4gICAgTWFza1JlZmVyZW5jZU1vZGVbXCJNQVNLX01PREVfVVNFUl9QUk9WSURFRFwiXSA9IFwiTUFTS19NT0RFX1VTRVJfUFJPVklERURcIjtcbiAgICBNYXNrUmVmZXJlbmNlTW9kZVtcIk1BU0tfTU9ERV9CQUNLR1JPVU5EXCJdID0gXCJNQVNLX01PREVfQkFDS0dST1VORFwiO1xuICAgIE1hc2tSZWZlcmVuY2VNb2RlW1wiTUFTS19NT0RFX0ZPUkVHUk9VTkRcIl0gPSBcIk1BU0tfTU9ERV9GT1JFR1JPVU5EXCI7XG4gICAgTWFza1JlZmVyZW5jZU1vZGVbXCJNQVNLX01PREVfU0VNQU5USUNcIl0gPSBcIk1BU0tfTU9ERV9TRU1BTlRJQ1wiO1xufSkoTWFza1JlZmVyZW5jZU1vZGUgfHwgKE1hc2tSZWZlcmVuY2VNb2RlID0ge30pKTtcbi8qKiBFbnVtIHJlcHJlc2VudGluZyB0aGUgY29udHJvbCB0eXBlIG9mIGEgY29udHJvbCByZWZlcmVuY2UgaW1hZ2UuICovXG52YXIgQ29udHJvbFJlZmVyZW5jZVR5cGU7XG4oZnVuY3Rpb24gKENvbnRyb2xSZWZlcmVuY2VUeXBlKSB7XG4gICAgQ29udHJvbFJlZmVyZW5jZVR5cGVbXCJDT05UUk9MX1RZUEVfREVGQVVMVFwiXSA9IFwiQ09OVFJPTF9UWVBFX0RFRkFVTFRcIjtcbiAgICBDb250cm9sUmVmZXJlbmNlVHlwZVtcIkNPTlRST0xfVFlQRV9DQU5OWVwiXSA9IFwiQ09OVFJPTF9UWVBFX0NBTk5ZXCI7XG4gICAgQ29udHJvbFJlZmVyZW5jZVR5cGVbXCJDT05UUk9MX1RZUEVfU0NSSUJCTEVcIl0gPSBcIkNPTlRST0xfVFlQRV9TQ1JJQkJMRVwiO1xuICAgIENvbnRyb2xSZWZlcmVuY2VUeXBlW1wiQ09OVFJPTF9UWVBFX0ZBQ0VfTUVTSFwiXSA9IFwiQ09OVFJPTF9UWVBFX0ZBQ0VfTUVTSFwiO1xufSkoQ29udHJvbFJlZmVyZW5jZVR5cGUgfHwgKENvbnRyb2xSZWZlcmVuY2VUeXBlID0ge30pKTtcbi8qKiBFbnVtIHJlcHJlc2VudGluZyB0aGUgc3ViamVjdCB0eXBlIG9mIGEgc3ViamVjdCByZWZlcmVuY2UgaW1hZ2UuICovXG52YXIgU3ViamVjdFJlZmVyZW5jZVR5cGU7XG4oZnVuY3Rpb24gKFN1YmplY3RSZWZlcmVuY2VUeXBlKSB7XG4gICAgU3ViamVjdFJlZmVyZW5jZVR5cGVbXCJTVUJKRUNUX1RZUEVfREVGQVVMVFwiXSA9IFwiU1VCSkVDVF9UWVBFX0RFRkFVTFRcIjtcbiAgICBTdWJqZWN0UmVmZXJlbmNlVHlwZVtcIlNVQkpFQ1RfVFlQRV9QRVJTT05cIl0gPSBcIlNVQkpFQ1RfVFlQRV9QRVJTT05cIjtcbiAgICBTdWJqZWN0UmVmZXJlbmNlVHlwZVtcIlNVQkpFQ1RfVFlQRV9BTklNQUxcIl0gPSBcIlNVQkpFQ1RfVFlQRV9BTklNQUxcIjtcbiAgICBTdWJqZWN0UmVmZXJlbmNlVHlwZVtcIlNVQkpFQ1RfVFlQRV9QUk9EVUNUXCJdID0gXCJTVUJKRUNUX1RZUEVfUFJPRFVDVFwiO1xufSkoU3ViamVjdFJlZmVyZW5jZVR5cGUgfHwgKFN1YmplY3RSZWZlcmVuY2VUeXBlID0ge30pKTtcbi8qKiBFbnVtIHJlcHJlc2VudGluZyB0aGUgZWRpdGluZyBtb2RlLiAqL1xudmFyIEVkaXRNb2RlO1xuKGZ1bmN0aW9uIChFZGl0TW9kZSkge1xuICAgIEVkaXRNb2RlW1wiRURJVF9NT0RFX0RFRkFVTFRcIl0gPSBcIkVESVRfTU9ERV9ERUZBVUxUXCI7XG4gICAgRWRpdE1vZGVbXCJFRElUX01PREVfSU5QQUlOVF9SRU1PVkFMXCJdID0gXCJFRElUX01PREVfSU5QQUlOVF9SRU1PVkFMXCI7XG4gICAgRWRpdE1vZGVbXCJFRElUX01PREVfSU5QQUlOVF9JTlNFUlRJT05cIl0gPSBcIkVESVRfTU9ERV9JTlBBSU5UX0lOU0VSVElPTlwiO1xuICAgIEVkaXRNb2RlW1wiRURJVF9NT0RFX09VVFBBSU5UXCJdID0gXCJFRElUX01PREVfT1VUUEFJTlRcIjtcbiAgICBFZGl0TW9kZVtcIkVESVRfTU9ERV9DT05UUk9MTEVEX0VESVRJTkdcIl0gPSBcIkVESVRfTU9ERV9DT05UUk9MTEVEX0VESVRJTkdcIjtcbiAgICBFZGl0TW9kZVtcIkVESVRfTU9ERV9TVFlMRVwiXSA9IFwiRURJVF9NT0RFX1NUWUxFXCI7XG4gICAgRWRpdE1vZGVbXCJFRElUX01PREVfQkdTV0FQXCJdID0gXCJFRElUX01PREVfQkdTV0FQXCI7XG4gICAgRWRpdE1vZGVbXCJFRElUX01PREVfUFJPRFVDVF9JTUFHRVwiXSA9IFwiRURJVF9NT0RFX1BST0RVQ1RfSU1BR0VcIjtcbn0pKEVkaXRNb2RlIHx8IChFZGl0TW9kZSA9IHt9KSk7XG4vKiogRW51bSB0aGF0IHJlcHJlc2VudHMgdGhlIHNlZ21lbnRhdGlvbiBtb2RlLiAqL1xudmFyIFNlZ21lbnRNb2RlO1xuKGZ1bmN0aW9uIChTZWdtZW50TW9kZSkge1xuICAgIFNlZ21lbnRNb2RlW1wiRk9SRUdST1VORFwiXSA9IFwiRk9SRUdST1VORFwiO1xuICAgIFNlZ21lbnRNb2RlW1wiQkFDS0dST1VORFwiXSA9IFwiQkFDS0dST1VORFwiO1xuICAgIFNlZ21lbnRNb2RlW1wiUFJPTVBUXCJdID0gXCJQUk9NUFRcIjtcbiAgICBTZWdtZW50TW9kZVtcIlNFTUFOVElDXCJdID0gXCJTRU1BTlRJQ1wiO1xuICAgIFNlZ21lbnRNb2RlW1wiSU5URVJBQ1RJVkVcIl0gPSBcIklOVEVSQUNUSVZFXCI7XG59KShTZWdtZW50TW9kZSB8fCAoU2VnbWVudE1vZGUgPSB7fSkpO1xuLyoqIEVudW0gZm9yIHRoZSByZWZlcmVuY2UgdHlwZSBvZiBhIHZpZGVvIGdlbmVyYXRpb24gcmVmZXJlbmNlIGltYWdlLiAqL1xudmFyIFZpZGVvR2VuZXJhdGlvblJlZmVyZW5jZVR5cGU7XG4oZnVuY3Rpb24gKFZpZGVvR2VuZXJhdGlvblJlZmVyZW5jZVR5cGUpIHtcbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSBpbWFnZSB0aGF0IHByb3ZpZGVzIGFzc2V0cyB0byB0aGUgZ2VuZXJhdGVkIHZpZGVvLFxuICAgICAgICBzdWNoIGFzIHRoZSBzY2VuZSwgYW4gb2JqZWN0LCBhIGNoYXJhY3RlciwgZXRjLlxuICAgICAqL1xuICAgIFZpZGVvR2VuZXJhdGlvblJlZmVyZW5jZVR5cGVbXCJBU1NFVFwiXSA9IFwiQVNTRVRcIjtcbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSBpbWFnZSB0aGF0IHByb3ZpZGVzIGFlc3RoZXRpY3MgaW5jbHVkaW5nIGNvbG9ycyxcbiAgICAgICAgbGlnaHRpbmcsIHRleHR1cmUsIGV0Yy4sIHRvIGJlIHVzZWQgYXMgdGhlIHN0eWxlIG9mIHRoZSBnZW5lcmF0ZWQgdmlkZW8sXG4gICAgICAgIHN1Y2ggYXMgJ2FuaW1lJywgJ3Bob3RvZ3JhcGh5JywgJ29yaWdhbWknLCBldGMuXG4gICAgICovXG4gICAgVmlkZW9HZW5lcmF0aW9uUmVmZXJlbmNlVHlwZVtcIlNUWUxFXCJdID0gXCJTVFlMRVwiO1xufSkoVmlkZW9HZW5lcmF0aW9uUmVmZXJlbmNlVHlwZSB8fCAoVmlkZW9HZW5lcmF0aW9uUmVmZXJlbmNlVHlwZSA9IHt9KSk7XG4vKiogRW51bSBmb3IgdGhlIG1hc2sgbW9kZSBvZiBhIHZpZGVvIGdlbmVyYXRpb24gbWFzay4gKi9cbnZhciBWaWRlb0dlbmVyYXRpb25NYXNrTW9kZTtcbihmdW5jdGlvbiAoVmlkZW9HZW5lcmF0aW9uTWFza01vZGUpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgaW1hZ2UgbWFzayBjb250YWlucyBhIG1hc2tlZCByZWN0YW5ndWxhciByZWdpb24gd2hpY2ggaXNcbiAgICAgICAgYXBwbGllZCBvbiB0aGUgZmlyc3QgZnJhbWUgb2YgdGhlIGlucHV0IHZpZGVvLiBUaGUgb2JqZWN0IGRlc2NyaWJlZCBpblxuICAgICAgICB0aGUgcHJvbXB0IGlzIGluc2VydGVkIGludG8gdGhpcyByZWdpb24gYW5kIHdpbGwgYXBwZWFyIGluIHN1YnNlcXVlbnRcbiAgICAgICAgZnJhbWVzLlxuICAgICAqL1xuICAgIFZpZGVvR2VuZXJhdGlvbk1hc2tNb2RlW1wiSU5TRVJUXCJdID0gXCJJTlNFUlRcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgaW1hZ2UgbWFzayBpcyB1c2VkIHRvIGRldGVybWluZSBhbiBvYmplY3QgaW4gdGhlXG4gICAgICAgIGZpcnN0IHZpZGVvIGZyYW1lIHRvIHRyYWNrLiBUaGlzIG9iamVjdCBpcyByZW1vdmVkIGZyb20gdGhlIHZpZGVvLlxuICAgICAqL1xuICAgIFZpZGVvR2VuZXJhdGlvbk1hc2tNb2RlW1wiUkVNT1ZFXCJdID0gXCJSRU1PVkVcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgaW1hZ2UgbWFzayBpcyB1c2VkIHRvIGRldGVybWluZSBhIHJlZ2lvbiBpbiB0aGVcbiAgICAgICAgdmlkZW8uIE9iamVjdHMgaW4gdGhpcyByZWdpb24gd2lsbCBiZSByZW1vdmVkLlxuICAgICAqL1xuICAgIFZpZGVvR2VuZXJhdGlvbk1hc2tNb2RlW1wiUkVNT1ZFX1NUQVRJQ1wiXSA9IFwiUkVNT1ZFX1NUQVRJQ1wiO1xuICAgIC8qKlxuICAgICAqIFRoZSBpbWFnZSBtYXNrIGNvbnRhaW5zIGEgbWFza2VkIHJlY3Rhbmd1bGFyIHJlZ2lvbiB3aGVyZVxuICAgICAgICB0aGUgaW5wdXQgdmlkZW8gd2lsbCBnby4gVGhlIHJlbWFpbmluZyBhcmVhIHdpbGwgYmUgZ2VuZXJhdGVkLiBWaWRlb1xuICAgICAgICBtYXNrcyBhcmUgbm90IHN1cHBvcnRlZC5cbiAgICAgKi9cbiAgICBWaWRlb0dlbmVyYXRpb25NYXNrTW9kZVtcIk9VVFBBSU5UXCJdID0gXCJPVVRQQUlOVFwiO1xufSkoVmlkZW9HZW5lcmF0aW9uTWFza01vZGUgfHwgKFZpZGVvR2VuZXJhdGlvbk1hc2tNb2RlID0ge30pKTtcbi8qKiBFbnVtIHRoYXQgY29udHJvbHMgdGhlIGNvbXByZXNzaW9uIHF1YWxpdHkgb2YgdGhlIGdlbmVyYXRlZCB2aWRlb3MuICovXG52YXIgVmlkZW9Db21wcmVzc2lvblF1YWxpdHk7XG4oZnVuY3Rpb24gKFZpZGVvQ29tcHJlc3Npb25RdWFsaXR5KSB7XG4gICAgLyoqXG4gICAgICogT3B0aW1pemVkIHZpZGVvIGNvbXByZXNzaW9uIHF1YWxpdHkuIFRoaXMgd2lsbCBwcm9kdWNlIHZpZGVvc1xuICAgICAgICB3aXRoIGEgY29tcHJlc3NlZCwgc21hbGxlciBmaWxlIHNpemUuXG4gICAgICovXG4gICAgVmlkZW9Db21wcmVzc2lvblF1YWxpdHlbXCJPUFRJTUlaRURcIl0gPSBcIk9QVElNSVpFRFwiO1xuICAgIC8qKlxuICAgICAqIExvc3NsZXNzIHZpZGVvIGNvbXByZXNzaW9uIHF1YWxpdHkuIFRoaXMgd2lsbCBwcm9kdWNlIHZpZGVvc1xuICAgICAgICB3aXRoIGEgbGFyZ2VyIGZpbGUgc2l6ZS5cbiAgICAgKi9cbiAgICBWaWRlb0NvbXByZXNzaW9uUXVhbGl0eVtcIkxPU1NMRVNTXCJdID0gXCJMT1NTTEVTU1wiO1xufSkoVmlkZW9Db21wcmVzc2lvblF1YWxpdHkgfHwgKFZpZGVvQ29tcHJlc3Npb25RdWFsaXR5ID0ge30pKTtcbi8qKiBFbnVtIHJlcHJlc2VudGluZyB0aGUgdHVuaW5nIG1ldGhvZC4gKi9cbnZhciBUdW5pbmdNZXRob2Q7XG4oZnVuY3Rpb24gKFR1bmluZ01ldGhvZCkge1xuICAgIC8qKlxuICAgICAqIFN1cGVydmlzZWQgZmluZSB0dW5pbmcuXG4gICAgICovXG4gICAgVHVuaW5nTWV0aG9kW1wiU1VQRVJWSVNFRF9GSU5FX1RVTklOR1wiXSA9IFwiU1VQRVJWSVNFRF9GSU5FX1RVTklOR1wiO1xuICAgIC8qKlxuICAgICAqIFByZWZlcmVuY2Ugb3B0aW1pemF0aW9uIHR1bmluZy5cbiAgICAgKi9cbiAgICBUdW5pbmdNZXRob2RbXCJQUkVGRVJFTkNFX1RVTklOR1wiXSA9IFwiUFJFRkVSRU5DRV9UVU5JTkdcIjtcbn0pKFR1bmluZ01ldGhvZCB8fCAoVHVuaW5nTWV0aG9kID0ge30pKTtcbi8qKiBTdGF0ZSBmb3IgdGhlIGxpZmVjeWNsZSBvZiBhIERvY3VtZW50LiAqL1xudmFyIERvY3VtZW50U3RhdGU7XG4oZnVuY3Rpb24gKERvY3VtZW50U3RhdGUpIHtcbiAgICBEb2N1bWVudFN0YXRlW1wiU1RBVEVfVU5TUEVDSUZJRURcIl0gPSBcIlNUQVRFX1VOU1BFQ0lGSUVEXCI7XG4gICAgRG9jdW1lbnRTdGF0ZVtcIlNUQVRFX1BFTkRJTkdcIl0gPSBcIlNUQVRFX1BFTkRJTkdcIjtcbiAgICBEb2N1bWVudFN0YXRlW1wiU1RBVEVfQUNUSVZFXCJdID0gXCJTVEFURV9BQ1RJVkVcIjtcbiAgICBEb2N1bWVudFN0YXRlW1wiU1RBVEVfRkFJTEVEXCJdID0gXCJTVEFURV9GQUlMRURcIjtcbn0pKERvY3VtZW50U3RhdGUgfHwgKERvY3VtZW50U3RhdGUgPSB7fSkpO1xuLyoqIFN0YXRlIGZvciB0aGUgbGlmZWN5Y2xlIG9mIGEgRmlsZS4gKi9cbnZhciBGaWxlU3RhdGU7XG4oZnVuY3Rpb24gKEZpbGVTdGF0ZSkge1xuICAgIEZpbGVTdGF0ZVtcIlNUQVRFX1VOU1BFQ0lGSUVEXCJdID0gXCJTVEFURV9VTlNQRUNJRklFRFwiO1xuICAgIEZpbGVTdGF0ZVtcIlBST0NFU1NJTkdcIl0gPSBcIlBST0NFU1NJTkdcIjtcbiAgICBGaWxlU3RhdGVbXCJBQ1RJVkVcIl0gPSBcIkFDVElWRVwiO1xuICAgIEZpbGVTdGF0ZVtcIkZBSUxFRFwiXSA9IFwiRkFJTEVEXCI7XG59KShGaWxlU3RhdGUgfHwgKEZpbGVTdGF0ZSA9IHt9KSk7XG4vKiogU291cmNlIG9mIHRoZSBGaWxlLiAqL1xudmFyIEZpbGVTb3VyY2U7XG4oZnVuY3Rpb24gKEZpbGVTb3VyY2UpIHtcbiAgICBGaWxlU291cmNlW1wiU09VUkNFX1VOU1BFQ0lGSUVEXCJdID0gXCJTT1VSQ0VfVU5TUEVDSUZJRURcIjtcbiAgICBGaWxlU291cmNlW1wiVVBMT0FERURcIl0gPSBcIlVQTE9BREVEXCI7XG4gICAgRmlsZVNvdXJjZVtcIkdFTkVSQVRFRFwiXSA9IFwiR0VORVJBVEVEXCI7XG59KShGaWxlU291cmNlIHx8IChGaWxlU291cmNlID0ge30pKTtcbi8qKiBUaGUgcmVhc29uIHdoeSB0aGUgdHVybiBpcyBjb21wbGV0ZS4gKi9cbnZhciBUdXJuQ29tcGxldGVSZWFzb247XG4oZnVuY3Rpb24gKFR1cm5Db21wbGV0ZVJlYXNvbikge1xuICAgIC8qKlxuICAgICAqIERlZmF1bHQgdmFsdWUuIFJlYXNvbiBpcyB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBUdXJuQ29tcGxldGVSZWFzb25bXCJUVVJOX0NPTVBMRVRFX1JFQVNPTl9VTlNQRUNJRklFRFwiXSA9IFwiVFVSTl9DT01QTEVURV9SRUFTT05fVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgZnVuY3Rpb24gY2FsbCBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsIGlzIGludmFsaWQuXG4gICAgICovXG4gICAgVHVybkNvbXBsZXRlUmVhc29uW1wiTUFMRk9STUVEX0ZVTkNUSU9OX0NBTExcIl0gPSBcIk1BTEZPUk1FRF9GVU5DVElPTl9DQUxMXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHJlc3BvbnNlIGlzIHJlamVjdGVkIGJ5IHRoZSBtb2RlbC5cbiAgICAgKi9cbiAgICBUdXJuQ29tcGxldGVSZWFzb25bXCJSRVNQT05TRV9SRUpFQ1RFRFwiXSA9IFwiUkVTUE9OU0VfUkVKRUNURURcIjtcbiAgICAvKipcbiAgICAgKiBOZWVkcyBtb3JlIGlucHV0IGZyb20gdGhlIHVzZXIuXG4gICAgICovXG4gICAgVHVybkNvbXBsZXRlUmVhc29uW1wiTkVFRF9NT1JFX0lOUFVUXCJdID0gXCJORUVEX01PUkVfSU5QVVRcIjtcbn0pKFR1cm5Db21wbGV0ZVJlYXNvbiB8fCAoVHVybkNvbXBsZXRlUmVhc29uID0ge30pKTtcbi8qKiBTZXJ2ZXIgY29udGVudCBtb2RhbGl0aWVzLiAqL1xudmFyIE1lZGlhTW9kYWxpdHk7XG4oZnVuY3Rpb24gKE1lZGlhTW9kYWxpdHkpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbW9kYWxpdHkgaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgTWVkaWFNb2RhbGl0eVtcIk1PREFMSVRZX1VOU1BFQ0lGSUVEXCJdID0gXCJNT0RBTElUWV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFBsYWluIHRleHQuXG4gICAgICovXG4gICAgTWVkaWFNb2RhbGl0eVtcIlRFWFRcIl0gPSBcIlRFWFRcIjtcbiAgICAvKipcbiAgICAgKiBJbWFnZXMuXG4gICAgICovXG4gICAgTWVkaWFNb2RhbGl0eVtcIklNQUdFXCJdID0gXCJJTUFHRVwiO1xuICAgIC8qKlxuICAgICAqIFZpZGVvLlxuICAgICAqL1xuICAgIE1lZGlhTW9kYWxpdHlbXCJWSURFT1wiXSA9IFwiVklERU9cIjtcbiAgICAvKipcbiAgICAgKiBBdWRpby5cbiAgICAgKi9cbiAgICBNZWRpYU1vZGFsaXR5W1wiQVVESU9cIl0gPSBcIkFVRElPXCI7XG4gICAgLyoqXG4gICAgICogRG9jdW1lbnQsIGUuZy4gUERGLlxuICAgICAqL1xuICAgIE1lZGlhTW9kYWxpdHlbXCJET0NVTUVOVFwiXSA9IFwiRE9DVU1FTlRcIjtcbn0pKE1lZGlhTW9kYWxpdHkgfHwgKE1lZGlhTW9kYWxpdHkgPSB7fSkpO1xuLyoqIFN0YXJ0IG9mIHNwZWVjaCBzZW5zaXRpdml0eS4gKi9cbnZhciBTdGFydFNlbnNpdGl2aXR5O1xuKGZ1bmN0aW9uIChTdGFydFNlbnNpdGl2aXR5KSB7XG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgaXMgU1RBUlRfU0VOU0lUSVZJVFlfTE9XLlxuICAgICAqL1xuICAgIFN0YXJ0U2Vuc2l0aXZpdHlbXCJTVEFSVF9TRU5TSVRJVklUWV9VTlNQRUNJRklFRFwiXSA9IFwiU1RBUlRfU0VOU0lUSVZJVFlfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBBdXRvbWF0aWMgZGV0ZWN0aW9uIHdpbGwgZGV0ZWN0IHRoZSBzdGFydCBvZiBzcGVlY2ggbW9yZSBvZnRlbi5cbiAgICAgKi9cbiAgICBTdGFydFNlbnNpdGl2aXR5W1wiU1RBUlRfU0VOU0lUSVZJVFlfSElHSFwiXSA9IFwiU1RBUlRfU0VOU0lUSVZJVFlfSElHSFwiO1xuICAgIC8qKlxuICAgICAqIEF1dG9tYXRpYyBkZXRlY3Rpb24gd2lsbCBkZXRlY3QgdGhlIHN0YXJ0IG9mIHNwZWVjaCBsZXNzIG9mdGVuLlxuICAgICAqL1xuICAgIFN0YXJ0U2Vuc2l0aXZpdHlbXCJTVEFSVF9TRU5TSVRJVklUWV9MT1dcIl0gPSBcIlNUQVJUX1NFTlNJVElWSVRZX0xPV1wiO1xufSkoU3RhcnRTZW5zaXRpdml0eSB8fCAoU3RhcnRTZW5zaXRpdml0eSA9IHt9KSk7XG4vKiogRW5kIG9mIHNwZWVjaCBzZW5zaXRpdml0eS4gKi9cbnZhciBFbmRTZW5zaXRpdml0eTtcbihmdW5jdGlvbiAoRW5kU2Vuc2l0aXZpdHkpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBpcyBFTkRfU0VOU0lUSVZJVFlfTE9XLlxuICAgICAqL1xuICAgIEVuZFNlbnNpdGl2aXR5W1wiRU5EX1NFTlNJVElWSVRZX1VOU1BFQ0lGSUVEXCJdID0gXCJFTkRfU0VOU0lUSVZJVFlfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBBdXRvbWF0aWMgZGV0ZWN0aW9uIGVuZHMgc3BlZWNoIG1vcmUgb2Z0ZW4uXG4gICAgICovXG4gICAgRW5kU2Vuc2l0aXZpdHlbXCJFTkRfU0VOU0lUSVZJVFlfSElHSFwiXSA9IFwiRU5EX1NFTlNJVElWSVRZX0hJR0hcIjtcbiAgICAvKipcbiAgICAgKiBBdXRvbWF0aWMgZGV0ZWN0aW9uIGVuZHMgc3BlZWNoIGxlc3Mgb2Z0ZW4uXG4gICAgICovXG4gICAgRW5kU2Vuc2l0aXZpdHlbXCJFTkRfU0VOU0lUSVZJVFlfTE9XXCJdID0gXCJFTkRfU0VOU0lUSVZJVFlfTE9XXCI7XG59KShFbmRTZW5zaXRpdml0eSB8fCAoRW5kU2Vuc2l0aXZpdHkgPSB7fSkpO1xuLyoqIFRoZSBkaWZmZXJlbnQgd2F5cyBvZiBoYW5kbGluZyB1c2VyIGFjdGl2aXR5LiAqL1xudmFyIEFjdGl2aXR5SGFuZGxpbmc7XG4oZnVuY3Rpb24gKEFjdGl2aXR5SGFuZGxpbmcpIHtcbiAgICAvKipcbiAgICAgKiBJZiB1bnNwZWNpZmllZCwgdGhlIGRlZmF1bHQgYmVoYXZpb3IgaXMgYFNUQVJUX09GX0FDVElWSVRZX0lOVEVSUlVQVFNgLlxuICAgICAqL1xuICAgIEFjdGl2aXR5SGFuZGxpbmdbXCJBQ1RJVklUWV9IQU5ETElOR19VTlNQRUNJRklFRFwiXSA9IFwiQUNUSVZJVFlfSEFORExJTkdfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBzdGFydCBvZiBhY3Rpdml0eSB3aWxsIGludGVycnVwdCB0aGUgbW9kZWwncyByZXNwb25zZSAoYWxzbyBjYWxsZWQgXCJiYXJnZSBpblwiKS4gVGhlIG1vZGVsJ3MgY3VycmVudCByZXNwb25zZSB3aWxsIGJlIGN1dC1vZmYgaW4gdGhlIG1vbWVudCBvZiB0aGUgaW50ZXJydXB0aW9uLiBUaGlzIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW9yLlxuICAgICAqL1xuICAgIEFjdGl2aXR5SGFuZGxpbmdbXCJTVEFSVF9PRl9BQ1RJVklUWV9JTlRFUlJVUFRTXCJdID0gXCJTVEFSVF9PRl9BQ1RJVklUWV9JTlRFUlJVUFRTXCI7XG4gICAgLyoqXG4gICAgICogVGhlIG1vZGVsJ3MgcmVzcG9uc2Ugd2lsbCBub3QgYmUgaW50ZXJydXB0ZWQuXG4gICAgICovXG4gICAgQWN0aXZpdHlIYW5kbGluZ1tcIk5PX0lOVEVSUlVQVElPTlwiXSA9IFwiTk9fSU5URVJSVVBUSU9OXCI7XG59KShBY3Rpdml0eUhhbmRsaW5nIHx8IChBY3Rpdml0eUhhbmRsaW5nID0ge30pKTtcbi8qKiBPcHRpb25zIGFib3V0IHdoaWNoIGlucHV0IGlzIGluY2x1ZGVkIGluIHRoZSB1c2VyJ3MgdHVybi4gKi9cbnZhciBUdXJuQ292ZXJhZ2U7XG4oZnVuY3Rpb24gKFR1cm5Db3ZlcmFnZSkge1xuICAgIC8qKlxuICAgICAqIElmIHVuc3BlY2lmaWVkLCB0aGUgZGVmYXVsdCBiZWhhdmlvciBpcyBgVFVSTl9JTkNMVURFU19PTkxZX0FDVElWSVRZYC5cbiAgICAgKi9cbiAgICBUdXJuQ292ZXJhZ2VbXCJUVVJOX0NPVkVSQUdFX1VOU1BFQ0lGSUVEXCJdID0gXCJUVVJOX0NPVkVSQUdFX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHVzZXJzIHR1cm4gb25seSBpbmNsdWRlcyBhY3Rpdml0eSBzaW5jZSB0aGUgbGFzdCB0dXJuLCBleGNsdWRpbmcgaW5hY3Rpdml0eSAoZS5nLiBzaWxlbmNlIG9uIHRoZSBhdWRpbyBzdHJlYW0pLiBUaGlzIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW9yLlxuICAgICAqL1xuICAgIFR1cm5Db3ZlcmFnZVtcIlRVUk5fSU5DTFVERVNfT05MWV9BQ1RJVklUWVwiXSA9IFwiVFVSTl9JTkNMVURFU19PTkxZX0FDVElWSVRZXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHVzZXJzIHR1cm4gaW5jbHVkZXMgYWxsIHJlYWx0aW1lIGlucHV0IHNpbmNlIHRoZSBsYXN0IHR1cm4sIGluY2x1ZGluZyBpbmFjdGl2aXR5IChlLmcuIHNpbGVuY2Ugb24gdGhlIGF1ZGlvIHN0cmVhbSkuXG4gICAgICovXG4gICAgVHVybkNvdmVyYWdlW1wiVFVSTl9JTkNMVURFU19BTExfSU5QVVRcIl0gPSBcIlRVUk5fSU5DTFVERVNfQUxMX0lOUFVUXCI7XG59KShUdXJuQ292ZXJhZ2UgfHwgKFR1cm5Db3ZlcmFnZSA9IHt9KSk7XG4vKiogU2NhbGUgb2YgdGhlIGdlbmVyYXRlZCBtdXNpYy4gKi9cbnZhciBTY2FsZTtcbihmdW5jdGlvbiAoU2NhbGUpIHtcbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHZhbHVlLiBUaGlzIHZhbHVlIGlzIHVudXNlZC5cbiAgICAgKi9cbiAgICBTY2FsZVtcIlNDQUxFX1VOU1BFQ0lGSUVEXCJdID0gXCJTQ0FMRV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIEMgbWFqb3Igb3IgQSBtaW5vci5cbiAgICAgKi9cbiAgICBTY2FsZVtcIkNfTUFKT1JfQV9NSU5PUlwiXSA9IFwiQ19NQUpPUl9BX01JTk9SXCI7XG4gICAgLyoqXG4gICAgICogRGIgbWFqb3Igb3IgQmIgbWlub3IuXG4gICAgICovXG4gICAgU2NhbGVbXCJEX0ZMQVRfTUFKT1JfQl9GTEFUX01JTk9SXCJdID0gXCJEX0ZMQVRfTUFKT1JfQl9GTEFUX01JTk9SXCI7XG4gICAgLyoqXG4gICAgICogRCBtYWpvciBvciBCIG1pbm9yLlxuICAgICAqL1xuICAgIFNjYWxlW1wiRF9NQUpPUl9CX01JTk9SXCJdID0gXCJEX01BSk9SX0JfTUlOT1JcIjtcbiAgICAvKipcbiAgICAgKiBFYiBtYWpvciBvciBDIG1pbm9yXG4gICAgICovXG4gICAgU2NhbGVbXCJFX0ZMQVRfTUFKT1JfQ19NSU5PUlwiXSA9IFwiRV9GTEFUX01BSk9SX0NfTUlOT1JcIjtcbiAgICAvKipcbiAgICAgKiBFIG1ham9yIG9yIERiIG1pbm9yLlxuICAgICAqL1xuICAgIFNjYWxlW1wiRV9NQUpPUl9EX0ZMQVRfTUlOT1JcIl0gPSBcIkVfTUFKT1JfRF9GTEFUX01JTk9SXCI7XG4gICAgLyoqXG4gICAgICogRiBtYWpvciBvciBEIG1pbm9yLlxuICAgICAqL1xuICAgIFNjYWxlW1wiRl9NQUpPUl9EX01JTk9SXCJdID0gXCJGX01BSk9SX0RfTUlOT1JcIjtcbiAgICAvKipcbiAgICAgKiBHYiBtYWpvciBvciBFYiBtaW5vci5cbiAgICAgKi9cbiAgICBTY2FsZVtcIkdfRkxBVF9NQUpPUl9FX0ZMQVRfTUlOT1JcIl0gPSBcIkdfRkxBVF9NQUpPUl9FX0ZMQVRfTUlOT1JcIjtcbiAgICAvKipcbiAgICAgKiBHIG1ham9yIG9yIEUgbWlub3IuXG4gICAgICovXG4gICAgU2NhbGVbXCJHX01BSk9SX0VfTUlOT1JcIl0gPSBcIkdfTUFKT1JfRV9NSU5PUlwiO1xuICAgIC8qKlxuICAgICAqIEFiIG1ham9yIG9yIEYgbWlub3IuXG4gICAgICovXG4gICAgU2NhbGVbXCJBX0ZMQVRfTUFKT1JfRl9NSU5PUlwiXSA9IFwiQV9GTEFUX01BSk9SX0ZfTUlOT1JcIjtcbiAgICAvKipcbiAgICAgKiBBIG1ham9yIG9yIEdiIG1pbm9yLlxuICAgICAqL1xuICAgIFNjYWxlW1wiQV9NQUpPUl9HX0ZMQVRfTUlOT1JcIl0gPSBcIkFfTUFKT1JfR19GTEFUX01JTk9SXCI7XG4gICAgLyoqXG4gICAgICogQmIgbWFqb3Igb3IgRyBtaW5vci5cbiAgICAgKi9cbiAgICBTY2FsZVtcIkJfRkxBVF9NQUpPUl9HX01JTk9SXCJdID0gXCJCX0ZMQVRfTUFKT1JfR19NSU5PUlwiO1xuICAgIC8qKlxuICAgICAqIEIgbWFqb3Igb3IgQWIgbWlub3IuXG4gICAgICovXG4gICAgU2NhbGVbXCJCX01BSk9SX0FfRkxBVF9NSU5PUlwiXSA9IFwiQl9NQUpPUl9BX0ZMQVRfTUlOT1JcIjtcbn0pKFNjYWxlIHx8IChTY2FsZSA9IHt9KSk7XG4vKiogVGhlIG1vZGUgb2YgbXVzaWMgZ2VuZXJhdGlvbi4gKi9cbnZhciBNdXNpY0dlbmVyYXRpb25Nb2RlO1xuKGZ1bmN0aW9uIChNdXNpY0dlbmVyYXRpb25Nb2RlKSB7XG4gICAgLyoqXG4gICAgICogUmVseSBvbiB0aGUgc2VydmVyIGRlZmF1bHQgZ2VuZXJhdGlvbiBtb2RlLlxuICAgICAqL1xuICAgIE11c2ljR2VuZXJhdGlvbk1vZGVbXCJNVVNJQ19HRU5FUkFUSU9OX01PREVfVU5TUEVDSUZJRURcIl0gPSBcIk1VU0lDX0dFTkVSQVRJT05fTU9ERV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFN0ZWVyIHRleHQgcHJvbXB0cyB0byByZWdpb25zIG9mIGxhdGVudCBzcGFjZSB3aXRoIGhpZ2hlciBxdWFsaXR5XG4gICAgICAgIG11c2ljLlxuICAgICAqL1xuICAgIE11c2ljR2VuZXJhdGlvbk1vZGVbXCJRVUFMSVRZXCJdID0gXCJRVUFMSVRZXCI7XG4gICAgLyoqXG4gICAgICogU3RlZXIgdGV4dCBwcm9tcHRzIHRvIHJlZ2lvbnMgb2YgbGF0ZW50IHNwYWNlIHdpdGggYSBsYXJnZXJcbiAgICAgICAgZGl2ZXJzaXR5IG9mIG11c2ljLlxuICAgICAqL1xuICAgIE11c2ljR2VuZXJhdGlvbk1vZGVbXCJESVZFUlNJVFlcIl0gPSBcIkRJVkVSU0lUWVwiO1xuICAgIC8qKlxuICAgICAqIFN0ZWVyIHRleHQgcHJvbXB0cyB0byByZWdpb25zIG9mIGxhdGVudCBzcGFjZSBtb3JlIGxpa2VseSB0b1xuICAgICAgICBnZW5lcmF0ZSBtdXNpYyB3aXRoIHZvY2Fscy5cbiAgICAgKi9cbiAgICBNdXNpY0dlbmVyYXRpb25Nb2RlW1wiVk9DQUxJWkFUSU9OXCJdID0gXCJWT0NBTElaQVRJT05cIjtcbn0pKE11c2ljR2VuZXJhdGlvbk1vZGUgfHwgKE11c2ljR2VuZXJhdGlvbk1vZGUgPSB7fSkpO1xuLyoqIFRoZSBwbGF5YmFjayBjb250cm9sIHNpZ25hbCB0byBhcHBseSB0byB0aGUgbXVzaWMgZ2VuZXJhdGlvbi4gKi9cbnZhciBMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2w7XG4oZnVuY3Rpb24gKExpdmVNdXNpY1BsYXliYWNrQ29udHJvbCkge1xuICAgIC8qKlxuICAgICAqIFRoaXMgdmFsdWUgaXMgdW51c2VkLlxuICAgICAqL1xuICAgIExpdmVNdXNpY1BsYXliYWNrQ29udHJvbFtcIlBMQVlCQUNLX0NPTlRST0xfVU5TUEVDSUZJRURcIl0gPSBcIlBMQVlCQUNLX0NPTlRST0xfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBTdGFydCBnZW5lcmF0aW5nIHRoZSBtdXNpYy5cbiAgICAgKi9cbiAgICBMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2xbXCJQTEFZXCJdID0gXCJQTEFZXCI7XG4gICAgLyoqXG4gICAgICogSG9sZCB0aGUgbXVzaWMgZ2VuZXJhdGlvbi4gVXNlIFBMQVkgdG8gcmVzdW1lIGZyb20gdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICovXG4gICAgTGl2ZU11c2ljUGxheWJhY2tDb250cm9sW1wiUEFVU0VcIl0gPSBcIlBBVVNFXCI7XG4gICAgLyoqXG4gICAgICogU3RvcCB0aGUgbXVzaWMgZ2VuZXJhdGlvbiBhbmQgcmVzZXQgdGhlIGNvbnRleHQgKHByb21wdHMgcmV0YWluZWQpLlxuICAgICAgICBVc2UgUExBWSB0byByZXN0YXJ0IHRoZSBtdXNpYyBnZW5lcmF0aW9uLlxuICAgICAqL1xuICAgIExpdmVNdXNpY1BsYXliYWNrQ29udHJvbFtcIlNUT1BcIl0gPSBcIlNUT1BcIjtcbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgY29udGV4dCBvZiB0aGUgbXVzaWMgZ2VuZXJhdGlvbiB3aXRob3V0IHN0b3BwaW5nIGl0LlxuICAgICAgICBSZXRhaW5zIHRoZSBjdXJyZW50IHByb21wdHMgYW5kIGNvbmZpZy5cbiAgICAgKi9cbiAgICBMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2xbXCJSRVNFVF9DT05URVhUXCJdID0gXCJSRVNFVF9DT05URVhUXCI7XG59KShMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2wgfHwgKExpdmVNdXNpY1BsYXliYWNrQ29udHJvbCA9IHt9KSk7XG4vKiogUmF3IG1lZGlhIGJ5dGVzIGZvciBmdW5jdGlvbiByZXNwb25zZS5cblxuVGV4dCBzaG91bGQgbm90IGJlIHNlbnQgYXMgcmF3IGJ5dGVzLCB1c2UgdGhlIEZ1bmN0aW9uUmVzcG9uc2UucmVzcG9uc2VcbmZpZWxkLiAqL1xuY2xhc3MgRnVuY3Rpb25SZXNwb25zZUJsb2Ige1xufVxuLyoqIFVSSSBiYXNlZCBkYXRhIGZvciBmdW5jdGlvbiByZXNwb25zZS4gKi9cbmNsYXNzIEZ1bmN0aW9uUmVzcG9uc2VGaWxlRGF0YSB7XG59XG4vKiogQSBkYXRhdHlwZSBjb250YWluaW5nIG1lZGlhIHRoYXQgaXMgcGFydCBvZiBhIGBGdW5jdGlvblJlc3BvbnNlYCBtZXNzYWdlLlxuXG5BIGBGdW5jdGlvblJlc3BvbnNlUGFydGAgY29uc2lzdHMgb2YgZGF0YSB3aGljaCBoYXMgYW4gYXNzb2NpYXRlZCBkYXRhdHlwZS4gQVxuYEZ1bmN0aW9uUmVzcG9uc2VQYXJ0YCBjYW4gb25seSBjb250YWluIG9uZSBvZiB0aGUgYWNjZXB0ZWQgdHlwZXMgaW5cbmBGdW5jdGlvblJlc3BvbnNlUGFydC5kYXRhYC5cblxuQSBgRnVuY3Rpb25SZXNwb25zZVBhcnRgIG11c3QgaGF2ZSBhIGZpeGVkIElBTkEgTUlNRSB0eXBlIGlkZW50aWZ5aW5nIHRoZVxudHlwZSBhbmQgc3VidHlwZSBvZiB0aGUgbWVkaWEgaWYgdGhlIGBpbmxpbmVfZGF0YWAgZmllbGQgaXMgZmlsbGVkIHdpdGggcmF3XG5ieXRlcy4gKi9cbmNsYXNzIEZ1bmN0aW9uUmVzcG9uc2VQYXJ0IHtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBGdW5jdGlvblJlc3BvbnNlUGFydGAgb2JqZWN0IGZyb20gYSBgYmFzZTY0YCBlbmNvZGVkIGBzdHJpbmdgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvblJlc3BvbnNlUGFydEZyb21CYXNlNjQoZGF0YSwgbWltZVR5cGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpbmxpbmVEYXRhOiB7XG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgbWltZVR5cGU6IG1pbWVUeXBlLFxuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBgRnVuY3Rpb25SZXNwb25zZVBhcnRgIG9iamVjdCBmcm9tIGEgYFVSSWAgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvblJlc3BvbnNlUGFydEZyb21VcmkodXJpLCBtaW1lVHlwZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZpbGVEYXRhOiB7XG4gICAgICAgICAgICBmaWxlVXJpOiB1cmksXG4gICAgICAgICAgICBtaW1lVHlwZTogbWltZVR5cGUsXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKiBBIGZ1bmN0aW9uIHJlc3BvbnNlLiAqL1xuY2xhc3MgRnVuY3Rpb25SZXNwb25zZSB7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBgUGFydGAgb2JqZWN0IGZyb20gYSBgVVJJYCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBhcnRGcm9tVXJpKHVyaSwgbWltZVR5cGUsIG1lZGlhUmVzb2x1dGlvbikge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgZmlsZURhdGE6IHtcbiAgICAgICAgICAgIGZpbGVVcmk6IHVyaSxcbiAgICAgICAgICAgIG1pbWVUeXBlOiBtaW1lVHlwZSxcbiAgICAgICAgfSB9LCAobWVkaWFSZXNvbHV0aW9uICYmIHsgbWVkaWFSZXNvbHV0aW9uOiB7IGxldmVsOiBtZWRpYVJlc29sdXRpb24gfSB9KSk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBgUGFydGAgb2JqZWN0IGZyb20gYSBgdGV4dGAgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBjcmVhdGVQYXJ0RnJvbVRleHQodGV4dCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHRleHQ6IHRleHQsXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBQYXJ0YCBvYmplY3QgZnJvbSBhIGBGdW5jdGlvbkNhbGxgIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGFydEZyb21GdW5jdGlvbkNhbGwobmFtZSwgYXJncykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZ1bmN0aW9uQ2FsbDoge1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGFyZ3M6IGFyZ3MsXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBQYXJ0YCBvYmplY3QgZnJvbSBhIGBGdW5jdGlvblJlc3BvbnNlYCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBhcnRGcm9tRnVuY3Rpb25SZXNwb25zZShpZCwgbmFtZSwgcmVzcG9uc2UsIHBhcnRzID0gW10pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmdW5jdGlvblJlc3BvbnNlOiBPYmplY3QuYXNzaWduKHsgaWQ6IGlkLCBuYW1lOiBuYW1lLCByZXNwb25zZTogcmVzcG9uc2UgfSwgKHBhcnRzLmxlbmd0aCA+IDAgJiYgeyBwYXJ0cyB9KSksXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBQYXJ0YCBvYmplY3QgZnJvbSBhIGBiYXNlNjRgIGVuY29kZWQgYHN0cmluZ2AuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBhcnRGcm9tQmFzZTY0KGRhdGEsIG1pbWVUeXBlLCBtZWRpYVJlc29sdXRpb24pIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IGlubGluZURhdGE6IHtcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICBtaW1lVHlwZTogbWltZVR5cGUsXG4gICAgICAgIH0gfSwgKG1lZGlhUmVzb2x1dGlvbiAmJiB7IG1lZGlhUmVzb2x1dGlvbjogeyBsZXZlbDogbWVkaWFSZXNvbHV0aW9uIH0gfSkpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYFBhcnRgIG9iamVjdCBmcm9tIHRoZSBgb3V0Y29tZWAgYW5kIGBvdXRwdXRgIG9mIGEgYENvZGVFeGVjdXRpb25SZXN1bHRgIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGFydEZyb21Db2RlRXhlY3V0aW9uUmVzdWx0KG91dGNvbWUsIG91dHB1dCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGVFeGVjdXRpb25SZXN1bHQ6IHtcbiAgICAgICAgICAgIG91dGNvbWU6IG91dGNvbWUsXG4gICAgICAgICAgICBvdXRwdXQ6IG91dHB1dCxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYFBhcnRgIG9iamVjdCBmcm9tIHRoZSBgY29kZWAgYW5kIGBsYW5ndWFnZWAgb2YgYW4gYEV4ZWN1dGFibGVDb2RlYCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBhcnRGcm9tRXhlY3V0YWJsZUNvZGUoY29kZSwgbGFuZ3VhZ2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBleGVjdXRhYmxlQ29kZToge1xuICAgICAgICAgICAgY29kZTogY29kZSxcbiAgICAgICAgICAgIGxhbmd1YWdlOiBsYW5ndWFnZSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gX2lzUGFydChvYmopIHtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAoJ2ZpbGVEYXRhJyBpbiBvYmogfHxcbiAgICAgICAgICAgICd0ZXh0JyBpbiBvYmogfHxcbiAgICAgICAgICAgICdmdW5jdGlvbkNhbGwnIGluIG9iaiB8fFxuICAgICAgICAgICAgJ2Z1bmN0aW9uUmVzcG9uc2UnIGluIG9iaiB8fFxuICAgICAgICAgICAgJ2lubGluZURhdGEnIGluIG9iaiB8fFxuICAgICAgICAgICAgJ3ZpZGVvTWV0YWRhdGEnIGluIG9iaiB8fFxuICAgICAgICAgICAgJ2NvZGVFeGVjdXRpb25SZXN1bHQnIGluIG9iaiB8fFxuICAgICAgICAgICAgJ2V4ZWN1dGFibGVDb2RlJyBpbiBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBfdG9QYXJ0cyhwYXJ0T3JTdHJpbmcpIHtcbiAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgIGlmICh0eXBlb2YgcGFydE9yU3RyaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXJ0cy5wdXNoKGNyZWF0ZVBhcnRGcm9tVGV4dChwYXJ0T3JTdHJpbmcpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoX2lzUGFydChwYXJ0T3JTdHJpbmcpKSB7XG4gICAgICAgIHBhcnRzLnB1c2gocGFydE9yU3RyaW5nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwYXJ0T3JTdHJpbmcpKSB7XG4gICAgICAgIGlmIChwYXJ0T3JTdHJpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcnRPclN0cmluZyBjYW5ub3QgYmUgYW4gZW1wdHkgYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydE9yU3RyaW5nKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChjcmVhdGVQYXJ0RnJvbVRleHQocGFydCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX2lzUGFydChwYXJ0KSkge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2gocGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VsZW1lbnQgaW4gUGFydFVuaW9uIG11c3QgYmUgYSBQYXJ0IG9iamVjdCBvciBzdHJpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXJ0T3JTdHJpbmcgbXVzdCBiZSBhIFBhcnQgb2JqZWN0LCBzdHJpbmcsIG9yIGFycmF5Jyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0cztcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBDb250ZW50YCBvYmplY3Qgd2l0aCBhIHVzZXIgcm9sZSBmcm9tIGEgYFBhcnRMaXN0VW5pb25gIG9iamVjdCBvciBgc3RyaW5nYC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVXNlckNvbnRlbnQocGFydE9yU3RyaW5nKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICBwYXJ0czogX3RvUGFydHMocGFydE9yU3RyaW5nKSxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYENvbnRlbnRgIG9iamVjdCB3aXRoIGEgbW9kZWwgcm9sZSBmcm9tIGEgYFBhcnRMaXN0VW5pb25gIG9iamVjdCBvciBgc3RyaW5nYC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTW9kZWxDb250ZW50KHBhcnRPclN0cmluZykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6ICdtb2RlbCcsXG4gICAgICAgIHBhcnRzOiBfdG9QYXJ0cyhwYXJ0T3JTdHJpbmcpLFxuICAgIH07XG59XG4vKiogQSB3cmFwcGVyIGNsYXNzIGZvciB0aGUgaHR0cCByZXNwb25zZS4gKi9cbmNsYXNzIEh0dHBSZXNwb25zZSB7XG4gICAgY29uc3RydWN0b3IocmVzcG9uc2UpIHtcbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgaGVhZGVycy5cbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcmVzcG9uc2UuaGVhZGVycy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbcGFpclswXV0gPSBwYWlyWzFdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICAgIC8vIEtlZXAgdGhlIG9yaWdpbmFsIHJlc3BvbnNlLlxuICAgICAgICB0aGlzLnJlc3BvbnNlSW50ZXJuYWwgPSByZXNwb25zZTtcbiAgICB9XG4gICAganNvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzcG9uc2VJbnRlcm5hbC5qc29uKCk7XG4gICAgfVxufVxuLyoqIENvbnRlbnQgZmlsdGVyIHJlc3VsdHMgZm9yIGEgcHJvbXB0IHNlbnQgaW4gdGhlIHJlcXVlc3QuIE5vdGU6IFRoaXMgaXMgc2VudCBvbmx5IGluIHRoZSBmaXJzdCBzdHJlYW0gY2h1bmsgYW5kIG9ubHkgaWYgbm8gY2FuZGlkYXRlcyB3ZXJlIGdlbmVyYXRlZCBkdWUgdG8gY29udGVudCB2aW9sYXRpb25zLiAqL1xuY2xhc3MgR2VuZXJhdGVDb250ZW50UmVzcG9uc2VQcm9tcHRGZWVkYmFjayB7XG59XG4vKiogVXNhZ2UgbWV0YWRhdGEgYWJvdXQgdGhlIGNvbnRlbnQgZ2VuZXJhdGlvbiByZXF1ZXN0IGFuZCByZXNwb25zZS4gVGhpcyBtZXNzYWdlIHByb3ZpZGVzIGEgZGV0YWlsZWQgYnJlYWtkb3duIG9mIHRva2VuIHVzYWdlIGFuZCBvdGhlciByZWxldmFudCBtZXRyaWNzLiBUaGlzIGRhdGEgdHlwZSBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuICovXG5jbGFzcyBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZVVzYWdlTWV0YWRhdGEge1xufVxuLyoqIFJlc3BvbnNlIG1lc3NhZ2UgZm9yIFByZWRpY3Rpb25TZXJ2aWNlLkdlbmVyYXRlQ29udGVudC4gKi9cbmNsYXNzIEdlbmVyYXRlQ29udGVudFJlc3BvbnNlIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb25jYXRlbmF0aW9uIG9mIGFsbCB0ZXh0IHBhcnRzIGZyb20gdGhlIGZpcnN0IGNhbmRpZGF0ZSBpbiB0aGUgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBjYW5kaWRhdGVzIGluIHRoZSByZXNwb25zZSwgdGhlIHRleHQgZnJvbSB0aGUgZmlyc3RcbiAgICAgKiBvbmUgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKiBJZiB0aGVyZSBhcmUgbm9uLXRleHQgcGFydHMgaW4gdGhlIHJlc3BvbnNlLCB0aGUgY29uY2F0ZW5hdGlvbiBvZiBhbGwgdGV4dFxuICAgICAqIHBhcnRzIHdpbGwgYmUgcmV0dXJuZWQsIGFuZCBhIHdhcm5pbmcgd2lsbCBiZSBsb2dnZWQuXG4gICAgICogSWYgdGhlcmUgYXJlIHRob3VnaHQgcGFydHMgaW4gdGhlIHJlc3BvbnNlLCB0aGUgY29uY2F0ZW5hdGlvbiBvZiBhbGwgdGV4dFxuICAgICAqIHBhcnRzIGV4Y2x1ZGluZyB0aGUgdGhvdWdodCBwYXJ0cyB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmdlbmVyYXRlQ29udGVudCh7XG4gICAgICogICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnLFxuICAgICAqICAgY29udGVudHM6XG4gICAgICogICAgICdXaHkgaXMgdGhlIHNreSBibHVlPycsXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmRlYnVnKHJlc3BvbnNlLnRleHQpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCB0ZXh0KCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oO1xuICAgICAgICBpZiAoKChfZCA9IChfYyA9IChfYiA9IChfYSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY29udGVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnBhcnRzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jYW5kaWRhdGVzICYmIHRoaXMuY2FuZGlkYXRlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3RoZXJlIGFyZSBtdWx0aXBsZSBjYW5kaWRhdGVzIGluIHRoZSByZXNwb25zZSwgcmV0dXJuaW5nIHRleHQgZnJvbSB0aGUgZmlyc3Qgb25lLicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0ZXh0ID0gJyc7XG4gICAgICAgIGxldCBhbnlUZXh0UGFydFRleHQgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgbm9uVGV4dFBhcnRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiAoX2ggPSAoX2cgPSAoX2YgPSAoX2UgPSB0aGlzLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZVswXSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNvbnRlbnQpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5wYXJ0cykgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogW10pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgZmllbGRWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocGFydCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGROYW1lICE9PSAndGV4dCcgJiZcbiAgICAgICAgICAgICAgICAgICAgZmllbGROYW1lICE9PSAndGhvdWdodCcgJiZcbiAgICAgICAgICAgICAgICAgICAgZmllbGROYW1lICE9PSAndGhvdWdodFNpZ25hdHVyZScgJiZcbiAgICAgICAgICAgICAgICAgICAgKGZpZWxkVmFsdWUgIT09IG51bGwgfHwgZmllbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgICAgICBub25UZXh0UGFydHMucHVzaChmaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydC50ZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydC50aG91Z2h0ID09PSAnYm9vbGVhbicgJiYgcGFydC50aG91Z2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhbnlUZXh0UGFydFRleHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRleHQgKz0gcGFydC50ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub25UZXh0UGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGB0aGVyZSBhcmUgbm9uLXRleHQgcGFydHMgJHtub25UZXh0UGFydHN9IGluIHRoZSByZXNwb25zZSwgcmV0dXJuaW5nIGNvbmNhdGVuYXRpb24gb2YgYWxsIHRleHQgcGFydHMuIFBsZWFzZSByZWZlciB0byB0aGUgbm9uIHRleHQgcGFydHMgZm9yIGEgZnVsbCByZXNwb25zZSBmcm9tIG1vZGVsLmApO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhcnQudGV4dCA9PT0gJycgaXMgZGlmZmVyZW50IGZyb20gcGFydC50ZXh0IGlzIG51bGxcbiAgICAgICAgcmV0dXJuIGFueVRleHRQYXJ0VGV4dCA/IHRleHQgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIGlubGluZSBkYXRhIHBhcnRzIGZyb20gdGhlIGZpcnN0IGNhbmRpZGF0ZVxuICAgICAqIGluIHRoZSByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSWYgdGhlcmUgYXJlIG11bHRpcGxlIGNhbmRpZGF0ZXMgaW4gdGhlIHJlc3BvbnNlLCB0aGUgaW5saW5lIGRhdGEgZnJvbSB0aGVcbiAgICAgKiBmaXJzdCBvbmUgd2lsbCBiZSByZXR1cm5lZC4gSWYgdGhlcmUgYXJlIG5vbi1pbmxpbmUgZGF0YSBwYXJ0cyBpbiB0aGVcbiAgICAgKiByZXNwb25zZSwgdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIGlubGluZSBkYXRhIHBhcnRzIHdpbGwgYmUgcmV0dXJuZWQsIGFuZFxuICAgICAqIGEgd2FybmluZyB3aWxsIGJlIGxvZ2dlZC5cbiAgICAgKi9cbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICAgICAgaWYgKCgoX2QgPSAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvbnRlbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5wYXJ0cykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmxlbmd0aCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2FuZGlkYXRlcyAmJiB0aGlzLmNhbmRpZGF0ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCd0aGVyZSBhcmUgbXVsdGlwbGUgY2FuZGlkYXRlcyBpbiB0aGUgcmVzcG9uc2UsIHJldHVybmluZyBkYXRhIGZyb20gdGhlIGZpcnN0IG9uZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGF0YSA9ICcnO1xuICAgICAgICBjb25zdCBub25EYXRhUGFydHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIChfaCA9IChfZyA9IChfZiA9IChfZSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lWzBdKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY29udGVudCkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLnBhcnRzKSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiBbXSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbZmllbGROYW1lLCBmaWVsZFZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwYXJ0KSkge1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZE5hbWUgIT09ICdpbmxpbmVEYXRhJyAmJlxuICAgICAgICAgICAgICAgICAgICAoZmllbGRWYWx1ZSAhPT0gbnVsbCB8fCBmaWVsZFZhbHVlICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vbkRhdGFQYXJ0cy5wdXNoKGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcnQuaW5saW5lRGF0YSAmJiB0eXBlb2YgcGFydC5pbmxpbmVEYXRhLmRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZGF0YSArPSBhdG9iKHBhcnQuaW5saW5lRGF0YS5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9uRGF0YVBhcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgdGhlcmUgYXJlIG5vbi1kYXRhIHBhcnRzICR7bm9uRGF0YVBhcnRzfSBpbiB0aGUgcmVzcG9uc2UsIHJldHVybmluZyBjb25jYXRlbmF0aW9uIG9mIGFsbCBkYXRhIHBhcnRzLiBQbGVhc2UgcmVmZXIgdG8gdGhlIG5vbiBkYXRhIHBhcnRzIGZvciBhIGZ1bGwgcmVzcG9uc2UgZnJvbSBtb2RlbC5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YS5sZW5ndGggPiAwID8gYnRvYShkYXRhKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZnVuY3Rpb24gY2FsbHMgZnJvbSB0aGUgZmlyc3QgY2FuZGlkYXRlIGluIHRoZSByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSWYgdGhlcmUgYXJlIG11bHRpcGxlIGNhbmRpZGF0ZXMgaW4gdGhlIHJlc3BvbnNlLCB0aGUgZnVuY3Rpb24gY2FsbHMgZnJvbVxuICAgICAqIHRoZSBmaXJzdCBvbmUgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKiBJZiB0aGVyZSBhcmUgbm8gZnVuY3Rpb24gY2FsbHMgaW4gdGhlIHJlc3BvbnNlLCB1bmRlZmluZWQgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBjb250cm9sTGlnaHRGdW5jdGlvbkRlY2xhcmF0aW9uOiBGdW5jdGlvbkRlY2xhcmF0aW9uID0ge1xuICAgICAqICAgbmFtZTogJ2NvbnRyb2xMaWdodCcsXG4gICAgICogICBwYXJhbWV0ZXJzOiB7XG4gICAgICogICB0eXBlOiBUeXBlLk9CSkVDVCxcbiAgICAgKiAgIGRlc2NyaXB0aW9uOiAnU2V0IHRoZSBicmlnaHRuZXNzIGFuZCBjb2xvciB0ZW1wZXJhdHVyZSBvZiBhIHJvb20gbGlnaHQuJyxcbiAgICAgKiAgIHByb3BlcnRpZXM6IHtcbiAgICAgKiAgICAgYnJpZ2h0bmVzczoge1xuICAgICAqICAgICAgIHR5cGU6IFR5cGUuTlVNQkVSLFxuICAgICAqICAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAqICAgICAgICAgJ0xpZ2h0IGxldmVsIGZyb20gMCB0byAxMDAuIFplcm8gaXMgb2ZmIGFuZCAxMDAgaXMgZnVsbCBicmlnaHRuZXNzLicsXG4gICAgICogICAgIH0sXG4gICAgICogICAgIGNvbG9yVGVtcGVyYXR1cmU6IHtcbiAgICAgKiAgICAgICB0eXBlOiBUeXBlLlNUUklORyxcbiAgICAgKiAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgKiAgICAgICAgICdDb2xvciB0ZW1wZXJhdHVyZSBvZiB0aGUgbGlnaHQgZml4dHVyZSB3aGljaCBjYW4gYmUgYGRheWxpZ2h0YCwgYGNvb2xgIG9yIGB3YXJtYC4nLFxuICAgICAqICAgICB9LFxuICAgICAqICAgfSxcbiAgICAgKiAgIHJlcXVpcmVkOiBbJ2JyaWdodG5lc3MnLCAnY29sb3JUZW1wZXJhdHVyZSddLFxuICAgICAqICB9O1xuICAgICAqICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy5nZW5lcmF0ZUNvbnRlbnQoe1xuICAgICAqICAgICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnLFxuICAgICAqICAgICBjb250ZW50czogJ0RpbSB0aGUgbGlnaHRzIHNvIHRoZSByb29tIGZlZWxzIGNvenkgYW5kIHdhcm0uJyxcbiAgICAgKiAgICAgY29uZmlnOiB7XG4gICAgICogICAgICAgdG9vbHM6IFt7ZnVuY3Rpb25EZWNsYXJhdGlvbnM6IFtjb250cm9sTGlnaHRGdW5jdGlvbkRlY2xhcmF0aW9uXX1dLFxuICAgICAqICAgICAgIHRvb2xDb25maWc6IHtcbiAgICAgKiAgICAgICAgIGZ1bmN0aW9uQ2FsbGluZ0NvbmZpZzoge1xuICAgICAqICAgICAgICAgICBtb2RlOiBGdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlLkFOWSxcbiAgICAgKiAgICAgICAgICAgYWxsb3dlZEZ1bmN0aW9uTmFtZXM6IFsnY29udHJvbExpZ2h0J10sXG4gICAgICogICAgICAgICB9LFxuICAgICAqICAgICAgIH0sXG4gICAgICogICAgIH0sXG4gICAgICogICB9KTtcbiAgICAgKiAgY29uc29sZS5kZWJ1ZyhKU09OLnN0cmluZ2lmeShyZXNwb25zZS5mdW5jdGlvbkNhbGxzKSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IGZ1bmN0aW9uQ2FsbHMoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2g7XG4gICAgICAgIGlmICgoKF9kID0gKF9jID0gKF9iID0gKF9hID0gdGhpcy5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb250ZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucGFydHMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5sZW5ndGgpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNhbmRpZGF0ZXMgJiYgdGhpcy5jYW5kaWRhdGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigndGhlcmUgYXJlIG11bHRpcGxlIGNhbmRpZGF0ZXMgaW4gdGhlIHJlc3BvbnNlLCByZXR1cm5pbmcgZnVuY3Rpb24gY2FsbHMgZnJvbSB0aGUgZmlyc3Qgb25lLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbHMgPSAoX2ggPSAoX2cgPSAoX2YgPSAoX2UgPSB0aGlzLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZVswXSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNvbnRlbnQpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5wYXJ0cykgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLmZpbHRlcigocGFydCkgPT4gcGFydC5mdW5jdGlvbkNhbGwpLm1hcCgocGFydCkgPT4gcGFydC5mdW5jdGlvbkNhbGwpLmZpbHRlcigoZnVuY3Rpb25DYWxsKSA9PiBmdW5jdGlvbkNhbGwgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmICgoZnVuY3Rpb25DYWxscyA9PT0gbnVsbCB8fCBmdW5jdGlvbkNhbGxzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmdW5jdGlvbkNhbGxzLmxlbmd0aCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uQ2FsbHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGV4ZWN1dGFibGUgY29kZSBmcm9tIHRoZSBmaXJzdCBjYW5kaWRhdGUgaW4gdGhlIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgY2FuZGlkYXRlcyBpbiB0aGUgcmVzcG9uc2UsIHRoZSBleGVjdXRhYmxlIGNvZGUgZnJvbVxuICAgICAqIHRoZSBmaXJzdCBvbmUgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKiBJZiB0aGVyZSBhcmUgbm8gZXhlY3V0YWJsZSBjb2RlIGluIHRoZSByZXNwb25zZSwgdW5kZWZpbmVkIHdpbGwgYmVcbiAgICAgKiByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy5nZW5lcmF0ZUNvbnRlbnQoe1xuICAgICAqICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJyxcbiAgICAgKiAgIGNvbnRlbnRzOlxuICAgICAqICAgICAnV2hhdCBpcyB0aGUgc3VtIG9mIHRoZSBmaXJzdCA1MCBwcmltZSBudW1iZXJzPyBHZW5lcmF0ZSBhbmQgcnVuIGNvZGUgZm9yIHRoZSBjYWxjdWxhdGlvbiwgYW5kIG1ha2Ugc3VyZSB5b3UgZ2V0IGFsbCA1MC4nXG4gICAgICogICBjb25maWc6IHtcbiAgICAgKiAgICAgdG9vbHM6IFt7Y29kZUV4ZWN1dGlvbjoge319XSxcbiAgICAgKiAgIH0sXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmRlYnVnKHJlc3BvbnNlLmV4ZWN1dGFibGVDb2RlKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgZXhlY3V0YWJsZUNvZGUoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qO1xuICAgICAgICBpZiAoKChfZCA9IChfYyA9IChfYiA9IChfYSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY29udGVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnBhcnRzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jYW5kaWRhdGVzICYmIHRoaXMuY2FuZGlkYXRlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3RoZXJlIGFyZSBtdWx0aXBsZSBjYW5kaWRhdGVzIGluIHRoZSByZXNwb25zZSwgcmV0dXJuaW5nIGV4ZWN1dGFibGUgY29kZSBmcm9tIHRoZSBmaXJzdCBvbmUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXhlY3V0YWJsZUNvZGUgPSAoX2ggPSAoX2cgPSAoX2YgPSAoX2UgPSB0aGlzLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZVswXSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNvbnRlbnQpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5wYXJ0cykgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLmZpbHRlcigocGFydCkgPT4gcGFydC5leGVjdXRhYmxlQ29kZSkubWFwKChwYXJ0KSA9PiBwYXJ0LmV4ZWN1dGFibGVDb2RlKS5maWx0ZXIoKGV4ZWN1dGFibGVDb2RlKSA9PiBleGVjdXRhYmxlQ29kZSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKChleGVjdXRhYmxlQ29kZSA9PT0gbnVsbCB8fCBleGVjdXRhYmxlQ29kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXhlY3V0YWJsZUNvZGUubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKF9qID0gZXhlY3V0YWJsZUNvZGUgPT09IG51bGwgfHwgZXhlY3V0YWJsZUNvZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4ZWN1dGFibGVDb2RlWzBdKSA9PT0gbnVsbCB8fCBfaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ouY29kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgY29kZSBleGVjdXRpb24gcmVzdWx0IGZyb20gdGhlIGZpcnN0IGNhbmRpZGF0ZSBpbiB0aGUgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBjYW5kaWRhdGVzIGluIHRoZSByZXNwb25zZSwgdGhlIGNvZGUgZXhlY3V0aW9uIHJlc3VsdCBmcm9tXG4gICAgICogdGhlIGZpcnN0IG9uZSB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIElmIHRoZXJlIGFyZSBubyBjb2RlIGV4ZWN1dGlvbiByZXN1bHQgaW4gdGhlIHJlc3BvbnNlLCB1bmRlZmluZWQgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy5nZW5lcmF0ZUNvbnRlbnQoe1xuICAgICAqICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJyxcbiAgICAgKiAgIGNvbnRlbnRzOlxuICAgICAqICAgICAnV2hhdCBpcyB0aGUgc3VtIG9mIHRoZSBmaXJzdCA1MCBwcmltZSBudW1iZXJzPyBHZW5lcmF0ZSBhbmQgcnVuIGNvZGUgZm9yIHRoZSBjYWxjdWxhdGlvbiwgYW5kIG1ha2Ugc3VyZSB5b3UgZ2V0IGFsbCA1MC4nXG4gICAgICogICBjb25maWc6IHtcbiAgICAgKiAgICAgdG9vbHM6IFt7Y29kZUV4ZWN1dGlvbjoge319XSxcbiAgICAgKiAgIH0sXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmRlYnVnKHJlc3BvbnNlLmNvZGVFeGVjdXRpb25SZXN1bHQpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBjb2RlRXhlY3V0aW9uUmVzdWx0KCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfajtcbiAgICAgICAgaWYgKCgoX2QgPSAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvbnRlbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5wYXJ0cykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmxlbmd0aCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2FuZGlkYXRlcyAmJiB0aGlzLmNhbmRpZGF0ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCd0aGVyZSBhcmUgbXVsdGlwbGUgY2FuZGlkYXRlcyBpbiB0aGUgcmVzcG9uc2UsIHJldHVybmluZyBjb2RlIGV4ZWN1dGlvbiByZXN1bHQgZnJvbSB0aGUgZmlyc3Qgb25lLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvZGVFeGVjdXRpb25SZXN1bHQgPSAoX2ggPSAoX2cgPSAoX2YgPSAoX2UgPSB0aGlzLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZVswXSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNvbnRlbnQpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5wYXJ0cykgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLmZpbHRlcigocGFydCkgPT4gcGFydC5jb2RlRXhlY3V0aW9uUmVzdWx0KS5tYXAoKHBhcnQpID0+IHBhcnQuY29kZUV4ZWN1dGlvblJlc3VsdCkuZmlsdGVyKChjb2RlRXhlY3V0aW9uUmVzdWx0KSA9PiBjb2RlRXhlY3V0aW9uUmVzdWx0ICE9PSB1bmRlZmluZWQpO1xuICAgICAgICBpZiAoKGNvZGVFeGVjdXRpb25SZXN1bHQgPT09IG51bGwgfHwgY29kZUV4ZWN1dGlvblJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29kZUV4ZWN1dGlvblJlc3VsdC5sZW5ndGgpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoX2ogPSBjb2RlRXhlY3V0aW9uUmVzdWx0ID09PSBudWxsIHx8IGNvZGVFeGVjdXRpb25SZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvZGVFeGVjdXRpb25SZXN1bHRbMF0pID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfai5vdXRwdXQ7XG4gICAgfVxufVxuLyoqIFJlc3BvbnNlIGZvciB0aGUgZW1iZWRfY29udGVudCBtZXRob2QuICovXG5jbGFzcyBFbWJlZENvbnRlbnRSZXNwb25zZSB7XG59XG4vKiogVGhlIG91dHB1dCBpbWFnZXMgcmVzcG9uc2UuICovXG5jbGFzcyBHZW5lcmF0ZUltYWdlc1Jlc3BvbnNlIHtcbn1cbi8qKiBSZXNwb25zZSBmb3IgdGhlIHJlcXVlc3QgdG8gZWRpdCBhbiBpbWFnZS4gKi9cbmNsYXNzIEVkaXRJbWFnZVJlc3BvbnNlIHtcbn1cbmNsYXNzIFVwc2NhbGVJbWFnZVJlc3BvbnNlIHtcbn1cbi8qKiBUaGUgb3V0cHV0IGltYWdlcyByZXNwb25zZS4gKi9cbmNsYXNzIFJlY29udGV4dEltYWdlUmVzcG9uc2Uge1xufVxuLyoqIFRoZSBvdXRwdXQgaW1hZ2VzIHJlc3BvbnNlLiAqL1xuY2xhc3MgU2VnbWVudEltYWdlUmVzcG9uc2Uge1xufVxuY2xhc3MgTGlzdE1vZGVsc1Jlc3BvbnNlIHtcbn1cbmNsYXNzIERlbGV0ZU1vZGVsUmVzcG9uc2Uge1xufVxuLyoqIFJlc3BvbnNlIGZvciBjb3VudGluZyB0b2tlbnMuICovXG5jbGFzcyBDb3VudFRva2Vuc1Jlc3BvbnNlIHtcbn1cbi8qKiBSZXNwb25zZSBmb3IgY29tcHV0aW5nIHRva2Vucy4gKi9cbmNsYXNzIENvbXB1dGVUb2tlbnNSZXNwb25zZSB7XG59XG4vKiogUmVzcG9uc2Ugd2l0aCBnZW5lcmF0ZWQgdmlkZW9zLiAqL1xuY2xhc3MgR2VuZXJhdGVWaWRlb3NSZXNwb25zZSB7XG59XG4vKiogQSB2aWRlbyBnZW5lcmF0aW9uIG9wZXJhdGlvbi4gKi9cbmNsYXNzIEdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uIHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZXMgYW4gT3BlcmF0aW9uIG9mIHRoZSBzYW1lIHR5cGUgYXMgdGhlIG9uZSBiZWluZyBjYWxsZWQgd2l0aCB0aGUgZmllbGRzIHNldCBmcm9tIHRoZSBBUEkgcmVzcG9uc2UuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX2Zyb21BUElSZXNwb25zZSh7IGFwaVJlc3BvbnNlLCBfaXNWZXJ0ZXhBSSwgfSkge1xuICAgICAgICBjb25zdCBvcGVyYXRpb24gPSBuZXcgR2VuZXJhdGVWaWRlb3NPcGVyYXRpb24oKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBjb25zdCBvcCA9IGFwaVJlc3BvbnNlO1xuICAgICAgICBpZiAoX2lzVmVydGV4QUkpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gZ2VuZXJhdGVWaWRlb3NPcGVyYXRpb25Gcm9tVmVydGV4JDEob3ApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBnZW5lcmF0ZVZpZGVvc09wZXJhdGlvbkZyb21NbGRldiQxKG9wKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuYXNzaWduKG9wZXJhdGlvbiwgcmVzcG9uc2UpO1xuICAgICAgICByZXR1cm4gb3BlcmF0aW9uO1xuICAgIH1cbn1cbi8qKiBSZXNwb25zZSBmb3IgdGhlIGxpc3QgdHVuaW5nIGpvYnMgbWV0aG9kLiAqL1xuY2xhc3MgTGlzdFR1bmluZ0pvYnNSZXNwb25zZSB7XG59XG4vKiogRW1wdHkgcmVzcG9uc2UgZm9yIHR1bmluZ3MuY2FuY2VsIG1ldGhvZC4gKi9cbmNsYXNzIENhbmNlbFR1bmluZ0pvYlJlc3BvbnNlIHtcbn1cbi8qKiBFbXB0eSByZXNwb25zZSBmb3IgY2FjaGVzLmRlbGV0ZSBtZXRob2QuICovXG5jbGFzcyBEZWxldGVDYWNoZWRDb250ZW50UmVzcG9uc2Uge1xufVxuY2xhc3MgTGlzdENhY2hlZENvbnRlbnRzUmVzcG9uc2Uge1xufVxuLyoqIENvbmZpZyBmb3IgZG9jdW1lbnRzLmxpc3QgcmV0dXJuIHZhbHVlLiAqL1xuY2xhc3MgTGlzdERvY3VtZW50c1Jlc3BvbnNlIHtcbn1cbi8qKiBDb25maWcgZm9yIGZpbGVfc2VhcmNoX3N0b3Jlcy5saXN0IHJldHVybiB2YWx1ZS4gKi9cbmNsYXNzIExpc3RGaWxlU2VhcmNoU3RvcmVzUmVzcG9uc2Uge1xufVxuLyoqIFJlc3BvbnNlIGZvciB0aGUgcmVzdW1hYmxlIHVwbG9hZCBtZXRob2QuICovXG5jbGFzcyBVcGxvYWRUb0ZpbGVTZWFyY2hTdG9yZVJlc3VtYWJsZVJlc3BvbnNlIHtcbn1cbi8qKiBSZXNwb25zZSBmb3IgSW1wb3J0RmlsZSB0byBpbXBvcnQgYSBGaWxlIEFQSSBmaWxlIHdpdGggYSBmaWxlIHNlYXJjaCBzdG9yZS4gKi9cbmNsYXNzIEltcG9ydEZpbGVSZXNwb25zZSB7XG59XG4vKiogTG9uZy1ydW5uaW5nIG9wZXJhdGlvbiBmb3IgaW1wb3J0aW5nIGEgZmlsZSB0byBhIEZpbGVTZWFyY2hTdG9yZS4gKi9cbmNsYXNzIEltcG9ydEZpbGVPcGVyYXRpb24ge1xuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlcyBhbiBPcGVyYXRpb24gb2YgdGhlIHNhbWUgdHlwZSBhcyB0aGUgb25lIGJlaW5nIGNhbGxlZCB3aXRoIHRoZSBmaWVsZHMgc2V0IGZyb20gdGhlIEFQSSByZXNwb25zZS5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfZnJvbUFQSVJlc3BvbnNlKHsgYXBpUmVzcG9uc2UsIF9pc1ZlcnRleEFJLCB9KSB7XG4gICAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IG5ldyBJbXBvcnRGaWxlT3BlcmF0aW9uKCk7XG4gICAgICAgIGNvbnN0IG9wID0gYXBpUmVzcG9uc2U7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gaW1wb3J0RmlsZU9wZXJhdGlvbkZyb21NbGRldiQxKG9wKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihvcGVyYXRpb24sIHJlc3BvbnNlKTtcbiAgICAgICAgcmV0dXJuIG9wZXJhdGlvbjtcbiAgICB9XG59XG4vKiogUmVzcG9uc2UgZm9yIHRoZSBsaXN0IGZpbGVzIG1ldGhvZC4gKi9cbmNsYXNzIExpc3RGaWxlc1Jlc3BvbnNlIHtcbn1cbi8qKiBSZXNwb25zZSBmb3IgdGhlIGNyZWF0ZSBmaWxlIG1ldGhvZC4gKi9cbmNsYXNzIENyZWF0ZUZpbGVSZXNwb25zZSB7XG59XG4vKiogUmVzcG9uc2UgZm9yIHRoZSBkZWxldGUgZmlsZSBtZXRob2QuICovXG5jbGFzcyBEZWxldGVGaWxlUmVzcG9uc2Uge1xufVxuLyoqIENvbmZpZyBmb3IgYGlubGluZWRfcmVzcG9uc2VzYCBwYXJhbWV0ZXIuICovXG5jbGFzcyBJbmxpbmVkUmVzcG9uc2Uge1xufVxuLyoqIENvbmZpZyBmb3IgYHJlc3BvbnNlYCBwYXJhbWV0ZXIuICovXG5jbGFzcyBTaW5nbGVFbWJlZENvbnRlbnRSZXNwb25zZSB7XG59XG4vKiogQ29uZmlnIGZvciBgaW5saW5lZF9lbWJlZGRpbmdfcmVzcG9uc2VzYCBwYXJhbWV0ZXIuICovXG5jbGFzcyBJbmxpbmVkRW1iZWRDb250ZW50UmVzcG9uc2Uge1xufVxuLyoqIENvbmZpZyBmb3IgYmF0Y2hlcy5saXN0IHJldHVybiB2YWx1ZS4gKi9cbmNsYXNzIExpc3RCYXRjaEpvYnNSZXNwb25zZSB7XG59XG4vKiogUmVwcmVzZW50cyBhIHNpbmdsZSByZXNwb25zZSBpbiBhIHJlcGxheS4gKi9cbmNsYXNzIFJlcGxheVJlc3BvbnNlIHtcbn1cbi8qKiBBIHJhdyByZWZlcmVuY2UgaW1hZ2UuXG5cbkEgcmF3IHJlZmVyZW5jZSBpbWFnZSByZXByZXNlbnRzIHRoZSBiYXNlIGltYWdlIHRvIGVkaXQsIHByb3ZpZGVkIGJ5IHRoZSB1c2VyLlxuSXQgY2FuIG9wdGlvbmFsbHkgYmUgcHJvdmlkZWQgaW4gYWRkaXRpb24gdG8gYSBtYXNrIHJlZmVyZW5jZSBpbWFnZSBvclxuYSBzdHlsZSByZWZlcmVuY2UgaW1hZ2UuICovXG5jbGFzcyBSYXdSZWZlcmVuY2VJbWFnZSB7XG4gICAgLyoqIEludGVybmFsIG1ldGhvZCB0byBjb252ZXJ0IHRvIFJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWwuICovXG4gICAgdG9SZWZlcmVuY2VJbWFnZUFQSSgpIHtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlSW1hZ2VBUEkgPSB7XG4gICAgICAgICAgICByZWZlcmVuY2VUeXBlOiAnUkVGRVJFTkNFX1RZUEVfUkFXJyxcbiAgICAgICAgICAgIHJlZmVyZW5jZUltYWdlOiB0aGlzLnJlZmVyZW5jZUltYWdlLFxuICAgICAgICAgICAgcmVmZXJlbmNlSWQ6IHRoaXMucmVmZXJlbmNlSWQsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZWZlcmVuY2VJbWFnZUFQSTtcbiAgICB9XG59XG4vKiogQSBtYXNrIHJlZmVyZW5jZSBpbWFnZS5cblxuVGhpcyBlbmNhcHN1bGF0ZXMgZWl0aGVyIGEgbWFzayBpbWFnZSBwcm92aWRlZCBieSB0aGUgdXNlciBhbmQgY29uZmlncyBmb3JcbnRoZSB1c2VyIHByb3ZpZGVkIG1hc2ssIG9yIG9ubHkgY29uZmlnIHBhcmFtZXRlcnMgZm9yIHRoZSBtb2RlbCB0byBnZW5lcmF0ZVxuYSBtYXNrLlxuXG5BIG1hc2sgaW1hZ2UgaXMgYW4gaW1hZ2Ugd2hvc2Ugbm9uLXplcm8gdmFsdWVzIGluZGljYXRlIHdoZXJlIHRvIGVkaXQgdGhlIGJhc2VcbmltYWdlLiBJZiB0aGUgdXNlciBwcm92aWRlcyBhIG1hc2sgaW1hZ2UsIHRoZSBtYXNrIG11c3QgYmUgaW4gdGhlIHNhbWVcbmRpbWVuc2lvbnMgYXMgdGhlIHJhdyBpbWFnZS4gKi9cbmNsYXNzIE1hc2tSZWZlcmVuY2VJbWFnZSB7XG4gICAgLyoqIEludGVybmFsIG1ldGhvZCB0byBjb252ZXJ0IHRvIFJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWwuICovXG4gICAgdG9SZWZlcmVuY2VJbWFnZUFQSSgpIHtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlSW1hZ2VBUEkgPSB7XG4gICAgICAgICAgICByZWZlcmVuY2VUeXBlOiAnUkVGRVJFTkNFX1RZUEVfTUFTSycsXG4gICAgICAgICAgICByZWZlcmVuY2VJbWFnZTogdGhpcy5yZWZlcmVuY2VJbWFnZSxcbiAgICAgICAgICAgIHJlZmVyZW5jZUlkOiB0aGlzLnJlZmVyZW5jZUlkLFxuICAgICAgICAgICAgbWFza0ltYWdlQ29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZUltYWdlQVBJO1xuICAgIH1cbn1cbi8qKiBBIGNvbnRyb2wgcmVmZXJlbmNlIGltYWdlLlxuXG5UaGUgaW1hZ2Ugb2YgdGhlIGNvbnRyb2wgcmVmZXJlbmNlIGltYWdlIGlzIGVpdGhlciBhIGNvbnRyb2wgaW1hZ2UgcHJvdmlkZWRcbmJ5IHRoZSB1c2VyLCBvciBhIHJlZ3VsYXIgaW1hZ2Ugd2hpY2ggdGhlIGJhY2tlbmQgd2lsbCB1c2UgdG8gZ2VuZXJhdGUgYVxuY29udHJvbCBpbWFnZSBvZi4gSW4gdGhlIGNhc2Ugb2YgdGhlIGxhdHRlciwgdGhlXG5lbmFibGVfY29udHJvbF9pbWFnZV9jb21wdXRhdGlvbiBmaWVsZCBpbiB0aGUgY29uZmlnIHNob3VsZCBiZSBzZXQgdG8gVHJ1ZS5cblxuQSBjb250cm9sIGltYWdlIGlzIGFuIGltYWdlIHRoYXQgcmVwcmVzZW50cyBhIHNrZXRjaCBpbWFnZSBvZiBhcmVhcyBmb3IgdGhlXG5tb2RlbCB0byBmaWxsIGluIGJhc2VkIG9uIHRoZSBwcm9tcHQuICovXG5jbGFzcyBDb250cm9sUmVmZXJlbmNlSW1hZ2Uge1xuICAgIC8qKiBJbnRlcm5hbCBtZXRob2QgdG8gY29udmVydCB0byBSZWZlcmVuY2VJbWFnZUFQSUludGVybmFsLiAqL1xuICAgIHRvUmVmZXJlbmNlSW1hZ2VBUEkoKSB7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZUltYWdlQVBJID0ge1xuICAgICAgICAgICAgcmVmZXJlbmNlVHlwZTogJ1JFRkVSRU5DRV9UWVBFX0NPTlRST0wnLFxuICAgICAgICAgICAgcmVmZXJlbmNlSW1hZ2U6IHRoaXMucmVmZXJlbmNlSW1hZ2UsXG4gICAgICAgICAgICByZWZlcmVuY2VJZDogdGhpcy5yZWZlcmVuY2VJZCxcbiAgICAgICAgICAgIGNvbnRyb2xJbWFnZUNvbmZpZzogdGhpcy5jb25maWcsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZWZlcmVuY2VJbWFnZUFQSTtcbiAgICB9XG59XG4vKiogQSBzdHlsZSByZWZlcmVuY2UgaW1hZ2UuXG5cblRoaXMgZW5jYXBzdWxhdGVzIGEgc3R5bGUgcmVmZXJlbmNlIGltYWdlIHByb3ZpZGVkIGJ5IHRoZSB1c2VyLCBhbmRcbmFkZGl0aW9uYWxseSBvcHRpb25hbCBjb25maWcgcGFyYW1ldGVycyBmb3IgdGhlIHN0eWxlIHJlZmVyZW5jZSBpbWFnZS5cblxuQSByYXcgcmVmZXJlbmNlIGltYWdlIGNhbiBhbHNvIGJlIHByb3ZpZGVkIGFzIGEgZGVzdGluYXRpb24gZm9yIHRoZSBzdHlsZSB0b1xuYmUgYXBwbGllZCB0by4gKi9cbmNsYXNzIFN0eWxlUmVmZXJlbmNlSW1hZ2Uge1xuICAgIC8qKiBJbnRlcm5hbCBtZXRob2QgdG8gY29udmVydCB0byBSZWZlcmVuY2VJbWFnZUFQSUludGVybmFsLiAqL1xuICAgIHRvUmVmZXJlbmNlSW1hZ2VBUEkoKSB7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZUltYWdlQVBJID0ge1xuICAgICAgICAgICAgcmVmZXJlbmNlVHlwZTogJ1JFRkVSRU5DRV9UWVBFX1NUWUxFJyxcbiAgICAgICAgICAgIHJlZmVyZW5jZUltYWdlOiB0aGlzLnJlZmVyZW5jZUltYWdlLFxuICAgICAgICAgICAgcmVmZXJlbmNlSWQ6IHRoaXMucmVmZXJlbmNlSWQsXG4gICAgICAgICAgICBzdHlsZUltYWdlQ29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZUltYWdlQVBJO1xuICAgIH1cbn1cbi8qKiBBIHN1YmplY3QgcmVmZXJlbmNlIGltYWdlLlxuXG5UaGlzIGVuY2Fwc3VsYXRlcyBhIHN1YmplY3QgcmVmZXJlbmNlIGltYWdlIHByb3ZpZGVkIGJ5IHRoZSB1c2VyLCBhbmRcbmFkZGl0aW9uYWxseSBvcHRpb25hbCBjb25maWcgcGFyYW1ldGVycyBmb3IgdGhlIHN1YmplY3QgcmVmZXJlbmNlIGltYWdlLlxuXG5BIHJhdyByZWZlcmVuY2UgaW1hZ2UgY2FuIGFsc28gYmUgcHJvdmlkZWQgYXMgYSBkZXN0aW5hdGlvbiBmb3IgdGhlIHN1YmplY3QgdG9cbmJlIGFwcGxpZWQgdG8uICovXG5jbGFzcyBTdWJqZWN0UmVmZXJlbmNlSW1hZ2Uge1xuICAgIC8qIEludGVybmFsIG1ldGhvZCB0byBjb252ZXJ0IHRvIFJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWwuICovXG4gICAgdG9SZWZlcmVuY2VJbWFnZUFQSSgpIHtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlSW1hZ2VBUEkgPSB7XG4gICAgICAgICAgICByZWZlcmVuY2VUeXBlOiAnUkVGRVJFTkNFX1RZUEVfU1VCSkVDVCcsXG4gICAgICAgICAgICByZWZlcmVuY2VJbWFnZTogdGhpcy5yZWZlcmVuY2VJbWFnZSxcbiAgICAgICAgICAgIHJlZmVyZW5jZUlkOiB0aGlzLnJlZmVyZW5jZUlkLFxuICAgICAgICAgICAgc3ViamVjdEltYWdlQ29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZUltYWdlQVBJO1xuICAgIH1cbn1cbi8qKiBBIGNvbnRlbnQgcmVmZXJlbmNlIGltYWdlLlxuXG5BIGNvbnRlbnQgcmVmZXJlbmNlIGltYWdlIHJlcHJlc2VudHMgYSBzdWJqZWN0IHRvIHJlZmVyZW5jZSAoZXguIHBlcnNvbixcbnByb2R1Y3QsIGFuaW1hbCkgcHJvdmlkZWQgYnkgdGhlIHVzZXIuIEl0IGNhbiBvcHRpb25hbGx5IGJlIHByb3ZpZGVkIGluXG5hZGRpdGlvbiB0byBhIHN0eWxlIHJlZmVyZW5jZSBpbWFnZSAoZXguIGJhY2tncm91bmQsIHN0eWxlIHJlZmVyZW5jZSkuICovXG5jbGFzcyBDb250ZW50UmVmZXJlbmNlSW1hZ2Uge1xuICAgIC8qKiBJbnRlcm5hbCBtZXRob2QgdG8gY29udmVydCB0byBSZWZlcmVuY2VJbWFnZUFQSUludGVybmFsLiAqL1xuICAgIHRvUmVmZXJlbmNlSW1hZ2VBUEkoKSB7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZUltYWdlQVBJID0ge1xuICAgICAgICAgICAgcmVmZXJlbmNlVHlwZTogJ1JFRkVSRU5DRV9UWVBFX0NPTlRFTlQnLFxuICAgICAgICAgICAgcmVmZXJlbmNlSW1hZ2U6IHRoaXMucmVmZXJlbmNlSW1hZ2UsXG4gICAgICAgICAgICByZWZlcmVuY2VJZDogdGhpcy5yZWZlcmVuY2VJZCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZUltYWdlQVBJO1xuICAgIH1cbn1cbi8qKiBSZXNwb25zZSBtZXNzYWdlIGZvciBBUEkgY2FsbC4gKi9cbmNsYXNzIExpdmVTZXJ2ZXJNZXNzYWdlIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb25jYXRlbmF0aW9uIG9mIGFsbCB0ZXh0IHBhcnRzIGZyb20gdGhlIHNlcnZlciBjb250ZW50IGlmIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIHRoZXJlIGFyZSBub24tdGV4dCBwYXJ0cyBpbiB0aGUgcmVzcG9uc2UsIHRoZSBjb25jYXRlbmF0aW9uIG9mIGFsbCB0ZXh0XG4gICAgICogcGFydHMgd2lsbCBiZSByZXR1cm5lZCwgYW5kIGEgd2FybmluZyB3aWxsIGJlIGxvZ2dlZC5cbiAgICAgKi9cbiAgICBnZXQgdGV4dCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGxldCB0ZXh0ID0gJyc7XG4gICAgICAgIGxldCBhbnlUZXh0UGFydEZvdW5kID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IG5vblRleHRQYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgKF9jID0gKF9iID0gKF9hID0gdGhpcy5zZXJ2ZXJDb250ZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubW9kZWxUdXJuKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucGFydHMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFtdKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIGZpZWxkVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcnQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSAhPT0gJ3RleHQnICYmXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkTmFtZSAhPT0gJ3Rob3VnaHQnICYmXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkVmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9uVGV4dFBhcnRzLnB1c2goZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcnQudGV4dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhcnQudGhvdWdodCA9PT0gJ2Jvb2xlYW4nICYmIHBhcnQudGhvdWdodCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYW55VGV4dFBhcnRGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGV4dCArPSBwYXJ0LnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vblRleHRQYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYHRoZXJlIGFyZSBub24tdGV4dCBwYXJ0cyAke25vblRleHRQYXJ0c30gaW4gdGhlIHJlc3BvbnNlLCByZXR1cm5pbmcgY29uY2F0ZW5hdGlvbiBvZiBhbGwgdGV4dCBwYXJ0cy4gUGxlYXNlIHJlZmVyIHRvIHRoZSBub24gdGV4dCBwYXJ0cyBmb3IgYSBmdWxsIHJlc3BvbnNlIGZyb20gbW9kZWwuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGFydC50ZXh0ID09PSAnJyBpcyBkaWZmZXJlbnQgZnJvbSBwYXJ0LnRleHQgaXMgbnVsbFxuICAgICAgICByZXR1cm4gYW55VGV4dFBhcnRGb3VuZCA/IHRleHQgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIGlubGluZSBkYXRhIHBhcnRzIGZyb20gdGhlIHNlcnZlciBjb250ZW50IGlmIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIHRoZXJlIGFyZSBub24taW5saW5lIGRhdGEgcGFydHMgaW4gdGhlXG4gICAgICogcmVzcG9uc2UsIHRoZSBjb25jYXRlbmF0aW9uIG9mIGFsbCBpbmxpbmUgZGF0YSBwYXJ0cyB3aWxsIGJlIHJldHVybmVkLCBhbmRcbiAgICAgKiBhIHdhcm5pbmcgd2lsbCBiZSBsb2dnZWQuXG4gICAgICovXG4gICAgZ2V0IGRhdGEoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBsZXQgZGF0YSA9ICcnO1xuICAgICAgICBjb25zdCBub25EYXRhUGFydHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIChfYyA9IChfYiA9IChfYSA9IHRoaXMuc2VydmVyQ29udGVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1vZGVsVHVybikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnBhcnRzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBbXSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbZmllbGROYW1lLCBmaWVsZFZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwYXJ0KSkge1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZE5hbWUgIT09ICdpbmxpbmVEYXRhJyAmJiBmaWVsZFZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vbkRhdGFQYXJ0cy5wdXNoKGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcnQuaW5saW5lRGF0YSAmJiB0eXBlb2YgcGFydC5pbmxpbmVEYXRhLmRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZGF0YSArPSBhdG9iKHBhcnQuaW5saW5lRGF0YS5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9uRGF0YVBhcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgdGhlcmUgYXJlIG5vbi1kYXRhIHBhcnRzICR7bm9uRGF0YVBhcnRzfSBpbiB0aGUgcmVzcG9uc2UsIHJldHVybmluZyBjb25jYXRlbmF0aW9uIG9mIGFsbCBkYXRhIHBhcnRzLiBQbGVhc2UgcmVmZXIgdG8gdGhlIG5vbiBkYXRhIHBhcnRzIGZvciBhIGZ1bGwgcmVzcG9uc2UgZnJvbSBtb2RlbC5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YS5sZW5ndGggPiAwID8gYnRvYShkYXRhKSA6IHVuZGVmaW5lZDtcbiAgICB9XG59XG4vKiogQ2xpZW50IGdlbmVyYXRlZCByZXNwb25zZSB0byBhIGBUb29sQ2FsbGAgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyLlxuXG5JbmRpdmlkdWFsIGBGdW5jdGlvblJlc3BvbnNlYCBvYmplY3RzIGFyZSBtYXRjaGVkIHRvIHRoZSByZXNwZWN0aXZlXG5gRnVuY3Rpb25DYWxsYCBvYmplY3RzIGJ5IHRoZSBgaWRgIGZpZWxkLlxuXG5Ob3RlIHRoYXQgaW4gdGhlIHVuYXJ5IGFuZCBzZXJ2ZXItc3RyZWFtaW5nIEdlbmVyYXRlQ29udGVudCBBUElzIGZ1bmN0aW9uXG5jYWxsaW5nIGhhcHBlbnMgYnkgZXhjaGFuZ2luZyB0aGUgYENvbnRlbnRgIHBhcnRzLCB3aGlsZSBpbiB0aGUgYmlkaVxuR2VuZXJhdGVDb250ZW50IEFQSXMgZnVuY3Rpb24gY2FsbGluZyBoYXBwZW5zIG92ZXIgdGhpcyBkZWRpY2F0ZWQgc2V0IG9mXG5tZXNzYWdlcy4gKi9cbmNsYXNzIExpdmVDbGllbnRUb29sUmVzcG9uc2Uge1xufVxuLyoqIFBhcmFtZXRlcnMgZm9yIHNlbmRpbmcgdG9vbCByZXNwb25zZXMgdG8gdGhlIGxpdmUgQVBJLiAqL1xuY2xhc3MgTGl2ZVNlbmRUb29sUmVzcG9uc2VQYXJhbWV0ZXJzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqIFRvb2wgcmVzcG9uc2VzIHRvIHNlbmQgdG8gdGhlIHNlc3Npb24uICovXG4gICAgICAgIHRoaXMuZnVuY3Rpb25SZXNwb25zZXMgPSBbXTtcbiAgICB9XG59XG4vKiogUmVzcG9uc2UgbWVzc2FnZSBmb3IgdGhlIExpdmVNdXNpY0NsaWVudE1lc3NhZ2UgY2FsbC4gKi9cbmNsYXNzIExpdmVNdXNpY1NlcnZlck1lc3NhZ2Uge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGF1ZGlvIGNodW5rIGZyb20gdGhlIHNlcnZlciBjb250ZW50LCBpZiBwcmVzZW50LlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJZiB0aGVyZSBhcmUgbm8gYXVkaW8gY2h1bmtzIGluIHRoZSByZXNwb25zZSwgdW5kZWZpbmVkIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICovXG4gICAgZ2V0IGF1ZGlvQ2h1bmsoKSB7XG4gICAgICAgIGlmICh0aGlzLnNlcnZlckNvbnRlbnQgJiZcbiAgICAgICAgICAgIHRoaXMuc2VydmVyQ29udGVudC5hdWRpb0NodW5rcyAmJlxuICAgICAgICAgICAgdGhpcy5zZXJ2ZXJDb250ZW50LmF1ZGlvQ2h1bmtzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcnZlckNvbnRlbnQuYXVkaW9DaHVua3NbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG4vKiogVGhlIHJlc3BvbnNlIHdoZW4gbG9uZy1ydW5uaW5nIG9wZXJhdGlvbiBmb3IgdXBsb2FkaW5nIGEgZmlsZSB0byBhIEZpbGVTZWFyY2hTdG9yZSBjb21wbGV0ZS4gKi9cbmNsYXNzIFVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlUmVzcG9uc2Uge1xufVxuLyoqIExvbmctcnVubmluZyBvcGVyYXRpb24gZm9yIHVwbG9hZGluZyBhIGZpbGUgdG8gYSBGaWxlU2VhcmNoU3RvcmUuICovXG5jbGFzcyBVcGxvYWRUb0ZpbGVTZWFyY2hTdG9yZU9wZXJhdGlvbiB7XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGVzIGFuIE9wZXJhdGlvbiBvZiB0aGUgc2FtZSB0eXBlIGFzIHRoZSBvbmUgYmVpbmcgY2FsbGVkIHdpdGggdGhlIGZpZWxkcyBzZXQgZnJvbSB0aGUgQVBJIHJlc3BvbnNlLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9mcm9tQVBJUmVzcG9uc2UoeyBhcGlSZXNwb25zZSwgX2lzVmVydGV4QUksIH0pIHtcbiAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gbmV3IFVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlT3BlcmF0aW9uKCk7XG4gICAgICAgIGNvbnN0IG9wID0gYXBpUmVzcG9uc2U7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gdXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVPcGVyYXRpb25Gcm9tTWxkZXYob3ApO1xuICAgICAgICBPYmplY3QuYXNzaWduKG9wZXJhdGlvbiwgcmVzcG9uc2UpO1xuICAgICAgICByZXR1cm4gb3BlcmF0aW9uO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuZnVuY3Rpb24gdE1vZGVsKGFwaUNsaWVudCwgbW9kZWwpIHtcbiAgICBpZiAoIW1vZGVsIHx8IHR5cGVvZiBtb2RlbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtb2RlbCBpcyByZXF1aXJlZCBhbmQgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cbiAgICBpZiAobW9kZWwuaW5jbHVkZXMoJy4uJykgfHwgbW9kZWwuaW5jbHVkZXMoJz8nKSB8fCBtb2RlbC5pbmNsdWRlcygnJicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBtb2RlbCBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgaWYgKGFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgaWYgKG1vZGVsLnN0YXJ0c1dpdGgoJ3B1Ymxpc2hlcnMvJykgfHxcbiAgICAgICAgICAgIG1vZGVsLnN0YXJ0c1dpdGgoJ3Byb2plY3RzLycpIHx8XG4gICAgICAgICAgICBtb2RlbC5zdGFydHNXaXRoKCdtb2RlbHMvJykpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2RlbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtb2RlbC5pbmRleE9mKCcvJykgPj0gMCkge1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSBtb2RlbC5zcGxpdCgnLycsIDIpO1xuICAgICAgICAgICAgcmV0dXJuIGBwdWJsaXNoZXJzLyR7cGFydHNbMF19L21vZGVscy8ke3BhcnRzWzFdfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYHB1Ymxpc2hlcnMvZ29vZ2xlL21vZGVscy8ke21vZGVsfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChtb2RlbC5zdGFydHNXaXRoKCdtb2RlbHMvJykgfHwgbW9kZWwuc3RhcnRzV2l0aCgndHVuZWRNb2RlbHMvJykpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2RlbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgbW9kZWxzLyR7bW9kZWx9YDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHRDYWNoZXNNb2RlbChhcGlDbGllbnQsIG1vZGVsKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtZWRNb2RlbCA9IHRNb2RlbChhcGlDbGllbnQsIG1vZGVsKTtcbiAgICBpZiAoIXRyYW5zZm9ybWVkTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBpZiAodHJhbnNmb3JtZWRNb2RlbC5zdGFydHNXaXRoKCdwdWJsaXNoZXJzLycpICYmIGFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgLy8gdmVydGV4IGNhY2hlcyBvbmx5IHN1cHBvcnQgbW9kZWwgbmFtZSBzdGFydCB3aXRoIHByb2plY3RzLlxuICAgICAgICByZXR1cm4gYHByb2plY3RzLyR7YXBpQ2xpZW50LmdldFByb2plY3QoKX0vbG9jYXRpb25zLyR7YXBpQ2xpZW50LmdldExvY2F0aW9uKCl9LyR7dHJhbnNmb3JtZWRNb2RlbH1gO1xuICAgIH1cbiAgICBlbHNlIGlmICh0cmFuc2Zvcm1lZE1vZGVsLnN0YXJ0c1dpdGgoJ21vZGVscy8nKSAmJiBhcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgIHJldHVybiBgcHJvamVjdHMvJHthcGlDbGllbnQuZ2V0UHJvamVjdCgpfS9sb2NhdGlvbnMvJHthcGlDbGllbnQuZ2V0TG9jYXRpb24oKX0vcHVibGlzaGVycy9nb29nbGUvJHt0cmFuc2Zvcm1lZE1vZGVsfWA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWRNb2RlbDtcbiAgICB9XG59XG5mdW5jdGlvbiB0QmxvYnMoYmxvYnMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShibG9icykpIHtcbiAgICAgICAgcmV0dXJuIGJsb2JzLm1hcCgoYmxvYikgPT4gdEJsb2IoYmxvYikpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFt0QmxvYihibG9icyldO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRCbG9iKGJsb2IpIHtcbiAgICBpZiAodHlwZW9mIGJsb2IgPT09ICdvYmplY3QnICYmIGJsb2IgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGJsb2I7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHBhcnNlIGlucHV0IGFzIEJsb2IuIFVuc3VwcG9ydGVkIGJsb2IgdHlwZTogJHt0eXBlb2YgYmxvYn1gKTtcbn1cbmZ1bmN0aW9uIHRJbWFnZUJsb2IoYmxvYikge1xuICAgIGNvbnN0IHRyYW5zZm9ybWVkQmxvYiA9IHRCbG9iKGJsb2IpO1xuICAgIGlmICh0cmFuc2Zvcm1lZEJsb2IubWltZVR5cGUgJiZcbiAgICAgICAgdHJhbnNmb3JtZWRCbG9iLm1pbWVUeXBlLnN0YXJ0c1dpdGgoJ2ltYWdlLycpKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZEJsb2I7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbWltZSB0eXBlOiAke3RyYW5zZm9ybWVkQmxvYi5taW1lVHlwZX1gKTtcbn1cbmZ1bmN0aW9uIHRBdWRpb0Jsb2IoYmxvYikge1xuICAgIGNvbnN0IHRyYW5zZm9ybWVkQmxvYiA9IHRCbG9iKGJsb2IpO1xuICAgIGlmICh0cmFuc2Zvcm1lZEJsb2IubWltZVR5cGUgJiZcbiAgICAgICAgdHJhbnNmb3JtZWRCbG9iLm1pbWVUeXBlLnN0YXJ0c1dpdGgoJ2F1ZGlvLycpKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZEJsb2I7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbWltZSB0eXBlOiAke3RyYW5zZm9ybWVkQmxvYi5taW1lVHlwZX1gKTtcbn1cbmZ1bmN0aW9uIHRQYXJ0KG9yaWdpbikge1xuICAgIGlmIChvcmlnaW4gPT09IG51bGwgfHwgb3JpZ2luID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJ0VW5pb24gaXMgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcmlnaW4gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW47XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3JpZ2luID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4geyB0ZXh0OiBvcmlnaW4gfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwYXJ0IHR5cGU6ICR7dHlwZW9mIG9yaWdpbn1gKTtcbn1cbmZ1bmN0aW9uIHRQYXJ0cyhvcmlnaW4pIHtcbiAgICBpZiAob3JpZ2luID09PSBudWxsIHx8XG4gICAgICAgIG9yaWdpbiA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIChBcnJheS5pc0FycmF5KG9yaWdpbikgJiYgb3JpZ2luLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJ0TGlzdFVuaW9uIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KG9yaWdpbikpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbi5tYXAoKGl0ZW0pID0+IHRQYXJ0KGl0ZW0pKTtcbiAgICB9XG4gICAgcmV0dXJuIFt0UGFydChvcmlnaW4pXTtcbn1cbmZ1bmN0aW9uIF9pc0NvbnRlbnQob3JpZ2luKSB7XG4gICAgcmV0dXJuIChvcmlnaW4gIT09IG51bGwgJiZcbiAgICAgICAgb3JpZ2luICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdHlwZW9mIG9yaWdpbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ3BhcnRzJyBpbiBvcmlnaW4gJiZcbiAgICAgICAgQXJyYXkuaXNBcnJheShvcmlnaW4ucGFydHMpKTtcbn1cbmZ1bmN0aW9uIF9pc0Z1bmN0aW9uQ2FsbFBhcnQob3JpZ2luKSB7XG4gICAgcmV0dXJuIChvcmlnaW4gIT09IG51bGwgJiZcbiAgICAgICAgb3JpZ2luICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdHlwZW9mIG9yaWdpbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ2Z1bmN0aW9uQ2FsbCcgaW4gb3JpZ2luKTtcbn1cbmZ1bmN0aW9uIF9pc0Z1bmN0aW9uUmVzcG9uc2VQYXJ0KG9yaWdpbikge1xuICAgIHJldHVybiAob3JpZ2luICE9PSBudWxsICYmXG4gICAgICAgIG9yaWdpbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHR5cGVvZiBvcmlnaW4gPT09ICdvYmplY3QnICYmXG4gICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyBpbiBvcmlnaW4pO1xufVxuZnVuY3Rpb24gdENvbnRlbnQob3JpZ2luKSB7XG4gICAgaWYgKG9yaWdpbiA9PT0gbnVsbCB8fCBvcmlnaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRlbnRVbmlvbiBpcyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBpZiAoX2lzQ29udGVudChvcmlnaW4pKSB7XG4gICAgICAgIC8vIF9pc0NvbnRlbnQgaXMgYSB1dGlsaXR5IGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIHRoZVxuICAgICAgICAvLyBvcmlnaW4gaXMgYSBDb250ZW50LlxuICAgICAgICByZXR1cm4gb3JpZ2luO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgIHBhcnRzOiB0UGFydHMob3JpZ2luKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gdENvbnRlbnRzRm9yRW1iZWQoYXBpQ2xpZW50LCBvcmlnaW4pIHtcbiAgICBpZiAoIW9yaWdpbikge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmIChhcGlDbGllbnQuaXNWZXJ0ZXhBSSgpICYmIEFycmF5LmlzQXJyYXkob3JpZ2luKSkge1xuICAgICAgICByZXR1cm4gb3JpZ2luLmZsYXRNYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0Q29udGVudChpdGVtKTtcbiAgICAgICAgICAgIGlmIChjb250ZW50LnBhcnRzICYmXG4gICAgICAgICAgICAgICAgY29udGVudC5wYXJ0cy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgY29udGVudC5wYXJ0c1swXS50ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2NvbnRlbnQucGFydHNbMF0udGV4dF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChhcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0Q29udGVudChvcmlnaW4pO1xuICAgICAgICBpZiAoY29udGVudC5wYXJ0cyAmJlxuICAgICAgICAgICAgY29udGVudC5wYXJ0cy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICBjb250ZW50LnBhcnRzWzBdLnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFtjb250ZW50LnBhcnRzWzBdLnRleHRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3JpZ2luKSkge1xuICAgICAgICByZXR1cm4gb3JpZ2luLm1hcCgoaXRlbSkgPT4gdENvbnRlbnQoaXRlbSkpO1xuICAgIH1cbiAgICByZXR1cm4gW3RDb250ZW50KG9yaWdpbildO1xufVxuZnVuY3Rpb24gdENvbnRlbnRzKG9yaWdpbikge1xuICAgIGlmIChvcmlnaW4gPT09IG51bGwgfHxcbiAgICAgICAgb3JpZ2luID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgKEFycmF5LmlzQXJyYXkob3JpZ2luKSAmJiBvcmlnaW4ubGVuZ3RoID09PSAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnRlbnRzIGFyZSByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkob3JpZ2luKSkge1xuICAgICAgICAvLyBJZiBpdCdzIG5vdCBhbiBhcnJheSwgaXQncyBhIHNpbmdsZSBjb250ZW50IG9yIGEgc2luZ2xlIFBhcnRVbmlvbi5cbiAgICAgICAgaWYgKF9pc0Z1bmN0aW9uQ2FsbFBhcnQob3JpZ2luKSB8fCBfaXNGdW5jdGlvblJlc3BvbnNlUGFydChvcmlnaW4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvIHNwZWNpZnkgZnVuY3Rpb25DYWxsIG9yIGZ1bmN0aW9uUmVzcG9uc2UgcGFydHMsIHBsZWFzZSB3cmFwIHRoZW0gaW4gYSBDb250ZW50IG9iamVjdCwgc3BlY2lmeWluZyB0aGUgcm9sZSBmb3IgdGhlbScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbdENvbnRlbnQob3JpZ2luKV07XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IGFjY3VtdWxhdGVkUGFydHMgPSBbXTtcbiAgICBjb25zdCBpc0NvbnRlbnRBcnJheSA9IF9pc0NvbnRlbnQob3JpZ2luWzBdKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygb3JpZ2luKSB7XG4gICAgICAgIGNvbnN0IGlzQ29udGVudCA9IF9pc0NvbnRlbnQoaXRlbSk7XG4gICAgICAgIGlmIChpc0NvbnRlbnQgIT0gaXNDb250ZW50QXJyYXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWl4aW5nIENvbnRlbnQgYW5kIFBhcnRzIGlzIG5vdCBzdXBwb3J0ZWQsIHBsZWFzZSBncm91cCB0aGUgcGFydHMgaW50byBhIHRoZSBhcHByb3ByaWF0ZSBDb250ZW50IG9iamVjdHMgYW5kIHNwZWNpZnkgdGhlIHJvbGVzIGZvciB0aGVtJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ29udGVudCkge1xuICAgICAgICAgICAgLy8gYGlzQ29udGVudGAgY29udGFpbnMgdGhlIHJlc3VsdCBvZiBfaXNDb250ZW50LCB3aGljaCBpcyBhIHV0aWxpdHlcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIHRoZSBpdGVtIGlzIGEgQ29udGVudC5cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9pc0Z1bmN0aW9uQ2FsbFBhcnQoaXRlbSkgfHwgX2lzRnVuY3Rpb25SZXNwb25zZVBhcnQoaXRlbSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG8gc3BlY2lmeSBmdW5jdGlvbkNhbGwgb3IgZnVuY3Rpb25SZXNwb25zZSBwYXJ0cywgcGxlYXNlIHdyYXAgdGhlbSwgYW5kIGFueSBvdGhlciBwYXJ0cywgaW4gQ29udGVudCBvYmplY3RzIGFzIGFwcHJvcHJpYXRlLCBzcGVjaWZ5aW5nIHRoZSByb2xlIGZvciB0aGVtJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhY2N1bXVsYXRlZFBhcnRzLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc0NvbnRlbnRBcnJheSkge1xuICAgICAgICByZXN1bHQucHVzaCh7IHJvbGU6ICd1c2VyJywgcGFydHM6IHRQYXJ0cyhhY2N1bXVsYXRlZFBhcnRzKSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qXG5UcmFuc2Zvcm0gdGhlIHR5cGUgZmllbGQgZnJvbSBhbiBhcnJheSBvZiB0eXBlcyB0byBhbiBhcnJheSBvZiBhbnlPZiBmaWVsZHMuXG5FeGFtcGxlOlxuICB7dHlwZTogWydTVFJJTkcnLCAnTlVNQkVSJ119XG53aWxsIGJlIHRyYW5zZm9ybWVkIHRvXG4gIHthbnlPZjogW3t0eXBlOiAnU1RSSU5HJ30sIHt0eXBlOiAnTlVNQkVSJ31dfVxuKi9cbmZ1bmN0aW9uIGZsYXR0ZW5UeXBlQXJyYXlUb0FueU9mKHR5cGVMaXN0LCByZXN1bHRpbmdTY2hlbWEpIHtcbiAgICBpZiAodHlwZUxpc3QuaW5jbHVkZXMoJ251bGwnKSkge1xuICAgICAgICByZXN1bHRpbmdTY2hlbWFbJ251bGxhYmxlJ10gPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBsaXN0V2l0aG91dE51bGwgPSB0eXBlTGlzdC5maWx0ZXIoKHR5cGUpID0+IHR5cGUgIT09ICdudWxsJyk7XG4gICAgaWYgKGxpc3RXaXRob3V0TnVsbC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmVzdWx0aW5nU2NoZW1hWyd0eXBlJ10gPSBPYmplY3QudmFsdWVzKFR5cGUpLmluY2x1ZGVzKGxpc3RXaXRob3V0TnVsbFswXS50b1VwcGVyQ2FzZSgpKVxuICAgICAgICAgICAgPyBsaXN0V2l0aG91dE51bGxbMF0udG9VcHBlckNhc2UoKVxuICAgICAgICAgICAgOiBUeXBlLlRZUEVfVU5TUEVDSUZJRUQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHRpbmdTY2hlbWFbJ2FueU9mJ10gPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIGxpc3RXaXRob3V0TnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0aW5nU2NoZW1hWydhbnlPZiddLnB1c2goe1xuICAgICAgICAgICAgICAgICd0eXBlJzogT2JqZWN0LnZhbHVlcyhUeXBlKS5pbmNsdWRlcyhpLnRvVXBwZXJDYXNlKCkpXG4gICAgICAgICAgICAgICAgICAgID8gaS50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgIDogVHlwZS5UWVBFX1VOU1BFQ0lGSUVELFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBwcm9jZXNzSnNvblNjaGVtYShfanNvblNjaGVtYSkge1xuICAgIGNvbnN0IGdlbkFJU2NoZW1hID0ge307XG4gICAgY29uc3Qgc2NoZW1hRmllbGROYW1lcyA9IFsnaXRlbXMnXTtcbiAgICBjb25zdCBsaXN0U2NoZW1hRmllbGROYW1lcyA9IFsnYW55T2YnXTtcbiAgICBjb25zdCBkaWN0U2NoZW1hRmllbGROYW1lcyA9IFsncHJvcGVydGllcyddO1xuICAgIGlmIChfanNvblNjaGVtYVsndHlwZSddICYmIF9qc29uU2NoZW1hWydhbnlPZiddKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndHlwZSBhbmQgYW55T2YgY2Fubm90IGJlIGJvdGggcG9wdWxhdGVkLicpO1xuICAgIH1cbiAgICAvKlxuICAgIFRoaXMgaXMgdG8gaGFuZGxlIHRoZSBudWxsYWJsZSBhcnJheSBvciBvYmplY3QuIFRoZSBfanNvblNjaGVtYSB3aWxsXG4gICAgYmUgaW4gdGhlIGZvcm1hdCBvZiB7YW55T2Y6IFt7dHlwZTogJ251bGwnfSwge3R5cGU6ICdvYmplY3QnfV19LiBUaGVcbiAgICBsb2dpYyBpcyB0byBjaGVjayBpZiBhbnlPZiBoYXMgMiBlbGVtZW50cyBhbmQgb25lIG9mIHRoZSBlbGVtZW50IGlzIG51bGwsXG4gICAgaWYgc28sIHRoZSBhbnlPZiBmaWVsZCBpcyB1bm5lY2Vzc2FyeSwgc28gd2UgbmVlZCB0byBnZXQgcmlkIG9mIHRoZSBhbnlPZlxuICAgIGZpZWxkIGFuZCBtYWtlIHRoZSBzY2hlbWEgbnVsbGFibGUuIFRoZW4gdXNlIHRoZSBvdGhlciBlbGVtZW50IGFzIHRoZSBuZXdcbiAgICBfanNvblNjaGVtYSBmb3IgcHJvY2Vzc2luZy4gVGhpcyBpcyBiZWNhdXNlIHRoZSBiYWNrZW5kIGRvZXNuJ3QgaGF2ZSBhIG51bGxcbiAgICB0eXBlLlxuICAgIFRoaXMgaGFzIHRvIGJlIGNoZWNrZWQgYmVmb3JlIHdlIHByb2Nlc3MgYW55IG90aGVyIGZpZWxkcy5cbiAgICBGb3IgZXhhbXBsZTpcbiAgICAgIGNvbnN0IG9iamVjdE51bGxhYmxlID0gei5vYmplY3Qoe1xuICAgICAgICBudWxsYWJsZUFycmF5OiB6LmFycmF5KHouc3RyaW5nKCkpLm51bGxhYmxlKCksXG4gICAgICB9KTtcbiAgICBXaWxsIGhhdmUgdGhlIHJhdyBfanNvblNjaGVtYSBhczpcbiAgICB7XG4gICAgICB0eXBlOiAnT0JKRUNUJyxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICBudWxsYWJsZUFycmF5OiB7XG4gICAgICAgICAgICAgYW55T2Y6IFtcbiAgICAgICAgICAgICAgICB7dHlwZTogJ251bGwnfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgICAgICAgICAgICAgaXRlbXM6IHt0eXBlOiAnc3RyaW5nJ30sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVxdWlyZWQ6IFsgJ251bGxhYmxlQXJyYXknIF0sXG4gICAgfVxuICAgIFdpbGwgcmVzdWx0IGluIGZvbGxvd2luZyBzY2hlbWEgY29tcGF0aWJsZSB3aXRoIEdlbWluaSBBUEk6XG4gICAgICB7XG4gICAgICAgIHR5cGU6ICdPQkpFQ1QnLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgIG51bGxhYmxlQXJyYXk6IHtcbiAgICAgICAgICAgICAgbnVsbGFibGU6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6ICdBUlJBWScsXG4gICAgICAgICAgICAgIGl0ZW1zOiB7dHlwZTogJ3N0cmluZyd9LFxuICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlcXVpcmVkOiBbICdudWxsYWJsZUFycmF5JyBdLFxuICAgICAgfVxuICAgICovXG4gICAgY29uc3QgaW5jb21pbmdBbnlPZiA9IF9qc29uU2NoZW1hWydhbnlPZiddO1xuICAgIGlmIChpbmNvbWluZ0FueU9mICE9IG51bGwgJiYgaW5jb21pbmdBbnlPZi5sZW5ndGggPT0gMikge1xuICAgICAgICBpZiAoaW5jb21pbmdBbnlPZlswXVsndHlwZSddID09PSAnbnVsbCcpIHtcbiAgICAgICAgICAgIGdlbkFJU2NoZW1hWydudWxsYWJsZSddID0gdHJ1ZTtcbiAgICAgICAgICAgIF9qc29uU2NoZW1hID0gaW5jb21pbmdBbnlPZlsxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbmNvbWluZ0FueU9mWzFdWyd0eXBlJ10gPT09ICdudWxsJykge1xuICAgICAgICAgICAgZ2VuQUlTY2hlbWFbJ251bGxhYmxlJ10gPSB0cnVlO1xuICAgICAgICAgICAgX2pzb25TY2hlbWEgPSBpbmNvbWluZ0FueU9mWzBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChfanNvblNjaGVtYVsndHlwZSddIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgZmxhdHRlblR5cGVBcnJheVRvQW55T2YoX2pzb25TY2hlbWFbJ3R5cGUnXSwgZ2VuQUlTY2hlbWEpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIGZpZWxkVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKF9qc29uU2NoZW1hKSkge1xuICAgICAgICAvLyBTa2lwIGlmIHRoZSBmaWVsZHZhbHVlIGlzIHVuZGVmaW5lZCBvciBudWxsLlxuICAgICAgICBpZiAoZmllbGRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmllbGROYW1lID09ICd0eXBlJykge1xuICAgICAgICAgICAgaWYgKGZpZWxkVmFsdWUgPT09ICdudWxsJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHlwZTogbnVsbCBjYW4gbm90IGJlIHRoZSBvbmx5IHBvc3NpYmxlIHR5cGUgZm9yIHRoZSBmaWVsZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWVsZFZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIGFscmVhZHkgaGFuZGxlZCB0aGUgdHlwZSBmaWVsZCB3aXRoIGFycmF5IG9mIHR5cGVzIGluIHRoZVxuICAgICAgICAgICAgICAgIC8vIGJlZ2lubmluZyBvZiB0aGlzIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2VuQUlTY2hlbWFbJ3R5cGUnXSA9IE9iamVjdC52YWx1ZXMoVHlwZSkuaW5jbHVkZXMoZmllbGRWYWx1ZS50b1VwcGVyQ2FzZSgpKVxuICAgICAgICAgICAgICAgID8gZmllbGRWYWx1ZS50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgICAgICAgOiBUeXBlLlRZUEVfVU5TUEVDSUZJRUQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2NoZW1hRmllbGROYW1lcy5pbmNsdWRlcyhmaWVsZE5hbWUpKSB7XG4gICAgICAgICAgICBnZW5BSVNjaGVtYVtmaWVsZE5hbWVdID1cbiAgICAgICAgICAgICAgICBwcm9jZXNzSnNvblNjaGVtYShmaWVsZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsaXN0U2NoZW1hRmllbGROYW1lcy5pbmNsdWRlcyhmaWVsZE5hbWUpKSB7XG4gICAgICAgICAgICBjb25zdCBsaXN0U2NoZW1hRmllbGRWYWx1ZSA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGZpZWxkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbVsndHlwZSddID09ICdudWxsJykge1xuICAgICAgICAgICAgICAgICAgICBnZW5BSVNjaGVtYVsnbnVsbGFibGUnXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaXN0U2NoZW1hRmllbGRWYWx1ZS5wdXNoKHByb2Nlc3NKc29uU2NoZW1hKGl0ZW0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdlbkFJU2NoZW1hW2ZpZWxkTmFtZV0gPVxuICAgICAgICAgICAgICAgIGxpc3RTY2hlbWFGaWVsZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRpY3RTY2hlbWFGaWVsZE5hbWVzLmluY2x1ZGVzKGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpY3RTY2hlbWFGaWVsZFZhbHVlID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhmaWVsZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGRpY3RTY2hlbWFGaWVsZFZhbHVlW2tleV0gPSBwcm9jZXNzSnNvblNjaGVtYSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZW5BSVNjaGVtYVtmaWVsZE5hbWVdID1cbiAgICAgICAgICAgICAgICBkaWN0U2NoZW1hRmllbGRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGFkZGl0aW9uYWxQcm9wZXJ0aWVzIGlzIG5vdCBpbmNsdWRlZCBpbiBKU09OU2NoZW1hLCBza2lwcGluZyBpdC5cbiAgICAgICAgICAgIGlmIChmaWVsZE5hbWUgPT09ICdhZGRpdGlvbmFsUHJvcGVydGllcycpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdlbkFJU2NoZW1hW2ZpZWxkTmFtZV0gPSBmaWVsZFZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBnZW5BSVNjaGVtYTtcbn1cbi8vIHdlIHRha2UgdGhlIHVua25vd24gaW4gdGhlIHNjaGVtYSBmaWVsZCBiZWNhdXNlIHdlIHdhbnQgZW5hYmxlIHVzZXIgdG8gcGFzc1xuLy8gdGhlIG91dHB1dCBvZiBtYWpvciBzY2hlbWEgZGVjbGFyYXRpb24gdG9vbHMgd2l0aG91dCBjYXN0aW5nLiBUb29scyBzdWNoIGFzXG4vLyB6b2RUb0pzb25TY2hlbWEsIHR5cGVib3gsIHpvZFRvSnNvblNjaGVtYSBmdW5jdGlvbiBjYW4gcmV0dXJuIEpzb25TY2hlbWE3VHlwZVxuLy8gb3Igb2JqZWN0LCBzZWUgZGV0YWlscyBpblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL1N0ZWZhblRlcmRlbGwvem9kLXRvLWpzb24tc2NoZW1hL2Jsb2IvNzA1MjVlZmU1NTVjZDIyNjY5MWUwOTNkMTcxMzcwYTNiMTA5MjFkMS9zcmMvem9kVG9Kc29uU2NoZW1hLnRzI0w3XG4vLyB0eXBlYm94IGNhbiByZXR1cm4gdW5rbm93biwgc2VlIGRldGFpbHMgaW5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5jbGFpcnp4ODEvdHlwZWJveC9ibG9iLzVhNTQzMTQzOWY3ZDVjYTZiNDk0ZDBkMThmYmZkN2IxYTM1NmQ2N2Mvc3JjL3R5cGUvY3JlYXRlL3R5cGUudHMjTDM1XG4vLyBOb3RlOiBwcm9wZXIganNvbiBzY2hlbWFzIHdpdGggdGhlICRzY2hlbWEgZmllbGQgc2V0IG5ldmVyIGFycml2ZSB0byB0aGlzXG4vLyB0cmFuc2Zvcm1lci4gU2NoZW1hcyB3aXRoICRzY2hlbWEgYXJlIHJvdXRlZCB0byB0aGUgZXF1aXZhbGVudCBBUEkganNvblxuLy8gc2NoZW1hIGZpZWxkLlxuZnVuY3Rpb24gdFNjaGVtYShzY2hlbWEpIHtcbiAgICByZXR1cm4gcHJvY2Vzc0pzb25TY2hlbWEoc2NoZW1hKTtcbn1cbmZ1bmN0aW9uIHRTcGVlY2hDb25maWcoc3BlZWNoQ29uZmlnKSB7XG4gICAgaWYgKHR5cGVvZiBzcGVlY2hDb25maWcgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBzcGVlY2hDb25maWc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBzcGVlY2hDb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2b2ljZUNvbmZpZzoge1xuICAgICAgICAgICAgICAgIHByZWJ1aWx0Vm9pY2VDb25maWc6IHtcbiAgICAgICAgICAgICAgICAgICAgdm9pY2VOYW1lOiBzcGVlY2hDb25maWcsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHNwZWVjaENvbmZpZyB0eXBlOiAke3R5cGVvZiBzcGVlY2hDb25maWd9YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdExpdmVTcGVlY2hDb25maWcoc3BlZWNoQ29uZmlnKSB7XG4gICAgaWYgKCdtdWx0aVNwZWFrZXJWb2ljZUNvbmZpZycgaW4gc3BlZWNoQ29uZmlnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbXVsdGlTcGVha2VyVm9pY2VDb25maWcgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgbGl2ZSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiBzcGVlY2hDb25maWc7XG59XG5mdW5jdGlvbiB0VG9vbCh0b29sKSB7XG4gICAgaWYgKHRvb2wuZnVuY3Rpb25EZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBmdW5jdGlvbkRlY2xhcmF0aW9uIG9mIHRvb2wuZnVuY3Rpb25EZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChmdW5jdGlvbkRlY2xhcmF0aW9uLnBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKGZ1bmN0aW9uRGVjbGFyYXRpb24ucGFyYW1ldGVycykuaW5jbHVkZXMoJyRzY2hlbWEnKSkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uLnBhcmFtZXRlcnMgPSBwcm9jZXNzSnNvblNjaGVtYShmdW5jdGlvbkRlY2xhcmF0aW9uLnBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmdW5jdGlvbkRlY2xhcmF0aW9uLnBhcmFtZXRlcnNKc29uU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uLnBhcmFtZXRlcnNKc29uU2NoZW1hID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uLnBhcmFtZXRlcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZnVuY3Rpb25EZWNsYXJhdGlvbi5wYXJhbWV0ZXJzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZ1bmN0aW9uRGVjbGFyYXRpb24ucmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKGZ1bmN0aW9uRGVjbGFyYXRpb24ucmVzcG9uc2UpLmluY2x1ZGVzKCckc2NoZW1hJykpIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbi5yZXNwb25zZSA9IHByb2Nlc3NKc29uU2NoZW1hKGZ1bmN0aW9uRGVjbGFyYXRpb24ucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmdW5jdGlvbkRlY2xhcmF0aW9uLnJlc3BvbnNlSnNvblNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbi5yZXNwb25zZUpzb25TY2hlbWEgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb24ucmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZnVuY3Rpb25EZWNsYXJhdGlvbi5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG9vbDtcbn1cbmZ1bmN0aW9uIHRUb29scyh0b29scykge1xuICAgIC8vIENoZWNrIGlmIHRoZSBpbmNvbWluZyB0eXBlIGlzIGRlZmluZWQuXG4gICAgaWYgKHRvb2xzID09PSB1bmRlZmluZWQgfHwgdG9vbHMgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b29scyBpcyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodG9vbHMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndG9vbHMgaXMgcmVxdWlyZWQgYW5kIG11c3QgYmUgYW4gYXJyYXkgb2YgVG9vbHMnKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChjb25zdCB0b29sIG9mIHRvb2xzKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRvb2wpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBQcmVwZW5kcyByZXNvdXJjZSBuYW1lIHdpdGggcHJvamVjdCwgbG9jYXRpb24sIHJlc291cmNlX3ByZWZpeCBpZiBuZWVkZWQuXG4gKlxuICogQHBhcmFtIGNsaWVudCBUaGUgQVBJIGNsaWVudC5cbiAqIEBwYXJhbSByZXNvdXJjZU5hbWUgVGhlIHJlc291cmNlIG5hbWUuXG4gKiBAcGFyYW0gcmVzb3VyY2VQcmVmaXggVGhlIHJlc291cmNlIHByZWZpeC5cbiAqIEBwYXJhbSBzcGxpdHNBZnRlclByZWZpeCBUaGUgbnVtYmVyIG9mIHNwbGl0cyBhZnRlciB0aGUgcHJlZml4LlxuICogQHJldHVybnMgVGhlIGNvbXBsZXRlZCByZXNvdXJjZSBuYW1lLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqIGBgYFxuICogcmVzb3VyY2VfbmFtZSA9ICcxMjMnXG4gKiByZXNvdXJjZV9wcmVmaXggPSAnY2FjaGVkQ29udGVudHMnXG4gKiBzcGxpdHNfYWZ0ZXJfcHJlZml4ID0gMVxuICogY2xpZW50LnZlcnRleGFpID0gVHJ1ZVxuICogY2xpZW50LnByb2plY3QgPSAnYmFyJ1xuICogY2xpZW50LmxvY2F0aW9uID0gJ3VzLXdlc3QxJ1xuICogX3Jlc291cmNlX25hbWUoY2xpZW50LCByZXNvdXJjZV9uYW1lLCByZXNvdXJjZV9wcmVmaXgsIHNwbGl0c19hZnRlcl9wcmVmaXgpXG4gKiByZXR1cm5zOiAncHJvamVjdHMvYmFyL2xvY2F0aW9ucy91cy13ZXN0MS9jYWNoZWRDb250ZW50cy8xMjMnXG4gKiBgYGBcbiAqXG4gKiBgYGBcbiAqIHJlc291cmNlX25hbWUgPSAncHJvamVjdHMvZm9vL2xvY2F0aW9ucy91cy1jZW50cmFsMS9jYWNoZWRDb250ZW50cy8xMjMnXG4gKiByZXNvdXJjZV9wcmVmaXggPSAnY2FjaGVkQ29udGVudHMnXG4gKiBzcGxpdHNfYWZ0ZXJfcHJlZml4ID0gMVxuICogY2xpZW50LnZlcnRleGFpID0gVHJ1ZVxuICogY2xpZW50LnByb2plY3QgPSAnYmFyJ1xuICogY2xpZW50LmxvY2F0aW9uID0gJ3VzLXdlc3QxJ1xuICogX3Jlc291cmNlX25hbWUoY2xpZW50LCByZXNvdXJjZV9uYW1lLCByZXNvdXJjZV9wcmVmaXgsIHNwbGl0c19hZnRlcl9wcmVmaXgpXG4gKiByZXR1cm5zOiAncHJvamVjdHMvZm9vL2xvY2F0aW9ucy91cy1jZW50cmFsMS9jYWNoZWRDb250ZW50cy8xMjMnXG4gKiBgYGBcbiAqXG4gKiBgYGBcbiAqIHJlc291cmNlX25hbWUgPSAnMTIzJ1xuICogcmVzb3VyY2VfcHJlZml4ID0gJ2NhY2hlZENvbnRlbnRzJ1xuICogc3BsaXRzX2FmdGVyX3ByZWZpeCA9IDFcbiAqIGNsaWVudC52ZXJ0ZXhhaSA9IEZhbHNlXG4gKiBfcmVzb3VyY2VfbmFtZShjbGllbnQsIHJlc291cmNlX25hbWUsIHJlc291cmNlX3ByZWZpeCwgc3BsaXRzX2FmdGVyX3ByZWZpeClcbiAqIHJldHVybnMgJ2NhY2hlZENvbnRlbnRzLzEyMydcbiAqIGBgYFxuICpcbiAqIGBgYFxuICogcmVzb3VyY2VfbmFtZSA9ICdzb21lL3dyb25nL2NhY2hlZENvbnRlbnRzL3Jlc291cmNlL25hbWUvMTIzJ1xuICogcmVzb3VyY2VfcHJlZml4ID0gJ2NhY2hlZENvbnRlbnRzJ1xuICogc3BsaXRzX2FmdGVyX3ByZWZpeCA9IDFcbiAqIGNsaWVudC52ZXJ0ZXhhaSA9IEZhbHNlXG4gKiAjIGNsaWVudC52ZXJ0ZXhhaSA9IFRydWVcbiAqIF9yZXNvdXJjZV9uYW1lKGNsaWVudCwgcmVzb3VyY2VfbmFtZSwgcmVzb3VyY2VfcHJlZml4LCBzcGxpdHNfYWZ0ZXJfcHJlZml4KVxuICogLT4gJ3NvbWUvd3JvbmcvcmVzb3VyY2UvbmFtZS8xMjMnXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gcmVzb3VyY2VOYW1lKGNsaWVudCwgcmVzb3VyY2VOYW1lLCByZXNvdXJjZVByZWZpeCwgc3BsaXRzQWZ0ZXJQcmVmaXggPSAxKSB7XG4gICAgY29uc3Qgc2hvdWxkQXBwZW5kUHJlZml4ID0gIXJlc291cmNlTmFtZS5zdGFydHNXaXRoKGAke3Jlc291cmNlUHJlZml4fS9gKSAmJlxuICAgICAgICByZXNvdXJjZU5hbWUuc3BsaXQoJy8nKS5sZW5ndGggPT09IHNwbGl0c0FmdGVyUHJlZml4O1xuICAgIGlmIChjbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgIGlmIChyZXNvdXJjZU5hbWUuc3RhcnRzV2l0aCgncHJvamVjdHMvJykpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvdXJjZU5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzb3VyY2VOYW1lLnN0YXJ0c1dpdGgoJ2xvY2F0aW9ucy8nKSkge1xuICAgICAgICAgICAgcmV0dXJuIGBwcm9qZWN0cy8ke2NsaWVudC5nZXRQcm9qZWN0KCl9LyR7cmVzb3VyY2VOYW1lfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzb3VyY2VOYW1lLnN0YXJ0c1dpdGgoYCR7cmVzb3VyY2VQcmVmaXh9L2ApKSB7XG4gICAgICAgICAgICByZXR1cm4gYHByb2plY3RzLyR7Y2xpZW50LmdldFByb2plY3QoKX0vbG9jYXRpb25zLyR7Y2xpZW50LmdldExvY2F0aW9uKCl9LyR7cmVzb3VyY2VOYW1lfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2hvdWxkQXBwZW5kUHJlZml4KSB7XG4gICAgICAgICAgICByZXR1cm4gYHByb2plY3RzLyR7Y2xpZW50LmdldFByb2plY3QoKX0vbG9jYXRpb25zLyR7Y2xpZW50LmdldExvY2F0aW9uKCl9LyR7cmVzb3VyY2VQcmVmaXh9LyR7cmVzb3VyY2VOYW1lfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb3VyY2VOYW1lO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzaG91bGRBcHBlbmRQcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIGAke3Jlc291cmNlUHJlZml4fS8ke3Jlc291cmNlTmFtZX1gO1xuICAgIH1cbiAgICByZXR1cm4gcmVzb3VyY2VOYW1lO1xufVxuZnVuY3Rpb24gdENhY2hlZENvbnRlbnROYW1lKGFwaUNsaWVudCwgbmFtZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduYW1lIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc291cmNlTmFtZShhcGlDbGllbnQsIG5hbWUsICdjYWNoZWRDb250ZW50cycpO1xufVxuZnVuY3Rpb24gdFR1bmluZ0pvYlN0YXR1cyhzdGF0dXMpIHtcbiAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgICBjYXNlICdTVEFURV9VTlNQRUNJRklFRCc6XG4gICAgICAgICAgICByZXR1cm4gJ0pPQl9TVEFURV9VTlNQRUNJRklFRCc7XG4gICAgICAgIGNhc2UgJ0NSRUFUSU5HJzpcbiAgICAgICAgICAgIHJldHVybiAnSk9CX1NUQVRFX1JVTk5JTkcnO1xuICAgICAgICBjYXNlICdBQ1RJVkUnOlxuICAgICAgICAgICAgcmV0dXJuICdKT0JfU1RBVEVfU1VDQ0VFREVEJztcbiAgICAgICAgY2FzZSAnRkFJTEVEJzpcbiAgICAgICAgICAgIHJldHVybiAnSk9CX1NUQVRFX0ZBSUxFRCc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gc3RhdHVzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRCeXRlcyhmcm9tSW1hZ2VCeXRlcykge1xuICAgIHJldHVybiB0Qnl0ZXMkMShmcm9tSW1hZ2VCeXRlcyk7XG59XG5mdW5jdGlvbiBfaXNGaWxlKG9yaWdpbikge1xuICAgIHJldHVybiAob3JpZ2luICE9PSBudWxsICYmXG4gICAgICAgIG9yaWdpbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHR5cGVvZiBvcmlnaW4gPT09ICdvYmplY3QnICYmXG4gICAgICAgICduYW1lJyBpbiBvcmlnaW4pO1xufVxuZnVuY3Rpb24gaXNHZW5lcmF0ZWRWaWRlbyhvcmlnaW4pIHtcbiAgICByZXR1cm4gKG9yaWdpbiAhPT0gbnVsbCAmJlxuICAgICAgICBvcmlnaW4gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICB0eXBlb2Ygb3JpZ2luID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAndmlkZW8nIGluIG9yaWdpbik7XG59XG5mdW5jdGlvbiBpc1ZpZGVvKG9yaWdpbikge1xuICAgIHJldHVybiAob3JpZ2luICE9PSBudWxsICYmXG4gICAgICAgIG9yaWdpbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHR5cGVvZiBvcmlnaW4gPT09ICdvYmplY3QnICYmXG4gICAgICAgICd1cmknIGluIG9yaWdpbik7XG59XG5mdW5jdGlvbiB0RmlsZU5hbWUoZnJvbU5hbWUpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IG5hbWU7XG4gICAgaWYgKF9pc0ZpbGUoZnJvbU5hbWUpKSB7XG4gICAgICAgIG5hbWUgPSBmcm9tTmFtZS5uYW1lO1xuICAgIH1cbiAgICBpZiAoaXNWaWRlbyhmcm9tTmFtZSkpIHtcbiAgICAgICAgbmFtZSA9IGZyb21OYW1lLnVyaTtcbiAgICAgICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNHZW5lcmF0ZWRWaWRlbyhmcm9tTmFtZSkpIHtcbiAgICAgICAgbmFtZSA9IChfYSA9IGZyb21OYW1lLnZpZGVvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudXJpO1xuICAgICAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZnJvbU5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG5hbWUgPSBmcm9tTmFtZTtcbiAgICB9XG4gICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBleHRyYWN0IGZpbGUgbmFtZSBmcm9tIHRoZSBwcm92aWRlZCBpbnB1dC4nKTtcbiAgICB9XG4gICAgaWYgKG5hbWUuc3RhcnRzV2l0aCgnaHR0cHM6Ly8nKSkge1xuICAgICAgICBjb25zdCBzdWZmaXggPSBuYW1lLnNwbGl0KCdmaWxlcy8nKVsxXTtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBzdWZmaXgubWF0Y2goL1thLXowLTldKy8pO1xuICAgICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGV4dHJhY3QgZmlsZSBuYW1lIGZyb20gVVJJICR7bmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBuYW1lID0gbWF0Y2hbMF07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5hbWUuc3RhcnRzV2l0aCgnZmlsZXMvJykpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUuc3BsaXQoJ2ZpbGVzLycpWzFdO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZTtcbn1cbmZ1bmN0aW9uIHRNb2RlbHNVcmwoYXBpQ2xpZW50LCBiYXNlTW9kZWxzKSB7XG4gICAgbGV0IHJlcztcbiAgICBpZiAoYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICByZXMgPSBiYXNlTW9kZWxzID8gJ3B1Ymxpc2hlcnMvZ29vZ2xlL21vZGVscycgOiAnbW9kZWxzJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlcyA9IGJhc2VNb2RlbHMgPyAnbW9kZWxzJyA6ICd0dW5lZE1vZGVscyc7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiB0RXh0cmFjdE1vZGVscyhyZXNwb25zZSkge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIFsnbW9kZWxzJywgJ3R1bmVkTW9kZWxzJywgJ3B1Ymxpc2hlck1vZGVscyddKSB7XG4gICAgICAgIGlmIChoYXNGaWVsZChyZXNwb25zZSwga2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxuZnVuY3Rpb24gaGFzRmllbGQoZGF0YSwgZmllbGROYW1lKSB7XG4gICAgcmV0dXJuIGRhdGEgIT09IG51bGwgJiYgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmIGZpZWxkTmFtZSBpbiBkYXRhO1xufVxuZnVuY3Rpb24gbWNwVG9HZW1pbmlUb29sKG1jcFRvb2wsIGNvbmZpZyA9IHt9KSB7XG4gICAgY29uc3QgbWNwVG9vbFNjaGVtYSA9IG1jcFRvb2w7XG4gICAgY29uc3QgZnVuY3Rpb25EZWNsYXJhdGlvbiA9IHtcbiAgICAgICAgbmFtZTogbWNwVG9vbFNjaGVtYVsnbmFtZSddLFxuICAgICAgICBkZXNjcmlwdGlvbjogbWNwVG9vbFNjaGVtYVsnZGVzY3JpcHRpb24nXSxcbiAgICAgICAgcGFyYW1ldGVyc0pzb25TY2hlbWE6IG1jcFRvb2xTY2hlbWFbJ2lucHV0U2NoZW1hJ10sXG4gICAgfTtcbiAgICBpZiAobWNwVG9vbFNjaGVtYVsnb3V0cHV0U2NoZW1hJ10pIHtcbiAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvblsncmVzcG9uc2VKc29uU2NoZW1hJ10gPSBtY3BUb29sU2NoZW1hWydvdXRwdXRTY2hlbWEnXTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5iZWhhdmlvcikge1xuICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uWydiZWhhdmlvciddID0gY29uZmlnLmJlaGF2aW9yO1xuICAgIH1cbiAgICBjb25zdCBnZW1pbmlUb29sID0ge1xuICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uczogW1xuICAgICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbixcbiAgICAgICAgXSxcbiAgICB9O1xuICAgIHJldHVybiBnZW1pbmlUb29sO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIGxpc3Qgb2YgTUNQIHRvb2xzIHRvIGEgc2luZ2xlIEdlbWluaSB0b29sIHdpdGggYSBsaXN0IG9mIGZ1bmN0aW9uXG4gKiBkZWNsYXJhdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIG1jcFRvb2xzVG9HZW1pbmlUb29sKG1jcFRvb2xzLCBjb25maWcgPSB7fSkge1xuICAgIGNvbnN0IGZ1bmN0aW9uRGVjbGFyYXRpb25zID0gW107XG4gICAgY29uc3QgdG9vbE5hbWVzID0gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgbWNwVG9vbCBvZiBtY3BUb29scykge1xuICAgICAgICBjb25zdCBtY3BUb29sTmFtZSA9IG1jcFRvb2wubmFtZTtcbiAgICAgICAgaWYgKHRvb2xOYW1lcy5oYXMobWNwVG9vbE5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBmdW5jdGlvbiBuYW1lICR7bWNwVG9vbE5hbWV9IGZvdW5kIGluIE1DUCB0b29scy4gUGxlYXNlIGVuc3VyZSBmdW5jdGlvbiBuYW1lcyBhcmUgdW5pcXVlLmApO1xuICAgICAgICB9XG4gICAgICAgIHRvb2xOYW1lcy5hZGQobWNwVG9vbE5hbWUpO1xuICAgICAgICBjb25zdCBnZW1pbmlUb29sID0gbWNwVG9HZW1pbmlUb29sKG1jcFRvb2wsIGNvbmZpZyk7XG4gICAgICAgIGlmIChnZW1pbmlUb29sLmZ1bmN0aW9uRGVjbGFyYXRpb25zKSB7XG4gICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9ucy5wdXNoKC4uLmdlbWluaVRvb2wuZnVuY3Rpb25EZWNsYXJhdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGZ1bmN0aW9uRGVjbGFyYXRpb25zOiBmdW5jdGlvbkRlY2xhcmF0aW9ucyB9O1xufVxuLy8gVHJhbnNmb3JtcyBhIHNvdXJjZSBpbnB1dCBpbnRvIGEgQmF0Y2hKb2JTb3VyY2Ugb2JqZWN0IHdpdGggdmFsaWRhdGlvbi5cbmZ1bmN0aW9uIHRCYXRjaEpvYlNvdXJjZShjbGllbnQsIHNyYykge1xuICAgIGxldCBzb3VyY2VPYmo7XG4gICAgaWYgKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChjbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBpZiAoc3JjLnN0YXJ0c1dpdGgoJ2dzOi8vJykpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VPYmogPSB7IGZvcm1hdDogJ2pzb25sJywgZ2NzVXJpOiBbc3JjXSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3JjLnN0YXJ0c1dpdGgoJ2JxOi8vJykpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VPYmogPSB7IGZvcm1hdDogJ2JpZ3F1ZXJ5JywgYmlncXVlcnlVcmk6IHNyYyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBzdHJpbmcgc291cmNlIGZvciBWZXJ0ZXggQUk6ICR7c3JjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTUxERVZcbiAgICAgICAgICAgIGlmIChzcmMuc3RhcnRzV2l0aCgnZmlsZXMvJykpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VPYmogPSB7IGZpbGVOYW1lOiBzcmMgfTsgLy8gRGVmYXVsdCB0byBmaWxlTmFtZSBmb3Igc3RyaW5nIGlucHV0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHN0cmluZyBzb3VyY2UgZm9yIEdlbWluaSBBUEk6ICR7c3JjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc3JjKSkge1xuICAgICAgICBpZiAoY2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmxpbmVkUmVxdWVzdFtdIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZU9iaiA9IHsgaW5saW5lZFJlcXVlc3RzOiBzcmMgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEl0J3MgYWxyZWFkeSBhIEJhdGNoSm9iU291cmNlIG9iamVjdFxuICAgICAgICBzb3VyY2VPYmogPSBzcmM7XG4gICAgfVxuICAgIC8vIFZhbGlkYXRpb24gbG9naWNcbiAgICBjb25zdCB2ZXJ0ZXhTb3VyY2VzQ291bnQgPSBbc291cmNlT2JqLmdjc1VyaSwgc291cmNlT2JqLmJpZ3F1ZXJ5VXJpXS5maWx0ZXIoQm9vbGVhbikubGVuZ3RoO1xuICAgIGNvbnN0IG1sZGV2U291cmNlc0NvdW50ID0gW1xuICAgICAgICBzb3VyY2VPYmouaW5saW5lZFJlcXVlc3RzLFxuICAgICAgICBzb3VyY2VPYmouZmlsZU5hbWUsXG4gICAgXS5maWx0ZXIoQm9vbGVhbikubGVuZ3RoO1xuICAgIGlmIChjbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgIGlmIChtbGRldlNvdXJjZXNDb3VudCA+IDAgfHwgdmVydGV4U291cmNlc0NvdW50ICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4YWN0bHkgb25lIG9mIGBnY3NVcmlgIG9yIGBiaWdxdWVyeVVyaWAgbXVzdCBiZSBzZXQgZm9yIFZlcnRleCBBSS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gTUxERVZcbiAgICAgICAgaWYgKHZlcnRleFNvdXJjZXNDb3VudCA+IDAgfHwgbWxkZXZTb3VyY2VzQ291bnQgIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhhY3RseSBvbmUgb2YgYGlubGluZWRSZXF1ZXN0c2AsIGBmaWxlTmFtZWAsICcgK1xuICAgICAgICAgICAgICAgICdtdXN0IGJlIHNldCBmb3IgR2VtaW5pIEFQSS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc291cmNlT2JqO1xufVxuZnVuY3Rpb24gdEJhdGNoSm9iRGVzdGluYXRpb24oZGVzdCkge1xuICAgIGlmICh0eXBlb2YgZGVzdCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfVxuICAgIGNvbnN0IGRlc3RTdHJpbmcgPSBkZXN0O1xuICAgIGlmIChkZXN0U3RyaW5nLnN0YXJ0c1dpdGgoJ2dzOi8vJykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZvcm1hdDogJ2pzb25sJyxcbiAgICAgICAgICAgIGdjc1VyaTogZGVzdFN0cmluZyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGVzdFN0cmluZy5zdGFydHNXaXRoKCdicTovLycpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmb3JtYXQ6ICdiaWdxdWVyeScsXG4gICAgICAgICAgICBiaWdxdWVyeVVyaTogZGVzdFN0cmluZyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGVzdGluYXRpb246ICR7ZGVzdFN0cmluZ31gKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0UmVjdkJhdGNoSm9iRGVzdGluYXRpb24oZGVzdCkge1xuICAgIC8vIEVuc3VyZSBkZXN0IGlzIGEgbm9uLW51bGwgb2JqZWN0IGJlZm9yZSBwcm9jZWVkaW5nLlxuICAgIGlmICh0eXBlb2YgZGVzdCAhPT0gJ29iamVjdCcgfHwgZGVzdCA9PT0gbnVsbCkge1xuICAgICAgICAvLyBJZiB0aGUgaW5wdXQgaXMgbm90IGFuIG9iamVjdCwgaXQgY2Fubm90IGJlIGEgdmFsaWQgQmF0Y2hKb2JEZXN0aW5hdGlvblxuICAgICAgICAvLyBiYXNlZCBvbiB0aGUgb3BlcmF0aW9ucyBwZXJmb3JtZWQuIFJldHVybiBpdCBjYXN0LCBvciBoYW5kbGUgYXMgYW4gZXJyb3IuXG4gICAgICAgIC8vIENhc3RpbmcgYW4gZW1wdHkgb2JqZWN0IG1pZ2h0IGJlIGEgc2FmZSBkZWZhdWx0LlxuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIC8vIENhc3QgdG8gUmVjb3JkPHN0cmluZywgdW5rbm93bj4gdG8gYWxsb3cgc3RyaW5nIHByb3BlcnR5IGFjY2Vzcy5cbiAgICBjb25zdCBvYmogPSBkZXN0O1xuICAgIC8vIFNhZmVseSBhY2Nlc3MgbmVzdGVkIHByb3BlcnRpZXMuXG4gICAgY29uc3QgaW5saW5lUmVzcG9uc2VzVmFsID0gb2JqWydpbmxpbmVkUmVzcG9uc2VzJ107XG4gICAgaWYgKHR5cGVvZiBpbmxpbmVSZXNwb25zZXNWYWwgIT09ICdvYmplY3QnIHx8IGlubGluZVJlc3BvbnNlc1ZhbCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9XG4gICAgY29uc3QgaW5saW5lUmVzcG9uc2VzT2JqID0gaW5saW5lUmVzcG9uc2VzVmFsO1xuICAgIGNvbnN0IHJlc3BvbnNlc0FycmF5ID0gaW5saW5lUmVzcG9uc2VzT2JqWydpbmxpbmVkUmVzcG9uc2VzJ107XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3BvbnNlc0FycmF5KSB8fCByZXNwb25zZXNBcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfVxuICAgIC8vIENoZWNrIGlmIGFueSByZXNwb25zZSBoYXMgdGhlICdlbWJlZGRpbmcnIHByb3BlcnR5LlxuICAgIGxldCBoYXNFbWJlZGRpbmcgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IHJlc3BvbnNlSXRlbSBvZiByZXNwb25zZXNBcnJheSkge1xuICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlSXRlbSAhPT0gJ29iamVjdCcgfHwgcmVzcG9uc2VJdGVtID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZUl0ZW1PYmogPSByZXNwb25zZUl0ZW07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlVmFsID0gcmVzcG9uc2VJdGVtT2JqWydyZXNwb25zZSddO1xuICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlVmFsICE9PSAnb2JqZWN0JyB8fCByZXNwb25zZVZhbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2VPYmogPSByZXNwb25zZVZhbDtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIHRoZSBleGlzdGVuY2Ugb2YgdGhlICdlbWJlZGRpbmcnIGtleS5cbiAgICAgICAgaWYgKHJlc3BvbnNlT2JqWydlbWJlZGRpbmcnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBoYXNFbWJlZGRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gUGVyZm9ybSB0aGUgdHJhbnNmb3JtYXRpb24gaWYgYW4gZW1iZWRkaW5nIHdhcyBmb3VuZC5cbiAgICBpZiAoaGFzRW1iZWRkaW5nKSB7XG4gICAgICAgIG9ialsnaW5saW5lZEVtYmVkQ29udGVudFJlc3BvbnNlcyddID0gb2JqWydpbmxpbmVkUmVzcG9uc2VzJ107XG4gICAgICAgIGRlbGV0ZSBvYmpbJ2lubGluZWRSZXNwb25zZXMnXTtcbiAgICB9XG4gICAgLy8gQ2FzdCB0aGUgKHBvdGVudGlhbGx5KSBtb2RpZmllZCBvYmplY3QgdG8gdGhlIHRhcmdldCB0eXBlLlxuICAgIHJldHVybiBkZXN0O1xufVxuZnVuY3Rpb24gdEJhdGNoSm9iTmFtZShhcGlDbGllbnQsIG5hbWUpIHtcbiAgICBjb25zdCBuYW1lU3RyaW5nID0gbmFtZTtcbiAgICBpZiAoIWFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgY29uc3QgbWxkZXZQYXR0ZXJuID0gL2JhdGNoZXNcXC9bXi9dKyQvO1xuICAgICAgICBpZiAobWxkZXZQYXR0ZXJuLnRlc3QobmFtZVN0cmluZykpIHtcbiAgICAgICAgICAgIHJldHVybiBuYW1lU3RyaW5nLnNwbGl0KCcvJykucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYmF0Y2ggam9iIG5hbWU6ICR7bmFtZVN0cmluZ30uYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdmVydGV4UGF0dGVybiA9IC9ecHJvamVjdHNcXC9bXi9dK1xcL2xvY2F0aW9uc1xcL1teL10rXFwvYmF0Y2hQcmVkaWN0aW9uSm9ic1xcL1teL10rJC87XG4gICAgaWYgKHZlcnRleFBhdHRlcm4udGVzdChuYW1lU3RyaW5nKSkge1xuICAgICAgICByZXR1cm4gbmFtZVN0cmluZy5zcGxpdCgnLycpLnBvcCgpO1xuICAgIH1cbiAgICBlbHNlIGlmICgvXlxcZCskLy50ZXN0KG5hbWVTdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiBuYW1lU3RyaW5nO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGJhdGNoIGpvYiBuYW1lOiAke25hbWVTdHJpbmd9LmApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRKb2JTdGF0ZShzdGF0ZSkge1xuICAgIGNvbnN0IHN0YXRlU3RyaW5nID0gc3RhdGU7XG4gICAgaWYgKHN0YXRlU3RyaW5nID09PSAnQkFUQ0hfU1RBVEVfVU5TUEVDSUZJRUQnKSB7XG4gICAgICAgIHJldHVybiAnSk9CX1NUQVRFX1VOU1BFQ0lGSUVEJztcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhdGVTdHJpbmcgPT09ICdCQVRDSF9TVEFURV9QRU5ESU5HJykge1xuICAgICAgICByZXR1cm4gJ0pPQl9TVEFURV9QRU5ESU5HJztcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhdGVTdHJpbmcgPT09ICdCQVRDSF9TVEFURV9SVU5OSU5HJykge1xuICAgICAgICByZXR1cm4gJ0pPQl9TVEFURV9SVU5OSU5HJztcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhdGVTdHJpbmcgPT09ICdCQVRDSF9TVEFURV9TVUNDRUVERUQnKSB7XG4gICAgICAgIHJldHVybiAnSk9CX1NUQVRFX1NVQ0NFRURFRCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0YXRlU3RyaW5nID09PSAnQkFUQ0hfU1RBVEVfRkFJTEVEJykge1xuICAgICAgICByZXR1cm4gJ0pPQl9TVEFURV9GQUlMRUQnO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdGF0ZVN0cmluZyA9PT0gJ0JBVENIX1NUQVRFX0NBTkNFTExFRCcpIHtcbiAgICAgICAgcmV0dXJuICdKT0JfU1RBVEVfQ0FOQ0VMTEVEJztcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhdGVTdHJpbmcgPT09ICdCQVRDSF9TVEFURV9FWFBJUkVEJykge1xuICAgICAgICByZXR1cm4gJ0pPQl9TVEFURV9FWFBJUkVEJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBzdGF0ZVN0cmluZztcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmZ1bmN0aW9uIGJhdGNoSm9iRGVzdGluYXRpb25Gcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZpbGVOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZXNGaWxlJ10pO1xuICAgIGlmIChmcm9tRmlsZU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlTmFtZSddLCBmcm9tRmlsZU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lZFJlc3BvbnNlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2lubGluZWRSZXNwb25zZXMnLFxuICAgICAgICAnaW5saW5lZFJlc3BvbnNlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21JbmxpbmVkUmVzcG9uc2VzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21JbmxpbmVkUmVzcG9uc2VzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlubGluZWRSZXNwb25zZUZyb21NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lubGluZWRSZXNwb25zZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlubGluZWRFbWJlZENvbnRlbnRSZXNwb25zZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbmxpbmVkRW1iZWRDb250ZW50UmVzcG9uc2VzJyxcbiAgICAgICAgJ2lubGluZWRSZXNwb25zZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tSW5saW5lZEVtYmVkQ29udGVudFJlc3BvbnNlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tSW5saW5lZEVtYmVkQ29udGVudFJlc3BvbnNlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5saW5lZEVtYmVkQ29udGVudFJlc3BvbnNlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBiYXRjaEpvYkRlc3RpbmF0aW9uRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRm9ybWF0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcmVkaWN0aW9uc0Zvcm1hdCddKTtcbiAgICBpZiAoZnJvbUZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Zvcm1hdCddLCBmcm9tRm9ybWF0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2djc0Rlc3RpbmF0aW9uJyxcbiAgICAgICAgJ291dHB1dFVyaVByZWZpeCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21HY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnY3NVcmknXSwgZnJvbUdjc1VyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CaWdxdWVyeVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2JpZ3F1ZXJ5RGVzdGluYXRpb24nLFxuICAgICAgICAnb3V0cHV0VXJpJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUJpZ3F1ZXJ5VXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmlncXVlcnlVcmknXSwgZnJvbUJpZ3F1ZXJ5VXJpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmF0Y2hKb2JEZXN0aW5hdGlvblRvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Gb3JtYXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Zvcm1hdCddKTtcbiAgICBpZiAoZnJvbUZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZWRpY3Rpb25zRm9ybWF0J10sIGZyb21Gb3JtYXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NVcmknXSk7XG4gICAgaWYgKGZyb21HY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnY3NEZXN0aW5hdGlvbicsICdvdXRwdXRVcmlQcmVmaXgnXSwgZnJvbUdjc1VyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CaWdxdWVyeVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmlncXVlcnlVcmknXSk7XG4gICAgaWYgKGZyb21CaWdxdWVyeVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JpZ3F1ZXJ5RGVzdGluYXRpb24nLCAnb3V0cHV0VXJpJ10sIGZyb21CaWdxdWVyeVVyaSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVOYW1lJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWxlTmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lubGluZWRSZXNwb25zZXMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lubGluZWRSZXNwb25zZXMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVkRW1iZWRDb250ZW50UmVzcG9uc2VzJ10pICE9PVxuICAgICAgICB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbmxpbmVkRW1iZWRDb250ZW50UmVzcG9uc2VzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmF0Y2hKb2JGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21ldGFkYXRhJyxcbiAgICAgICAgJ2Rpc3BsYXlOYW1lJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YScsICdzdGF0ZSddKTtcbiAgICBpZiAoZnJvbVN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhdGUnXSwgdEpvYlN0YXRlKGZyb21TdGF0ZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ3JlYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21ldGFkYXRhJyxcbiAgICAgICAgJ2NyZWF0ZVRpbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ3JlYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSwgZnJvbUNyZWF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21ldGFkYXRhJyxcbiAgICAgICAgJ2VuZFRpbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRW5kVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZFRpbWUnXSwgZnJvbUVuZFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXBkYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21ldGFkYXRhJyxcbiAgICAgICAgJ3VwZGF0ZVRpbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVXBkYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSwgZnJvbVVwZGF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJywgJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbCddLCBmcm9tTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0YWRhdGEnLCAnb3V0cHV0J10pO1xuICAgIGlmIChmcm9tRGVzdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc3QnXSwgYmF0Y2hKb2JEZXN0aW5hdGlvbkZyb21NbGRldih0UmVjdkJhdGNoSm9iRGVzdGluYXRpb24oZnJvbURlc3QpKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJhdGNoSm9iRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAoZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGF0ZSddKTtcbiAgICBpZiAoZnJvbVN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhdGUnXSwgdEpvYlN0YXRlKGZyb21TdGF0ZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXJyb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vycm9yJ10pO1xuICAgIGlmIChmcm9tRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlcnJvciddLCBmcm9tRXJyb3IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ3JlYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY3JlYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbUNyZWF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjcmVhdGVUaW1lJ10sIGZyb21DcmVhdGVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXJ0VGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhcnRUaW1lJ10pO1xuICAgIGlmIChmcm9tU3RhcnRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRUaW1lJ10sIGZyb21TdGFydFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kVGltZSddKTtcbiAgICBpZiAoZnJvbUVuZFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRUaW1lJ10sIGZyb21FbmRUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVwZGF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21VcGRhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXBkYXRlVGltZSddLCBmcm9tVXBkYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsJ10sIGZyb21Nb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcmMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lucHV0Q29uZmlnJ10pO1xuICAgIGlmIChmcm9tU3JjICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3JjJ10sIGJhdGNoSm9iU291cmNlRnJvbVZlcnRleChmcm9tU3JjKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXN0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRDb25maWcnXSk7XG4gICAgaWYgKGZyb21EZXN0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzdCddLCBiYXRjaEpvYkRlc3RpbmF0aW9uRnJvbVZlcnRleCh0UmVjdkJhdGNoSm9iRGVzdGluYXRpb24oZnJvbURlc3QpKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db21wbGV0aW9uU3RhdHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb21wbGV0aW9uU3RhdHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29tcGxldGlvblN0YXRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29tcGxldGlvblN0YXRzJ10sIGZyb21Db21wbGV0aW9uU3RhdHMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBiYXRjaEpvYlNvdXJjZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZvcm1hdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5zdGFuY2VzRm9ybWF0J10pO1xuICAgIGlmIChmcm9tRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZm9ybWF0J10sIGZyb21Gb3JtYXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NTb3VyY2UnLCAndXJpcyddKTtcbiAgICBpZiAoZnJvbUdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2djc1VyaSddLCBmcm9tR2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJpZ3F1ZXJ5VXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYmlncXVlcnlTb3VyY2UnLFxuICAgICAgICAnaW5wdXRVcmknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQmlncXVlcnlVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiaWdxdWVyeVVyaSddLCBmcm9tQmlncXVlcnlVcmkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBiYXRjaEpvYlNvdXJjZVRvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmb3JtYXQnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Zvcm1hdCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NVcmknXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2djc1VyaSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiaWdxdWVyeVVyaSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmlncXVlcnlVcmkgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlTmFtZSddKTtcbiAgICBpZiAoZnJvbUZpbGVOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZU5hbWUnXSwgZnJvbUZpbGVOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlubGluZWRSZXF1ZXN0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2lubGluZWRSZXF1ZXN0cycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21JbmxpbmVkUmVxdWVzdHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUlubGluZWRSZXF1ZXN0cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmxpbmVkUmVxdWVzdFRvTWxkZXYoYXBpQ2xpZW50LCBpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlcXVlc3RzJywgJ3JlcXVlc3RzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJhdGNoSm9iU291cmNlVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZvcm1hdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZm9ybWF0J10pO1xuICAgIGlmIChmcm9tRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5zdGFuY2VzRm9ybWF0J10sIGZyb21Gb3JtYXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NVcmknXSk7XG4gICAgaWYgKGZyb21HY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnY3NTb3VyY2UnLCAndXJpcyddLCBmcm9tR2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJpZ3F1ZXJ5VXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiaWdxdWVyeVVyaSddKTtcbiAgICBpZiAoZnJvbUJpZ3F1ZXJ5VXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmlncXVlcnlTb3VyY2UnLCAnaW5wdXRVcmknXSwgZnJvbUJpZ3F1ZXJ5VXJpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpbGVOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5saW5lZFJlcXVlc3RzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbmxpbmVkUmVxdWVzdHMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBibG9iVG9NbGRldiQ0KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkYXRhJ10pO1xuICAgIGlmIChmcm9tRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RhdGEnXSwgZnJvbURhdGEpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGlzcGxheU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY2FuY2VsQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0QmF0Y2hKb2JOYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY2FuY2VsQmF0Y2hKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdEJhdGNoSm9iTmFtZShhcGlDbGllbnQsIGZyb21OYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNhbmRpZGF0ZUZyb21NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db250ZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50J10pO1xuICAgIGlmIChmcm9tQ29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRlbnQnXSwgZnJvbUNvbnRlbnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2l0YXRpb25NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NpdGF0aW9uTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2l0YXRpb25NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NpdGF0aW9uTWV0YWRhdGEnXSwgY2l0YXRpb25NZXRhZGF0YUZyb21NbGRldiQxKGZyb21DaXRhdGlvbk1ldGFkYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b2tlbkNvdW50J10pO1xuICAgIGlmIChmcm9tVG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rva2VuQ291bnQnXSwgZnJvbVRva2VuQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmluaXNoUmVhc29uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaW5pc2hSZWFzb24nXSk7XG4gICAgaWYgKGZyb21GaW5pc2hSZWFzb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaW5pc2hSZWFzb24nXSwgZnJvbUZpbmlzaFJlYXNvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BdmdMb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXZnTG9ncHJvYnMnXSk7XG4gICAgaWYgKGZyb21BdmdMb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F2Z0xvZ3Byb2JzJ10sIGZyb21BdmdMb2dwcm9icyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hcm91bmRpbmdNZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dyb3VuZGluZ01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdyb3VuZGluZ01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ3JvdW5kaW5nTWV0YWRhdGEnXSwgZnJvbUdyb3VuZGluZ01ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUluZGV4ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmRleCddKTtcbiAgICBpZiAoZnJvbUluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5kZXgnXSwgZnJvbUluZGV4KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxvZ3Byb2JzUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbG9ncHJvYnNSZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTG9ncHJvYnNSZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsb2dwcm9ic1Jlc3VsdCddLCBmcm9tTG9ncHJvYnNSZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5UmF0aW5ncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eVJhdGluZ3MnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2FmZXR5UmF0aW5ncyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tU2FmZXR5UmF0aW5ncztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2FmZXR5UmF0aW5ncyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJsQ29udGV4dE1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndXJsQ29udGV4dE1ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVybENvbnRleHRNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHRNZXRhZGF0YSddLCBmcm9tVXJsQ29udGV4dE1ldGFkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY2l0YXRpb25NZXRhZGF0YUZyb21NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21DaXRhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NpdGF0aW9uU291cmNlcyddKTtcbiAgICBpZiAoZnJvbUNpdGF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQ2l0YXRpb25zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjaXRhdGlvbnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudFRvTWxkZXYkNChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFydHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRzJ10pO1xuICAgIGlmIChmcm9tUGFydHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVBhcnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRUb01sZGV2JDQoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm9sZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm9sZSddKTtcbiAgICBpZiAoZnJvbVJvbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb2xlJ10sIGZyb21Sb2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQmF0Y2hKb2JDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2JhdGNoJywgJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc3QnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rlc3QgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQmF0Y2hKb2JDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzdCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURlc3QgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnb3V0cHV0Q29uZmlnJ10sIGJhdGNoSm9iRGVzdGluYXRpb25Ub1ZlcnRleCh0QmF0Y2hKb2JEZXN0aW5hdGlvbihmcm9tRGVzdCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcmMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NyYyddKTtcbiAgICBpZiAoZnJvbVNyYyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JhdGNoJywgJ2lucHV0Q29uZmlnJ10sIGJhdGNoSm9iU291cmNlVG9NbGRldihhcGlDbGllbnQsIHRCYXRjaEpvYlNvdXJjZShhcGlDbGllbnQsIGZyb21TcmMpKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGNyZWF0ZUJhdGNoSm9iQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJhdGNoSm9iUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcmMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NyYyddKTtcbiAgICBpZiAoZnJvbVNyYyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lucHV0Q29uZmlnJ10sIGJhdGNoSm9iU291cmNlVG9WZXJ0ZXgodEJhdGNoSm9iU291cmNlKGFwaUNsaWVudCwgZnJvbVNyYykpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgY3JlYXRlQmF0Y2hKb2JDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVtYmVkZGluZ3NCYXRjaEpvYkNvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnYmF0Y2gnLCAnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlRW1iZWRkaW5nc0JhdGNoSm9iUGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3JjID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzcmMnXSk7XG4gICAgaWYgKGZyb21TcmMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiYXRjaCcsICdpbnB1dENvbmZpZyddLCBlbWJlZGRpbmdzQmF0Y2hKb2JTb3VyY2VUb01sZGV2KGFwaUNsaWVudCwgZnJvbVNyYykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBjcmVhdGVFbWJlZGRpbmdzQmF0Y2hKb2JDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0QmF0Y2hKb2JOYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdEJhdGNoSm9iTmFtZShhcGlDbGllbnQsIGZyb21OYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZVJlc291cmNlSm9iRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvbmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RvbmUnXSk7XG4gICAgaWYgKGZyb21Eb25lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9uZSddLCBmcm9tRG9uZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZyb21FcnJvcik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZVJlc291cmNlSm9iRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Eb25lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkb25lJ10pO1xuICAgIGlmIChmcm9tRG9uZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RvbmUnXSwgZnJvbURvbmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXJyb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vycm9yJ10pO1xuICAgIGlmIChmcm9tRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlcnJvciddLCBmcm9tRXJyb3IpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbWJlZENvbnRlbnRCYXRjaFRvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdENvbnRlbnRzRm9yRW1iZWQoYXBpQ2xpZW50LCBmcm9tQ29udGVudHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXF1ZXN0c1tdJywgJ3JlcXVlc3QnLCAnY29udGVudCddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfc2VsZiddLCBlbWJlZENvbnRlbnRDb25maWdUb01sZGV2JDEoZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICAgICAgbW92ZVZhbHVlQnlQYXRoKHRvT2JqZWN0LCB7ICdyZXF1ZXN0c1tdLionOiAncmVxdWVzdHNbXS5yZXF1ZXN0LionIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbWJlZENvbnRlbnRDb25maWdUb01sZGV2JDEoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVGFza1R5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rhc2tUeXBlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGFza1R5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncmVxdWVzdHNbXScsICd0YXNrVHlwZSddLCBmcm9tVGFza1R5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGl0bGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RpdGxlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGl0bGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncmVxdWVzdHNbXScsICd0aXRsZSddLCBmcm9tVGl0bGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0RGltZW5zaW9uYWxpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXREaW1lbnNpb25hbGl0eScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXREaW1lbnNpb25hbGl0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydyZXF1ZXN0c1tdJywgJ291dHB1dERpbWVuc2lvbmFsaXR5J10sIGZyb21PdXRwdXREaW1lbnNpb25hbGl0eSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaW1lVHlwZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdXRvVHJ1bmNhdGUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F1dG9UcnVuY2F0ZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbWJlZGRpbmdzQmF0Y2hKb2JTb3VyY2VUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZpbGVOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlTmFtZSddKTtcbiAgICBpZiAoZnJvbUZpbGVOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZV9uYW1lJ10sIGZyb21GaWxlTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVkUmVxdWVzdHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbmxpbmVkUmVxdWVzdHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tSW5saW5lZFJlcXVlc3RzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVxdWVzdHMnXSwgZW1iZWRDb250ZW50QmF0Y2hUb01sZGV2KGFwaUNsaWVudCwgZnJvbUlubGluZWRSZXF1ZXN0cykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmaWxlRGF0YVRvTWxkZXYkNChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGlzcGxheU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVVcmknXSk7XG4gICAgaWYgKGZyb21GaWxlVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZVVyaSddLCBmcm9tRmlsZVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbFRvTWxkZXYkNChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lkJ10pO1xuICAgIGlmIChmcm9tSWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpZCddLCBmcm9tSWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXJncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXJncyddKTtcbiAgICBpZiAoZnJvbUFyZ3MgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhcmdzJ10sIGZyb21BcmdzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRpYWxBcmdzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXJ0aWFsQXJncyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd3aWxsQ29udGludWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dpbGxDb250aW51ZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkNhbGxpbmdDb25maWdUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGUnXSk7XG4gICAgaWYgKGZyb21Nb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZSddLCBmcm9tTW9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BbGxvd2VkRnVuY3Rpb25OYW1lcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2FsbG93ZWRGdW5jdGlvbk5hbWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYWxsb3dlZEZ1bmN0aW9uTmFtZXMnXSwgZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RyZWFtRnVuY3Rpb25DYWxsQXJndW1lbnRzJ10pICE9PVxuICAgICAgICB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHJlYW1GdW5jdGlvbkNhbGxBcmd1bWVudHMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVDb250ZW50Q29uZmlnVG9NbGRldiQxKGFwaUNsaWVudCwgZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TeXN0ZW1JbnN0cnVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzeXN0ZW1JbnN0cnVjdGlvbiddLCBjb250ZW50VG9NbGRldiQ0KHRDb250ZW50KGZyb21TeXN0ZW1JbnN0cnVjdGlvbikpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRlbXBlcmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZW1wZXJhdHVyZSddKTtcbiAgICBpZiAoZnJvbVRlbXBlcmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGVtcGVyYXR1cmUnXSwgZnJvbVRlbXBlcmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcFAgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcFAnXSk7XG4gICAgaWYgKGZyb21Ub3BQICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9wUCddLCBmcm9tVG9wUCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BLID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BLJ10pO1xuICAgIGlmIChmcm9tVG9wSyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvcEsnXSwgZnJvbVRvcEspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FuZGlkYXRlQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYW5kaWRhdGVDb3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYW5kaWRhdGVDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhbmRpZGF0ZUNvdW50J10sIGZyb21DYW5kaWRhdGVDb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhPdXRwdXRUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXhPdXRwdXRUb2tlbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWF4T3V0cHV0VG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWF4T3V0cHV0VG9rZW5zJ10sIGZyb21NYXhPdXRwdXRUb2tlbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RvcFNlcXVlbmNlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N0b3BTZXF1ZW5jZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3RvcFNlcXVlbmNlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0b3BTZXF1ZW5jZXMnXSwgZnJvbVN0b3BTZXF1ZW5jZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VMb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTG9ncHJvYnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VMb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTG9ncHJvYnMnXSwgZnJvbVJlc3BvbnNlTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTG9ncHJvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xvZ3Byb2JzJ10pO1xuICAgIGlmIChmcm9tTG9ncHJvYnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsb2dwcm9icyddLCBmcm9tTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJlc2VuY2VQZW5hbHR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlc2VuY2VQZW5hbHR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByZXNlbmNlUGVuYWx0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZXNlbmNlUGVuYWx0eSddLCBmcm9tUHJlc2VuY2VQZW5hbHR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZyZXF1ZW5jeVBlbmFsdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmcmVxdWVuY3lQZW5hbHR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZyZXF1ZW5jeVBlbmFsdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmcmVxdWVuY3lQZW5hbHR5J10sIGZyb21GcmVxdWVuY3lQZW5hbHR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VNaW1lVHlwZSddLCBmcm9tUmVzcG9uc2VNaW1lVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZVNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VTY2hlbWEnXSwgdFNjaGVtYShmcm9tUmVzcG9uc2VTY2hlbWEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUpzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUpzb25TY2hlbWEnXSwgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JvdXRpbmdDb25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JvdXRpbmdDb25maWcgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWxTZWxlY3Rpb25Db25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21vZGVsU2VsZWN0aW9uQ29uZmlnIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlTZXR0aW5ncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eVNldHRpbmdzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNhZmV0eVNldHRpbmdzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21TYWZldHlTZXR0aW5ncztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBzYWZldHlTZXR0aW5nVG9NbGRldiQxKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NhZmV0eVNldHRpbmdzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29scyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29scyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0VG9vbHMoZnJvbVRvb2xzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b29sVG9NbGRldiQ0KHRUb29sKGl0ZW0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29scyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbENvbmZpZyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndG9vbENvbmZpZyddLCB0b29sQ29uZmlnVG9NbGRldiQyKGZyb21Ub29sQ29uZmlnKSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhYmVscyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbGFiZWxzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYWNoZWRDb250ZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FjaGVkQ29udGVudCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21DYWNoZWRDb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2NhY2hlZENvbnRlbnQnXSwgdENhY2hlZENvbnRlbnROYW1lKGFwaUNsaWVudCwgZnJvbUNhY2hlZENvbnRlbnQpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTW9kYWxpdGllcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZU1vZGFsaXRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZU1vZGFsaXRpZXMnXSwgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZWRpYVJlc29sdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtZWRpYVJlc29sdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWVkaWFSZXNvbHV0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWVkaWFSZXNvbHV0aW9uJ10sIGZyb21NZWRpYVJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3BlZWNoQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzcGVlY2hDb25maWcnXSk7XG4gICAgaWYgKGZyb21TcGVlY2hDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzcGVlY2hDb25maWcnXSwgdFNwZWVjaENvbmZpZyhmcm9tU3BlZWNoQ29uZmlnKSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1ZGlvVGltZXN0YW1wJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdWRpb1RpbWVzdGFtcCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhpbmtpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aGlua2luZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaGlua2luZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RoaW5raW5nQ29uZmlnJ10sIGZyb21UaGlua2luZ0NvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2VDb25maWcnXSk7XG4gICAgaWYgKGZyb21JbWFnZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ltYWdlQ29uZmlnJ10sIGltYWdlQ29uZmlnVG9NbGRldiQxKGZyb21JbWFnZUNvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUNvbnRlbnRSZXNwb25zZUZyb21NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FuZGlkYXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY2FuZGlkYXRlcyddKTtcbiAgICBpZiAoZnJvbUNhbmRpZGF0ZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUNhbmRpZGF0ZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FuZGlkYXRlRnJvbU1sZGV2JDEoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYW5kaWRhdGVzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Nb2RlbFZlcnNpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsVmVyc2lvbiddKTtcbiAgICBpZiAoZnJvbU1vZGVsVmVyc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsVmVyc2lvbiddLCBmcm9tTW9kZWxWZXJzaW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb21wdEZlZWRiYWNrID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJvbXB0RmVlZGJhY2snLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJvbXB0RmVlZGJhY2sgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9tcHRGZWVkYmFjayddLCBmcm9tUHJvbXB0RmVlZGJhY2spO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VJZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2VJZCddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUlkJ10sIGZyb21SZXNwb25zZUlkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVzYWdlTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd1c2FnZU1ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVzYWdlTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1c2FnZU1ldGFkYXRhJ10sIGZyb21Vc2FnZU1ldGFkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0QmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0QmF0Y2hKb2JOYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0QmF0Y2hKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdEJhdGNoSm9iTmFtZShhcGlDbGllbnQsIGZyb21OYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZU1hcHNUb01sZGV2JDQoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXV0aENvbmZpZyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXV0aENvbmZpZyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5hYmxlV2lkZ2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmFibGVXaWRnZXQnXSk7XG4gICAgaWYgKGZyb21FbmFibGVXaWRnZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmFibGVXaWRnZXQnXSwgZnJvbUVuYWJsZVdpZGdldCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFRvTWxkZXYkNChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleGNsdWRlRG9tYWlucyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhjbHVkZURvbWFpbnMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmxvY2tpbmdDb25maWRlbmNlJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdibG9ja2luZ0NvbmZpZGVuY2UgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRpbWVSYW5nZUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RpbWVSYW5nZUZpbHRlcicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaW1lUmFuZ2VGaWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aW1lUmFuZ2VGaWx0ZXInXSwgZnJvbVRpbWVSYW5nZUZpbHRlcik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGltYWdlQ29uZmlnVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Bc3BlY3RSYXRpbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXNwZWN0UmF0aW8nXSk7XG4gICAgaWYgKGZyb21Bc3BlY3RSYXRpbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FzcGVjdFJhdGlvJ10sIGZyb21Bc3BlY3RSYXRpbyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZVNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlU2l6ZSddKTtcbiAgICBpZiAoZnJvbUltYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ltYWdlU2l6ZSddLCBmcm9tSW1hZ2VTaXplKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0TWltZVR5cGUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dHB1dE1pbWVUeXBlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ291dHB1dENvbXByZXNzaW9uUXVhbGl0eSddKSAhPT1cbiAgICAgICAgdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5IHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGlubGluZWRSZXF1ZXN0VG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlcXVlc3QnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudHMnXSk7XG4gICAgaWYgKGZyb21Db250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0Q29udGVudHMoZnJvbUNvbnRlbnRzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50VG9NbGRldiQ0KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVxdWVzdCcsICdjb250ZW50cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJ10pO1xuICAgIGlmIChmcm9tTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZXRhZGF0YSddLCBmcm9tTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXF1ZXN0JywgJ2dlbmVyYXRpb25Db25maWcnXSwgZ2VuZXJhdGVDb250ZW50Q29uZmlnVG9NbGRldiQxKGFwaUNsaWVudCwgZnJvbUNvbmZpZywgZ2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVxdWVzdCddLCB7fSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW5saW5lZFJlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2UnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlJ10sIGdlbmVyYXRlQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2JDEoZnJvbVJlc3BvbnNlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZyb21FcnJvcik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RCYXRjaEpvYnNDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlU2l6ZSddLCBmcm9tUGFnZVNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlVG9rZW4nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VUb2tlbiddLCBmcm9tUGFnZVRva2VuKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsdGVyJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWx0ZXIgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdEJhdGNoSm9ic0NvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlU2l6ZSddLCBmcm9tUGFnZVNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlVG9rZW4nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VUb2tlbiddLCBmcm9tUGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsdGVyJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdmaWx0ZXInXSwgZnJvbUZpbHRlcik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RCYXRjaEpvYnNQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBsaXN0QmF0Y2hKb2JzQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RCYXRjaEpvYnNQYXJhbWV0ZXJzVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgbGlzdEJhdGNoSm9ic0NvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdEJhdGNoSm9ic1Jlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmV4dFBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25leHRQYWdlVG9rZW4nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTmV4dFBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25leHRQYWdlVG9rZW4nXSwgZnJvbU5leHRQYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmF0Y2hKb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvcGVyYXRpb25zJ10pO1xuICAgIGlmIChmcm9tQmF0Y2hKb2JzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21CYXRjaEpvYnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmF0Y2hKb2JGcm9tTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiYXRjaEpvYnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdEJhdGNoSm9ic1Jlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5leHRQYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXh0UGFnZVRva2VuJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU5leHRQYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXh0UGFnZVRva2VuJ10sIGZyb21OZXh0UGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJhdGNoSm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2JhdGNoUHJlZGljdGlvbkpvYnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQmF0Y2hKb2JzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21CYXRjaEpvYnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmF0Y2hKb2JGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmF0Y2hKb2JzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHBhcnRUb01sZGV2JDQoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1lZGlhUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21lZGlhUmVzb2x1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NZWRpYVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZWRpYVJlc29sdXRpb24nXSwgZnJvbU1lZGlhUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvblJlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvblJlc3VsdCddLCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGVjdXRhYmxlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4ZWN1dGFibGVDb2RlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4ZWN1dGFibGVDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhlY3V0YWJsZUNvZGUnXSwgZnJvbUV4ZWN1dGFibGVDb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlRGF0YSddKTtcbiAgICBpZiAoZnJvbUZpbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZURhdGEnXSwgZmlsZURhdGFUb01sZGV2JDQoZnJvbUZpbGVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddLCBmdW5jdGlvbkNhbGxUb01sZGV2JDQoZnJvbUZ1bmN0aW9uQ2FsbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uUmVzcG9uc2UnXSwgZnJvbUZ1bmN0aW9uUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5saW5lRGF0YSddKTtcbiAgICBpZiAoZnJvbUlubGluZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmxpbmVEYXRhJ10sIGJsb2JUb01sZGV2JDQoZnJvbUlubGluZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aG91Z2h0J10pO1xuICAgIGlmIChmcm9tVGhvdWdodCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHQnXSwgZnJvbVRob3VnaHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodFNpZ25hdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rob3VnaHRTaWduYXR1cmUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhvdWdodFNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHRTaWduYXR1cmUnXSwgZnJvbVRob3VnaHRTaWduYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW9NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ZpZGVvTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvTWV0YWRhdGEnXSwgZnJvbVZpZGVvTWV0YWRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzYWZldHlTZXR0aW5nVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21DYXRlZ29yeSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY2F0ZWdvcnknXSk7XG4gICAgaWYgKGZyb21DYXRlZ29yeSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhdGVnb3J5J10sIGZyb21DYXRlZ29yeSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGhvZCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWV0aG9kIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaHJlc2hvbGQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RocmVzaG9sZCddKTtcbiAgICBpZiAoZnJvbVRocmVzaG9sZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RocmVzaG9sZCddLCBmcm9tVGhyZXNob2xkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbENvbmZpZ1RvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxsaW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25DYWxsaW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbGluZ0NvbmZpZyddLCBmdW5jdGlvbkNhbGxpbmdDb25maWdUb01sZGV2JDIoZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmV0cmlldmFsQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmV0cmlldmFsQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJldHJpZXZhbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JldHJpZXZhbENvbmZpZyddLCBmcm9tUmV0cmlldmFsQ29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbFRvTWxkZXYkNChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkRlY2xhcmF0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JldHJpZXZhbCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmV0cmlldmFsIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnb29nbGVTZWFyY2hSZXRyaWV2YWwnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJ10sIGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29tcHV0ZXJVc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10pO1xuICAgIGlmIChmcm9tQ29tcHV0ZXJVc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb21wdXRlclVzZSddLCBmcm9tQ29tcHV0ZXJVc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZVNlYXJjaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZVNlYXJjaCddKTtcbiAgICBpZiAoZnJvbUZpbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlU2VhcmNoJ10sIGZyb21GaWxlU2VhcmNoKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uJ10sIGZyb21Db2RlRXhlY3V0aW9uKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW50ZXJwcmlzZVdlYlNlYXJjaCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZW50ZXJwcmlzZVdlYlNlYXJjaCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlTWFwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlTWFwcyddKTtcbiAgICBpZiAoZnJvbUdvb2dsZU1hcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVNYXBzJ10sIGdvb2dsZU1hcHNUb01sZGV2JDQoZnJvbUdvb2dsZU1hcHMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10sIGdvb2dsZVNlYXJjaFRvTWxkZXYkNChmcm9tR29vZ2xlU2VhcmNoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmxDb250ZXh0J10pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHQnXSwgZnJvbVVybENvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbnZhciBQYWdlZEl0ZW07XG4oZnVuY3Rpb24gKFBhZ2VkSXRlbSkge1xuICAgIFBhZ2VkSXRlbVtcIlBBR0VEX0lURU1fQkFUQ0hfSk9CU1wiXSA9IFwiYmF0Y2hKb2JzXCI7XG4gICAgUGFnZWRJdGVtW1wiUEFHRURfSVRFTV9NT0RFTFNcIl0gPSBcIm1vZGVsc1wiO1xuICAgIFBhZ2VkSXRlbVtcIlBBR0VEX0lURU1fVFVOSU5HX0pPQlNcIl0gPSBcInR1bmluZ0pvYnNcIjtcbiAgICBQYWdlZEl0ZW1bXCJQQUdFRF9JVEVNX0ZJTEVTXCJdID0gXCJmaWxlc1wiO1xuICAgIFBhZ2VkSXRlbVtcIlBBR0VEX0lURU1fQ0FDSEVEX0NPTlRFTlRTXCJdID0gXCJjYWNoZWRDb250ZW50c1wiO1xuICAgIFBhZ2VkSXRlbVtcIlBBR0VEX0lURU1fRklMRV9TRUFSQ0hfU1RPUkVTXCJdID0gXCJmaWxlU2VhcmNoU3RvcmVzXCI7XG4gICAgUGFnZWRJdGVtW1wiUEFHRURfSVRFTV9ET0NVTUVOVFNcIl0gPSBcImRvY3VtZW50c1wiO1xufSkoUGFnZWRJdGVtIHx8IChQYWdlZEl0ZW0gPSB7fSkpO1xuLyoqXG4gKiBQYWdlciBjbGFzcyBmb3IgaXRlcmF0aW5nIHRocm91Z2ggcGFnaW5hdGVkIHJlc3VsdHMuXG4gKi9cbmNsYXNzIFBhZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCByZXF1ZXN0LCByZXNwb25zZSwgcGFyYW1zKSB7XG4gICAgICAgIHRoaXMucGFnZUludGVybmFsID0gW107XG4gICAgICAgIHRoaXMucGFyYW1zSW50ZXJuYWwgPSB7fTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0SW50ZXJuYWwgPSByZXF1ZXN0O1xuICAgICAgICB0aGlzLmluaXQobmFtZSwgcmVzcG9uc2UsIHBhcmFtcyk7XG4gICAgfVxuICAgIGluaXQobmFtZSwgcmVzcG9uc2UsIHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLm5hbWVJbnRlcm5hbCA9IG5hbWU7XG4gICAgICAgIHRoaXMucGFnZUludGVybmFsID0gcmVzcG9uc2VbdGhpcy5uYW1lSW50ZXJuYWxdIHx8IFtdO1xuICAgICAgICB0aGlzLnNka0h0dHBSZXNwb25zZUludGVybmFsID0gcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZTtcbiAgICAgICAgdGhpcy5pZHhJbnRlcm5hbCA9IDA7XG4gICAgICAgIGxldCByZXF1ZXN0UGFyYW1zID0geyBjb25maWc6IHt9IH07XG4gICAgICAgIGlmICghcGFyYW1zIHx8IE9iamVjdC5rZXlzKHBhcmFtcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXF1ZXN0UGFyYW1zID0geyBjb25maWc6IHt9IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHBhcmFtcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJlcXVlc3RQYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVxdWVzdFBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxdWVzdFBhcmFtc1snY29uZmlnJ10pIHtcbiAgICAgICAgICAgIHJlcXVlc3RQYXJhbXNbJ2NvbmZpZyddWydwYWdlVG9rZW4nXSA9IHJlc3BvbnNlWyduZXh0UGFnZVRva2VuJ107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJhbXNJbnRlcm5hbCA9IHJlcXVlc3RQYXJhbXM7XG4gICAgICAgIHRoaXMucGFnZUludGVybmFsU2l6ZSA9XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSByZXF1ZXN0UGFyYW1zWydjb25maWcnXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWydwYWdlU2l6ZSddKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0aGlzLnBhZ2VJbnRlcm5hbC5sZW5ndGg7XG4gICAgfVxuICAgIGluaXROZXh0UGFnZShyZXNwb25zZSkge1xuICAgICAgICB0aGlzLmluaXQodGhpcy5uYW1lSW50ZXJuYWwsIHJlc3BvbnNlLCB0aGlzLnBhcmFtc0ludGVybmFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBwYWdlLCB3aGljaCBpcyBhIGxpc3Qgb2YgaXRlbXMuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoZSBmaXJzdCBwYWdlIGlzIHJldHJpZXZlZCB3aGVuIHRoZSBwYWdlciBpcyBjcmVhdGVkLiBUaGUgcmV0dXJuZWQgbGlzdCBvZlxuICAgICAqIGl0ZW1zIGNvdWxkIGJlIGEgc3Vic2V0IG9mIHRoZSBlbnRpcmUgbGlzdC5cbiAgICAgKi9cbiAgICBnZXQgcGFnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFnZUludGVybmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0eXBlIG9mIHBhZ2VkIGl0ZW0gKGZvciBleGFtcGxlLCBgYGJhdGNoX2pvYnNgYCkuXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWVJbnRlcm5hbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBwYWdlIGZldGNoZWQgZWFjaCB0aW1lIGJ5IHRoaXMgcGFnZXIuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoZSBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIHBhZ2UgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwYWdlIGxlbmd0aC5cbiAgICAgKi9cbiAgICBnZXQgcGFnZVNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhZ2VJbnRlcm5hbFNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGhlYWRlcnMgb2YgdGhlIEFQSSByZXNwb25zZS5cbiAgICAgKi9cbiAgICBnZXQgc2RrSHR0cFJlc3BvbnNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZGtIdHRwUmVzcG9uc2VJbnRlcm5hbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGFyYW1ldGVycyB3aGVuIG1ha2luZyB0aGUgQVBJIHJlcXVlc3QgZm9yIHRoZSBuZXh0IHBhZ2UuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFBhcmFtZXRlcnMgY29udGFpbiBhIHNldCBvZiBvcHRpb25hbCBjb25maWdzIHRoYXQgY2FuIGJlXG4gICAgICogdXNlZCB0byBjdXN0b21pemUgdGhlIEFQSSByZXF1ZXN0LiBGb3IgZXhhbXBsZSwgdGhlIGBwYWdlVG9rZW5gIHBhcmFtZXRlclxuICAgICAqIGNvbnRhaW5zIHRoZSB0b2tlbiB0byByZXF1ZXN0IHRoZSBuZXh0IHBhZ2UuXG4gICAgICovXG4gICAgZ2V0IHBhcmFtcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1zSW50ZXJuYWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRvdGFsIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgY3VycmVudCBwYWdlLlxuICAgICAqL1xuICAgIGdldCBwYWdlTGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYWdlSW50ZXJuYWwubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpdGVtIGF0IHRoZSBnaXZlbiBpbmRleC5cbiAgICAgKi9cbiAgICBnZXRJdGVtKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhZ2VJbnRlcm5hbFtpbmRleF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXN5bmMgaXRlcmF0b3IgdGhhdCBzdXBwb3J0IGl0ZXJhdGluZyB0aHJvdWdoIGFsbCBpdGVtc1xuICAgICAqIHJldHJpZXZlZCBmcm9tIHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoZSBpdGVyYXRvciB3aWxsIGF1dG9tYXRpY2FsbHkgZmV0Y2ggdGhlIG5leHQgcGFnZSBpZiB0aGVyZSBhcmUgbW9yZSBpdGVtc1xuICAgICAqIHRvIGZldGNoIGZyb20gdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHBhZ2VyID0gYXdhaXQgYWkuZmlsZXMubGlzdCh7Y29uZmlnOiB7cGFnZVNpemU6IDEwfX0pO1xuICAgICAqIGZvciBhd2FpdCAoY29uc3QgZmlsZSBvZiBwYWdlcikge1xuICAgICAqICAgY29uc29sZS5sb2coZmlsZS5uYW1lKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQ6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHhJbnRlcm5hbCA+PSB0aGlzLnBhZ2VMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzTmV4dFBhZ2UoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5uZXh0UGFnZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLmdldEl0ZW0odGhpcy5pZHhJbnRlcm5hbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHhJbnRlcm5hbCArPSAxO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBpdGVtLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJldHVybjogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgdGhlIG5leHQgcGFnZSBvZiBpdGVtcy4gVGhpcyBtYWtlcyBhIG5ldyBBUEkgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSBhcmUgbm8gbW9yZSBwYWdlcyB0byBmZXRjaC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHBhZ2VyID0gYXdhaXQgYWkuZmlsZXMubGlzdCh7Y29uZmlnOiB7cGFnZVNpemU6IDEwfX0pO1xuICAgICAqIGxldCBwYWdlID0gcGFnZXIucGFnZTtcbiAgICAgKiB3aGlsZSAodHJ1ZSkge1xuICAgICAqICAgZm9yIChjb25zdCBmaWxlIG9mIHBhZ2UpIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coZmlsZS5uYW1lKTtcbiAgICAgKiAgIH1cbiAgICAgKiAgIGlmICghcGFnZXIuaGFzTmV4dFBhZ2UoKSkge1xuICAgICAqICAgICBicmVhaztcbiAgICAgKiAgIH1cbiAgICAgKiAgIHBhZ2UgPSBhd2FpdCBwYWdlci5uZXh0UGFnZSgpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBuZXh0UGFnZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc05leHRQYWdlKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gbW9yZSBwYWdlcyB0byBmZXRjaC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucmVxdWVzdEludGVybmFsKHRoaXMucGFyYW1zKTtcbiAgICAgICAgdGhpcy5pbml0TmV4dFBhZ2UocmVzcG9uc2UpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYWdlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlcmUgYXJlIG1vcmUgcGFnZXMgdG8gZmV0Y2ggZnJvbSB0aGUgQVBJLlxuICAgICAqL1xuICAgIGhhc05leHRQYWdlKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICgoKF9hID0gdGhpcy5wYXJhbXNbJ2NvbmZpZyddKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbJ3BhZ2VUb2tlbiddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBCYXRjaGVzIGV4dGVuZHMgQmFzZU1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdHMgYmF0Y2ggam9icy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgbGlzdCByZXF1ZXN0LlxuICAgICAgICAgKiBAcmV0dXJuIC0gQSBwYWdlciBvZiBiYXRjaCBqb2JzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBjb25zdCBiYXRjaEpvYnMgPSBhd2FpdCBhaS5iYXRjaGVzLmxpc3Qoe2NvbmZpZzogeydwYWdlU2l6ZSc6IDJ9fSk7XG4gICAgICAgICAqIGZvciBhd2FpdCAoY29uc3QgYmF0Y2hKb2Igb2YgYmF0Y2hKb2JzKSB7XG4gICAgICAgICAqICAgY29uc29sZS5sb2coYmF0Y2hKb2IpO1xuICAgICAgICAgKiB9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saXN0ID0gYXN5bmMgKHBhcmFtcyA9IHt9KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhZ2VyKFBhZ2VkSXRlbS5QQUdFRF9JVEVNX0JBVENIX0pPQlMsICh4KSA9PiB0aGlzLmxpc3RJbnRlcm5hbCh4KSwgYXdhaXQgdGhpcy5saXN0SW50ZXJuYWwocGFyYW1zKSwgcGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBiYXRjaCBqb2IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgY3JlYXRlIGJhdGNoIGpvYiByZXF1ZXN0LlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSBjcmVhdGVkIGJhdGNoIGpvYi5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5iYXRjaGVzLmNyZWF0ZSh7XG4gICAgICAgICAqICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJyxcbiAgICAgICAgICogICBzcmM6IHtnY3NVcmk6ICdnczovL2J1Y2tldC9wYXRoL3RvL2ZpbGUuanNvbmwnLCBmb3JtYXQ6ICdqc29ubCd9LFxuICAgICAgICAgKiAgIGNvbmZpZzoge1xuICAgICAgICAgKiAgICAgZGVzdDoge2djc1VyaTogJ2dzOi8vYnVja2V0L3BhdGgvb3V0cHV0L2RpcmVjdG9yeScsIGZvcm1hdDogJ2pzb25sJ30sXG4gICAgICAgICAqICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICogY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3JlYXRlID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgICAgIC8vIEZvcm1hdCBkZXN0aW5hdGlvbiBpZiBub3QgcHJvdmlkZWRcbiAgICAgICAgICAgICAgICAvLyBDYXN0IHBhcmFtcy5zcmMgYXMgVmVydGV4IEFJIHBhdGggZG9lcyBub3QgaGFuZGxlIElubGluZWRSZXF1ZXN0W11cbiAgICAgICAgICAgICAgICBwYXJhbXMuY29uZmlnID0gdGhpcy5mb3JtYXREZXN0aW5hdGlvbihwYXJhbXMuc3JjLCBwYXJhbXMuY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUludGVybmFsKHBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiAqKkV4cGVyaW1lbnRhbCoqIENyZWF0ZXMgYW4gZW1iZWRkaW5nIGJhdGNoIGpvYi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBjcmVhdGUgZW1iZWRkaW5nIGJhdGNoIGpvYiByZXF1ZXN0LlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSBjcmVhdGVkIGJhdGNoIGpvYi5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5iYXRjaGVzLmNyZWF0ZUVtYmVkZGluZ3Moe1xuICAgICAgICAgKiAgIG1vZGVsOiAndGV4dC1lbWJlZGRpbmctMDA0JyxcbiAgICAgICAgICogICBzcmM6IHtmaWxlTmFtZTogJ2ZpbGVzL215X2VtYmVkZGluZ19pbnB1dCd9LFxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICogY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3JlYXRlRW1iZWRkaW5ncyA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignYmF0Y2hlcy5jcmVhdGVFbWJlZGRpbmdzKCkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlIHdpdGhvdXQgbm90aWNlLicpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmVydGV4IEFJIGRvZXMgbm90IHN1cHBvcnQgYmF0Y2hlcy5jcmVhdGVFbWJlZGRpbmdzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRW1iZWRkaW5nc0ludGVybmFsKHBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBoYW5kbGUgaW5saW5lZCBnZW5lcmF0ZSBjb250ZW50IHJlcXVlc3RzXG4gICAgY3JlYXRlSW5saW5lZEdlbmVyYXRlQ29udGVudFJlcXVlc3QocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBjcmVhdGVCYXRjaEpvYlBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCAvLyBVc2UgaW5zdGFuY2UgYXBpQ2xpZW50XG4gICAgICAgIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHVybFBhcmFtcyA9IGJvZHlbJ191cmwnXTtcbiAgICAgICAgY29uc3QgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpiYXRjaEdlbmVyYXRlQ29udGVudCcsIHVybFBhcmFtcyk7XG4gICAgICAgIGNvbnN0IGJhdGNoID0gYm9keVsnYmF0Y2gnXTtcbiAgICAgICAgY29uc3QgaW5wdXRDb25maWcgPSBiYXRjaFsnaW5wdXRDb25maWcnXTtcbiAgICAgICAgY29uc3QgcmVxdWVzdHNXcmFwcGVyID0gaW5wdXRDb25maWdbJ3JlcXVlc3RzJ107XG4gICAgICAgIGNvbnN0IHJlcXVlc3RzID0gcmVxdWVzdHNXcmFwcGVyWydyZXF1ZXN0cyddO1xuICAgICAgICBjb25zdCBuZXdSZXF1ZXN0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHJlcXVlc3Qgb2YgcmVxdWVzdHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3REaWN0ID0gT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdCk7IC8vIENsb25lXG4gICAgICAgICAgICBpZiAocmVxdWVzdERpY3RbJ3N5c3RlbUluc3RydWN0aW9uJ10pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzeXN0ZW1JbnN0cnVjdGlvblZhbHVlID0gcmVxdWVzdERpY3RbJ3N5c3RlbUluc3RydWN0aW9uJ107XG4gICAgICAgICAgICAgICAgZGVsZXRlIHJlcXVlc3REaWN0WydzeXN0ZW1JbnN0cnVjdGlvbiddO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RDb250ZW50ID0gcmVxdWVzdERpY3RbJ3JlcXVlc3QnXTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Q29udGVudFsnc3lzdGVtSW5zdHJ1Y3Rpb24nXSA9IHN5c3RlbUluc3RydWN0aW9uVmFsdWU7XG4gICAgICAgICAgICAgICAgcmVxdWVzdERpY3RbJ3JlcXVlc3QnXSA9IHJlcXVlc3RDb250ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3UmVxdWVzdHMucHVzaChyZXF1ZXN0RGljdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdHNXcmFwcGVyWydyZXF1ZXN0cyddID0gbmV3UmVxdWVzdHM7XG4gICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICByZXR1cm4geyBwYXRoLCBib2R5IH07XG4gICAgfVxuICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGZpcnN0IEdDUyBVUklcbiAgICBnZXRHY3NVcmkoc3JjKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3JjID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHNyYy5zdGFydHNXaXRoKCdnczovLycpID8gc3JjIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzcmMpICYmIHNyYy5nY3NVcmkgJiYgc3JjLmdjc1VyaS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gc3JjLmdjc1VyaVswXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBCaWdRdWVyeSBVUklcbiAgICBnZXRCaWdxdWVyeVVyaShzcmMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gc3JjLnN0YXJ0c1dpdGgoJ2JxOi8vJykgPyBzcmMgOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNyYykpIHtcbiAgICAgICAgICAgIHJldHVybiBzcmMuYmlncXVlcnlVcmk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gRnVuY3Rpb24gdG8gZm9ybWF0IHRoZSBkZXN0aW5hdGlvbiBjb25maWd1cmF0aW9uIGZvciBWZXJ0ZXggQUlcbiAgICBmb3JtYXREZXN0aW5hdGlvbihzcmMsIGNvbmZpZykge1xuICAgICAgICBjb25zdCBuZXdDb25maWcgPSBjb25maWcgPyBPYmplY3QuYXNzaWduKHt9LCBjb25maWcpIDoge307XG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcFN0ciA9IERhdGUubm93KCkudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKCFuZXdDb25maWcuZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICAgIG5ld0NvbmZpZy5kaXNwbGF5TmFtZSA9IGBnZW5haUJhdGNoSm9iXyR7dGltZXN0YW1wU3RyfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld0NvbmZpZy5kZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGdjc1VyaSA9IHRoaXMuZ2V0R2NzVXJpKHNyYyk7XG4gICAgICAgICAgICBjb25zdCBiaWdxdWVyeVVyaSA9IHRoaXMuZ2V0QmlncXVlcnlVcmkoc3JjKTtcbiAgICAgICAgICAgIGlmIChnY3NVcmkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2NzVXJpLmVuZHNXaXRoKCcuanNvbmwnKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgLmpzb25sIGZpbGVzLCByZW1vdmUgc3VmZml4IGFuZCBhZGQgL2Rlc3RcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29uZmlnLmRlc3QgPSBgJHtnY3NVcmkuc2xpY2UoMCwgLTYpfS9kZXN0YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrIGZvciBvdGhlciBHQ1MgVVJJc1xuICAgICAgICAgICAgICAgICAgICBuZXdDb25maWcuZGVzdCA9IGAke2djc1VyaX1fZGVzdF8ke3RpbWVzdGFtcFN0cn1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJpZ3F1ZXJ5VXJpKSB7XG4gICAgICAgICAgICAgICAgbmV3Q29uZmlnLmRlc3QgPSBgJHtiaWdxdWVyeVVyaX1fZGVzdF8ke3RpbWVzdGFtcFN0cn1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBzb3VyY2UgZm9yIFZlcnRleCBBSTogTm8gR0NTIG9yIEJpZ1F1ZXJ5IFVSSSBmb3VuZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3Q29uZmlnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBtZXRob2QgdG8gY3JlYXRlIGJhdGNoIGpvYi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgY3JlYXRlIGJhdGNoIGpvYiByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIGNyZWF0ZWQgYmF0Y2ggam9iLlxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlSW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNyZWF0ZUJhdGNoSm9iUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnYmF0Y2hQcmVkaWN0aW9uSm9icycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gYmF0Y2hKb2JGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNyZWF0ZUJhdGNoSm9iUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OmJhdGNoR2VuZXJhdGVDb250ZW50JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBiYXRjaEpvYkZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBtZXRob2QgdG8gY3JlYXRlIGJhdGNoIGpvYi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgY3JlYXRlIGJhdGNoIGpvYiByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIGNyZWF0ZWQgYmF0Y2ggam9iLlxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlRW1iZWRkaW5nc0ludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjcmVhdGVFbWJlZGRpbmdzQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06YXN5bmNCYXRjaEVtYmVkQ29udGVudCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gYmF0Y2hKb2JGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBiYXRjaCBqb2IgY29uZmlndXJhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBnZXQgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSBiYXRjaCBqb2IuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogYXdhaXQgYWkuYmF0Y2hlcy5nZXQoe25hbWU6ICcuLi4nfSk7IC8vIFRoZSBzZXJ2ZXItZ2VuZXJhdGVkIHJlc291cmNlIG5hbWUuXG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgZ2V0KHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXRCYXRjaEpvYlBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2JhdGNoUHJlZGljdGlvbkpvYnMve25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGJhdGNoSm9iRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXRCYXRjaEpvYlBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnYmF0Y2hlcy97bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gYmF0Y2hKb2JGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FuY2VscyBhIGJhdGNoIGpvYi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGNhbmNlbCByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIGVtcHR5IHJlc3BvbnNlIHJldHVybmVkIGJ5IHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogYXdhaXQgYWkuYmF0Y2hlcy5jYW5jZWwoe25hbWU6ICcuLi4nfSk7IC8vIFRoZSBzZXJ2ZXItZ2VuZXJhdGVkIHJlc291cmNlIG5hbWUuXG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgY2FuY2VsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY2FuY2VsQmF0Y2hKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdiYXRjaFByZWRpY3Rpb25Kb2JzL3tuYW1lfTpjYW5jZWwnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFwaUNsaWVudC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY2FuY2VsQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2JhdGNoZXMve25hbWV9OmNhbmNlbCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBpQ2xpZW50LnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBsaXN0SW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGxpc3RCYXRjaEpvYnNQYXJhbWV0ZXJzVG9WZXJ0ZXgocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2JhdGNoUHJlZGljdGlvbkpvYnMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGxpc3RCYXRjaEpvYnNSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBMaXN0QmF0Y2hKb2JzUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGxpc3RCYXRjaEpvYnNQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnYmF0Y2hlcycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gbGlzdEJhdGNoSm9ic1Jlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgTGlzdEJhdGNoSm9ic1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGEgYmF0Y2ggam9iLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZGVsZXRlIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgZW1wdHkgcmVzcG9uc2UgcmV0dXJuZWQgYnkgdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBhd2FpdCBhaS5iYXRjaGVzLmRlbGV0ZSh7bmFtZTogJy4uLid9KTsgLy8gVGhlIHNlcnZlci1nZW5lcmF0ZWQgcmVzb3VyY2UgbmFtZS5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGRlbGV0ZUJhdGNoSm9iUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnYmF0Y2hQcmVkaWN0aW9uSm9icy97bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGRlbGV0ZVJlc291cmNlSm9iRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBkZWxldGVCYXRjaEpvYlBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnYmF0Y2hlcy97bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGRlbGV0ZVJlc291cmNlSm9iRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5mdW5jdGlvbiBibG9iVG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkYXRhJ10pO1xuICAgIGlmIChmcm9tRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RhdGEnXSwgZnJvbURhdGEpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGlzcGxheU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudFRvTWxkZXYkMyhmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFydHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRzJ10pO1xuICAgIGlmIChmcm9tUGFydHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVBhcnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRUb01sZGV2JDMoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm9sZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm9sZSddKTtcbiAgICBpZiAoZnJvbVJvbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb2xlJ10sIGZyb21Sb2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQ2FjaGVkQ29udGVudENvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVHRsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0dGwnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UdGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndHRsJ10sIGZyb21UdGwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhwaXJlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhwaXJlVGltZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUV4cGlyZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZXhwaXJlVGltZSddLCBmcm9tRXhwaXJlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdENvbnRlbnRzKGZyb21Db250ZW50cyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudFRvTWxkZXYkMyhpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydjb250ZW50cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TeXN0ZW1JbnN0cnVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzeXN0ZW1JbnN0cnVjdGlvbiddLCBjb250ZW50VG9NbGRldiQzKHRDb250ZW50KGZyb21TeXN0ZW1JbnN0cnVjdGlvbikpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29scyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21Ub29scztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b29sVG9NbGRldiQzKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3Rvb2xzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29sQ29uZmlnJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29sQ29uZmlnJ10sIHRvb2xDb25maWdUb01sZGV2JDEoZnJvbVRvb2xDb25maWcpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsna21zS2V5TmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigna21zS2V5TmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVDYWNoZWRDb250ZW50Q29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVHRsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0dGwnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UdGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndHRsJ10sIGZyb21UdGwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhwaXJlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhwaXJlVGltZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUV4cGlyZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZXhwaXJlVGltZSddLCBmcm9tRXhwaXJlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdENvbnRlbnRzKGZyb21Db250ZW50cyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydjb250ZW50cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TeXN0ZW1JbnN0cnVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzeXN0ZW1JbnN0cnVjdGlvbiddLCB0Q29udGVudChmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29scyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21Ub29scztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b29sVG9WZXJ0ZXgkMihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29scyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbENvbmZpZyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndG9vbENvbmZpZyddLCBmcm9tVG9vbENvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21LbXNLZXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydrbXNLZXlOYW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tS21zS2V5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydlbmNyeXB0aW9uX3NwZWMnLCAna21zS2V5TmFtZSddLCBmcm9tS21zS2V5TmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsJ10sIHRDYWNoZXNNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBjcmVhdGVDYWNoZWRDb250ZW50Q29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbCddLCB0Q2FjaGVzTW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgY3JlYXRlQ2FjaGVkQ29udGVudENvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRDYWNoZWRDb250ZW50TmFtZShhcGlDbGllbnQsIGZyb21OYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdENhY2hlZENvbnRlbnROYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVDYWNoZWRDb250ZW50UmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmaWxlRGF0YVRvTWxkZXYkMyhmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGlzcGxheU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVVcmknXSk7XG4gICAgaWYgKGZyb21GaWxlVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZVVyaSddLCBmcm9tRmlsZVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbFRvTWxkZXYkMyhmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lkJ10pO1xuICAgIGlmIChmcm9tSWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpZCddLCBmcm9tSWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXJncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXJncyddKTtcbiAgICBpZiAoZnJvbUFyZ3MgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhcmdzJ10sIGZyb21BcmdzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRpYWxBcmdzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXJ0aWFsQXJncyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd3aWxsQ29udGludWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dpbGxDb250aW51ZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkNhbGxpbmdDb25maWdUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGUnXSk7XG4gICAgaWYgKGZyb21Nb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZSddLCBmcm9tTW9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BbGxvd2VkRnVuY3Rpb25OYW1lcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2FsbG93ZWRGdW5jdGlvbk5hbWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYWxsb3dlZEZ1bmN0aW9uTmFtZXMnXSwgZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RyZWFtRnVuY3Rpb25DYWxsQXJndW1lbnRzJ10pICE9PVxuICAgICAgICB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHJlYW1GdW5jdGlvbkNhbGxBcmd1bWVudHMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25EZWNsYXJhdGlvblRvVmVydGV4JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmVoYXZpb3InXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JlaGF2aW9yIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAoZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJhbWV0ZXJzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJhbWV0ZXJzJ10pO1xuICAgIGlmIChmcm9tUGFyYW1ldGVycyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmFtZXRlcnMnXSwgZnJvbVBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwYXJhbWV0ZXJzSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmFtZXRlcnNKc29uU2NoZW1hJ10sIGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2UnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlJ10sIGZyb21SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUpzb25TY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZUpzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VKc29uU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VKc29uU2NoZW1hJ10sIGZyb21SZXNwb25zZUpzb25TY2hlbWEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZXRDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdENhY2hlZENvbnRlbnROYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0Q2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVNYXBzVG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1dGhDb25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F1dGhDb25maWcgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuYWJsZVdpZGdldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5hYmxlV2lkZ2V0J10pO1xuICAgIGlmIChmcm9tRW5hYmxlV2lkZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5hYmxlV2lkZ2V0J10sIGZyb21FbmFibGVXaWRnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVTZWFyY2hUb01sZGV2JDMoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhjbHVkZURvbWFpbnMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4Y2x1ZGVEb21haW5zIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Jsb2NraW5nQ29uZmlkZW5jZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmxvY2tpbmdDb25maWRlbmNlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaW1lUmFuZ2VGaWx0ZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aW1lUmFuZ2VGaWx0ZXInLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGltZVJhbmdlRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGltZVJhbmdlRmlsdGVyJ10sIGZyb21UaW1lUmFuZ2VGaWx0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0Q2FjaGVkQ29udGVudHNDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlU2l6ZSddLCBmcm9tUGFnZVNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlVG9rZW4nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VUb2tlbiddLCBmcm9tUGFnZVRva2VuKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdENhY2hlZENvbnRlbnRzQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFnZVNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VTaXplJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VTaXplJ10sIGZyb21QYWdlU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VUb2tlbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVRva2VuJ10sIGZyb21QYWdlVG9rZW4pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0Q2FjaGVkQ29udGVudHNQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBsaXN0Q2FjaGVkQ29udGVudHNDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdENhY2hlZENvbnRlbnRzUGFyYW1ldGVyc1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGxpc3RDYWNoZWRDb250ZW50c0NvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdENhY2hlZENvbnRlbnRzUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZXh0UGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmV4dFBhZ2VUb2tlbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21OZXh0UGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmV4dFBhZ2VUb2tlbiddLCBmcm9tTmV4dFBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYWNoZWRDb250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhY2hlZENvbnRlbnRzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNhY2hlZENvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21DYWNoZWRDb250ZW50cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FjaGVkQ29udGVudHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdENhY2hlZENvbnRlbnRzUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmV4dFBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25leHRQYWdlVG9rZW4nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTmV4dFBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25leHRQYWdlVG9rZW4nXSwgZnJvbU5leHRQYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FjaGVkQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYWNoZWRDb250ZW50cycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYWNoZWRDb250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQ2FjaGVkQ29udGVudHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhY2hlZENvbnRlbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHBhcnRUb01sZGV2JDMoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1lZGlhUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21lZGlhUmVzb2x1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NZWRpYVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZWRpYVJlc29sdXRpb24nXSwgZnJvbU1lZGlhUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvblJlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvblJlc3VsdCddLCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGVjdXRhYmxlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4ZWN1dGFibGVDb2RlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4ZWN1dGFibGVDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhlY3V0YWJsZUNvZGUnXSwgZnJvbUV4ZWN1dGFibGVDb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlRGF0YSddKTtcbiAgICBpZiAoZnJvbUZpbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZURhdGEnXSwgZmlsZURhdGFUb01sZGV2JDMoZnJvbUZpbGVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddLCBmdW5jdGlvbkNhbGxUb01sZGV2JDMoZnJvbUZ1bmN0aW9uQ2FsbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uUmVzcG9uc2UnXSwgZnJvbUZ1bmN0aW9uUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5saW5lRGF0YSddKTtcbiAgICBpZiAoZnJvbUlubGluZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmxpbmVEYXRhJ10sIGJsb2JUb01sZGV2JDMoZnJvbUlubGluZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aG91Z2h0J10pO1xuICAgIGlmIChmcm9tVGhvdWdodCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHQnXSwgZnJvbVRob3VnaHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodFNpZ25hdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rob3VnaHRTaWduYXR1cmUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhvdWdodFNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHRTaWduYXR1cmUnXSwgZnJvbVRob3VnaHRTaWduYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW9NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ZpZGVvTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvTWV0YWRhdGEnXSwgZnJvbVZpZGVvTWV0YWRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0b29sQ29uZmlnVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkNhbGxpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxsaW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxsaW5nQ29uZmlnJ10sIGZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ1RvTWxkZXYkMShmcm9tRnVuY3Rpb25DYWxsaW5nQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXRyaWV2YWxDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXRyaWV2YWxDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmV0cmlldmFsQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmV0cmlldmFsQ29uZmlnJ10sIGZyb21SZXRyaWV2YWxDb25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0b29sVG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25EZWNsYXJhdGlvbnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmV0cmlldmFsJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXRyaWV2YWwgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2hSZXRyaWV2YWwnXSwgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db21wdXRlclVzZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSk7XG4gICAgaWYgKGZyb21Db21wdXRlclVzZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10sIGZyb21Db21wdXRlclVzZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlU2VhcmNoJ10pO1xuICAgIGlmIChmcm9tRmlsZVNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVTZWFyY2gnXSwgZnJvbUZpbGVTZWFyY2gpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb24nXSwgZnJvbUNvZGVFeGVjdXRpb24pO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbnRlcnByaXNlV2ViU2VhcmNoJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbnRlcnByaXNlV2ViU2VhcmNoIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVNYXBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVNYXBzJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlTWFwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSwgZ29vZ2xlTWFwc1RvTWxkZXYkMyhmcm9tR29vZ2xlTWFwcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2gnXSwgZ29vZ2xlU2VhcmNoVG9NbGRldiQzKGZyb21Hb29nbGVTZWFyY2gpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVybENvbnRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VybENvbnRleHQnXSk7XG4gICAgaWYgKGZyb21VcmxDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsQ29udGV4dCddLCBmcm9tVXJsQ29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xUb1ZlcnRleCQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbkRlY2xhcmF0aW9uVG9WZXJ0ZXgkMihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXRyaWV2YWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JldHJpZXZhbCddKTtcbiAgICBpZiAoZnJvbVJldHJpZXZhbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JldHJpZXZhbCddLCBmcm9tUmV0cmlldmFsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2hSZXRyaWV2YWwnXSwgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db21wdXRlclVzZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSk7XG4gICAgaWYgKGZyb21Db21wdXRlclVzZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10sIGZyb21Db21wdXRlclVzZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVTZWFyY2gnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpbGVTZWFyY2ggcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb24nXSwgZnJvbUNvZGVFeGVjdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW50ZXJwcmlzZVdlYlNlYXJjaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VudGVycHJpc2VXZWJTZWFyY2gnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRW50ZXJwcmlzZVdlYlNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VudGVycHJpc2VXZWJTZWFyY2gnXSwgZnJvbUVudGVycHJpc2VXZWJTZWFyY2gpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlTWFwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlTWFwcyddKTtcbiAgICBpZiAoZnJvbUdvb2dsZU1hcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVNYXBzJ10sIGZyb21Hb29nbGVNYXBzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10sIGZyb21Hb29nbGVTZWFyY2gpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJsQ29udGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXJsQ29udGV4dCddKTtcbiAgICBpZiAoZnJvbVVybENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmxDb250ZXh0J10sIGZyb21VcmxDb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBkYXRlQ2FjaGVkQ29udGVudENvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVHRsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0dGwnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UdGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndHRsJ10sIGZyb21UdGwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhwaXJlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhwaXJlVGltZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUV4cGlyZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZXhwaXJlVGltZSddLCBmcm9tRXhwaXJlVGltZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNhY2hlZENvbnRlbnRDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UdGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R0bCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVR0bCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0dGwnXSwgZnJvbVR0bCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeHBpcmVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleHBpcmVUaW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRXhwaXJlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydleHBpcmVUaW1lJ10sIGZyb21FeHBpcmVUaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBkYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRDYWNoZWRDb250ZW50TmFtZShhcGlDbGllbnQsIGZyb21OYW1lKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHVwZGF0ZUNhY2hlZENvbnRlbnRDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBkYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVDYWNoZWRDb250ZW50Q29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNsYXNzIENhY2hlcyBleHRlbmRzIEJhc2VNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3RzIGNhY2hlZCBjb250ZW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgbGlzdCByZXF1ZXN0LlxuICAgICAgICAgKiBAcmV0dXJuIC0gQSBwYWdlciBvZiBjYWNoZWQgY29udGVudHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IGNhY2hlZENvbnRlbnRzID0gYXdhaXQgYWkuY2FjaGVzLmxpc3Qoe2NvbmZpZzogeydwYWdlU2l6ZSc6IDJ9fSk7XG4gICAgICAgICAqIGZvciBhd2FpdCAoY29uc3QgY2FjaGVkQ29udGVudCBvZiBjYWNoZWRDb250ZW50cykge1xuICAgICAgICAgKiAgIGNvbnNvbGUubG9nKGNhY2hlZENvbnRlbnQpO1xuICAgICAgICAgKiB9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saXN0ID0gYXN5bmMgKHBhcmFtcyA9IHt9KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhZ2VyKFBhZ2VkSXRlbS5QQUdFRF9JVEVNX0NBQ0hFRF9DT05URU5UUywgKHgpID0+IHRoaXMubGlzdEludGVybmFsKHgpLCBhd2FpdCB0aGlzLmxpc3RJbnRlcm5hbChwYXJhbXMpLCBwYXJhbXMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2FjaGVkIGNvbnRlbnRzIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBDb250ZXh0IGNhY2hpbmcgaXMgb25seSBzdXBwb3J0ZWQgZm9yIHNwZWNpZmljIG1vZGVscy4gU2VlIFtHZW1pbmlcbiAgICAgKiBEZXZlbG9wZXIgQVBJIHJlZmVyZW5jZV0oaHR0cHM6Ly9haS5nb29nbGUuZGV2L2dlbWluaS1hcGkvZG9jcy9jYWNoaW5nP2xhbmc9bm9kZS9jb250ZXh0LWNhYylcbiAgICAgKiBhbmQgW1ZlcnRleCBBSSByZWZlcmVuY2VdKGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS92ZXJ0ZXgtYWkvZ2VuZXJhdGl2ZS1haS9kb2NzL2NvbnRleHQtY2FjaGUvY29udGV4dC1jYWNoZS1vdmVydmlldyNzdXBwb3J0ZWRfbW9kZWxzKVxuICAgICAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgY3JlYXRlIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgY3JlYXRlZCBjYWNoZWQgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBjb250ZW50cyA9IC4uLjsgLy8gSW5pdGlhbGl6ZSB0aGUgY29udGVudCB0byBjYWNoZS5cbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLmNhY2hlcy5jcmVhdGUoe1xuICAgICAqICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoLTAwMScsXG4gICAgICogICBjb25maWc6IHtcbiAgICAgKiAgICAnY29udGVudHMnOiBjb250ZW50cyxcbiAgICAgKiAgICAnZGlzcGxheU5hbWUnOiAndGVzdCBjYWNoZScsXG4gICAgICogICAgJ3N5c3RlbUluc3RydWN0aW9uJzogJ1doYXQgaXMgdGhlIHN1bSBvZiB0aGUgdHdvIHBkZnM/JyxcbiAgICAgKiAgICAndHRsJzogJzg2NDAwcycsXG4gICAgICogIH1cbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNyZWF0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdjYWNoZWRDb250ZW50cycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigocmVzcCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnY2FjaGVkQ29udGVudHMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKHJlc3ApID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgY2FjaGVkIGNvbnRlbnQgY29uZmlndXJhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBnZXQgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSBjYWNoZWQgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBhd2FpdCBhaS5jYWNoZXMuZ2V0KHtuYW1lOiAnLi4uJ30pOyAvLyBUaGUgc2VydmVyLWdlbmVyYXRlZCByZXNvdXJjZSBuYW1lLlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGdldChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2V0Q2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChyZXNwKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXRDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigocmVzcCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBjYWNoZWQgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGRlbGV0ZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIGVtcHR5IHJlc3BvbnNlIHJldHVybmVkIGJ5IHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogYXdhaXQgYWkuY2FjaGVzLmRlbGV0ZSh7bmFtZTogJy4uLid9KTsgLy8gVGhlIHNlcnZlci1nZW5lcmF0ZWQgcmVzb3VyY2UgbmFtZS5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGRlbGV0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGRlbGV0ZUNhY2hlZENvbnRlbnRSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBEZWxldGVDYWNoZWRDb250ZW50UmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGRlbGV0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgRGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGNhY2hlZCBjb250ZW50IGNvbmZpZ3VyYXRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgdXBkYXRlIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgdXBkYXRlZCBjYWNoZWQgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLmNhY2hlcy51cGRhdGUoe1xuICAgICAqICAgbmFtZTogJy4uLicsICAvLyBUaGUgc2VydmVyLWdlbmVyYXRlZCByZXNvdXJjZSBuYW1lLlxuICAgICAqICAgY29uZmlnOiB7J3R0bCc6ICc3NjAwcyd9XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSB1cGRhdGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUEFUQ0gnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigocmVzcCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gdXBkYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUEFUQ0gnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigocmVzcCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbGlzdEludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBsaXN0Q2FjaGVkQ29udGVudHNQYXJhbWV0ZXJzVG9WZXJ0ZXgocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2NhY2hlZENvbnRlbnRzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBMaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbGlzdENhY2hlZENvbnRlbnRzUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2NhY2hlZENvbnRlbnRzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IExpc3RDYWNoZWRDb250ZW50c1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlLCBTdXBwcmVzc2VkRXJyb3IsIFN5bWJvbCwgSXRlcmF0b3IgKi9cclxuXHJcblxyXG5mdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSBPYmplY3QuY3JlYXRlKCh0eXBlb2YgQXN5bmNJdGVyYXRvciA9PT0gXCJmdW5jdGlvblwiID8gQXN5bmNJdGVyYXRvciA6IE9iamVjdCkucHJvdG90eXBlKSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiLCBhd2FpdFJldHVybiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIGF3YWl0UmV0dXJuKGYpIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodikudGhlbihmLCByZWplY3QpOyB9OyB9XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaWYgKGdbbl0pIHsgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgaWYgKGYpIGlbbl0gPSBmKGlbbl0pOyB9IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG50eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcclxuICAgIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcclxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHJlc3BvbnNlIGlzIHZhbGlkLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRSZXNwb25zZShyZXNwb25zZSkge1xuICAgIHZhciBfYTtcbiAgICBpZiAocmVzcG9uc2UuY2FuZGlkYXRlcyA9PSB1bmRlZmluZWQgfHwgcmVzcG9uc2UuY2FuZGlkYXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBjb250ZW50ID0gKF9hID0gcmVzcG9uc2UuY2FuZGlkYXRlc1swXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRlbnQ7XG4gICAgaWYgKGNvbnRlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBpc1ZhbGlkQ29udGVudChjb250ZW50KTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRDb250ZW50KGNvbnRlbnQpIHtcbiAgICBpZiAoY29udGVudC5wYXJ0cyA9PT0gdW5kZWZpbmVkIHx8IGNvbnRlbnQucGFydHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBwYXJ0IG9mIGNvbnRlbnQucGFydHMpIHtcbiAgICAgICAgaWYgKHBhcnQgPT09IHVuZGVmaW5lZCB8fCBPYmplY3Qua2V5cyhwYXJ0KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogVmFsaWRhdGVzIHRoZSBoaXN0b3J5IGNvbnRhaW5zIHRoZSBjb3JyZWN0IHJvbGVzLlxuICpcbiAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIGhpc3RvcnkgZG9lcyBub3Qgc3RhcnQgd2l0aCBhIHVzZXIgdHVybi5cbiAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIGhpc3RvcnkgY29udGFpbnMgYW4gaW52YWxpZCByb2xlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUhpc3RvcnkoaGlzdG9yeSkge1xuICAgIC8vIEVtcHR5IGhpc3RvcnkgaXMgdmFsaWQuXG4gICAgaWYgKGhpc3RvcnkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjb250ZW50IG9mIGhpc3RvcnkpIHtcbiAgICAgICAgaWYgKGNvbnRlbnQucm9sZSAhPT0gJ3VzZXInICYmIGNvbnRlbnQucm9sZSAhPT0gJ21vZGVsJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSb2xlIG11c3QgYmUgdXNlciBvciBtb2RlbCwgYnV0IGdvdCAke2NvbnRlbnQucm9sZX0uYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEV4dHJhY3RzIHRoZSBjdXJhdGVkICh2YWxpZCkgaGlzdG9yeSBmcm9tIGEgY29tcHJlaGVuc2l2ZSBoaXN0b3J5LlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGUgbW9kZWwgbWF5IHNvbWV0aW1lcyBnZW5lcmF0ZSBpbnZhbGlkIG9yIGVtcHR5IGNvbnRlbnRzKGUuZy4sIGR1ZSB0byBzYWZ0eVxuICogZmlsdGVycyBvciByZWNpdGF0aW9uKS4gRXh0cmFjdGluZyB2YWxpZCB0dXJucyBmcm9tIHRoZSBoaXN0b3J5XG4gKiBlbnN1cmVzIHRoYXQgc3Vic2VxdWVudCByZXF1ZXN0cyBjb3VsZCBiZSBhY2NwZXRlZCBieSB0aGUgbW9kZWwuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RDdXJhdGVkSGlzdG9yeShjb21wcmVoZW5zaXZlSGlzdG9yeSkge1xuICAgIGlmIChjb21wcmVoZW5zaXZlSGlzdG9yeSA9PT0gdW5kZWZpbmVkIHx8IGNvbXByZWhlbnNpdmVIaXN0b3J5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGN1cmF0ZWRIaXN0b3J5ID0gW107XG4gICAgY29uc3QgbGVuZ3RoID0gY29tcHJlaGVuc2l2ZUhpc3RvcnkubGVuZ3RoO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoY29tcHJlaGVuc2l2ZUhpc3RvcnlbaV0ucm9sZSA9PT0gJ3VzZXInKSB7XG4gICAgICAgICAgICBjdXJhdGVkSGlzdG9yeS5wdXNoKGNvbXByZWhlbnNpdmVIaXN0b3J5W2ldKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsT3V0cHV0ID0gW107XG4gICAgICAgICAgICBsZXQgaXNWYWxpZCA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IGxlbmd0aCAmJiBjb21wcmVoZW5zaXZlSGlzdG9yeVtpXS5yb2xlID09PSAnbW9kZWwnKSB7XG4gICAgICAgICAgICAgICAgbW9kZWxPdXRwdXQucHVzaChjb21wcmVoZW5zaXZlSGlzdG9yeVtpXSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsaWQgJiYgIWlzVmFsaWRDb250ZW50KGNvbXByZWhlbnNpdmVIaXN0b3J5W2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgY3VyYXRlZEhpc3RvcnkucHVzaCguLi5tb2RlbE91dHB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGxhc3QgdXNlciBpbnB1dCB3aGVuIG1vZGVsIGNvbnRlbnQgaXMgaW52YWxpZC5cbiAgICAgICAgICAgICAgICBjdXJhdGVkSGlzdG9yeS5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3VyYXRlZEhpc3Rvcnk7XG59XG4vKipcbiAqIEEgdXRpbGl0eSBjbGFzcyB0byBjcmVhdGUgYSBjaGF0IHNlc3Npb24uXG4gKi9cbmNsYXNzIENoYXRzIHtcbiAgICBjb25zdHJ1Y3Rvcihtb2RlbHNNb2R1bGUsIGFwaUNsaWVudCkge1xuICAgICAgICB0aGlzLm1vZGVsc01vZHVsZSA9IG1vZGVsc01vZHVsZTtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY2hhdCBzZXNzaW9uLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgY29uZmlnIGluIHRoZSBwYXJhbXMgd2lsbCBiZSB1c2VkIGZvciBhbGwgcmVxdWVzdHMgd2l0aGluIHRoZSBjaGF0XG4gICAgICogc2Vzc2lvbiB1bmxlc3Mgb3ZlcnJpZGRlbiBieSBhIHBlci1yZXF1ZXN0IGBjb25maWdgIGluXG4gICAgICogQHNlZSB7QGxpbmsgdHlwZXMuU2VuZE1lc3NhZ2VQYXJhbWV0ZXJzI2NvbmZpZ30uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gUGFyYW1ldGVycyBmb3IgY3JlYXRpbmcgYSBjaGF0IHNlc3Npb24uXG4gICAgICogQHJldHVybnMgQSBuZXcgY2hhdCBzZXNzaW9uLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGNoYXQgPSBhaS5jaGF0cy5jcmVhdGUoe1xuICAgICAqICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJ1xuICAgICAqICAgY29uZmlnOiB7XG4gICAgICogICAgIHRlbXBlcmF0dXJlOiAwLjUsXG4gICAgICogICAgIG1heE91dHB1dFRva2VuczogMTAyNCxcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBjcmVhdGUocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhdCh0aGlzLmFwaUNsaWVudCwgdGhpcy5tb2RlbHNNb2R1bGUsIHBhcmFtcy5tb2RlbCwgcGFyYW1zLmNvbmZpZywgXG4gICAgICAgIC8vIERlZXAgY29weSB0aGUgaGlzdG9yeSB0byBhdm9pZCBtdXRhdGluZyB0aGUgaGlzdG9yeSBvdXRzaWRlIG9mIHRoZVxuICAgICAgICAvLyBjaGF0IHNlc3Npb24uXG4gICAgICAgIHN0cnVjdHVyZWRDbG9uZShwYXJhbXMuaGlzdG9yeSkpO1xuICAgIH1cbn1cbi8qKlxuICogQ2hhdCBzZXNzaW9uIHRoYXQgZW5hYmxlcyBzZW5kaW5nIG1lc3NhZ2VzIHRvIHRoZSBtb2RlbCB3aXRoIHByZXZpb3VzXG4gKiBjb252ZXJzYXRpb24gY29udGV4dC5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhlIHNlc3Npb24gbWFpbnRhaW5zIGFsbCB0aGUgdHVybnMgYmV0d2VlbiB1c2VyIGFuZCBtb2RlbC5cbiAqL1xuY2xhc3MgQ2hhdCB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50LCBtb2RlbHNNb2R1bGUsIG1vZGVsLCBjb25maWcgPSB7fSwgaGlzdG9yeSA9IFtdKSB7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgICAgICB0aGlzLm1vZGVsc01vZHVsZSA9IG1vZGVsc01vZHVsZTtcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5oaXN0b3J5ID0gaGlzdG9yeTtcbiAgICAgICAgLy8gQSBwcm9taXNlIHRvIHJlcHJlc2VudCB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgbWVzc2FnZSBiZWluZyBzZW50IHRvIHRoZVxuICAgICAgICAvLyBtb2RlbC5cbiAgICAgICAgdGhpcy5zZW5kUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB2YWxpZGF0ZUhpc3RvcnkoaGlzdG9yeSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgbWVzc2FnZSB0byB0aGUgbW9kZWwgYW5kIHJldHVybnMgdGhlIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHdhaXQgZm9yIHRoZSBwcmV2aW91cyBtZXNzYWdlIHRvIGJlIHByb2Nlc3NlZCBiZWZvcmVcbiAgICAgKiBzZW5kaW5nIHRoZSBuZXh0IG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBDaGF0I3NlbmRNZXNzYWdlU3RyZWFtfSBmb3Igc3RyZWFtaW5nIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gcGFyYW1ldGVycyBmb3Igc2VuZGluZyBtZXNzYWdlcyB3aXRoaW4gYSBjaGF0IHNlc3Npb24uXG4gICAgICogQHJldHVybnMgVGhlIG1vZGVsJ3MgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgY2hhdCA9IGFpLmNoYXRzLmNyZWF0ZSh7bW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJ30pO1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2hhdC5zZW5kTWVzc2FnZSh7XG4gICAgICogICBtZXNzYWdlOiAnV2h5IGlzIHRoZSBza3kgYmx1ZT8nXG4gICAgICogfSk7XG4gICAgICogY29uc29sZS5sb2cocmVzcG9uc2UudGV4dCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgc2VuZE1lc3NhZ2UocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kUHJvbWlzZTtcbiAgICAgICAgY29uc3QgaW5wdXRDb250ZW50ID0gdENvbnRlbnQocGFyYW1zLm1lc3NhZ2UpO1xuICAgICAgICBjb25zdCByZXNwb25zZVByb21pc2UgPSB0aGlzLm1vZGVsc01vZHVsZS5nZW5lcmF0ZUNvbnRlbnQoe1xuICAgICAgICAgICAgbW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICAgICAgICBjb250ZW50czogdGhpcy5nZXRIaXN0b3J5KHRydWUpLmNvbmNhdChpbnB1dENvbnRlbnQpLFxuICAgICAgICAgICAgY29uZmlnOiAoX2EgPSBwYXJhbXMuY29uZmlnKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2VuZFByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlc3BvbnNlUHJvbWlzZTtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dENvbnRlbnQgPSAoX2IgPSAoX2EgPSByZXNwb25zZS5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb250ZW50O1xuICAgICAgICAgICAgLy8gQmVjYXVzZSB0aGUgQUZDIGlucHV0IGNvbnRhaW5zIHRoZSBlbnRpcmUgY3VyYXRlZCBjaGF0IGhpc3RvcnkgaW5cbiAgICAgICAgICAgIC8vIGFkZGl0aW9uIHRvIHRoZSBuZXcgdXNlciBpbnB1dCwgd2UgbmVlZCB0byB0cnVuY2F0ZSB0aGUgQUZDIGhpc3RvcnlcbiAgICAgICAgICAgIC8vIHRvIGRlZHVwbGljYXRlIHRoZSBleGlzdGluZyBjaGF0IGhpc3RvcnkuXG4gICAgICAgICAgICBjb25zdCBmdWxsQXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSA9IHJlc3BvbnNlLmF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3Rvcnk7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0SGlzdG9yeSh0cnVlKS5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSA9IFtdO1xuICAgICAgICAgICAgaWYgKGZ1bGxBdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5ID1cbiAgICAgICAgICAgICAgICAgICAgKF9jID0gZnVsbEF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3Rvcnkuc2xpY2UoaW5kZXgpKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1vZGVsT3V0cHV0ID0gb3V0cHV0Q29udGVudCA/IFtvdXRwdXRDb250ZW50XSA6IFtdO1xuICAgICAgICAgICAgdGhpcy5yZWNvcmRIaXN0b3J5KGlucHV0Q29udGVudCwgbW9kZWxPdXRwdXQsIGF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3RvcnkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9KSgpO1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmRQcm9taXNlLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgIC8vIFJlc2V0cyBzZW5kUHJvbWlzZSB0byBhdm9pZCBzdWJzZXF1ZW50IGNhbGxzIGZhaWxpbmdcbiAgICAgICAgICAgIHRoaXMuc2VuZFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZVByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgbWVzc2FnZSB0byB0aGUgbW9kZWwgYW5kIHJldHVybnMgdGhlIHJlc3BvbnNlIGluIGNodW5rcy5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCB3YWl0IGZvciB0aGUgcHJldmlvdXMgbWVzc2FnZSB0byBiZSBwcm9jZXNzZWQgYmVmb3JlXG4gICAgICogc2VuZGluZyB0aGUgbmV4dCBtZXNzYWdlLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgQ2hhdCNzZW5kTWVzc2FnZX0gZm9yIG5vbi1zdHJlYW1pbmcgbWV0aG9kLlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBwYXJhbWV0ZXJzIGZvciBzZW5kaW5nIHRoZSBtZXNzYWdlLlxuICAgICAqIEByZXR1cm4gVGhlIG1vZGVsJ3MgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgY2hhdCA9IGFpLmNoYXRzLmNyZWF0ZSh7bW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJ30pO1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2hhdC5zZW5kTWVzc2FnZVN0cmVhbSh7XG4gICAgICogICBtZXNzYWdlOiAnV2h5IGlzIHRoZSBza3kgYmx1ZT8nXG4gICAgICogfSk7XG4gICAgICogZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiByZXNwb25zZSkge1xuICAgICAqICAgY29uc29sZS5sb2coY2h1bmsudGV4dCk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIHNlbmRNZXNzYWdlU3RyZWFtKHBhcmFtcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZFByb21pc2U7XG4gICAgICAgIGNvbnN0IGlucHV0Q29udGVudCA9IHRDb250ZW50KHBhcmFtcy5tZXNzYWdlKTtcbiAgICAgICAgY29uc3Qgc3RyZWFtUmVzcG9uc2UgPSB0aGlzLm1vZGVsc01vZHVsZS5nZW5lcmF0ZUNvbnRlbnRTdHJlYW0oe1xuICAgICAgICAgICAgbW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICAgICAgICBjb250ZW50czogdGhpcy5nZXRIaXN0b3J5KHRydWUpLmNvbmNhdChpbnB1dENvbnRlbnQpLFxuICAgICAgICAgICAgY29uZmlnOiAoX2EgPSBwYXJhbXMuY29uZmlnKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJlc29sdmUgdGhlIGludGVybmFsIHRyYWNraW5nIG9mIHNlbmQgY29tcGxldGlvbiBwcm9taXNlIC0gYHNlbmRQcm9taXNlYFxuICAgICAgICAvLyBmb3IgYm90aCBzdWNjZXNzIGFuZCBmYWlsdXJlIHJlc3BvbnNlLiBUaGUgYWN0dWFsIGZhaWx1cmUgaXMgc3RpbGxcbiAgICAgICAgLy8gcHJvcGFnYXRlZCBieSB0aGUgYGF3YWl0IHN0cmVhbVJlc3BvbnNlYC5cbiAgICAgICAgdGhpcy5zZW5kUHJvbWlzZSA9IHN0cmVhbVJlc3BvbnNlXG4gICAgICAgICAgICAudGhlbigoKSA9PiB1bmRlZmluZWQpXG4gICAgICAgICAgICAuY2F0Y2goKCkgPT4gdW5kZWZpbmVkKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzdHJlYW1SZXNwb25zZTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5wcm9jZXNzU3RyZWFtUmVzcG9uc2UocmVzcG9uc2UsIGlucHV0Q29udGVudCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNoYXQgaGlzdG9yeS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhlIGhpc3RvcnkgaXMgYSBsaXN0IG9mIGNvbnRlbnRzIGFsdGVybmF0aW5nIGJldHdlZW4gdXNlciBhbmQgbW9kZWwuXG4gICAgICpcbiAgICAgKiBUaGVyZSBhcmUgdHdvIHR5cGVzIG9mIGhpc3Rvcnk6XG4gICAgICogLSBUaGUgYGN1cmF0ZWQgaGlzdG9yeWAgY29udGFpbnMgb25seSB0aGUgdmFsaWQgdHVybnMgYmV0d2VlbiB1c2VyIGFuZFxuICAgICAqIG1vZGVsLCB3aGljaCB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBzdWJzZXF1ZW50IHJlcXVlc3RzIHNlbnQgdG8gdGhlIG1vZGVsLlxuICAgICAqIC0gVGhlIGBjb21wcmVoZW5zaXZlIGhpc3RvcnlgIGNvbnRhaW5zIGFsbCB0dXJucywgaW5jbHVkaW5nIGludmFsaWQgb3JcbiAgICAgKiAgIGVtcHR5IG1vZGVsIG91dHB1dHMsIHByb3ZpZGluZyBhIGNvbXBsZXRlIHJlY29yZCBvZiB0aGUgaGlzdG9yeS5cbiAgICAgKlxuICAgICAqIFRoZSBoaXN0b3J5IGlzIHVwZGF0ZWQgYWZ0ZXIgcmVjZWl2aW5nIHRoZSByZXNwb25zZSBmcm9tIHRoZSBtb2RlbCxcbiAgICAgKiBmb3Igc3RyZWFtaW5nIHJlc3BvbnNlLCBpdCBtZWFucyByZWNlaXZpbmcgdGhlIGxhc3QgY2h1bmsgb2YgdGhlIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogVGhlIGBjb21wcmVoZW5zaXZlIGhpc3RvcnlgIGlzIHJldHVybmVkIGJ5IGRlZmF1bHQuIFRvIGdldCB0aGUgYGN1cmF0ZWRcbiAgICAgKiBoaXN0b3J5YCwgc2V0IHRoZSBgY3VyYXRlZGAgcGFyYW1ldGVyIHRvIGB0cnVlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjdXJhdGVkIC0gd2hldGhlciB0byByZXR1cm4gdGhlIGN1cmF0ZWQgaGlzdG9yeSBvciB0aGUgY29tcHJlaGVuc2l2ZVxuICAgICAqICAgICBoaXN0b3J5LlxuICAgICAqIEByZXR1cm4gSGlzdG9yeSBjb250ZW50cyBhbHRlcm5hdGluZyBiZXR3ZWVuIHVzZXIgYW5kIG1vZGVsIGZvciB0aGUgZW50aXJlXG4gICAgICogICAgIGNoYXQgc2Vzc2lvbi5cbiAgICAgKi9cbiAgICBnZXRIaXN0b3J5KGN1cmF0ZWQgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBoaXN0b3J5ID0gY3VyYXRlZFxuICAgICAgICAgICAgPyBleHRyYWN0Q3VyYXRlZEhpc3RvcnkodGhpcy5oaXN0b3J5KVxuICAgICAgICAgICAgOiB0aGlzLmhpc3Rvcnk7XG4gICAgICAgIC8vIERlZXAgY29weSB0aGUgaGlzdG9yeSB0byBhdm9pZCBtdXRhdGluZyB0aGUgaGlzdG9yeSBvdXRzaWRlIG9mIHRoZVxuICAgICAgICAvLyBjaGF0IHNlc3Npb24uXG4gICAgICAgIHJldHVybiBzdHJ1Y3R1cmVkQ2xvbmUoaGlzdG9yeSk7XG4gICAgfVxuICAgIHByb2Nlc3NTdHJlYW1SZXNwb25zZShzdHJlYW1SZXNwb25zZSwgaW5wdXRDb250ZW50KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qIHByb2Nlc3NTdHJlYW1SZXNwb25zZV8xKCkge1xuICAgICAgICAgICAgdmFyIF9jLCBlXzEsIF9kLCBfZTtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dENvbnRlbnQgPSBbXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2YgPSB0cnVlLCBzdHJlYW1SZXNwb25zZV8xID0gX19hc3luY1ZhbHVlcyhzdHJlYW1SZXNwb25zZSksIHN0cmVhbVJlc3BvbnNlXzFfMTsgc3RyZWFtUmVzcG9uc2VfMV8xID0geWllbGQgX19hd2FpdChzdHJlYW1SZXNwb25zZV8xLm5leHQoKSksIF9jID0gc3RyZWFtUmVzcG9uc2VfMV8xLmRvbmUsICFfYzsgX2YgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9lID0gc3RyZWFtUmVzcG9uc2VfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBfZiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IF9lO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZFJlc3BvbnNlKGNodW5rKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IChfYiA9IChfYSA9IGNodW5rLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0Q29udGVudC5wdXNoKGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQoY2h1bmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9mICYmICFfYyAmJiAoX2QgPSBzdHJlYW1SZXNwb25zZV8xLnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2QuY2FsbChzdHJlYW1SZXNwb25zZV8xKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVjb3JkSGlzdG9yeShpbnB1dENvbnRlbnQsIG91dHB1dENvbnRlbnQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVjb3JkSGlzdG9yeSh1c2VySW5wdXQsIG1vZGVsT3V0cHV0LCBhdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5KSB7XG4gICAgICAgIGxldCBvdXRwdXRDb250ZW50cyA9IFtdO1xuICAgICAgICBpZiAobW9kZWxPdXRwdXQubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgbW9kZWxPdXRwdXQuZXZlcnkoKGNvbnRlbnQpID0+IGNvbnRlbnQucm9sZSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgb3V0cHV0Q29udGVudHMgPSBtb2RlbE91dHB1dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFwcGVuZHMgYW4gZW1wdHkgY29udGVudCB3aGVuIG1vZGVsIHJldHVybnMgZW1wdHkgcmVzcG9uc2UsIHNvIHRoYXQgdGhlXG4gICAgICAgICAgICAvLyBoaXN0b3J5IGlzIGFsd2F5cyBhbHRlcm5hdGluZyBiZXR3ZWVuIHVzZXIgYW5kIG1vZGVsLlxuICAgICAgICAgICAgb3V0cHV0Q29udGVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgcm9sZTogJ21vZGVsJyxcbiAgICAgICAgICAgICAgICBwYXJ0czogW10sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSAmJlxuICAgICAgICAgICAgYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmhpc3RvcnkucHVzaCguLi5leHRyYWN0Q3VyYXRlZEhpc3RvcnkoYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oaXN0b3J5LnB1c2godXNlcklucHV0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhpc3RvcnkucHVzaCguLi5vdXRwdXRDb250ZW50cyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vKipcbiAqIEFQSSBlcnJvcnMgcmFpc2VkIGJ5IHRoZSBHZW5BSSBBUEkuXG4gKi9cbmNsYXNzIEFwaUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucy5tZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0FwaUVycm9yJztcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBvcHRpb25zLnN0YXR1cztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIEFwaUVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vLyBDb2RlIGdlbmVyYXRlZCBieSB0aGUgR29vZ2xlIEdlbiBBSSBTREsgZ2VuZXJhdG9yIERPIE5PVCBFRElULlxuZnVuY3Rpb24gY3JlYXRlRmlsZVBhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GaWxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlJ10pO1xuICAgIGlmIChmcm9tRmlsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGUnXSwgZnJvbUZpbGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWxlUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUZpbGVQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ2ZpbGUnXSwgdEZpbGVOYW1lKGZyb21OYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUZpbGVSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0RmlsZVBhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnZmlsZSddLCB0RmlsZU5hbWUoZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdEZpbGVzQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVNpemUnXSwgZnJvbVBhZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVRva2VuJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlVG9rZW4nXSwgZnJvbVBhZ2VUb2tlbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RGaWxlc1BhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGxpc3RGaWxlc0NvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0RmlsZXNSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5leHRQYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXh0UGFnZVRva2VuJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU5leHRQYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXh0UGFnZVRva2VuJ10sIGZyb21OZXh0UGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlcyddKTtcbiAgICBpZiAoZnJvbUZpbGVzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21GaWxlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBGaWxlcyBleHRlbmRzIEJhc2VNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3RzIGZpbGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBsaXN0IHJlcXVlc3QuXG4gICAgICAgICAqIEByZXR1cm4gLSBBIHBhZ2VyIG9mIGZpbGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBjb25zdCBmaWxlcyA9IGF3YWl0IGFpLmZpbGVzLmxpc3Qoe2NvbmZpZzogeydwYWdlU2l6ZSc6IDJ9fSk7XG4gICAgICAgICAqIGZvciBhd2FpdCAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xuICAgICAgICAgKiAgIGNvbnNvbGUubG9nKGZpbGUpO1xuICAgICAgICAgKiB9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saXN0ID0gYXN5bmMgKHBhcmFtcyA9IHt9KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhZ2VyKFBhZ2VkSXRlbS5QQUdFRF9JVEVNX0ZJTEVTLCAoeCkgPT4gdGhpcy5saXN0SW50ZXJuYWwoeCksIGF3YWl0IHRoaXMubGlzdEludGVybmFsKHBhcmFtcyksIHBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwbG9hZHMgYSBmaWxlIGFzeW5jaHJvbm91c2x5IHRvIHRoZSBHZW1pbmkgQVBJLlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIG5vdCBhdmFpbGFibGUgaW4gVmVydGV4IEFJLlxuICAgICAqIFN1cHBvcnRlZCB1cGxvYWQgc291cmNlczpcbiAgICAgKiAtIE5vZGUuanM6IEZpbGUgcGF0aCAoc3RyaW5nKSBvciBCbG9iIG9iamVjdC5cbiAgICAgKiAtIEJyb3dzZXI6IEJsb2Igb2JqZWN0IChlLmcuLCBGaWxlKS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhlIGBtaW1lVHlwZWAgY2FuIGJlIHNwZWNpZmllZCBpbiB0aGUgYGNvbmZpZ2AgcGFyYW1ldGVyLiBJZiBvbWl0dGVkOlxuICAgICAqICAtIEZvciBmaWxlIHBhdGggKHN0cmluZykgaW5wdXRzLCB0aGUgYG1pbWVUeXBlYCB3aWxsIGJlIGluZmVycmVkIGZyb20gdGhlXG4gICAgICogICAgIGZpbGUgZXh0ZW5zaW9uLlxuICAgICAqICAtIEZvciBCbG9iIG9iamVjdCBpbnB1dHMsIHRoZSBgbWltZVR5cGVgIHdpbGwgYmUgc2V0IHRvIHRoZSBCbG9iJ3MgYHR5cGVgXG4gICAgICogICAgIHByb3BlcnR5LlxuICAgICAqIFNvbWV4IGVhbXBsZXMgZm9yIGZpbGUgZXh0ZW5zaW9uIHRvIG1pbWVUeXBlIG1hcHBpbmc6XG4gICAgICogLnR4dCAtPiB0ZXh0L3BsYWluXG4gICAgICogLmpzb24gLT4gYXBwbGljYXRpb24vanNvblxuICAgICAqIC5qcGcgIC0+IGltYWdlL2pwZWdcbiAgICAgKiAucG5nIC0+IGltYWdlL3BuZ1xuICAgICAqIC5tcDMgLT4gYXVkaW8vbXBlZ1xuICAgICAqIC5tcDQgLT4gdmlkZW8vbXA0XG4gICAgICpcbiAgICAgKiBUaGlzIHNlY3Rpb24gY2FuIGNvbnRhaW4gbXVsdGlwbGUgcGFyYWdyYXBocyBhbmQgY29kZSBleGFtcGxlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBPcHRpb25hbCBwYXJhbWV0ZXJzIHNwZWNpZmllZCBpbiB0aGVcbiAgICAgKiAgICAgICAgYHR5cGVzLlVwbG9hZEZpbGVQYXJhbWV0ZXJzYCBpbnRlcmZhY2UuXG4gICAgICogICAgICAgICBAc2VlIHtAbGluayB0eXBlcy5VcGxvYWRGaWxlUGFyYW1ldGVycyNjb25maWd9IGZvciB0aGUgb3B0aW9uYWxcbiAgICAgKiAgICAgICAgIGNvbmZpZyBpbiB0aGUgcGFyYW1ldGVycy5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYHR5cGVzLkZpbGVgIG9iamVjdC5cbiAgICAgKiBAdGhyb3dzIEFuIGVycm9yIGlmIGNhbGxlZCBvbiBhIFZlcnRleCBBSSBjbGllbnQuXG4gICAgICogQHRocm93cyBBbiBlcnJvciBpZiB0aGUgYG1pbWVUeXBlYCBpcyBub3QgcHJvdmlkZWQgYW5kIGNhbiBub3QgYmUgaW5mZXJyZWQsXG4gICAgICogdGhlIGBtaW1lVHlwZWAgY2FuIGJlIHByb3ZpZGVkIGluIHRoZSBgcGFyYW1zLmNvbmZpZ2AgcGFyYW1ldGVyLlxuICAgICAqIEB0aHJvd3MgQW4gZXJyb3Igb2NjdXJzIGlmIGEgc3VpdGFibGUgdXBsb2FkIGxvY2F0aW9uIGNhbm5vdCBiZSBlc3RhYmxpc2hlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogVGhlIGZvbGxvd2luZyBjb2RlIHVwbG9hZHMgYSBmaWxlIHRvIEdlbWluaSBBUEkuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGZpbGUgPSBhd2FpdCBhaS5maWxlcy51cGxvYWQoe2ZpbGU6ICdmaWxlLnR4dCcsIGNvbmZpZzoge1xuICAgICAqICAgbWltZVR5cGU6ICd0ZXh0L3BsYWluJyxcbiAgICAgKiB9fSk7XG4gICAgICogY29uc29sZS5sb2coZmlsZS5uYW1lKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyB1cGxvYWQocGFyYW1zKSB7XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmVydGV4IEFJIGRvZXMgbm90IHN1cHBvcnQgdXBsb2FkaW5nIGZpbGVzLiBZb3UgY2FuIHNoYXJlIGZpbGVzIHRocm91Z2ggYSBHQ1MgYnVja2V0LicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgLnVwbG9hZEZpbGUocGFyYW1zLmZpbGUsIHBhcmFtcy5jb25maWcpXG4gICAgICAgICAgICAudGhlbigocmVzcCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEb3dubG9hZHMgYSByZW1vdGVseSBzdG9yZWQgZmlsZSBhc3luY2hyb25vdXNseSB0byBhIGxvY2F0aW9uIHNwZWNpZmllZCBpblxuICAgICAqIHRoZSBgcGFyYW1zYCBvYmplY3QuIFRoaXMgbWV0aG9kIG9ubHkgd29ya3Mgb24gTm9kZSBlbnZpcm9ubWVudCwgdG9cbiAgICAgKiBkb3dubG9hZCBmaWxlcyBpbiB0aGUgYnJvd3NlciwgdXNlIGEgYnJvd3NlciBjb21wbGlhbnQgbWV0aG9kIGxpa2UgYW4gPGE+XG4gICAgICogdGFnLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZG93bmxvYWQgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogVGhlIGZvbGxvd2luZyBjb2RlIGRvd25sb2FkcyBhbiBleGFtcGxlIGZpbGUgbmFtZWQgXCJmaWxlcy9tZWhvenB4Zjg3N2RcIiBhc1xuICAgICAqIFwiZmlsZS50eHRcIi5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogYXdhaXQgYWkuZmlsZXMuZG93bmxvYWQoe2ZpbGU6IGZpbGUubmFtZSwgZG93bmxvYWRQYXRoOiAnZmlsZS50eHQnfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgZG93bmxvYWQocGFyYW1zKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuYXBpQ2xpZW50LmRvd25sb2FkRmlsZShwYXJhbXMpO1xuICAgIH1cbiAgICBhc3luYyBsaXN0SW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGxpc3RGaWxlc1BhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdmaWxlcycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gbGlzdEZpbGVzUmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBMaXN0RmlsZXNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlSW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNyZWF0ZUZpbGVQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgndXBsb2FkL3YxYmV0YS9maWxlcycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gY3JlYXRlRmlsZVJlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgQ3JlYXRlRmlsZVJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGZpbGUgaW5mb3JtYXRpb24gZnJvbSB0aGUgc2VydmljZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGdldCByZXF1ZXN0XG4gICAgICogQHJldHVybiBUaGUgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSB0eXBlcy5GaWxlIG9iamVjdCByZXF1ZXN0ZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgY29uZmlnOiBHZXRGaWxlUGFyYW1ldGVycyA9IHtcbiAgICAgKiAgIG5hbWU6IGZpbGVOYW1lLFxuICAgICAqIH07XG4gICAgICogZmlsZSA9IGF3YWl0IGFpLmZpbGVzLmdldChjb25maWcpO1xuICAgICAqIGNvbnNvbGUubG9nKGZpbGUubmFtZSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgZ2V0KHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXRGaWxlUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2ZpbGVzL3tmaWxlfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChyZXNwKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGEgcmVtb3RlbHkgc3RvcmVkIGZpbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBkZWxldGUgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSBEZWxldGVGaWxlUmVzcG9uc2UsIHRoZSByZXNwb25zZSBmb3IgdGhlIGRlbGV0ZSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIFRoZSBmb2xsb3dpbmcgY29kZSBkZWxldGVzIGFuIGV4YW1wbGUgZmlsZSBuYW1lZCBcImZpbGVzL21laG96cHhmODc3ZFwiLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBhd2FpdCBhaS5maWxlcy5kZWxldGUoe25hbWU6IGZpbGUubmFtZX0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZGVsZXRlRmlsZVBhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdmaWxlcy97ZmlsZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGRlbGV0ZUZpbGVSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IERlbGV0ZUZpbGVSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmZ1bmN0aW9uIGJsb2JUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RhdGEnXSk7XG4gICAgaWYgKGZyb21EYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGF0YSddLCBmcm9tRGF0YSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaXNwbGF5TmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZW50VG9NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYXJ0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFydHMnXSk7XG4gICAgaWYgKGZyb21QYXJ0cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUGFydHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydFRvTWxkZXYkMihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Sb2xlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyb2xlJ10pO1xuICAgIGlmIChmcm9tUm9sZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JvbGUnXSwgZnJvbVJvbGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmaWxlRGF0YVRvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGlzcGxheU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVVcmknXSk7XG4gICAgaWYgKGZyb21GaWxlVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZVVyaSddLCBmcm9tRmlsZVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbFRvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lkJ10pO1xuICAgIGlmIChmcm9tSWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpZCddLCBmcm9tSWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXJncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXJncyddKTtcbiAgICBpZiAoZnJvbUFyZ3MgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhcmdzJ10sIGZyb21BcmdzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRpYWxBcmdzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXJ0aWFsQXJncyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd3aWxsQ29udGludWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dpbGxDb250aW51ZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkRlY2xhcmF0aW9uVG9WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiZWhhdmlvciddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmVoYXZpb3IgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmFtZXRlcnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcmFtZXRlcnMnXSk7XG4gICAgaWYgKGZyb21QYXJhbWV0ZXJzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFyYW1ldGVycyddLCBmcm9tUGFyYW1ldGVycyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BhcmFtZXRlcnNKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFyYW1ldGVyc0pzb25TY2hlbWEnXSwgZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZSddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2UnXSwgZnJvbVJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUpzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUpzb25TY2hlbWEnXSwgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRpb25Db25maWdUb1ZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbFNlbGVjdGlvbkNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21vZGVsU2VsZWN0aW9uQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1vZGVsU2VsZWN0aW9uQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWxDb25maWcnXSwgZnJvbU1vZGVsU2VsZWN0aW9uQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUpzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUpzb25TY2hlbWEnXSwgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BdWRpb1RpbWVzdGFtcCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2F1ZGlvVGltZXN0YW1wJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUF1ZGlvVGltZXN0YW1wICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXVkaW9UaW1lc3RhbXAnXSwgZnJvbUF1ZGlvVGltZXN0YW1wKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhbmRpZGF0ZUNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FuZGlkYXRlQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2FuZGlkYXRlQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYW5kaWRhdGVDb3VudCddLCBmcm9tQ2FuZGlkYXRlQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5hYmxlQWZmZWN0aXZlRGlhbG9nID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW5hYmxlQWZmZWN0aXZlRGlhbG9nJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuYWJsZUFmZmVjdGl2ZURpYWxvZyddLCBmcm9tRW5hYmxlQWZmZWN0aXZlRGlhbG9nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZyZXF1ZW5jeVBlbmFsdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmcmVxdWVuY3lQZW5hbHR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZyZXF1ZW5jeVBlbmFsdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmcmVxdWVuY3lQZW5hbHR5J10sIGZyb21GcmVxdWVuY3lQZW5hbHR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxvZ3Byb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsb2dwcm9icyddKTtcbiAgICBpZiAoZnJvbUxvZ3Byb2JzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbG9ncHJvYnMnXSwgZnJvbUxvZ3Byb2JzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heE91dHB1dFRva2VucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21heE91dHB1dFRva2VucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NYXhPdXRwdXRUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXhPdXRwdXRUb2tlbnMnXSwgZnJvbU1heE91dHB1dFRva2Vucyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZWRpYVJlc29sdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtZWRpYVJlc29sdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWVkaWFSZXNvbHV0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWVkaWFSZXNvbHV0aW9uJ10sIGZyb21NZWRpYVJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJlc2VuY2VQZW5hbHR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlc2VuY2VQZW5hbHR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByZXNlbmNlUGVuYWx0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZXNlbmNlUGVuYWx0eSddLCBmcm9tUHJlc2VuY2VQZW5hbHR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTG9ncHJvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZUxvZ3Byb2JzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTG9ncHJvYnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUxvZ3Byb2JzJ10sIGZyb21SZXNwb25zZUxvZ3Byb2JzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZU1pbWVUeXBlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZU1pbWVUeXBlJ10sIGZyb21SZXNwb25zZU1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTW9kYWxpdGllcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZU1vZGFsaXRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZU1vZGFsaXRpZXMnXSwgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZVNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VTY2hlbWEnXSwgZnJvbVJlc3BvbnNlU2NoZW1hKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJvdXRpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyb3V0aW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJvdXRpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb3V0aW5nQ29uZmlnJ10sIGZyb21Sb3V0aW5nQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcGVlY2hDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddKTtcbiAgICBpZiAoZnJvbVNwZWVjaENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddLCBzcGVlY2hDb25maWdUb1ZlcnRleCQxKGZyb21TcGVlY2hDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0b3BTZXF1ZW5jZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzdG9wU2VxdWVuY2VzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVN0b3BTZXF1ZW5jZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdG9wU2VxdWVuY2VzJ10sIGZyb21TdG9wU2VxdWVuY2VzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRlbXBlcmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZW1wZXJhdHVyZSddKTtcbiAgICBpZiAoZnJvbVRlbXBlcmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGVtcGVyYXR1cmUnXSwgZnJvbVRlbXBlcmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRoaW5raW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhpbmtpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhpbmtpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aGlua2luZ0NvbmZpZyddLCBmcm9tVGhpbmtpbmdDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wSyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wSyddKTtcbiAgICBpZiAoZnJvbVRvcEsgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3BLJ10sIGZyb21Ub3BLKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcFAgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcFAnXSk7XG4gICAgaWYgKGZyb21Ub3BQICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9wUCddLCBmcm9tVG9wUCk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuYWJsZUVuaGFuY2VkQ2l2aWNBbnN3ZXJzJ10pICE9PVxuICAgICAgICB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbmFibGVFbmhhbmNlZENpdmljQW5zd2VycyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZU1hcHNUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXV0aENvbmZpZyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXV0aENvbmZpZyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5hYmxlV2lkZ2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmFibGVXaWRnZXQnXSk7XG4gICAgaWYgKGZyb21FbmFibGVXaWRnZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmFibGVXaWRnZXQnXSwgZnJvbUVuYWJsZVdpZGdldCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFRvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleGNsdWRlRG9tYWlucyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhjbHVkZURvbWFpbnMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmxvY2tpbmdDb25maWRlbmNlJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdibG9ja2luZ0NvbmZpZGVuY2UgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRpbWVSYW5nZUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RpbWVSYW5nZUZpbHRlcicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaW1lUmFuZ2VGaWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aW1lUmFuZ2VGaWx0ZXInXSwgZnJvbVRpbWVSYW5nZUZpbHRlcik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVDb25uZWN0Q29uZmlnVG9NbGRldiQxKGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUdlbmVyYXRpb25Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnZW5lcmF0aW9uQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUdlbmVyYXRpb25Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZyddLCBmcm9tR2VuZXJhdGlvbkNvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1vZGFsaXRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZU1vZGFsaXRpZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAncmVzcG9uc2VNb2RhbGl0aWVzJ10sIGZyb21SZXNwb25zZU1vZGFsaXRpZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGVtcGVyYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0ZW1wZXJhdHVyZSddLCBmcm9tVGVtcGVyYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wUCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wUCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvcFAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0b3BQJ10sIGZyb21Ub3BQKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcEsgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcEsnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub3BLICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAndG9wSyddLCBmcm9tVG9wSyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhPdXRwdXRUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXhPdXRwdXRUb2tlbnMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTWF4T3V0cHV0VG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnbWF4T3V0cHV0VG9rZW5zJ10sIGZyb21NYXhPdXRwdXRUb2tlbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWVkaWFSZXNvbHV0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWVkaWFSZXNvbHV0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU1lZGlhUmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ21lZGlhUmVzb2x1dGlvbiddLCBmcm9tTWVkaWFSZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcGVlY2hDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNwZWVjaENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3NwZWVjaENvbmZpZyddLCB0TGl2ZVNwZWVjaENvbmZpZyhmcm9tU3BlZWNoQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaGlua2luZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RoaW5raW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRoaW5raW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAndGhpbmtpbmdDb25maWcnXSwgZnJvbVRoaW5raW5nQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VuYWJsZUFmZmVjdGl2ZURpYWxvZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdlbmFibGVBZmZlY3RpdmVEaWFsb2cnXSwgZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TeXN0ZW1JbnN0cnVjdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVN5c3RlbUluc3RydWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3N5c3RlbUluc3RydWN0aW9uJ10sIGNvbnRlbnRUb01sZGV2JDIodENvbnRlbnQoZnJvbVN5c3RlbUluc3RydWN0aW9uKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdFRvb2xzKGZyb21Ub29scyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9vbFRvTWxkZXYkMih0VG9vbChpdGVtKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAndG9vbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlc3Npb25SZXN1bXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2Vzc2lvblJlc3VtcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2Vzc2lvblJlc3VtcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnc2Vzc2lvblJlc3VtcHRpb24nXSwgc2Vzc2lvblJlc3VtcHRpb25Db25maWdUb01sZGV2JDEoZnJvbVNlc3Npb25SZXN1bXB0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2lucHV0QXVkaW9UcmFuc2NyaXB0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUlucHV0QXVkaW9UcmFuc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2lucHV0QXVkaW9UcmFuc2NyaXB0aW9uJ10sIGZyb21JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ291dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbiddLCBmcm9tT3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlYWx0aW1lSW5wdXRDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZWFsdGltZUlucHV0Q29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVJlYWx0aW1lSW5wdXRDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAncmVhbHRpbWVJbnB1dENvbmZpZyddLCBmcm9tUmVhbHRpbWVJbnB1dENvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZXh0V2luZG93Q29tcHJlc3Npb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb250ZXh0V2luZG93Q29tcHJlc3Npb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ29udGV4dFdpbmRvd0NvbXByZXNzaW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2NvbnRleHRXaW5kb3dDb21wcmVzc2lvbiddLCBmcm9tQ29udGV4dFdpbmRvd0NvbXByZXNzaW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb2FjdGl2aXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9hY3Rpdml0eSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVByb2FjdGl2aXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3Byb2FjdGl2aXR5J10sIGZyb21Qcm9hY3Rpdml0eSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVDb25uZWN0Q29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2VuZXJhdGlvbkNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dlbmVyYXRpb25Db25maWcnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tR2VuZXJhdGlvbkNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJ10sIGdlbmVyYXRpb25Db25maWdUb1ZlcnRleCQxKGZyb21HZW5lcmF0aW9uQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1vZGFsaXRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZU1vZGFsaXRpZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAncmVzcG9uc2VNb2RhbGl0aWVzJ10sIGZyb21SZXNwb25zZU1vZGFsaXRpZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGVtcGVyYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0ZW1wZXJhdHVyZSddLCBmcm9tVGVtcGVyYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wUCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wUCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvcFAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0b3BQJ10sIGZyb21Ub3BQKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcEsgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcEsnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub3BLICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAndG9wSyddLCBmcm9tVG9wSyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhPdXRwdXRUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXhPdXRwdXRUb2tlbnMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTWF4T3V0cHV0VG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnbWF4T3V0cHV0VG9rZW5zJ10sIGZyb21NYXhPdXRwdXRUb2tlbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWVkaWFSZXNvbHV0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWVkaWFSZXNvbHV0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU1lZGlhUmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ21lZGlhUmVzb2x1dGlvbiddLCBmcm9tTWVkaWFSZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcGVlY2hDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNwZWVjaENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3NwZWVjaENvbmZpZyddLCBzcGVlY2hDb25maWdUb1ZlcnRleCQxKHRMaXZlU3BlZWNoQ29uZmlnKGZyb21TcGVlY2hDb25maWcpKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaGlua2luZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RoaW5raW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRoaW5raW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAndGhpbmtpbmdDb25maWcnXSwgZnJvbVRoaW5raW5nQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VuYWJsZUFmZmVjdGl2ZURpYWxvZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdlbmFibGVBZmZlY3RpdmVEaWFsb2cnXSwgZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TeXN0ZW1JbnN0cnVjdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVN5c3RlbUluc3RydWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3N5c3RlbUluc3RydWN0aW9uJ10sIHRDb250ZW50KGZyb21TeXN0ZW1JbnN0cnVjdGlvbikpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdFRvb2xzKGZyb21Ub29scyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9vbFRvVmVydGV4JDEodFRvb2woaXRlbSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3Rvb2xzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZXNzaW9uUmVzdW1wdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nlc3Npb25SZXN1bXB0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNlc3Npb25SZXN1bXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3Nlc3Npb25SZXN1bXB0aW9uJ10sIGZyb21TZXNzaW9uUmVzdW1wdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2lucHV0QXVkaW9UcmFuc2NyaXB0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUlucHV0QXVkaW9UcmFuc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2lucHV0QXVkaW9UcmFuc2NyaXB0aW9uJ10sIGZyb21JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ291dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbiddLCBmcm9tT3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlYWx0aW1lSW5wdXRDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZWFsdGltZUlucHV0Q29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVJlYWx0aW1lSW5wdXRDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAncmVhbHRpbWVJbnB1dENvbmZpZyddLCBmcm9tUmVhbHRpbWVJbnB1dENvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZXh0V2luZG93Q29tcHJlc3Npb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb250ZXh0V2luZG93Q29tcHJlc3Npb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ29udGV4dFdpbmRvd0NvbXByZXNzaW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2NvbnRleHRXaW5kb3dDb21wcmVzc2lvbiddLCBmcm9tQ29udGV4dFdpbmRvd0NvbXByZXNzaW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb2FjdGl2aXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9hY3Rpdml0eSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVByb2FjdGl2aXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3Byb2FjdGl2aXR5J10sIGZyb21Qcm9hY3Rpdml0eSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVDb25uZWN0UGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZXR1cCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGxpdmVDb25uZWN0Q29uZmlnVG9NbGRldiQxKGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVDb25uZWN0UGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2V0dXAnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBsaXZlQ29ubmVjdENvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVNdXNpY1NldENvbmZpZ1BhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21NdXNpY0dlbmVyYXRpb25Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtdXNpY0dlbmVyYXRpb25Db25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTXVzaWNHZW5lcmF0aW9uQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbXVzaWNHZW5lcmF0aW9uQ29uZmlnJ10sIGZyb21NdXNpY0dlbmVyYXRpb25Db25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlTXVzaWNTZXRXZWlnaHRlZFByb21wdHNQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tV2VpZ2h0ZWRQcm9tcHRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnd2VpZ2h0ZWRQcm9tcHRzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVdlaWdodGVkUHJvbXB0cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tV2VpZ2h0ZWRQcm9tcHRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd3ZWlnaHRlZFByb21wdHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZVNlbmRSZWFsdGltZUlucHV0UGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1lZGlhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZWRpYSddKTtcbiAgICBpZiAoZnJvbU1lZGlhICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRCbG9icyhmcm9tTWVkaWEpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJsb2JUb01sZGV2JDIoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZWRpYUNodW5rcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXVkaW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1ZGlvJ10pO1xuICAgIGlmIChmcm9tQXVkaW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdWRpbyddLCBibG9iVG9NbGRldiQyKHRBdWRpb0Jsb2IoZnJvbUF1ZGlvKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXVkaW9TdHJlYW1FbmQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhdWRpb1N0cmVhbUVuZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BdWRpb1N0cmVhbUVuZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F1ZGlvU3RyZWFtRW5kJ10sIGZyb21BdWRpb1N0cmVhbUVuZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmlkZW8nXSk7XG4gICAgaWYgKGZyb21WaWRlbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvJ10sIGJsb2JUb01sZGV2JDIodEltYWdlQmxvYihmcm9tVmlkZW8pKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQWN0aXZpdHlTdGFydCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2FjdGl2aXR5U3RhcnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQWN0aXZpdHlTdGFydCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FjdGl2aXR5U3RhcnQnXSwgZnJvbUFjdGl2aXR5U3RhcnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQWN0aXZpdHlFbmQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FjdGl2aXR5RW5kJ10pO1xuICAgIGlmIChmcm9tQWN0aXZpdHlFbmQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhY3Rpdml0eUVuZCddLCBmcm9tQWN0aXZpdHlFbmQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlU2VuZFJlYWx0aW1lSW5wdXRQYXJhbWV0ZXJzVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1lZGlhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZWRpYSddKTtcbiAgICBpZiAoZnJvbU1lZGlhICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRCbG9icyhmcm9tTWVkaWEpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZWRpYUNodW5rcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXVkaW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1ZGlvJ10pO1xuICAgIGlmIChmcm9tQXVkaW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdWRpbyddLCB0QXVkaW9CbG9iKGZyb21BdWRpbykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXVkaW9TdHJlYW1FbmQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhdWRpb1N0cmVhbUVuZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BdWRpb1N0cmVhbUVuZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F1ZGlvU3RyZWFtRW5kJ10sIGZyb21BdWRpb1N0cmVhbUVuZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmlkZW8nXSk7XG4gICAgaWYgKGZyb21WaWRlbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvJ10sIHRJbWFnZUJsb2IoZnJvbVZpZGVvKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQWN0aXZpdHlTdGFydCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2FjdGl2aXR5U3RhcnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQWN0aXZpdHlTdGFydCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FjdGl2aXR5U3RhcnQnXSwgZnJvbUFjdGl2aXR5U3RhcnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQWN0aXZpdHlFbmQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FjdGl2aXR5RW5kJ10pO1xuICAgIGlmIChmcm9tQWN0aXZpdHlFbmQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhY3Rpdml0eUVuZCddLCBmcm9tQWN0aXZpdHlFbmQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlU2VydmVyTWVzc2FnZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNldHVwQ29tcGxldGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZXR1cENvbXBsZXRlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNldHVwQ29tcGxldGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZXR1cENvbXBsZXRlJ10sIGZyb21TZXR1cENvbXBsZXRlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlcnZlckNvbnRlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZXJ2ZXJDb250ZW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNlcnZlckNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZXJ2ZXJDb250ZW50J10sIGZyb21TZXJ2ZXJDb250ZW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xDYWxsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29sQ2FsbCddKTtcbiAgICBpZiAoZnJvbVRvb2xDYWxsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9vbENhbGwnXSwgZnJvbVRvb2xDYWxsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xDYWxsQ2FuY2VsbGF0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndG9vbENhbGxDYW5jZWxsYXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVG9vbENhbGxDYW5jZWxsYXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b29sQ2FsbENhbmNlbGxhdGlvbiddLCBmcm9tVG9vbENhbGxDYW5jZWxsYXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXNhZ2VNZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3VzYWdlTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVXNhZ2VNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VzYWdlTWV0YWRhdGEnXSwgdXNhZ2VNZXRhZGF0YUZyb21WZXJ0ZXgoZnJvbVVzYWdlTWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvQXdheSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29Bd2F5J10pO1xuICAgIGlmIChmcm9tR29Bd2F5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29Bd2F5J10sIGZyb21Hb0F3YXkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2Vzc2lvblJlc3VtcHRpb25VcGRhdGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZXNzaW9uUmVzdW1wdGlvblVwZGF0ZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZXNzaW9uUmVzdW1wdGlvblVwZGF0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nlc3Npb25SZXN1bXB0aW9uVXBkYXRlJ10sIGZyb21TZXNzaW9uUmVzdW1wdGlvblVwZGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHBhcnRUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1lZGlhUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21lZGlhUmVzb2x1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NZWRpYVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZWRpYVJlc29sdXRpb24nXSwgZnJvbU1lZGlhUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvblJlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvblJlc3VsdCddLCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGVjdXRhYmxlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4ZWN1dGFibGVDb2RlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4ZWN1dGFibGVDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhlY3V0YWJsZUNvZGUnXSwgZnJvbUV4ZWN1dGFibGVDb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlRGF0YSddKTtcbiAgICBpZiAoZnJvbUZpbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZURhdGEnXSwgZmlsZURhdGFUb01sZGV2JDIoZnJvbUZpbGVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddLCBmdW5jdGlvbkNhbGxUb01sZGV2JDIoZnJvbUZ1bmN0aW9uQ2FsbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uUmVzcG9uc2UnXSwgZnJvbUZ1bmN0aW9uUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5saW5lRGF0YSddKTtcbiAgICBpZiAoZnJvbUlubGluZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmxpbmVEYXRhJ10sIGJsb2JUb01sZGV2JDIoZnJvbUlubGluZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aG91Z2h0J10pO1xuICAgIGlmIChmcm9tVGhvdWdodCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHQnXSwgZnJvbVRob3VnaHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodFNpZ25hdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rob3VnaHRTaWduYXR1cmUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhvdWdodFNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHRTaWduYXR1cmUnXSwgZnJvbVRob3VnaHRTaWduYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW9NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ZpZGVvTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvTWV0YWRhdGEnXSwgZnJvbVZpZGVvTWV0YWRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzZXNzaW9uUmVzdW1wdGlvbkNvbmZpZ1RvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSGFuZGxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydoYW5kbGUnXSk7XG4gICAgaWYgKGZyb21IYW5kbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydoYW5kbGUnXSwgZnJvbUhhbmRsZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RyYW5zcGFyZW50J10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmFuc3BhcmVudCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzcGVlY2hDb25maWdUb1ZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21MYW5ndWFnZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddKTtcbiAgICBpZiAoZnJvbUxhbmd1YWdlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddLCBmcm9tTGFuZ3VhZ2VDb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZvaWNlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2b2ljZUNvbmZpZyddKTtcbiAgICBpZiAoZnJvbVZvaWNlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndm9pY2VDb25maWcnXSwgZnJvbVZvaWNlQ29uZmlnKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbXVsdGlTcGVha2VyVm9pY2VDb25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ211bHRpU3BlYWtlclZvaWNlQ29uZmlnIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbFRvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkRlY2xhcmF0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JldHJpZXZhbCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmV0cmlldmFsIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnb29nbGVTZWFyY2hSZXRyaWV2YWwnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJ10sIGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29tcHV0ZXJVc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10pO1xuICAgIGlmIChmcm9tQ29tcHV0ZXJVc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb21wdXRlclVzZSddLCBmcm9tQ29tcHV0ZXJVc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZVNlYXJjaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZVNlYXJjaCddKTtcbiAgICBpZiAoZnJvbUZpbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlU2VhcmNoJ10sIGZyb21GaWxlU2VhcmNoKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uJ10sIGZyb21Db2RlRXhlY3V0aW9uKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW50ZXJwcmlzZVdlYlNlYXJjaCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZW50ZXJwcmlzZVdlYlNlYXJjaCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlTWFwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlTWFwcyddKTtcbiAgICBpZiAoZnJvbUdvb2dsZU1hcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVNYXBzJ10sIGdvb2dsZU1hcHNUb01sZGV2JDIoZnJvbUdvb2dsZU1hcHMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10sIGdvb2dsZVNlYXJjaFRvTWxkZXYkMihmcm9tR29vZ2xlU2VhcmNoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmxDb250ZXh0J10pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHQnXSwgZnJvbVVybENvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0b29sVG9WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkRlY2xhcmF0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25EZWNsYXJhdGlvblRvVmVydGV4JDEoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkRlY2xhcmF0aW9ucyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXRyaWV2YWwnXSk7XG4gICAgaWYgKGZyb21SZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXRyaWV2YWwnXSwgZnJvbVJldHJpZXZhbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnb29nbGVTZWFyY2hSZXRyaWV2YWwnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJ10sIGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29tcHV0ZXJVc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10pO1xuICAgIGlmIChmcm9tQ29tcHV0ZXJVc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb21wdXRlclVzZSddLCBmcm9tQ29tcHV0ZXJVc2UpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlU2VhcmNoJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWxlU2VhcmNoIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uJ10sIGZyb21Db2RlRXhlY3V0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVudGVycHJpc2VXZWJTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbnRlcnByaXNlV2ViU2VhcmNoJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUVudGVycHJpc2VXZWJTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbnRlcnByaXNlV2ViU2VhcmNoJ10sIGZyb21FbnRlcnByaXNlV2ViU2VhcmNoKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZU1hcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVNYXBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlTWFwcyddLCBmcm9tR29vZ2xlTWFwcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddLCBmcm9tR29vZ2xlU2VhcmNoKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVybENvbnRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VybENvbnRleHQnXSk7XG4gICAgaWYgKGZyb21VcmxDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsQ29udGV4dCddLCBmcm9tVXJsQ29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVzYWdlTWV0YWRhdGFGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Qcm9tcHRUb2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJvbXB0VG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Qcm9tcHRUb2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJvbXB0VG9rZW5Db3VudCddLCBmcm9tUHJvbXB0VG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYWNoZWRDb250ZW50VG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhY2hlZENvbnRlbnRUb2tlbkNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNhY2hlZENvbnRlbnRUb2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FjaGVkQ29udGVudFRva2VuQ291bnQnXSwgZnJvbUNhY2hlZENvbnRlbnRUb2tlbkNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlVG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhbmRpZGF0ZXNUb2tlbkNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlVG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlVG9rZW5Db3VudCddLCBmcm9tUmVzcG9uc2VUb2tlbkNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xVc2VQcm9tcHRUb2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndG9vbFVzZVByb21wdFRva2VuQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVG9vbFVzZVByb21wdFRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b29sVXNlUHJvbXB0VG9rZW5Db3VudCddLCBmcm9tVG9vbFVzZVByb21wdFRva2VuQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodHNUb2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhvdWdodHNUb2tlbkNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRob3VnaHRzVG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHRzVG9rZW5Db3VudCddLCBmcm9tVGhvdWdodHNUb2tlbkNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvdGFsVG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RvdGFsVG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Ub3RhbFRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3RhbFRva2VuQ291bnQnXSwgZnJvbVRvdGFsVG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9tcHRUb2tlbnNEZXRhaWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJvbXB0VG9rZW5zRGV0YWlscycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Qcm9tcHRUb2tlbnNEZXRhaWxzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21Qcm9tcHRUb2tlbnNEZXRhaWxzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9tcHRUb2tlbnNEZXRhaWxzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYWNoZVRva2Vuc0RldGFpbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYWNoZVRva2Vuc0RldGFpbHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2FjaGVUb2tlbnNEZXRhaWxzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21DYWNoZVRva2Vuc0RldGFpbHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhY2hlVG9rZW5zRGV0YWlscyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VUb2tlbnNEZXRhaWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FuZGlkYXRlc1Rva2Vuc0RldGFpbHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VUb2tlbnNEZXRhaWxzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21SZXNwb25zZVRva2Vuc0RldGFpbHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlVG9rZW5zRGV0YWlscyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbFVzZVByb21wdFRva2Vuc0RldGFpbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0b29sVXNlUHJvbXB0VG9rZW5zRGV0YWlscycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Ub29sVXNlUHJvbXB0VG9rZW5zRGV0YWlscyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tVG9vbFVzZVByb21wdFRva2Vuc0RldGFpbHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rvb2xVc2VQcm9tcHRUb2tlbnNEZXRhaWxzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UcmFmZmljVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHJhZmZpY1R5cGUnXSk7XG4gICAgaWYgKGZyb21UcmFmZmljVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RyYWZmaWNUeXBlJ10sIGZyb21UcmFmZmljVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuZnVuY3Rpb24gYmxvYlRvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGF0YSddKTtcbiAgICBpZiAoZnJvbURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkYXRhJ10sIGZyb21EYXRhKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3BsYXlOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNhbmRpZGF0ZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29udGVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudCddKTtcbiAgICBpZiAoZnJvbUNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb250ZW50J10sIGZyb21Db250ZW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNpdGF0aW9uTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjaXRhdGlvbk1ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNpdGF0aW9uTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjaXRhdGlvbk1ldGFkYXRhJ10sIGNpdGF0aW9uTWV0YWRhdGFGcm9tTWxkZXYoZnJvbUNpdGF0aW9uTWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rva2VuQ291bnQnXSk7XG4gICAgaWYgKGZyb21Ub2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9rZW5Db3VudCddLCBmcm9tVG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaW5pc2hSZWFzb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbmlzaFJlYXNvbiddKTtcbiAgICBpZiAoZnJvbUZpbmlzaFJlYXNvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbmlzaFJlYXNvbiddLCBmcm9tRmluaXNoUmVhc29uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF2Z0xvZ3Byb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdmdMb2dwcm9icyddKTtcbiAgICBpZiAoZnJvbUF2Z0xvZ3Byb2JzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXZnTG9ncHJvYnMnXSwgZnJvbUF2Z0xvZ3Byb2JzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdyb3VuZGluZ01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ3JvdW5kaW5nTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR3JvdW5kaW5nTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydncm91bmRpbmdNZXRhZGF0YSddLCBmcm9tR3JvdW5kaW5nTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5kZXggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2luZGV4J10pO1xuICAgIGlmIChmcm9tSW5kZXggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmRleCddLCBmcm9tSW5kZXgpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTG9ncHJvYnNSZXN1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdsb2dwcm9ic1Jlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Mb2dwcm9ic1Jlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xvZ3Byb2JzUmVzdWx0J10sIGZyb21Mb2dwcm9ic1Jlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlSYXRpbmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5UmF0aW5ncycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TYWZldHlSYXRpbmdzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21TYWZldHlSYXRpbmdzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzYWZldHlSYXRpbmdzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0TWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd1cmxDb250ZXh0TWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dE1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsQ29udGV4dE1ldGFkYXRhJ10sIGZyb21VcmxDb250ZXh0TWV0YWRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjaXRhdGlvbk1ldGFkYXRhRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21DaXRhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NpdGF0aW9uU291cmNlcyddKTtcbiAgICBpZiAoZnJvbUNpdGF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQ2l0YXRpb25zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjaXRhdGlvbnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29tcHV0ZVRva2Vuc1BhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudHMnXSk7XG4gICAgaWYgKGZyb21Db250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0Q29udGVudHMoZnJvbUNvbnRlbnRzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29udGVudHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29tcHV0ZVRva2Vuc1Jlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRva2Vuc0luZm8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rva2Vuc0luZm8nXSk7XG4gICAgaWYgKGZyb21Ub2tlbnNJbmZvICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21Ub2tlbnNJbmZvO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b2tlbnNJbmZvJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRFbWJlZGRpbmdGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21WYWx1ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZhbHVlcyddKTtcbiAgICBpZiAoZnJvbVZhbHVlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZhbHVlcyddLCBmcm9tVmFsdWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXRpc3RpY3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXRpc3RpY3MnXSk7XG4gICAgaWYgKGZyb21TdGF0aXN0aWNzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhdGlzdGljcyddLCBjb250ZW50RW1iZWRkaW5nU3RhdGlzdGljc0Zyb21WZXJ0ZXgoZnJvbVN0YXRpc3RpY3MpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudEVtYmVkZGluZ1N0YXRpc3RpY3NGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UcnVuY2F0ZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RydW5jYXRlZCddKTtcbiAgICBpZiAoZnJvbVRydW5jYXRlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RydW5jYXRlZCddLCBmcm9tVHJ1bmNhdGVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rva2VuX2NvdW50J10pO1xuICAgIGlmIChmcm9tVG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rva2VuQ291bnQnXSwgZnJvbVRva2VuQ291bnQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZW50VG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYXJ0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFydHMnXSk7XG4gICAgaWYgKGZyb21QYXJ0cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUGFydHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydFRvTWxkZXYkMShpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Sb2xlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyb2xlJ10pO1xuICAgIGlmIChmcm9tUm9sZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JvbGUnXSwgZnJvbVJvbGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250cm9sUmVmZXJlbmNlQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbnRyb2xUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250cm9sVHlwZSddKTtcbiAgICBpZiAoZnJvbUNvbnRyb2xUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29udHJvbFR5cGUnXSwgZnJvbUNvbnRyb2xUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuYWJsZUNvbnRyb2xJbWFnZUNvbXB1dGF0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW5hYmxlQ29udHJvbEltYWdlQ29tcHV0YXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRW5hYmxlQ29udHJvbEltYWdlQ29tcHV0YXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb21wdXRlQ29udHJvbCddLCBmcm9tRW5hYmxlQ29udHJvbEltYWdlQ29tcHV0YXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb3VudFRva2Vuc0NvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3lzdGVtSW5zdHJ1Y3Rpb24nXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N5c3RlbUluc3RydWN0aW9uIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b29scyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnZW5lcmF0aW9uQ29uZmlnJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnZW5lcmF0aW9uQ29uZmlnIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvdW50VG9rZW5zQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TeXN0ZW1JbnN0cnVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzeXN0ZW1JbnN0cnVjdGlvbiddLCB0Q29udGVudChmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29scyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21Ub29scztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b29sVG9WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndG9vbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdlbmVyYXRpb25Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnZW5lcmF0aW9uQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUdlbmVyYXRpb25Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZ2VuZXJhdGlvbkNvbmZpZyddLCBnZW5lcmF0aW9uQ29uZmlnVG9WZXJ0ZXgoZnJvbUdlbmVyYXRpb25Db25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY291bnRUb2tlbnNQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudHMnXSk7XG4gICAgaWYgKGZyb21Db250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0Q29udGVudHMoZnJvbUNvbnRlbnRzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50VG9NbGRldiQxKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29udGVudHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgY291bnRUb2tlbnNDb25maWdUb01sZGV2KGZyb21Db25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb3VudFRva2Vuc1BhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudHMnXSk7XG4gICAgaWYgKGZyb21Db250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0Q29udGVudHMoZnJvbUNvbnRlbnRzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29udGVudHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgY291bnRUb2tlbnNDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvdW50VG9rZW5zUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3RhbFRva2VucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG90YWxUb2tlbnMnXSk7XG4gICAgaWYgKGZyb21Ub3RhbFRva2VucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvdGFsVG9rZW5zJ10sIGZyb21Ub3RhbFRva2Vucyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYWNoZWRDb250ZW50VG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhY2hlZENvbnRlbnRUb2tlbkNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNhY2hlZENvbnRlbnRUb2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FjaGVkQ29udGVudFRva2VuQ291bnQnXSwgZnJvbUNhY2hlZENvbnRlbnRUb2tlbkNvdW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY291bnRUb2tlbnNSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3RhbFRva2VucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG90YWxUb2tlbnMnXSk7XG4gICAgaWYgKGZyb21Ub3RhbFRva2VucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvdGFsVG9rZW5zJ10sIGZyb21Ub3RhbFRva2Vucyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZU1vZGVsUGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZU1vZGVsUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVNb2RlbFJlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVNb2RlbFJlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZWRpdEltYWdlQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tT3V0cHV0R2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRHY3NVcmknXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRHY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzdG9yYWdlVXJpJ10sIGZyb21PdXRwdXRHY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmVnYXRpdmVQcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZWdhdGl2ZVByb21wdCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OZWdhdGl2ZVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ25lZ2F0aXZlUHJvbXB0J10sIGZyb21OZWdhdGl2ZVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OdW1iZXJPZkltYWdlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ251bWJlck9mSW1hZ2VzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU51bWJlck9mSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FtcGxlQ291bnQnXSwgZnJvbU51bWJlck9mSW1hZ2VzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFzcGVjdFJhdGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhc3BlY3RSYXRpbyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUFzcGVjdFJhdGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnYXNwZWN0UmF0aW8nXSwgZnJvbUFzcGVjdFJhdGlvKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUd1aWRhbmNlU2NhbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdndWlkYW5jZVNjYWxlJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUd1aWRhbmNlU2NhbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdndWlkYW5jZVNjYWxlJ10sIGZyb21HdWlkYW5jZVNjYWxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlGaWx0ZXJMZXZlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eUZpbHRlckxldmVsJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNhZmV0eUZpbHRlckxldmVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FmZXR5U2V0dGluZyddLCBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGVyc29uR2VuZXJhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BlcnNvbkdlbmVyYXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGVyc29uR2VuZXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3BlcnNvbkdlbmVyYXRpb24nXSwgZnJvbVBlcnNvbkdlbmVyYXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbmNsdWRlU2FmZXR5QXR0cmlidXRlcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbmNsdWRlU2FmZXR5QXR0cmlidXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2luY2x1ZGVTYWZldHlBdHRyaWJ1dGVzJ10sIGZyb21JbmNsdWRlU2FmZXR5QXR0cmlidXRlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmNsdWRlUmFpUmVhc29uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5jbHVkZVJhaVJlYXNvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbmNsdWRlUmFpUmVhc29uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnaW5jbHVkZVJhaVJlYXNvbiddLCBmcm9tSW5jbHVkZVJhaVJlYXNvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYW5ndWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFuZ3VhZ2UnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MYW5ndWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2xhbmd1YWdlJ10sIGZyb21MYW5ndWFnZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRNaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dE1pbWVUeXBlJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dE1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnb3V0cHV0T3B0aW9ucycsICdtaW1lVHlwZSddLCBmcm9tT3V0cHV0TWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dE9wdGlvbnMnLCAnY29tcHJlc3Npb25RdWFsaXR5J10sIGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQWRkV2F0ZXJtYXJrID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhZGRXYXRlcm1hcmsnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21BZGRXYXRlcm1hcmsgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdhZGRXYXRlcm1hcmsnXSwgZnJvbUFkZFdhdGVybWFyayk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYWJlbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhYmVscyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUxhYmVscyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydsYWJlbHMnXSwgZnJvbUxhYmVscyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FZGl0TW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZWRpdE1vZGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FZGl0TW9kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2VkaXRNb2RlJ10sIGZyb21FZGl0TW9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CYXNlU3RlcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Jhc2VTdGVwcyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUJhc2VTdGVwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2VkaXRDb25maWcnLCAnYmFzZVN0ZXBzJ10sIGZyb21CYXNlU3RlcHMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlZGl0SW1hZ2VQYXJhbWV0ZXJzSW50ZXJuYWxUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb21wdCddKTtcbiAgICBpZiAoZnJvbVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdwcm9tcHQnXSwgZnJvbVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZWZlcmVuY2VJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZWZlcmVuY2VJbWFnZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVmZXJlbmNlSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21SZWZlcmVuY2VJbWFnZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVmZXJlbmNlSW1hZ2VBUElJbnRlcm5hbFRvVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3JlZmVyZW5jZUltYWdlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBlZGl0SW1hZ2VDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVkaXRJbWFnZVJlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdlbmVyYXRlZEltYWdlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZWRpY3Rpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdlbmVyYXRlZEltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tR2VuZXJhdGVkSW1hZ2VzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlZEltYWdlRnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRlZEltYWdlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbWJlZENvbnRlbnRDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRhc2tUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0YXNrVHlwZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRhc2tUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3JlcXVlc3RzW10nLCAndGFza1R5cGUnXSwgZnJvbVRhc2tUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRpdGxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aXRsZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRpdGxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3JlcXVlc3RzW10nLCAndGl0bGUnXSwgZnJvbVRpdGxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dERpbWVuc2lvbmFsaXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0RGltZW5zaW9uYWxpdHknLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0RGltZW5zaW9uYWxpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncmVxdWVzdHNbXScsICdvdXRwdXREaW1lbnNpb25hbGl0eSddLCBmcm9tT3V0cHV0RGltZW5zaW9uYWxpdHkpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWltZVR5cGUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXV0b1RydW5jYXRlJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdXRvVHJ1bmNhdGUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZW1iZWRDb250ZW50Q29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVGFza1R5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rhc2tUeXBlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGFza1R5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzW10nLCAndGFza190eXBlJ10sIGZyb21UYXNrVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaXRsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGl0bGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UaXRsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbXScsICd0aXRsZSddLCBmcm9tVGl0bGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0RGltZW5zaW9uYWxpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXREaW1lbnNpb25hbGl0eScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXREaW1lbnNpb25hbGl0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dERpbWVuc2lvbmFsaXR5J10sIGZyb21PdXRwdXREaW1lbnNpb25hbGl0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbXScsICdtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXV0b1RydW5jYXRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdXRvVHJ1bmNhdGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21BdXRvVHJ1bmNhdGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdhdXRvVHJ1bmNhdGUnXSwgZnJvbUF1dG9UcnVuY2F0ZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVtYmVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50cyddKTtcbiAgICBpZiAoZnJvbUNvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRDb250ZW50c0ZvckVtYmVkKGFwaUNsaWVudCwgZnJvbUNvbnRlbnRzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVxdWVzdHNbXScsICdjb250ZW50J10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGVtYmVkQ29udGVudENvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZWxGb3JFbWJlZENvbnRlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWxGb3JFbWJlZENvbnRlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXF1ZXN0c1tdJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbEZvckVtYmVkQ29udGVudCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbWJlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdENvbnRlbnRzRm9yRW1iZWQoYXBpQ2xpZW50LCBmcm9tQ29udGVudHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbXScsICdjb250ZW50J10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGVtYmVkQ29udGVudENvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZW1iZWRDb250ZW50UmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbWJlZGRpbmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbWJlZGRpbmdzJ10pO1xuICAgIGlmIChmcm9tRW1iZWRkaW5ncyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRW1iZWRkaW5ncztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW1iZWRkaW5ncyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJ10pO1xuICAgIGlmIChmcm9tTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZXRhZGF0YSddLCBmcm9tTWV0YWRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbWJlZENvbnRlbnRSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbWJlZGRpbmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlZGljdGlvbnNbXScsXG4gICAgICAgICdlbWJlZGRpbmdzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUVtYmVkZGluZ3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUVtYmVkZGluZ3M7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudEVtYmVkZGluZ0Zyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbWJlZGRpbmdzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0YWRhdGEnXSk7XG4gICAgaWYgKGZyb21NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21ldGFkYXRhJ10sIGZyb21NZXRhZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVuZHBvaW50RnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kcG9pbnQnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXBsb3llZE1vZGVsSWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkZXBsb3llZE1vZGVsSWQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRGVwbG95ZWRNb2RlbElkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVwbG95ZWRNb2RlbElkJ10sIGZyb21EZXBsb3llZE1vZGVsSWQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmaWxlRGF0YVRvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGlzcGxheU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVVcmknXSk7XG4gICAgaWYgKGZyb21GaWxlVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZVVyaSddLCBmcm9tRmlsZVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbFRvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lkJ10pO1xuICAgIGlmIChmcm9tSWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpZCddLCBmcm9tSWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXJncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXJncyddKTtcbiAgICBpZiAoZnJvbUFyZ3MgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhcmdzJ10sIGZyb21BcmdzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRpYWxBcmdzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXJ0aWFsQXJncyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd3aWxsQ29udGludWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dpbGxDb250aW51ZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkNhbGxpbmdDb25maWdUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlJ10pO1xuICAgIGlmIChmcm9tTW9kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGUnXSwgZnJvbU1vZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhbGxvd2VkRnVuY3Rpb25OYW1lcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BbGxvd2VkRnVuY3Rpb25OYW1lcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FsbG93ZWRGdW5jdGlvbk5hbWVzJ10sIGZyb21BbGxvd2VkRnVuY3Rpb25OYW1lcyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0cmVhbUZ1bmN0aW9uQ2FsbEFyZ3VtZW50cyddKSAhPT1cbiAgICAgICAgdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3RyZWFtRnVuY3Rpb25DYWxsQXJndW1lbnRzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uRGVjbGFyYXRpb25Ub1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiZWhhdmlvciddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmVoYXZpb3IgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmFtZXRlcnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcmFtZXRlcnMnXSk7XG4gICAgaWYgKGZyb21QYXJhbWV0ZXJzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFyYW1ldGVycyddLCBmcm9tUGFyYW1ldGVycyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BhcmFtZXRlcnNKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFyYW1ldGVyc0pzb25TY2hlbWEnXSwgZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZSddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2UnXSwgZnJvbVJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUpzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUpzb25TY2hlbWEnXSwgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlQ29udGVudENvbmZpZ1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TeXN0ZW1JbnN0cnVjdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVN5c3RlbUluc3RydWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N5c3RlbUluc3RydWN0aW9uJ10sIGNvbnRlbnRUb01sZGV2JDEodENvbnRlbnQoZnJvbVN5c3RlbUluc3RydWN0aW9uKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGVtcGVyYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10pO1xuICAgIGlmIChmcm9tVGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZW1wZXJhdHVyZSddLCBmcm9tVGVtcGVyYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wUCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wUCddKTtcbiAgICBpZiAoZnJvbVRvcFAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3BQJ10sIGZyb21Ub3BQKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcEsgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcEsnXSk7XG4gICAgaWYgKGZyb21Ub3BLICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9wSyddLCBmcm9tVG9wSyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYW5kaWRhdGVDb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhbmRpZGF0ZUNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNhbmRpZGF0ZUNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FuZGlkYXRlQ291bnQnXSwgZnJvbUNhbmRpZGF0ZUNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heE91dHB1dFRva2VucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21heE91dHB1dFRva2VucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NYXhPdXRwdXRUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXhPdXRwdXRUb2tlbnMnXSwgZnJvbU1heE91dHB1dFRva2Vucyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdG9wU2VxdWVuY2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3RvcFNlcXVlbmNlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TdG9wU2VxdWVuY2VzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RvcFNlcXVlbmNlcyddLCBmcm9tU3RvcFNlcXVlbmNlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUxvZ3Byb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VMb2dwcm9icycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUxvZ3Byb2JzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VMb2dwcm9icyddLCBmcm9tUmVzcG9uc2VMb2dwcm9icyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Mb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbG9ncHJvYnMnXSk7XG4gICAgaWYgKGZyb21Mb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xvZ3Byb2JzJ10sIGZyb21Mb2dwcm9icyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QcmVzZW5jZVBlbmFsdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVzZW5jZVBlbmFsdHknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlc2VuY2VQZW5hbHR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJlc2VuY2VQZW5hbHR5J10sIGZyb21QcmVzZW5jZVBlbmFsdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnJlcXVlbmN5UGVuYWx0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2ZyZXF1ZW5jeVBlbmFsdHknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnJlcXVlbmN5UGVuYWx0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZyZXF1ZW5jeVBlbmFsdHknXSwgZnJvbUZyZXF1ZW5jeVBlbmFsdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKTtcbiAgICBpZiAoZnJvbVNlZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZWVkJ10sIGZyb21TZWVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZU1pbWVUeXBlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZU1pbWVUeXBlJ10sIGZyb21SZXNwb25zZU1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VTY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VTY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZVNjaGVtYSddLCB0U2NoZW1hKGZyb21SZXNwb25zZVNjaGVtYSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSnNvblNjaGVtYSddLCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm91dGluZ0NvbmZpZyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncm91dGluZ0NvbmZpZyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbFNlbGVjdGlvbkNvbmZpZyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbW9kZWxTZWxlY3Rpb25Db25maWcgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNhZmV0eVNldHRpbmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5U2V0dGluZ3MnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2FmZXR5U2V0dGluZ3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVNhZmV0eVNldHRpbmdzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNhZmV0eVNldHRpbmdUb01sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NhZmV0eVNldHRpbmdzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29scyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29scyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0VG9vbHMoZnJvbVRvb2xzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b29sVG9NbGRldiQxKHRUb29sKGl0ZW0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29scyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbENvbmZpZyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndG9vbENvbmZpZyddLCB0b29sQ29uZmlnVG9NbGRldihmcm9tVG9vbENvbmZpZykpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbHMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xhYmVscyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FjaGVkQ29udGVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhY2hlZENvbnRlbnQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ2FjaGVkQ29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydjYWNoZWRDb250ZW50J10sIHRDYWNoZWRDb250ZW50TmFtZShhcGlDbGllbnQsIGZyb21DYWNoZWRDb250ZW50KSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1vZGFsaXRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZU1vZGFsaXRpZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VNb2RhbGl0aWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VNb2RhbGl0aWVzJ10sIGZyb21SZXNwb25zZU1vZGFsaXRpZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWVkaWFSZXNvbHV0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWVkaWFSZXNvbHV0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1lZGlhUmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21lZGlhUmVzb2x1dGlvbiddLCBmcm9tTWVkaWFSZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNwZWVjaENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3BlZWNoQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tU3BlZWNoQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3BlZWNoQ29uZmlnJ10sIHRTcGVlY2hDb25maWcoZnJvbVNwZWVjaENvbmZpZykpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdWRpb1RpbWVzdGFtcCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXVkaW9UaW1lc3RhbXAgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRoaW5raW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhpbmtpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhpbmtpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aGlua2luZ0NvbmZpZyddLCBmcm9tVGhpbmtpbmdDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tSW1hZ2VDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbWFnZUNvbmZpZyddLCBpbWFnZUNvbmZpZ1RvTWxkZXYoZnJvbUltYWdlQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlQ29udGVudENvbmZpZ1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TeXN0ZW1JbnN0cnVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzeXN0ZW1JbnN0cnVjdGlvbiddLCB0Q29udGVudChmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRlbXBlcmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZW1wZXJhdHVyZSddKTtcbiAgICBpZiAoZnJvbVRlbXBlcmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGVtcGVyYXR1cmUnXSwgZnJvbVRlbXBlcmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcFAgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcFAnXSk7XG4gICAgaWYgKGZyb21Ub3BQICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9wUCddLCBmcm9tVG9wUCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BLID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BLJ10pO1xuICAgIGlmIChmcm9tVG9wSyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvcEsnXSwgZnJvbVRvcEspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FuZGlkYXRlQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYW5kaWRhdGVDb3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYW5kaWRhdGVDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhbmRpZGF0ZUNvdW50J10sIGZyb21DYW5kaWRhdGVDb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhPdXRwdXRUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXhPdXRwdXRUb2tlbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWF4T3V0cHV0VG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWF4T3V0cHV0VG9rZW5zJ10sIGZyb21NYXhPdXRwdXRUb2tlbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RvcFNlcXVlbmNlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N0b3BTZXF1ZW5jZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3RvcFNlcXVlbmNlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0b3BTZXF1ZW5jZXMnXSwgZnJvbVN0b3BTZXF1ZW5jZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VMb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTG9ncHJvYnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VMb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTG9ncHJvYnMnXSwgZnJvbVJlc3BvbnNlTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTG9ncHJvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xvZ3Byb2JzJ10pO1xuICAgIGlmIChmcm9tTG9ncHJvYnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsb2dwcm9icyddLCBmcm9tTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJlc2VuY2VQZW5hbHR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlc2VuY2VQZW5hbHR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByZXNlbmNlUGVuYWx0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZXNlbmNlUGVuYWx0eSddLCBmcm9tUHJlc2VuY2VQZW5hbHR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZyZXF1ZW5jeVBlbmFsdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmcmVxdWVuY3lQZW5hbHR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZyZXF1ZW5jeVBlbmFsdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmcmVxdWVuY3lQZW5hbHR5J10sIGZyb21GcmVxdWVuY3lQZW5hbHR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VNaW1lVHlwZSddLCBmcm9tUmVzcG9uc2VNaW1lVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZVNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VTY2hlbWEnXSwgdFNjaGVtYShmcm9tUmVzcG9uc2VTY2hlbWEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUpzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUpzb25TY2hlbWEnXSwgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Sb3V0aW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncm91dGluZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Sb3V0aW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncm91dGluZ0NvbmZpZyddLCBmcm9tUm91dGluZ0NvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Nb2RlbFNlbGVjdGlvbkNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21vZGVsU2VsZWN0aW9uQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1vZGVsU2VsZWN0aW9uQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWxDb25maWcnXSwgZnJvbU1vZGVsU2VsZWN0aW9uQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNhZmV0eVNldHRpbmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5U2V0dGluZ3MnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2FmZXR5U2V0dGluZ3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVNhZmV0eVNldHRpbmdzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2FmZXR5U2V0dGluZ3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29scyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRUb29scyhmcm9tVG9vbHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvb2xUb1ZlcnRleCh0VG9vbChpdGVtKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndG9vbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xDb25maWcnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29sQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3Rvb2xDb25maWcnXSwgZnJvbVRvb2xDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFiZWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MYWJlbHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnbGFiZWxzJ10sIGZyb21MYWJlbHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FjaGVkQ29udGVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhY2hlZENvbnRlbnQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ2FjaGVkQ29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydjYWNoZWRDb250ZW50J10sIHRDYWNoZWRDb250ZW50TmFtZShhcGlDbGllbnQsIGZyb21DYWNoZWRDb250ZW50KSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1vZGFsaXRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZU1vZGFsaXRpZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VNb2RhbGl0aWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VNb2RhbGl0aWVzJ10sIGZyb21SZXNwb25zZU1vZGFsaXRpZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWVkaWFSZXNvbHV0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWVkaWFSZXNvbHV0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1lZGlhUmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21lZGlhUmVzb2x1dGlvbiddLCBmcm9tTWVkaWFSZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNwZWVjaENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3BlZWNoQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tU3BlZWNoQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3BlZWNoQ29uZmlnJ10sIHNwZWVjaENvbmZpZ1RvVmVydGV4KHRTcGVlY2hDb25maWcoZnJvbVNwZWVjaENvbmZpZykpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF1ZGlvVGltZXN0YW1wID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYXVkaW9UaW1lc3RhbXAnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQXVkaW9UaW1lc3RhbXAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdWRpb1RpbWVzdGFtcCddLCBmcm9tQXVkaW9UaW1lc3RhbXApO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhpbmtpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aGlua2luZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaGlua2luZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RoaW5raW5nQ29uZmlnJ10sIGZyb21UaGlua2luZ0NvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2VDb25maWcnXSk7XG4gICAgaWYgKGZyb21JbWFnZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ltYWdlQ29uZmlnJ10sIGltYWdlQ29uZmlnVG9WZXJ0ZXgoZnJvbUltYWdlQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50cyddKTtcbiAgICBpZiAoZnJvbUNvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRDb250ZW50cyhmcm9tQ29udGVudHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRUb01sZGV2JDEoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb250ZW50cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0aW9uQ29uZmlnJ10sIGdlbmVyYXRlQ29udGVudENvbmZpZ1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tQ29uZmlnLCB0b09iamVjdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUNvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdENvbnRlbnRzKGZyb21Db250ZW50cyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRlbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRpb25Db25maWcnXSwgZ2VuZXJhdGVDb250ZW50Q29uZmlnVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tQ29uZmlnLCB0b09iamVjdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUNvbnRlbnRSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhbmRpZGF0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NhbmRpZGF0ZXMnXSk7XG4gICAgaWYgKGZyb21DYW5kaWRhdGVzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21DYW5kaWRhdGVzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZUZyb21NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhbmRpZGF0ZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1vZGVsVmVyc2lvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWxWZXJzaW9uJ10pO1xuICAgIGlmIChmcm9tTW9kZWxWZXJzaW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWxWZXJzaW9uJ10sIGZyb21Nb2RlbFZlcnNpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvbXB0RmVlZGJhY2sgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcm9tcHRGZWVkYmFjaycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Qcm9tcHRGZWVkYmFjayAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Byb21wdEZlZWRiYWNrJ10sIGZyb21Qcm9tcHRGZWVkYmFjayk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUlkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZUlkJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VJZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSWQnXSwgZnJvbVJlc3BvbnNlSWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXNhZ2VNZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3VzYWdlTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVXNhZ2VNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VzYWdlTWV0YWRhdGEnXSwgZnJvbVVzYWdlTWV0YWRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUNvbnRlbnRSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYW5kaWRhdGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjYW5kaWRhdGVzJ10pO1xuICAgIGlmIChmcm9tQ2FuZGlkYXRlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQ2FuZGlkYXRlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FuZGlkYXRlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ3JlYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY3JlYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbUNyZWF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjcmVhdGVUaW1lJ10sIGZyb21DcmVhdGVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1vZGVsVmVyc2lvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWxWZXJzaW9uJ10pO1xuICAgIGlmIChmcm9tTW9kZWxWZXJzaW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWxWZXJzaW9uJ10sIGZyb21Nb2RlbFZlcnNpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvbXB0RmVlZGJhY2sgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcm9tcHRGZWVkYmFjaycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Qcm9tcHRGZWVkYmFjayAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Byb21wdEZlZWRiYWNrJ10sIGZyb21Qcm9tcHRGZWVkYmFjayk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUlkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZUlkJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VJZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSWQnXSwgZnJvbVJlc3BvbnNlSWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXNhZ2VNZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3VzYWdlTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVXNhZ2VNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VzYWdlTWV0YWRhdGEnXSwgZnJvbVVzYWdlTWV0YWRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUltYWdlc0NvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRHY3NVcmknXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dHB1dEdjc1VyaSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduZWdhdGl2ZVByb21wdCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbmVnYXRpdmVQcm9tcHQgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU51bWJlck9mSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbnVtYmVyT2ZJbWFnZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTnVtYmVyT2ZJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzYW1wbGVDb3VudCddLCBmcm9tTnVtYmVyT2ZJbWFnZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXNwZWN0UmF0aW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FzcGVjdFJhdGlvJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQXNwZWN0UmF0aW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdhc3BlY3RSYXRpbyddLCBmcm9tQXNwZWN0UmF0aW8pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR3VpZGFuY2VTY2FsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2d1aWRhbmNlU2NhbGUnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tR3VpZGFuY2VTY2FsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2d1aWRhbmNlU2NhbGUnXSwgZnJvbUd1aWRhbmNlU2NhbGUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZWVkIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlGaWx0ZXJMZXZlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eUZpbHRlckxldmVsJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNhZmV0eUZpbHRlckxldmVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FmZXR5U2V0dGluZyddLCBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGVyc29uR2VuZXJhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BlcnNvbkdlbmVyYXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGVyc29uR2VuZXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3BlcnNvbkdlbmVyYXRpb24nXSwgZnJvbVBlcnNvbkdlbmVyYXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbmNsdWRlU2FmZXR5QXR0cmlidXRlcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbmNsdWRlU2FmZXR5QXR0cmlidXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2luY2x1ZGVTYWZldHlBdHRyaWJ1dGVzJ10sIGZyb21JbmNsdWRlU2FmZXR5QXR0cmlidXRlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmNsdWRlUmFpUmVhc29uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5jbHVkZVJhaVJlYXNvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbmNsdWRlUmFpUmVhc29uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnaW5jbHVkZVJhaVJlYXNvbiddLCBmcm9tSW5jbHVkZVJhaVJlYXNvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYW5ndWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFuZ3VhZ2UnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MYW5ndWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2xhbmd1YWdlJ10sIGZyb21MYW5ndWFnZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRNaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dE1pbWVUeXBlJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dE1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnb3V0cHV0T3B0aW9ucycsICdtaW1lVHlwZSddLCBmcm9tT3V0cHV0TWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dE9wdGlvbnMnLCAnY29tcHJlc3Npb25RdWFsaXR5J10sIGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhZGRXYXRlcm1hcmsnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FkZFdhdGVybWFyayBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbHMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xhYmVscyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbWFnZVNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzYW1wbGVJbWFnZVNpemUnXSwgZnJvbUltYWdlU2l6ZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuaGFuY2VQcm9tcHQnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuaGFuY2VQcm9tcHQgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVJbWFnZXNDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21PdXRwdXRHY3NVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ291dHB1dEdjc1VyaSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dEdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3N0b3JhZ2VVcmknXSwgZnJvbU91dHB1dEdjc1VyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZWdhdGl2ZVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25lZ2F0aXZlUHJvbXB0JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU5lZ2F0aXZlUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnbmVnYXRpdmVQcm9tcHQnXSwgZnJvbU5lZ2F0aXZlUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU51bWJlck9mSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbnVtYmVyT2ZJbWFnZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTnVtYmVyT2ZJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzYW1wbGVDb3VudCddLCBmcm9tTnVtYmVyT2ZJbWFnZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXNwZWN0UmF0aW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FzcGVjdFJhdGlvJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQXNwZWN0UmF0aW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdhc3BlY3RSYXRpbyddLCBmcm9tQXNwZWN0UmF0aW8pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR3VpZGFuY2VTY2FsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2d1aWRhbmNlU2NhbGUnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tR3VpZGFuY2VTY2FsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2d1aWRhbmNlU2NhbGUnXSwgZnJvbUd1aWRhbmNlU2NhbGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNlZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzZWVkJ10sIGZyb21TZWVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNhZmV0eUZpbHRlckxldmVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5RmlsdGVyTGV2ZWwnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzYWZldHlTZXR0aW5nJ10sIGZyb21TYWZldHlGaWx0ZXJMZXZlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QZXJzb25HZW5lcmF0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGVyc29uR2VuZXJhdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QZXJzb25HZW5lcmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAncGVyc29uR2VuZXJhdGlvbiddLCBmcm9tUGVyc29uR2VuZXJhdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmNsdWRlU2FmZXR5QXR0cmlidXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2luY2x1ZGVTYWZldHlBdHRyaWJ1dGVzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUluY2x1ZGVTYWZldHlBdHRyaWJ1dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnaW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMnXSwgZnJvbUluY2x1ZGVTYWZldHlBdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUluY2x1ZGVSYWlSZWFzb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbmNsdWRlUmFpUmVhc29uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUluY2x1ZGVSYWlSZWFzb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdpbmNsdWRlUmFpUmVhc29uJ10sIGZyb21JbmNsdWRlUmFpUmVhc29uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhbmd1YWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYW5ndWFnZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUxhbmd1YWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnbGFuZ3VhZ2UnXSwgZnJvbUxhbmd1YWdlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dE1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0TWltZVR5cGUnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0TWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdvdXRwdXRPcHRpb25zJywgJ21pbWVUeXBlJ10sIGZyb21PdXRwdXRNaW1lVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRDb21wcmVzc2lvblF1YWxpdHknLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnb3V0cHV0T3B0aW9ucycsICdjb21wcmVzc2lvblF1YWxpdHknXSwgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BZGRXYXRlcm1hcmsgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FkZFdhdGVybWFyayddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUFkZFdhdGVybWFyayAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2FkZFdhdGVybWFyayddLCBmcm9tQWRkV2F0ZXJtYXJrKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhYmVscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGFiZWxzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2xhYmVscyddLCBmcm9tTGFiZWxzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2VTaXplJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW1hZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FtcGxlSW1hZ2VTaXplJ10sIGZyb21JbWFnZVNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5oYW5jZVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VuaGFuY2VQcm9tcHQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRW5oYW5jZVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2VuaGFuY2VQcm9tcHQnXSwgZnJvbUVuaGFuY2VQcm9tcHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUltYWdlc1BhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvbXB0J10pO1xuICAgIGlmIChmcm9tUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3Byb21wdCddLCBmcm9tUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgZ2VuZXJhdGVJbWFnZXNDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVJbWFnZXNQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9tcHQnXSk7XG4gICAgaWYgKGZyb21Qcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncHJvbXB0J10sIGZyb21Qcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBnZW5lcmF0ZUltYWdlc0NvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVJbWFnZXNSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdlbmVyYXRlZEltYWdlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZWRpY3Rpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdlbmVyYXRlZEltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tR2VuZXJhdGVkSW1hZ2VzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlZEltYWdlRnJvbU1sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGVkSW1hZ2VzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzJ10sIHNhZmV0eUF0dHJpYnV0ZXNGcm9tTWxkZXYoZnJvbVBvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUltYWdlc1Jlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdlbmVyYXRlZEltYWdlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZWRpY3Rpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdlbmVyYXRlZEltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tR2VuZXJhdGVkSW1hZ2VzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlZEltYWdlRnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRlZEltYWdlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVBvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Bvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcyddLCBzYWZldHlBdHRyaWJ1dGVzRnJvbVZlcnRleChmcm9tUG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OdW1iZXJPZlZpZGVvcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ251bWJlck9mVmlkZW9zJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU51bWJlck9mVmlkZW9zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FtcGxlQ291bnQnXSwgZnJvbU51bWJlck9mVmlkZW9zKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0R2NzVXJpJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvdXRwdXRHY3NVcmkgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnBzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmcHMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUR1cmF0aW9uU2Vjb25kcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2R1cmF0aW9uU2Vjb25kcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EdXJhdGlvblNlY29uZHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdkdXJhdGlvblNlY29uZHMnXSwgZnJvbUR1cmF0aW9uU2Vjb25kcyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlZWQgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFzcGVjdFJhdGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhc3BlY3RSYXRpbyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUFzcGVjdFJhdGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnYXNwZWN0UmF0aW8nXSwgZnJvbUFzcGVjdFJhdGlvKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc29sdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc29sdXRpb24nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21SZXNvbHV0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAncmVzb2x1dGlvbiddLCBmcm9tUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QZXJzb25HZW5lcmF0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGVyc29uR2VuZXJhdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QZXJzb25HZW5lcmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAncGVyc29uR2VuZXJhdGlvbiddLCBmcm9tUGVyc29uR2VuZXJhdGlvbik7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3B1YnN1YlRvcGljJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwdWJzdWJUb3BpYyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmVnYXRpdmVQcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZWdhdGl2ZVByb21wdCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OZWdhdGl2ZVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ25lZ2F0aXZlUHJvbXB0J10sIGZyb21OZWdhdGl2ZVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmhhbmNlUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW5oYW5jZVByb21wdCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FbmhhbmNlUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZW5oYW5jZVByb21wdCddLCBmcm9tRW5oYW5jZVByb21wdCk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dlbmVyYXRlQXVkaW8nXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dlbmVyYXRlQXVkaW8gcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhc3RGcmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFzdEZyYW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGFzdEZyYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdsYXN0RnJhbWUnXSwgaW1hZ2VUb01sZGV2KGZyb21MYXN0RnJhbWUpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlZmVyZW5jZUltYWdlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JlZmVyZW5jZUltYWdlcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21SZWZlcmVuY2VJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVJlZmVyZW5jZUltYWdlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aWRlb0dlbmVyYXRpb25SZWZlcmVuY2VJbWFnZVRvTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3JlZmVyZW5jZUltYWdlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtYXNrJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXNrIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbXByZXNzaW9uUXVhbGl0eSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY29tcHJlc3Npb25RdWFsaXR5IHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTnVtYmVyT2ZWaWRlb3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdudW1iZXJPZlZpZGVvcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OdW1iZXJPZlZpZGVvcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhbXBsZUNvdW50J10sIGZyb21OdW1iZXJPZlZpZGVvcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRHY3NVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ291dHB1dEdjc1VyaSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dEdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3N0b3JhZ2VVcmknXSwgZnJvbU91dHB1dEdjc1VyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZwcyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUZwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2ZwcyddLCBmcm9tRnBzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUR1cmF0aW9uU2Vjb25kcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2R1cmF0aW9uU2Vjb25kcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EdXJhdGlvblNlY29uZHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdkdXJhdGlvblNlY29uZHMnXSwgZnJvbUR1cmF0aW9uU2Vjb25kcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2VlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NlZWQnXSwgZnJvbVNlZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXNwZWN0UmF0aW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FzcGVjdFJhdGlvJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQXNwZWN0UmF0aW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdhc3BlY3RSYXRpbyddLCBmcm9tQXNwZWN0UmF0aW8pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzb2x1dGlvbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdyZXNvbHV0aW9uJ10sIGZyb21SZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBlcnNvbkdlbmVyYXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwZXJzb25HZW5lcmF0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBlcnNvbkdlbmVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdwZXJzb25HZW5lcmF0aW9uJ10sIGZyb21QZXJzb25HZW5lcmF0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVB1YnN1YlRvcGljID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwdWJzdWJUb3BpYyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVB1YnN1YlRvcGljICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAncHVic3ViVG9waWMnXSwgZnJvbVB1YnN1YlRvcGljKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5lZ2F0aXZlUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmVnYXRpdmVQcm9tcHQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTmVnYXRpdmVQcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICduZWdhdGl2ZVByb21wdCddLCBmcm9tTmVnYXRpdmVQcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5oYW5jZVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VuaGFuY2VQcm9tcHQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRW5oYW5jZVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2VuaGFuY2VQcm9tcHQnXSwgZnJvbUVuaGFuY2VQcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR2VuZXJhdGVBdWRpbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dlbmVyYXRlQXVkaW8nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tR2VuZXJhdGVBdWRpbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2dlbmVyYXRlQXVkaW8nXSwgZnJvbUdlbmVyYXRlQXVkaW8pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFzdEZyYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYXN0RnJhbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MYXN0RnJhbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ2xhc3RGcmFtZSddLCBpbWFnZVRvVmVydGV4KGZyb21MYXN0RnJhbWUpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlZmVyZW5jZUltYWdlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JlZmVyZW5jZUltYWdlcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21SZWZlcmVuY2VJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVJlZmVyZW5jZUltYWdlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aWRlb0dlbmVyYXRpb25SZWZlcmVuY2VJbWFnZVRvVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdyZWZlcmVuY2VJbWFnZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1hc2sgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21hc2snXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21NYXNrICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdtYXNrJ10sIHZpZGVvR2VuZXJhdGlvbk1hc2tUb1ZlcnRleChmcm9tTWFzaykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29tcHJlc3Npb25RdWFsaXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29tcHJlc3Npb25RdWFsaXR5JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUNvbXByZXNzaW9uUXVhbGl0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2NvbXByZXNzaW9uUXVhbGl0eSddLCBmcm9tQ29tcHJlc3Npb25RdWFsaXR5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVWaWRlb3NPcGVyYXRpb25Gcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0YWRhdGEnXSk7XG4gICAgaWYgKGZyb21NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21ldGFkYXRhJ10sIGZyb21NZXRhZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Eb25lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkb25lJ10pO1xuICAgIGlmIChmcm9tRG9uZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RvbmUnXSwgZnJvbURvbmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXJyb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vycm9yJ10pO1xuICAgIGlmIChmcm9tRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlcnJvciddLCBmcm9tRXJyb3IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZScsXG4gICAgICAgICdnZW5lcmF0ZVZpZGVvUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCBnZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlRnJvbU1sZGV2KGZyb21SZXNwb25zZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc09wZXJhdGlvbkZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0YWRhdGEnXSk7XG4gICAgaWYgKGZyb21NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21ldGFkYXRhJ10sIGZyb21NZXRhZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Eb25lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkb25lJ10pO1xuICAgIGlmIChmcm9tRG9uZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RvbmUnXSwgZnJvbURvbmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXJyb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vycm9yJ10pO1xuICAgIGlmIChmcm9tRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlcnJvciddLCBmcm9tRXJyb3IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCBnZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlRnJvbVZlcnRleChmcm9tUmVzcG9uc2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVWaWRlb3NQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb21wdCddKTtcbiAgICBpZiAoZnJvbVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdwcm9tcHQnXSwgZnJvbVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2UnXSk7XG4gICAgaWYgKGZyb21JbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdpbWFnZSddLCBpbWFnZVRvTWxkZXYoZnJvbUltYWdlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmlkZW8nXSk7XG4gICAgaWYgKGZyb21WaWRlbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICd2aWRlbyddLCB2aWRlb1RvTWxkZXYoZnJvbVZpZGVvKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Tb3VyY2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NvdXJjZSddKTtcbiAgICBpZiAoZnJvbVNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgIGdlbmVyYXRlVmlkZW9zU291cmNlVG9NbGRldihmcm9tU291cmNlLCB0b09iamVjdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGdlbmVyYXRlVmlkZW9zQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvbXB0J10pO1xuICAgIGlmIChmcm9tUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3Byb21wdCddLCBmcm9tUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZSddKTtcbiAgICBpZiAoZnJvbUltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ2ltYWdlJ10sIGltYWdlVG9WZXJ0ZXgoZnJvbUltYWdlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmlkZW8nXSk7XG4gICAgaWYgKGZyb21WaWRlbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICd2aWRlbyddLCB2aWRlb1RvVmVydGV4KGZyb21WaWRlbykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU291cmNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzb3VyY2UnXSk7XG4gICAgaWYgKGZyb21Tb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICBnZW5lcmF0ZVZpZGVvc1NvdXJjZVRvVmVydGV4KGZyb21Tb3VyY2UsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgZ2VuZXJhdGVWaWRlb3NDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUdlbmVyYXRlZFZpZGVvcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dlbmVyYXRlZFNhbXBsZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR2VuZXJhdGVkVmlkZW9zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21HZW5lcmF0ZWRWaWRlb3M7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVkVmlkZW9Gcm9tTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0ZWRWaWRlb3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JhaU1lZGlhRmlsdGVyZWRDb3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyYWlNZWRpYUZpbHRlcmVkQ291bnQnXSwgZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JhaU1lZGlhRmlsdGVyZWRSZWFzb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMnXSwgZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVWaWRlb3NSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUdlbmVyYXRlZFZpZGVvcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmlkZW9zJ10pO1xuICAgIGlmIChmcm9tR2VuZXJhdGVkVmlkZW9zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21HZW5lcmF0ZWRWaWRlb3M7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVkVmlkZW9Gcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGVkVmlkZW9zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyYWlNZWRpYUZpbHRlcmVkQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmFpTWVkaWFGaWx0ZXJlZENvdW50J10sIGZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyYWlNZWRpYUZpbHRlcmVkUmVhc29ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JhaU1lZGlhRmlsdGVyZWRSZWFzb25zJ10sIGZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zU291cmNlVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Qcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb21wdCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncHJvbXB0J10sIGZyb21Qcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ2ltYWdlJ10sIGltYWdlVG9NbGRldihmcm9tSW1hZ2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2aWRlbyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVZpZGVvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICd2aWRlbyddLCB2aWRlb1RvTWxkZXYoZnJvbVZpZGVvKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zU291cmNlVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9tcHQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Qcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3Byb21wdCddLCBmcm9tUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdpbWFnZSddLCBpbWFnZVRvVmVydGV4KGZyb21JbWFnZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVmlkZW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3ZpZGVvJ10sIHZpZGVvVG9WZXJ0ZXgoZnJvbVZpZGVvKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlZEltYWdlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21JbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ltYWdlJ10sIGltYWdlRnJvbU1sZGV2KGZyb21JbWFnZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmFpRmlsdGVyZWRSZWFzb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyYWlGaWx0ZXJlZFJlYXNvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SYWlGaWx0ZXJlZFJlYXNvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JhaUZpbHRlcmVkUmVhc29uJ10sIGZyb21SYWlGaWx0ZXJlZFJlYXNvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlBdHRyaWJ1dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydfc2VsZiddKTtcbiAgICBpZiAoZnJvbVNhZmV0eUF0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzYWZldHlBdHRyaWJ1dGVzJ10sIHNhZmV0eUF0dHJpYnV0ZXNGcm9tTWxkZXYoZnJvbVNhZmV0eUF0dHJpYnV0ZXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVkSW1hZ2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21JbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ltYWdlJ10sIGltYWdlRnJvbVZlcnRleChmcm9tSW1hZ2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJhaUZpbHRlcmVkUmVhc29uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmFpRmlsdGVyZWRSZWFzb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmFpRmlsdGVyZWRSZWFzb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyYWlGaWx0ZXJlZFJlYXNvbiddLCBmcm9tUmFpRmlsdGVyZWRSZWFzb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5QXR0cmlidXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21TYWZldHlBdHRyaWJ1dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2FmZXR5QXR0cmlidXRlcyddLCBzYWZldHlBdHRyaWJ1dGVzRnJvbVZlcnRleChmcm9tU2FmZXR5QXR0cmlidXRlcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5oYW5jZWRQcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb21wdCddKTtcbiAgICBpZiAoZnJvbUVuaGFuY2VkUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5oYW5jZWRQcm9tcHQnXSwgZnJvbUVuaGFuY2VkUHJvbXB0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVkSW1hZ2VNYXNrRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTWFzayA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21NYXNrICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWFzayddLCBpbWFnZUZyb21WZXJ0ZXgoZnJvbU1hc2spKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhYmVscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pO1xuICAgIGlmIChmcm9tTGFiZWxzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21MYWJlbHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhYmVscyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZWRWaWRlb0Zyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmlkZW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvJ10pO1xuICAgIGlmIChmcm9tVmlkZW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlbyddLCB2aWRlb0Zyb21NbGRldihmcm9tVmlkZW8pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVkVmlkZW9Gcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21WaWRlbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21WaWRlbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvJ10sIHZpZGVvRnJvbVZlcnRleChmcm9tVmlkZW8pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGlvbkNvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbFNlbGVjdGlvbkNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21vZGVsU2VsZWN0aW9uQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1vZGVsU2VsZWN0aW9uQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWxDb25maWcnXSwgZnJvbU1vZGVsU2VsZWN0aW9uQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUpzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUpzb25TY2hlbWEnXSwgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BdWRpb1RpbWVzdGFtcCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2F1ZGlvVGltZXN0YW1wJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUF1ZGlvVGltZXN0YW1wICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXVkaW9UaW1lc3RhbXAnXSwgZnJvbUF1ZGlvVGltZXN0YW1wKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhbmRpZGF0ZUNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FuZGlkYXRlQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2FuZGlkYXRlQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYW5kaWRhdGVDb3VudCddLCBmcm9tQ2FuZGlkYXRlQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5hYmxlQWZmZWN0aXZlRGlhbG9nID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW5hYmxlQWZmZWN0aXZlRGlhbG9nJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuYWJsZUFmZmVjdGl2ZURpYWxvZyddLCBmcm9tRW5hYmxlQWZmZWN0aXZlRGlhbG9nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZyZXF1ZW5jeVBlbmFsdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmcmVxdWVuY3lQZW5hbHR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZyZXF1ZW5jeVBlbmFsdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmcmVxdWVuY3lQZW5hbHR5J10sIGZyb21GcmVxdWVuY3lQZW5hbHR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxvZ3Byb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsb2dwcm9icyddKTtcbiAgICBpZiAoZnJvbUxvZ3Byb2JzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbG9ncHJvYnMnXSwgZnJvbUxvZ3Byb2JzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heE91dHB1dFRva2VucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21heE91dHB1dFRva2VucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NYXhPdXRwdXRUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXhPdXRwdXRUb2tlbnMnXSwgZnJvbU1heE91dHB1dFRva2Vucyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZWRpYVJlc29sdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtZWRpYVJlc29sdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWVkaWFSZXNvbHV0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWVkaWFSZXNvbHV0aW9uJ10sIGZyb21NZWRpYVJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJlc2VuY2VQZW5hbHR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlc2VuY2VQZW5hbHR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByZXNlbmNlUGVuYWx0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZXNlbmNlUGVuYWx0eSddLCBmcm9tUHJlc2VuY2VQZW5hbHR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTG9ncHJvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZUxvZ3Byb2JzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTG9ncHJvYnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUxvZ3Byb2JzJ10sIGZyb21SZXNwb25zZUxvZ3Byb2JzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZU1pbWVUeXBlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZU1pbWVUeXBlJ10sIGZyb21SZXNwb25zZU1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTW9kYWxpdGllcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZU1vZGFsaXRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZU1vZGFsaXRpZXMnXSwgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZVNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VTY2hlbWEnXSwgZnJvbVJlc3BvbnNlU2NoZW1hKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJvdXRpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyb3V0aW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJvdXRpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb3V0aW5nQ29uZmlnJ10sIGZyb21Sb3V0aW5nQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcGVlY2hDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddKTtcbiAgICBpZiAoZnJvbVNwZWVjaENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddLCBzcGVlY2hDb25maWdUb1ZlcnRleChmcm9tU3BlZWNoQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdG9wU2VxdWVuY2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3RvcFNlcXVlbmNlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TdG9wU2VxdWVuY2VzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RvcFNlcXVlbmNlcyddLCBmcm9tU3RvcFNlcXVlbmNlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZW1wZXJhdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGVtcGVyYXR1cmUnXSk7XG4gICAgaWYgKGZyb21UZW1wZXJhdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10sIGZyb21UZW1wZXJhdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaGlua2luZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RoaW5raW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRoaW5raW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhpbmtpbmdDb25maWcnXSwgZnJvbVRoaW5raW5nQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcEsgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcEsnXSk7XG4gICAgaWYgKGZyb21Ub3BLICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9wSyddLCBmcm9tVG9wSyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BQID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BQJ10pO1xuICAgIGlmIChmcm9tVG9wUCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvcFAnXSwgZnJvbVRvcFApO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmFibGVFbmhhbmNlZENpdmljQW5zd2VycyddKSAhPT1cbiAgICAgICAgdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZW5hYmxlRW5oYW5jZWRDaXZpY0Fuc3dlcnMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZXRNb2RlbFBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZXRNb2RlbFBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlTWFwc1RvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdXRoQ29uZmlnJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdXRoQ29uZmlnIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmFibGVXaWRnZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuYWJsZVdpZGdldCddKTtcbiAgICBpZiAoZnJvbUVuYWJsZVdpZGdldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuYWJsZVdpZGdldCddLCBmcm9tRW5hYmxlV2lkZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlU2VhcmNoVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4Y2x1ZGVEb21haW5zJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleGNsdWRlRG9tYWlucyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydibG9ja2luZ0NvbmZpZGVuY2UnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Jsb2NraW5nQ29uZmlkZW5jZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGltZVJhbmdlRmlsdGVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGltZVJhbmdlRmlsdGVyJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRpbWVSYW5nZUZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RpbWVSYW5nZUZpbHRlciddLCBmcm9tVGltZVJhbmdlRmlsdGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW1hZ2VDb25maWdUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Bc3BlY3RSYXRpbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXNwZWN0UmF0aW8nXSk7XG4gICAgaWYgKGZyb21Bc3BlY3RSYXRpbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FzcGVjdFJhdGlvJ10sIGZyb21Bc3BlY3RSYXRpbyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZVNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlU2l6ZSddKTtcbiAgICBpZiAoZnJvbUltYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ltYWdlU2l6ZSddLCBmcm9tSW1hZ2VTaXplKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0TWltZVR5cGUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dHB1dE1pbWVUeXBlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ291dHB1dENvbXByZXNzaW9uUXVhbGl0eSddKSAhPT1cbiAgICAgICAgdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5IHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGltYWdlQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUFzcGVjdFJhdGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhc3BlY3RSYXRpbyddKTtcbiAgICBpZiAoZnJvbUFzcGVjdFJhdGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXNwZWN0UmF0aW8nXSwgZnJvbUFzcGVjdFJhdGlvKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2VTaXplJ10pO1xuICAgIGlmIChmcm9tSW1hZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2VTaXplJ10sIGZyb21JbWFnZVNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0TWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21PdXRwdXRNaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ltYWdlT3V0cHV0T3B0aW9ucycsICdtaW1lVHlwZSddLCBmcm9tT3V0cHV0TWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ltYWdlT3V0cHV0T3B0aW9ucycsICdjb21wcmVzc2lvblF1YWxpdHknXSwgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGltYWdlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JbWFnZUJ5dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYnl0ZXNCYXNlNjRFbmNvZGVkJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUltYWdlQnl0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbWFnZUJ5dGVzJ10sIHRCeXRlcyhmcm9tSW1hZ2VCeXRlcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbWFnZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2NzVXJpJ10pO1xuICAgIGlmIChmcm9tR2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2NzVXJpJ10sIGZyb21HY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2VCeXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2J5dGVzQmFzZTY0RW5jb2RlZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21JbWFnZUJ5dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2VCeXRlcyddLCB0Qnl0ZXMoZnJvbUltYWdlQnl0ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW1hZ2VUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2NzVXJpIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZUJ5dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZUJ5dGVzJ10pO1xuICAgIGlmIChmcm9tSW1hZ2VCeXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2J5dGVzQmFzZTY0RW5jb2RlZCddLCB0Qnl0ZXMoZnJvbUltYWdlQnl0ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW1hZ2VUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NVcmknXSk7XG4gICAgaWYgKGZyb21HY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnY3NVcmknXSwgZnJvbUdjc1VyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZUJ5dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZUJ5dGVzJ10pO1xuICAgIGlmIChmcm9tSW1hZ2VCeXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2J5dGVzQmFzZTY0RW5jb2RlZCddLCB0Qnl0ZXMoZnJvbUltYWdlQnl0ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdE1vZGVsc0NvbmZpZ1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVNpemUnXSwgZnJvbVBhZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVRva2VuJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlVG9rZW4nXSwgZnJvbVBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWx0ZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbHRlciddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAnZmlsdGVyJ10sIGZyb21GaWx0ZXIpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUXVlcnlCYXNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydxdWVyeUJhc2UnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21RdWVyeUJhc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3VybCcsICdtb2RlbHNfdXJsJ10sIHRNb2RlbHNVcmwoYXBpQ2xpZW50LCBmcm9tUXVlcnlCYXNlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RNb2RlbHNDb25maWdUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlU2l6ZSddLCBmcm9tUGFnZVNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlVG9rZW4nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VUb2tlbiddLCBmcm9tUGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsdGVyJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdmaWx0ZXInXSwgZnJvbUZpbHRlcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21RdWVyeUJhc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3F1ZXJ5QmFzZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVF1ZXJ5QmFzZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfdXJsJywgJ21vZGVsc191cmwnXSwgdE1vZGVsc1VybChhcGlDbGllbnQsIGZyb21RdWVyeUJhc2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdE1vZGVsc1BhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgbGlzdE1vZGVsc0NvbmZpZ1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RNb2RlbHNQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBsaXN0TW9kZWxzQ29uZmlnVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RNb2RlbHNSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5leHRQYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXh0UGFnZVRva2VuJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU5leHRQYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXh0UGFnZVRva2VuJ10sIGZyb21OZXh0UGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1vZGVscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21Nb2RlbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdEV4dHJhY3RNb2RlbHMoZnJvbU1vZGVscyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kZWxGcm9tTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdE1vZGVsc1Jlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5leHRQYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXh0UGFnZVRva2VuJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU5leHRQYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXh0UGFnZVRva2VuJ10sIGZyb21OZXh0UGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1vZGVscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21Nb2RlbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdEV4dHJhY3RNb2RlbHMoZnJvbU1vZGVscyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kZWxGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWxzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIG1hc2tSZWZlcmVuY2VDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTWFza01vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21hc2tNb2RlJ10pO1xuICAgIGlmIChmcm9tTWFza01vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXNrTW9kZSddLCBmcm9tTWFza01vZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VnbWVudGF0aW9uQ2xhc3NlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NlZ21lbnRhdGlvbkNsYXNzZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2VnbWVudGF0aW9uQ2xhc3NlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21hc2tDbGFzc2VzJ10sIGZyb21TZWdtZW50YXRpb25DbGFzc2VzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1hc2tEaWxhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWFza0RpbGF0aW9uJ10pO1xuICAgIGlmIChmcm9tTWFza0RpbGF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlsYXRpb24nXSwgZnJvbU1hc2tEaWxhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIG1vZGVsRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmVyc2lvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmVyc2lvbiddKTtcbiAgICBpZiAoZnJvbVZlcnNpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2ZXJzaW9uJ10sIGZyb21WZXJzaW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR1bmVkTW9kZWxJbmZvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydfc2VsZiddKTtcbiAgICBpZiAoZnJvbVR1bmVkTW9kZWxJbmZvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVuZWRNb2RlbEluZm8nXSwgdHVuZWRNb2RlbEluZm9Gcm9tTWxkZXYoZnJvbVR1bmVkTW9kZWxJbmZvKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbnB1dFRva2VuTGltaXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbnB1dFRva2VuTGltaXQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tSW5wdXRUb2tlbkxpbWl0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5wdXRUb2tlbkxpbWl0J10sIGZyb21JbnB1dFRva2VuTGltaXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0VG9rZW5MaW1pdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dFRva2VuTGltaXQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tT3V0cHV0VG9rZW5MaW1pdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ291dHB1dFRva2VuTGltaXQnXSwgZnJvbU91dHB1dFRva2VuTGltaXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3VwcG9ydGVkQWN0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N1cHBvcnRlZEdlbmVyYXRpb25NZXRob2RzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVN1cHBvcnRlZEFjdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdXBwb3J0ZWRBY3Rpb25zJ10sIGZyb21TdXBwb3J0ZWRBY3Rpb25zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRlbXBlcmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZW1wZXJhdHVyZSddKTtcbiAgICBpZiAoZnJvbVRlbXBlcmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGVtcGVyYXR1cmUnXSwgZnJvbVRlbXBlcmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heFRlbXBlcmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWF4VGVtcGVyYXR1cmUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWF4VGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXhUZW1wZXJhdHVyZSddLCBmcm9tTWF4VGVtcGVyYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wUCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wUCddKTtcbiAgICBpZiAoZnJvbVRvcFAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3BQJ10sIGZyb21Ub3BQKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcEsgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcEsnXSk7XG4gICAgaWYgKGZyb21Ub3BLICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9wSyddLCBmcm9tVG9wSyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaGlua2luZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGhpbmtpbmcnXSk7XG4gICAgaWYgKGZyb21UaGlua2luZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RoaW5raW5nJ10sIGZyb21UaGlua2luZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIG1vZGVsRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAoZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAoZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZlcnNpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZlcnNpb25JZCddKTtcbiAgICBpZiAoZnJvbVZlcnNpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2ZXJzaW9uJ10sIGZyb21WZXJzaW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZHBvaW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVwbG95ZWRNb2RlbHMnXSk7XG4gICAgaWYgKGZyb21FbmRwb2ludHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUVuZHBvaW50cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmRwb2ludEZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRwb2ludHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhYmVscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pO1xuICAgIGlmIChmcm9tTGFiZWxzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbGFiZWxzJ10sIGZyb21MYWJlbHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHVuZWRNb2RlbEluZm8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tVHVuZWRNb2RlbEluZm8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0dW5lZE1vZGVsSW5mbyddLCB0dW5lZE1vZGVsSW5mb0Zyb21WZXJ0ZXgoZnJvbVR1bmVkTW9kZWxJbmZvKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZWZhdWx0Q2hlY2twb2ludElkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZGVmYXVsdENoZWNrcG9pbnRJZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21EZWZhdWx0Q2hlY2twb2ludElkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVmYXVsdENoZWNrcG9pbnRJZCddLCBmcm9tRGVmYXVsdENoZWNrcG9pbnRJZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DaGVja3BvaW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY2hlY2twb2ludHMnXSk7XG4gICAgaWYgKGZyb21DaGVja3BvaW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQ2hlY2twb2ludHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NoZWNrcG9pbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHBhcnRUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1lZGlhUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21lZGlhUmVzb2x1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NZWRpYVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZWRpYVJlc29sdXRpb24nXSwgZnJvbU1lZGlhUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvblJlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvblJlc3VsdCddLCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGVjdXRhYmxlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4ZWN1dGFibGVDb2RlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4ZWN1dGFibGVDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhlY3V0YWJsZUNvZGUnXSwgZnJvbUV4ZWN1dGFibGVDb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlRGF0YSddKTtcbiAgICBpZiAoZnJvbUZpbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZURhdGEnXSwgZmlsZURhdGFUb01sZGV2JDEoZnJvbUZpbGVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddLCBmdW5jdGlvbkNhbGxUb01sZGV2JDEoZnJvbUZ1bmN0aW9uQ2FsbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uUmVzcG9uc2UnXSwgZnJvbUZ1bmN0aW9uUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5saW5lRGF0YSddKTtcbiAgICBpZiAoZnJvbUlubGluZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmxpbmVEYXRhJ10sIGJsb2JUb01sZGV2JDEoZnJvbUlubGluZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aG91Z2h0J10pO1xuICAgIGlmIChmcm9tVGhvdWdodCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHQnXSwgZnJvbVRob3VnaHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodFNpZ25hdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rob3VnaHRTaWduYXR1cmUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhvdWdodFNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHRTaWduYXR1cmUnXSwgZnJvbVRob3VnaHRTaWduYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW9NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ZpZGVvTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvTWV0YWRhdGEnXSwgZnJvbVZpZGVvTWV0YWRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwcm9kdWN0SW1hZ2VUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUHJvZHVjdEltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9kdWN0SW1hZ2UnXSk7XG4gICAgaWYgKGZyb21Qcm9kdWN0SW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbWFnZSddLCBpbWFnZVRvVmVydGV4KGZyb21Qcm9kdWN0SW1hZ2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcmVjb250ZXh0SW1hZ2VDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OdW1iZXJPZkltYWdlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ251bWJlck9mSW1hZ2VzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU51bWJlck9mSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FtcGxlQ291bnQnXSwgZnJvbU51bWJlck9mSW1hZ2VzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJhc2VTdGVwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmFzZVN0ZXBzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQmFzZVN0ZXBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnYmFzZVN0ZXBzJ10sIGZyb21CYXNlU3RlcHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0R2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRHY3NVcmknXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRHY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzdG9yYWdlVXJpJ10sIGZyb21PdXRwdXRHY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNlZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzZWVkJ10sIGZyb21TZWVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNhZmV0eUZpbHRlckxldmVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5RmlsdGVyTGV2ZWwnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzYWZldHlTZXR0aW5nJ10sIGZyb21TYWZldHlGaWx0ZXJMZXZlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QZXJzb25HZW5lcmF0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGVyc29uR2VuZXJhdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QZXJzb25HZW5lcmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAncGVyc29uR2VuZXJhdGlvbiddLCBmcm9tUGVyc29uR2VuZXJhdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BZGRXYXRlcm1hcmsgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FkZFdhdGVybWFyayddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUFkZFdhdGVybWFyayAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2FkZFdhdGVybWFyayddLCBmcm9tQWRkV2F0ZXJtYXJrKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dE1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0TWltZVR5cGUnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0TWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdvdXRwdXRPcHRpb25zJywgJ21pbWVUeXBlJ10sIGZyb21PdXRwdXRNaW1lVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRDb21wcmVzc2lvblF1YWxpdHknLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnb3V0cHV0T3B0aW9ucycsICdjb21wcmVzc2lvblF1YWxpdHknXSwgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmhhbmNlUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW5oYW5jZVByb21wdCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FbmhhbmNlUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZW5oYW5jZVByb21wdCddLCBmcm9tRW5oYW5jZVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYWJlbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhYmVscyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUxhYmVscyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydsYWJlbHMnXSwgZnJvbUxhYmVscyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHJlY29udGV4dEltYWdlUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNvdXJjZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc291cmNlJ10pO1xuICAgIGlmIChmcm9tU291cmNlICE9IG51bGwpIHtcbiAgICAgICAgcmVjb250ZXh0SW1hZ2VTb3VyY2VUb1ZlcnRleChmcm9tU291cmNlLCB0b09iamVjdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHJlY29udGV4dEltYWdlQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiByZWNvbnRleHRJbWFnZVJlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2VuZXJhdGVkSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlZGljdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR2VuZXJhdGVkSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21HZW5lcmF0ZWRJbWFnZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVkSW1hZ2VGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGVkSW1hZ2VzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHJlY29udGV4dEltYWdlU291cmNlVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9tcHQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Qcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3Byb21wdCddLCBmcm9tUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBlcnNvbkltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwZXJzb25JbWFnZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBlcnNvbkltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdwZXJzb25JbWFnZScsICdpbWFnZSddLCBpbWFnZVRvVmVydGV4KGZyb21QZXJzb25JbWFnZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvZHVjdEltYWdlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Byb2R1Y3RJbWFnZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUHJvZHVjdEltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUHJvZHVjdEltYWdlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9kdWN0SW1hZ2VUb1ZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncHJvZHVjdEltYWdlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiByZWZlcmVuY2VJbWFnZUFQSUludGVybmFsVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVJlZmVyZW5jZUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVmZXJlbmNlSW1hZ2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVmZXJlbmNlSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZWZlcmVuY2VJbWFnZSddLCBpbWFnZVRvVmVydGV4KGZyb21SZWZlcmVuY2VJbWFnZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVmZXJlbmNlSWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JlZmVyZW5jZUlkJ10pO1xuICAgIGlmIChmcm9tUmVmZXJlbmNlSWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZWZlcmVuY2VJZCddLCBmcm9tUmVmZXJlbmNlSWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVmZXJlbmNlVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JlZmVyZW5jZVR5cGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVmZXJlbmNlVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlZmVyZW5jZVR5cGUnXSwgZnJvbVJlZmVyZW5jZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWFza0ltYWdlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWFza0ltYWdlQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1hc2tJbWFnZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21hc2tJbWFnZUNvbmZpZyddLCBtYXNrUmVmZXJlbmNlQ29uZmlnVG9WZXJ0ZXgoZnJvbU1hc2tJbWFnZUNvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udHJvbEltYWdlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29udHJvbEltYWdlQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvbnRyb2xJbWFnZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRyb2xJbWFnZUNvbmZpZyddLCBjb250cm9sUmVmZXJlbmNlQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbnRyb2xJbWFnZUNvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3R5bGVJbWFnZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N0eWxlSW1hZ2VDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3R5bGVJbWFnZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0eWxlSW1hZ2VDb25maWcnXSwgZnJvbVN0eWxlSW1hZ2VDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3ViamVjdEltYWdlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3ViamVjdEltYWdlQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVN1YmplY3RJbWFnZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N1YmplY3RJbWFnZUNvbmZpZyddLCBmcm9tU3ViamVjdEltYWdlQ29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2FmZXR5QXR0cmlidXRlc0Zyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ2F0ZWdvcmllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eUF0dHJpYnV0ZXMnLFxuICAgICAgICAnY2F0ZWdvcmllcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYXRlZ29yaWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2F0ZWdvcmllcyddLCBmcm9tQ2F0ZWdvcmllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TY29yZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlBdHRyaWJ1dGVzJyxcbiAgICAgICAgJ3Njb3JlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TY29yZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzY29yZXMnXSwgZnJvbVNjb3Jlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50VHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudFR5cGUnXSk7XG4gICAgaWYgKGZyb21Db250ZW50VHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRlbnRUeXBlJ10sIGZyb21Db250ZW50VHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNhZmV0eUF0dHJpYnV0ZXNGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21DYXRlZ29yaWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5QXR0cmlidXRlcycsXG4gICAgICAgICdjYXRlZ29yaWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNhdGVnb3JpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYXRlZ29yaWVzJ10sIGZyb21DYXRlZ29yaWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNjb3JlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eUF0dHJpYnV0ZXMnLFxuICAgICAgICAnc2NvcmVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNjb3JlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Njb3JlcyddLCBmcm9tU2NvcmVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRlbnRUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50VHlwZSddKTtcbiAgICBpZiAoZnJvbUNvbnRlbnRUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29udGVudFR5cGUnXSwgZnJvbUNvbnRlbnRUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2FmZXR5U2V0dGluZ1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNhdGVnb3J5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjYXRlZ29yeSddKTtcbiAgICBpZiAoZnJvbUNhdGVnb3J5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2F0ZWdvcnknXSwgZnJvbUNhdGVnb3J5KTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0aG9kJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRocmVzaG9sZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGhyZXNob2xkJ10pO1xuICAgIGlmIChmcm9tVGhyZXNob2xkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhyZXNob2xkJ10sIGZyb21UaHJlc2hvbGQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzY3JpYmJsZUltYWdlVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZSddKTtcbiAgICBpZiAoZnJvbUltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2UnXSwgaW1hZ2VUb1ZlcnRleChmcm9tSW1hZ2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2VnbWVudEltYWdlQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdtb2RlJ10sIGZyb21Nb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heFByZWRpY3Rpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWF4UHJlZGljdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTWF4UHJlZGljdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdtYXhQcmVkaWN0aW9ucyddLCBmcm9tTWF4UHJlZGljdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlkZW5jZVRocmVzaG9sZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvbmZpZGVuY2VUaHJlc2hvbGQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ29uZmlkZW5jZVRocmVzaG9sZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2NvbmZpZGVuY2VUaHJlc2hvbGQnXSwgZnJvbUNvbmZpZGVuY2VUaHJlc2hvbGQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWFza0RpbGF0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtYXNrRGlsYXRpb24nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21NYXNrRGlsYXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdtYXNrRGlsYXRpb24nXSwgZnJvbU1hc2tEaWxhdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CaW5hcnlDb2xvclRocmVzaG9sZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2JpbmFyeUNvbG9yVGhyZXNob2xkJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUJpbmFyeUNvbG9yVGhyZXNob2xkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnYmluYXJ5Q29sb3JUaHJlc2hvbGQnXSwgZnJvbUJpbmFyeUNvbG9yVGhyZXNob2xkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhYmVscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGFiZWxzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2xhYmVscyddLCBmcm9tTGFiZWxzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2VnbWVudEltYWdlUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNvdXJjZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc291cmNlJ10pO1xuICAgIGlmIChmcm9tU291cmNlICE9IG51bGwpIHtcbiAgICAgICAgc2VnbWVudEltYWdlU291cmNlVG9WZXJ0ZXgoZnJvbVNvdXJjZSwgdG9PYmplY3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZWdtZW50SW1hZ2VDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNlZ21lbnRJbWFnZVJlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2VuZXJhdGVkTWFza3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ByZWRpY3Rpb25zJ10pO1xuICAgIGlmIChmcm9tR2VuZXJhdGVkTWFza3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUdlbmVyYXRlZE1hc2tzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlZEltYWdlTWFza0Zyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0ZWRNYXNrcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzZWdtZW50SW1hZ2VTb3VyY2VUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Qcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb21wdCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncHJvbXB0J10sIGZyb21Qcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ2ltYWdlJ10sIGltYWdlVG9WZXJ0ZXgoZnJvbUltYWdlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TY3JpYmJsZUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2NyaWJibGVJbWFnZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TY3JpYmJsZUltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdzY3JpYmJsZSddLCBzY3JpYmJsZUltYWdlVG9WZXJ0ZXgoZnJvbVNjcmliYmxlSW1hZ2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc3BlZWNoQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUxhbmd1YWdlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFuZ3VhZ2VDb2RlJ10pO1xuICAgIGlmIChmcm9tTGFuZ3VhZ2VDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbGFuZ3VhZ2VDb2RlJ10sIGZyb21MYW5ndWFnZUNvZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVm9pY2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZvaWNlQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tVm9pY2VDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2b2ljZUNvbmZpZyddLCBmcm9tVm9pY2VDb25maWcpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtdWx0aVNwZWFrZXJWb2ljZUNvbmZpZyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbXVsdGlTcGVha2VyVm9pY2VDb25maWcgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0b29sQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxsaW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25DYWxsaW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbGluZ0NvbmZpZyddLCBmdW5jdGlvbkNhbGxpbmdDb25maWdUb01sZGV2KGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJldHJpZXZhbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JldHJpZXZhbENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXRyaWV2YWxDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXRyaWV2YWxDb25maWcnXSwgZnJvbVJldHJpZXZhbENvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25EZWNsYXJhdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkRlY2xhcmF0aW9ucyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXRyaWV2YWwnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JldHJpZXZhbCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCddLCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbXB1dGVyVXNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb21wdXRlclVzZSddKTtcbiAgICBpZiAoZnJvbUNvbXB1dGVyVXNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSwgZnJvbUNvbXB1dGVyVXNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21GaWxlU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZVNlYXJjaCddLCBmcm9tRmlsZVNlYXJjaCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvbiddLCBmcm9tQ29kZUV4ZWN1dGlvbik7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VudGVycHJpc2VXZWJTZWFyY2gnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VudGVycHJpc2VXZWJTZWFyY2ggcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZU1hcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVNYXBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlTWFwcyddLCBnb29nbGVNYXBzVG9NbGRldiQxKGZyb21Hb29nbGVNYXBzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddLCBnb29nbGVTZWFyY2hUb01sZGV2JDEoZnJvbUdvb2dsZVNlYXJjaCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJsQ29udGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXJsQ29udGV4dCddKTtcbiAgICBpZiAoZnJvbVVybENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmxDb250ZXh0J10sIGZyb21VcmxDb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbFRvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbkRlY2xhcmF0aW9uVG9WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkRlY2xhcmF0aW9ucyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXRyaWV2YWwnXSk7XG4gICAgaWYgKGZyb21SZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXRyaWV2YWwnXSwgZnJvbVJldHJpZXZhbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnb29nbGVTZWFyY2hSZXRyaWV2YWwnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJ10sIGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29tcHV0ZXJVc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10pO1xuICAgIGlmIChmcm9tQ29tcHV0ZXJVc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb21wdXRlclVzZSddLCBmcm9tQ29tcHV0ZXJVc2UpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlU2VhcmNoJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWxlU2VhcmNoIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uJ10sIGZyb21Db2RlRXhlY3V0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVudGVycHJpc2VXZWJTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbnRlcnByaXNlV2ViU2VhcmNoJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUVudGVycHJpc2VXZWJTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbnRlcnByaXNlV2ViU2VhcmNoJ10sIGZyb21FbnRlcnByaXNlV2ViU2VhcmNoKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZU1hcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVNYXBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlTWFwcyddLCBmcm9tR29vZ2xlTWFwcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddLCBmcm9tR29vZ2xlU2VhcmNoKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVybENvbnRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VybENvbnRleHQnXSk7XG4gICAgaWYgKGZyb21VcmxDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsQ29udGV4dCddLCBmcm9tVXJsQ29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHR1bmVkTW9kZWxJbmZvRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21CYXNlTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Jhc2VNb2RlbCddKTtcbiAgICBpZiAoZnJvbUJhc2VNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Jhc2VNb2RlbCddLCBmcm9tQmFzZU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNyZWF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21DcmVhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY3JlYXRlVGltZSddLCBmcm9tQ3JlYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcGRhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cGRhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tVXBkYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSwgZnJvbVVwZGF0ZVRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0dW5lZE1vZGVsSW5mb0Zyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUJhc2VNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2xhYmVscycsXG4gICAgICAgICdnb29nbGUtdmVydGV4LWxsbS10dW5pbmctYmFzZS1tb2RlbC1pZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21CYXNlTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiYXNlTW9kZWwnXSwgZnJvbUJhc2VNb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DcmVhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjcmVhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tQ3JlYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSwgZnJvbUNyZWF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXBkYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXBkYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbVVwZGF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cGRhdGVUaW1lJ10sIGZyb21VcGRhdGVUaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBkYXRlTW9kZWxDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVmYXVsdENoZWNrcG9pbnRJZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2RlZmF1bHRDaGVja3BvaW50SWQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGVmYXVsdENoZWNrcG9pbnRJZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkZWZhdWx0Q2hlY2twb2ludElkJ10sIGZyb21EZWZhdWx0Q2hlY2twb2ludElkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBkYXRlTW9kZWxDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlZmF1bHRDaGVja3BvaW50SWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkZWZhdWx0Q2hlY2twb2ludElkJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURlZmF1bHRDaGVja3BvaW50SWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZGVmYXVsdENoZWNrcG9pbnRJZCddLCBmcm9tRGVmYXVsdENoZWNrcG9pbnRJZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZU1vZGVsUGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHVwZGF0ZU1vZGVsQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZU1vZGVsUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgdXBkYXRlTW9kZWxDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwc2NhbGVJbWFnZUFQSUNvbmZpZ0ludGVybmFsVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tT3V0cHV0R2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRHY3NVcmknXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRHY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzdG9yYWdlVXJpJ10sIGZyb21PdXRwdXRHY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlGaWx0ZXJMZXZlbCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TYWZldHlGaWx0ZXJMZXZlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhZmV0eVNldHRpbmcnXSwgZnJvbVNhZmV0eUZpbHRlckxldmVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBlcnNvbkdlbmVyYXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwZXJzb25HZW5lcmF0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBlcnNvbkdlbmVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdwZXJzb25HZW5lcmF0aW9uJ10sIGZyb21QZXJzb25HZW5lcmF0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUluY2x1ZGVSYWlSZWFzb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbmNsdWRlUmFpUmVhc29uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUluY2x1ZGVSYWlSZWFzb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdpbmNsdWRlUmFpUmVhc29uJ10sIGZyb21JbmNsdWRlUmFpUmVhc29uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dE1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0TWltZVR5cGUnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0TWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdvdXRwdXRPcHRpb25zJywgJ21pbWVUeXBlJ10sIGZyb21PdXRwdXRNaW1lVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRDb21wcmVzc2lvblF1YWxpdHknLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnb3V0cHV0T3B0aW9ucycsICdjb21wcmVzc2lvblF1YWxpdHknXSwgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmhhbmNlSW5wdXRJbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VuaGFuY2VJbnB1dEltYWdlJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUVuaGFuY2VJbnB1dEltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAndXBzY2FsZUNvbmZpZycsICdlbmhhbmNlSW5wdXRJbWFnZSddLCBmcm9tRW5oYW5jZUlucHV0SW1hZ2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2VQcmVzZXJ2YXRpb25GYWN0b3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbWFnZVByZXNlcnZhdGlvbkZhY3RvcicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbWFnZVByZXNlcnZhdGlvbkZhY3RvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3Vwc2NhbGVDb25maWcnLCAnaW1hZ2VQcmVzZXJ2YXRpb25GYWN0b3InXSwgZnJvbUltYWdlUHJlc2VydmF0aW9uRmFjdG9yKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhYmVscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGFiZWxzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2xhYmVscyddLCBmcm9tTGFiZWxzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU51bWJlck9mSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbnVtYmVyT2ZJbWFnZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTnVtYmVyT2ZJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzYW1wbGVDb3VudCddLCBmcm9tTnVtYmVyT2ZJbWFnZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdtb2RlJ10sIGZyb21Nb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBzY2FsZUltYWdlQVBJUGFyYW1ldGVyc0ludGVybmFsVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlJ10pO1xuICAgIGlmIChmcm9tSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAnaW1hZ2UnXSwgaW1hZ2VUb1ZlcnRleChmcm9tSW1hZ2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVwc2NhbGVGYWN0b3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd1cHNjYWxlRmFjdG9yJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVwc2NhbGVGYWN0b3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3Vwc2NhbGVDb25maWcnLCAndXBzY2FsZUZhY3RvciddLCBmcm9tVXBzY2FsZUZhY3Rvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHVwc2NhbGVJbWFnZUFQSUNvbmZpZ0ludGVybmFsVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cHNjYWxlSW1hZ2VSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HZW5lcmF0ZWRJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVkaWN0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0ZWRJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUdlbmVyYXRlZEltYWdlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRJbWFnZUZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0ZWRJbWFnZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdmlkZW9Gcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXJpJ10pO1xuICAgIGlmIChmcm9tVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJpJ10sIGZyb21VcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW9CeXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5jb2RlZFZpZGVvJ10pO1xuICAgIGlmIChmcm9tVmlkZW9CeXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvQnl0ZXMnXSwgdEJ5dGVzKGZyb21WaWRlb0J5dGVzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5jb2RpbmcnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NVcmknXSk7XG4gICAgaWYgKGZyb21VcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmknXSwgZnJvbVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlb0J5dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYnl0ZXNCYXNlNjRFbmNvZGVkJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvQnl0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb0J5dGVzJ10sIHRCeXRlcyhmcm9tVmlkZW9CeXRlcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb0dlbmVyYXRpb25NYXNrVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZSddKTtcbiAgICBpZiAoZnJvbUltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3NlbGYnXSwgaW1hZ2VUb1ZlcnRleChmcm9tSW1hZ2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1hc2tNb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtYXNrTW9kZSddKTtcbiAgICBpZiAoZnJvbU1hc2tNb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWFza01vZGUnXSwgZnJvbU1hc2tNb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdmlkZW9HZW5lcmF0aW9uUmVmZXJlbmNlSW1hZ2VUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2UnXSk7XG4gICAgaWYgKGZyb21JbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ltYWdlJ10sIGltYWdlVG9NbGRldihmcm9tSW1hZ2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlZmVyZW5jZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZWZlcmVuY2VUeXBlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlZmVyZW5jZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZWZlcmVuY2VUeXBlJ10sIGZyb21SZWZlcmVuY2VUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdmlkZW9HZW5lcmF0aW9uUmVmZXJlbmNlSW1hZ2VUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlJ10pO1xuICAgIGlmIChmcm9tSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbWFnZSddLCBpbWFnZVRvVmVydGV4KGZyb21JbWFnZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVmZXJlbmNlVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JlZmVyZW5jZVR5cGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVmZXJlbmNlVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlZmVyZW5jZVR5cGUnXSwgZnJvbVJlZmVyZW5jZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXJpJ10pO1xuICAgIGlmIChmcm9tVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJpJ10sIGZyb21VcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW9CeXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmlkZW9CeXRlcyddKTtcbiAgICBpZiAoZnJvbVZpZGVvQnl0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmNvZGVkVmlkZW8nXSwgdEJ5dGVzKGZyb21WaWRlb0J5dGVzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuY29kaW5nJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXJpJ10pO1xuICAgIGlmIChmcm9tVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2NzVXJpJ10sIGZyb21VcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW9CeXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmlkZW9CeXRlcyddKTtcbiAgICBpZiAoZnJvbVZpZGVvQnl0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydieXRlc0Jhc2U2NEVuY29kZWQnXSwgdEJ5dGVzKGZyb21WaWRlb0J5dGVzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuLy8gQ29kZSBnZW5lcmF0ZWQgYnkgdGhlIEdvb2dsZSBHZW4gQUkgU0RLIGdlbmVyYXRvciBETyBOT1QgRURJVC5cbmZ1bmN0aW9uIGNyZWF0ZUZpbGVTZWFyY2hTdG9yZUNvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlRmlsZVNlYXJjaFN0b3JlUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgY3JlYXRlRmlsZVNlYXJjaFN0b3JlQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUZpbGVTZWFyY2hTdG9yZUNvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRm9yY2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZvcmNlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRm9yY2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ2ZvcmNlJ10sIGZyb21Gb3JjZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUZpbGVTZWFyY2hTdG9yZVBhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZUZpbGVTZWFyY2hTdG9yZUNvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZXRGaWxlU2VhcmNoU3RvcmVQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbXBvcnRGaWxlQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21DdXN0b21NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2N1c3RvbU1ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUN1c3RvbU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21DdXN0b21NZXRhZGF0YTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2N1c3RvbU1ldGFkYXRhJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DaHVua2luZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NodW5raW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUNodW5raW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2NodW5raW5nQ29uZmlnJ10sIGZyb21DaHVua2luZ0NvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGltcG9ydEZpbGVPcGVyYXRpb25Gcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0YWRhdGEnXSk7XG4gICAgaWYgKGZyb21NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21ldGFkYXRhJ10sIGZyb21NZXRhZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Eb25lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkb25lJ10pO1xuICAgIGlmIChmcm9tRG9uZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RvbmUnXSwgZnJvbURvbmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXJyb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vycm9yJ10pO1xuICAgIGlmIChmcm9tRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlcnJvciddLCBmcm9tRXJyb3IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCBpbXBvcnRGaWxlUmVzcG9uc2VGcm9tTWxkZXYoZnJvbVJlc3BvbnNlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGltcG9ydEZpbGVQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRmlsZVNlYXJjaFN0b3JlTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2ZpbGVTZWFyY2hTdG9yZU5hbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRmlsZVNlYXJjaFN0b3JlTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnZmlsZV9zZWFyY2hfc3RvcmVfbmFtZSddLCBmcm9tRmlsZVNlYXJjaFN0b3JlTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZU5hbWUnXSk7XG4gICAgaWYgKGZyb21GaWxlTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVOYW1lJ10sIGZyb21GaWxlTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGltcG9ydEZpbGVDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW1wb3J0RmlsZVJlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFyZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJlbnQnXSk7XG4gICAgaWYgKGZyb21QYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJlbnQnXSwgZnJvbVBhcmVudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Eb2N1bWVudE5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RvY3VtZW50TmFtZSddKTtcbiAgICBpZiAoZnJvbURvY3VtZW50TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RvY3VtZW50TmFtZSddLCBmcm9tRG9jdW1lbnROYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdEZpbGVTZWFyY2hTdG9yZXNDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlU2l6ZSddLCBmcm9tUGFnZVNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlVG9rZW4nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VUb2tlbiddLCBmcm9tUGFnZVRva2VuKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdEZpbGVTZWFyY2hTdG9yZXNQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBsaXN0RmlsZVNlYXJjaFN0b3Jlc0NvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0RmlsZVNlYXJjaFN0b3Jlc1Jlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmV4dFBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25leHRQYWdlVG9rZW4nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTmV4dFBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25leHRQYWdlVG9rZW4nXSwgZnJvbU5leHRQYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZVNlYXJjaFN0b3JlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2ZpbGVTZWFyY2hTdG9yZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRmlsZVNlYXJjaFN0b3JlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRmlsZVNlYXJjaFN0b3JlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZVNlYXJjaFN0b3JlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cGxvYWRUb0ZpbGVTZWFyY2hTdG9yZUNvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DdXN0b21NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2N1c3RvbU1ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUN1c3RvbU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21DdXN0b21NZXRhZGF0YTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2N1c3RvbU1ldGFkYXRhJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DaHVua2luZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NodW5raW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUNodW5raW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2NodW5raW5nQ29uZmlnJ10sIGZyb21DaHVua2luZ0NvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZpbGVTZWFyY2hTdG9yZU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmaWxlU2VhcmNoU3RvcmVOYW1lJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZpbGVTZWFyY2hTdG9yZU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ2ZpbGVfc2VhcmNoX3N0b3JlX25hbWUnXSwgZnJvbUZpbGVTZWFyY2hTdG9yZU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICB1cGxvYWRUb0ZpbGVTZWFyY2hTdG9yZUNvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cGxvYWRUb0ZpbGVTZWFyY2hTdG9yZVJlc3VtYWJsZVJlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNvbnN0IENPTlRFTlRfVFlQRV9IRUFERVIgPSAnQ29udGVudC1UeXBlJztcbmNvbnN0IFNFUlZFUl9USU1FT1VUX0hFQURFUiA9ICdYLVNlcnZlci1UaW1lb3V0JztcbmNvbnN0IFVTRVJfQUdFTlRfSEVBREVSID0gJ1VzZXItQWdlbnQnO1xuY29uc3QgR09PR0xFX0FQSV9DTElFTlRfSEVBREVSID0gJ3gtZ29vZy1hcGktY2xpZW50JztcbmNvbnN0IFNES19WRVJTSU9OID0gJzEuMzEuMCc7IC8vIHgtcmVsZWFzZS1wbGVhc2UtdmVyc2lvblxuY29uc3QgTElCUkFSWV9MQUJFTCA9IGBnb29nbGUtZ2VuYWktc2RrLyR7U0RLX1ZFUlNJT059YDtcbmNvbnN0IFZFUlRFWF9BSV9BUElfREVGQVVMVF9WRVJTSU9OID0gJ3YxYmV0YTEnO1xuY29uc3QgR09PR0xFX0FJX0FQSV9ERUZBVUxUX1ZFUlNJT04gPSAndjFiZXRhJztcbmNvbnN0IHJlc3BvbnNlTGluZVJFID0gL15cXHMqZGF0YTogKC4qKSg/OlxcblxcbnxcXHJcXHJ8XFxyXFxuXFxyXFxuKS87XG4vKipcbiAqIFRoZSBBcGlDbGllbnQgY2xhc3MgaXMgdXNlZCB0byBzZW5kIHJlcXVlc3RzIHRvIHRoZSBHZW1pbmkgQVBJIG9yIFZlcnRleCBBSVxuICogZW5kcG9pbnRzLlxuICovXG5jbGFzcyBBcGlDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRzKSwgeyBwcm9qZWN0OiBvcHRzLnByb2plY3QsIGxvY2F0aW9uOiBvcHRzLmxvY2F0aW9uLCBhcGlLZXk6IG9wdHMuYXBpS2V5LCB2ZXJ0ZXhhaTogb3B0cy52ZXJ0ZXhhaSB9KTtcbiAgICAgICAgY29uc3QgaW5pdEh0dHBPcHRpb25zID0ge307XG4gICAgICAgIGlmICh0aGlzLmNsaWVudE9wdGlvbnMudmVydGV4YWkpIHtcbiAgICAgICAgICAgIGluaXRIdHRwT3B0aW9ucy5hcGlWZXJzaW9uID1cbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmNsaWVudE9wdGlvbnMuYXBpVmVyc2lvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogVkVSVEVYX0FJX0FQSV9ERUZBVUxUX1ZFUlNJT047XG4gICAgICAgICAgICBpbml0SHR0cE9wdGlvbnMuYmFzZVVybCA9IHRoaXMuYmFzZVVybEZyb21Qcm9qZWN0TG9jYXRpb24oKTtcbiAgICAgICAgICAgIHRoaXMubm9ybWFsaXplQXV0aFBhcmFtZXRlcnMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEdlbWluaSBBUElcbiAgICAgICAgICAgIGluaXRIdHRwT3B0aW9ucy5hcGlWZXJzaW9uID1cbiAgICAgICAgICAgICAgICAoX2IgPSB0aGlzLmNsaWVudE9wdGlvbnMuYXBpVmVyc2lvbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogR09PR0xFX0FJX0FQSV9ERUZBVUxUX1ZFUlNJT047XG4gICAgICAgICAgICBpbml0SHR0cE9wdGlvbnMuYmFzZVVybCA9IGBodHRwczovL2dlbmVyYXRpdmVsYW5ndWFnZS5nb29nbGVhcGlzLmNvbS9gO1xuICAgICAgICB9XG4gICAgICAgIGluaXRIdHRwT3B0aW9ucy5oZWFkZXJzID0gdGhpcy5nZXREZWZhdWx0SGVhZGVycygpO1xuICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMgPSBpbml0SHR0cE9wdGlvbnM7XG4gICAgICAgIGlmIChvcHRzLmh0dHBPcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMgPSB0aGlzLnBhdGNoSHR0cE9wdGlvbnMoaW5pdEh0dHBPcHRpb25zLCBvcHRzLmh0dHBPcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHRoZSBiYXNlIFVSTCBmb3IgVmVydGV4IEFJIGJhc2VkIG9uIHByb2plY3QgYW5kIGxvY2F0aW9uLlxuICAgICAqIFVzZXMgdGhlIGdsb2JhbCBlbmRwb2ludCBpZiBsb2NhdGlvbiBpcyAnZ2xvYmFsJyBvciBpZiBwcm9qZWN0L2xvY2F0aW9uXG4gICAgICogYXJlIG5vdCBzcGVjaWZpZWQgKGltcGx5aW5nIEFQSSBrZXkgdXNhZ2UpLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYmFzZVVybEZyb21Qcm9qZWN0TG9jYXRpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmNsaWVudE9wdGlvbnMucHJvamVjdCAmJlxuICAgICAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zLmxvY2F0aW9uICYmXG4gICAgICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMubG9jYXRpb24gIT09ICdnbG9iYWwnKSB7XG4gICAgICAgICAgICAvLyBSZWdpb25hbCBlbmRwb2ludFxuICAgICAgICAgICAgcmV0dXJuIGBodHRwczovLyR7dGhpcy5jbGllbnRPcHRpb25zLmxvY2F0aW9ufS1haXBsYXRmb3JtLmdvb2dsZWFwaXMuY29tL2A7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2xvYmFsIGVuZHBvaW50IChjb3ZlcnMgJ2dsb2JhbCcgbG9jYXRpb24gYW5kIEFQSSBrZXkgdXNhZ2UpXG4gICAgICAgIHJldHVybiBgaHR0cHM6Ly9haXBsYXRmb3JtLmdvb2dsZWFwaXMuY29tL2A7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZXMgYXV0aGVudGljYXRpb24gcGFyYW1ldGVycyBmb3IgVmVydGV4IEFJLlxuICAgICAqIElmIHByb2plY3QgYW5kIGxvY2F0aW9uIGFyZSBwcm92aWRlZCwgQVBJIGtleSBpcyBjbGVhcmVkLlxuICAgICAqIElmIHByb2plY3QgYW5kIGxvY2F0aW9uIGFyZSBub3QgcHJvdmlkZWQgKGltcGx5aW5nIEFQSSBrZXkgdXNhZ2UpLFxuICAgICAqIHByb2plY3QgYW5kIGxvY2F0aW9uIGFyZSBjbGVhcmVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbm9ybWFsaXplQXV0aFBhcmFtZXRlcnMoKSB7XG4gICAgICAgIGlmICh0aGlzLmNsaWVudE9wdGlvbnMucHJvamVjdCAmJiB0aGlzLmNsaWVudE9wdGlvbnMubG9jYXRpb24pIHtcbiAgICAgICAgICAgIC8vIFVzaW5nIHByb2plY3QvbG9jYXRpb24gZm9yIGF1dGgsIGNsZWFyIHBvdGVudGlhbCBBUEkga2V5XG4gICAgICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMuYXBpS2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVzaW5nIEFQSSBrZXkgZm9yIGF1dGggKG9yIG5vIGF1dGggcHJvdmlkZWQgeWV0KSwgY2xlYXIgcHJvamVjdC9sb2NhdGlvblxuICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMucHJvamVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zLmxvY2F0aW9uID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpc1ZlcnRleEFJKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLmNsaWVudE9wdGlvbnMudmVydGV4YWkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlO1xuICAgIH1cbiAgICBnZXRQcm9qZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRPcHRpb25zLnByb2plY3Q7XG4gICAgfVxuICAgIGdldExvY2F0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRPcHRpb25zLmxvY2F0aW9uO1xuICAgIH1cbiAgICBnZXRBcGlWZXJzaW9uKCkge1xuICAgICAgICBpZiAodGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zICYmXG4gICAgICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMuYXBpVmVyc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zLmFwaVZlcnNpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBUEkgdmVyc2lvbiBpcyBub3Qgc2V0LicpO1xuICAgIH1cbiAgICBnZXRCYXNlVXJsKCkge1xuICAgICAgICBpZiAodGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zICYmXG4gICAgICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMuYmFzZVVybCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zLmJhc2VVcmw7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCYXNlIFVSTCBpcyBub3Qgc2V0LicpO1xuICAgIH1cbiAgICBnZXRSZXF1ZXN0VXJsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZXF1ZXN0VXJsSW50ZXJuYWwodGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zKTtcbiAgICB9XG4gICAgZ2V0SGVhZGVycygpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucyAmJlxuICAgICAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zLmhlYWRlcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucy5oZWFkZXJzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIZWFkZXJzIGFyZSBub3Qgc2V0LicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFJlcXVlc3RVcmxJbnRlcm5hbChodHRwT3B0aW9ucykge1xuICAgICAgICBpZiAoIWh0dHBPcHRpb25zIHx8XG4gICAgICAgICAgICBodHRwT3B0aW9ucy5iYXNlVXJsID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIGh0dHBPcHRpb25zLmFwaVZlcnNpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIVFRQIG9wdGlvbnMgYXJlIG5vdCBjb3JyZWN0bHkgc2V0LicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJhc2VVcmwgPSBodHRwT3B0aW9ucy5iYXNlVXJsLmVuZHNXaXRoKCcvJylcbiAgICAgICAgICAgID8gaHR0cE9wdGlvbnMuYmFzZVVybC5zbGljZSgwLCAtMSlcbiAgICAgICAgICAgIDogaHR0cE9wdGlvbnMuYmFzZVVybDtcbiAgICAgICAgY29uc3QgdXJsRWxlbWVudCA9IFtiYXNlVXJsXTtcbiAgICAgICAgaWYgKGh0dHBPcHRpb25zLmFwaVZlcnNpb24gJiYgaHR0cE9wdGlvbnMuYXBpVmVyc2lvbiAhPT0gJycpIHtcbiAgICAgICAgICAgIHVybEVsZW1lbnQucHVzaChodHRwT3B0aW9ucy5hcGlWZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsRWxlbWVudC5qb2luKCcvJyk7XG4gICAgfVxuICAgIGdldEJhc2VSZXNvdXJjZVBhdGgoKSB7XG4gICAgICAgIHJldHVybiBgcHJvamVjdHMvJHt0aGlzLmNsaWVudE9wdGlvbnMucHJvamVjdH0vbG9jYXRpb25zLyR7dGhpcy5jbGllbnRPcHRpb25zLmxvY2F0aW9ufWA7XG4gICAgfVxuICAgIGdldEFwaUtleSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50T3B0aW9ucy5hcGlLZXk7XG4gICAgfVxuICAgIGdldFdlYnNvY2tldEJhc2VVcmwoKSB7XG4gICAgICAgIGNvbnN0IGJhc2VVcmwgPSB0aGlzLmdldEJhc2VVcmwoKTtcbiAgICAgICAgY29uc3QgdXJsUGFydHMgPSBuZXcgVVJMKGJhc2VVcmwpO1xuICAgICAgICB1cmxQYXJ0cy5wcm90b2NvbCA9IHVybFBhcnRzLnByb3RvY29sID09ICdodHRwOicgPyAnd3MnIDogJ3dzcyc7XG4gICAgICAgIHJldHVybiB1cmxQYXJ0cy50b1N0cmluZygpO1xuICAgIH1cbiAgICBzZXRCYXNlVXJsKHVybCkge1xuICAgICAgICBpZiAodGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMuYmFzZVVybCA9IHVybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSFRUUCBvcHRpb25zIGFyZSBub3QgY29ycmVjdGx5IHNldC4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdHJ1Y3RVcmwocGF0aCwgaHR0cE9wdGlvbnMsIHByZXBlbmRQcm9qZWN0TG9jYXRpb24pIHtcbiAgICAgICAgY29uc3QgdXJsRWxlbWVudCA9IFt0aGlzLmdldFJlcXVlc3RVcmxJbnRlcm5hbChodHRwT3B0aW9ucyldO1xuICAgICAgICBpZiAocHJlcGVuZFByb2plY3RMb2NhdGlvbikge1xuICAgICAgICAgICAgdXJsRWxlbWVudC5wdXNoKHRoaXMuZ2V0QmFzZVJlc291cmNlUGF0aCgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aCAhPT0gJycpIHtcbiAgICAgICAgICAgIHVybEVsZW1lbnQucHVzaChwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGAke3VybEVsZW1lbnQuam9pbignLycpfWApO1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICBzaG91bGRQcmVwZW5kVmVydGV4UHJvamVjdFBhdGgocmVxdWVzdCkge1xuICAgICAgICBpZiAodGhpcy5jbGllbnRPcHRpb25zLmFwaUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jbGllbnRPcHRpb25zLnZlcnRleGFpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcXVlc3QucGF0aC5zdGFydHNXaXRoKCdwcm9qZWN0cy8nKSkge1xuICAgICAgICAgICAgLy8gQXNzdW1lIHRoZSBwYXRoIGFscmVhZHkgc3RhcnRzIHdpdGhcbiAgICAgICAgICAgIC8vIGBwcm9qZWN0cy88cHJvamVjdD4vbG9jYXRpb24vPGxvY2F0aW9uPmAuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcXVlc3QuaHR0cE1ldGhvZCA9PT0gJ0dFVCcgJiZcbiAgICAgICAgICAgIHJlcXVlc3QucGF0aC5zdGFydHNXaXRoKCdwdWJsaXNoZXJzL2dvb2dsZS9tb2RlbHMnKSkge1xuICAgICAgICAgICAgLy8gVGhlc2UgcGF0aHMgYXJlIHVzZWQgYnkgVmVydGV4J3MgbW9kZWxzLmdldCBhbmQgbW9kZWxzLmxpc3RcbiAgICAgICAgICAgIC8vIGNhbGxzLiBGb3IgYmFzZSBtb2RlbHMgVmVydGV4IGRvZXMgbm90IGFjY2VwdCBhIHByb2plY3QvbG9jYXRpb25cbiAgICAgICAgICAgIC8vIHByZWZpeCAoZm9yIHR1bmVkIG1vZGVsIHRoZSBwcmVmaXggaXMgcmVxdWlyZWQpLlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBhc3luYyByZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICAgICAgbGV0IHBhdGNoZWRIdHRwT3B0aW9ucyA9IHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucztcbiAgICAgICAgaWYgKHJlcXVlc3QuaHR0cE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHBhdGNoZWRIdHRwT3B0aW9ucyA9IHRoaXMucGF0Y2hIdHRwT3B0aW9ucyh0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMsIHJlcXVlc3QuaHR0cE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXBlbmRQcm9qZWN0TG9jYXRpb24gPSB0aGlzLnNob3VsZFByZXBlbmRWZXJ0ZXhQcm9qZWN0UGF0aChyZXF1ZXN0KTtcbiAgICAgICAgY29uc3QgdXJsID0gdGhpcy5jb25zdHJ1Y3RVcmwocmVxdWVzdC5wYXRoLCBwYXRjaGVkSHR0cE9wdGlvbnMsIHByZXBlbmRQcm9qZWN0TG9jYXRpb24pO1xuICAgICAgICBpZiAocmVxdWVzdC5xdWVyeVBhcmFtcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocmVxdWVzdC5xdWVyeVBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIFN0cmluZyh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCByZXF1ZXN0SW5pdCA9IHt9O1xuICAgICAgICBpZiAocmVxdWVzdC5odHRwTWV0aG9kID09PSAnR0VUJykge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3QuYm9keSAmJiByZXF1ZXN0LmJvZHkgIT09ICd7fScpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVlc3QgYm9keSBzaG91bGQgYmUgZW1wdHkgZm9yIEdFVCByZXF1ZXN0LCBidXQgZ290IG5vbiBlbXB0eSByZXF1ZXN0IGJvZHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcXVlc3RJbml0LmJvZHkgPSByZXF1ZXN0LmJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdEluaXQgPSBhd2FpdCB0aGlzLmluY2x1ZGVFeHRyYUh0dHBPcHRpb25zVG9SZXF1ZXN0SW5pdChyZXF1ZXN0SW5pdCwgcGF0Y2hlZEh0dHBPcHRpb25zLCB1cmwudG9TdHJpbmcoKSwgcmVxdWVzdC5hYm9ydFNpZ25hbCk7XG4gICAgICAgIHJldHVybiB0aGlzLnVuYXJ5QXBpQ2FsbCh1cmwsIHJlcXVlc3RJbml0LCByZXF1ZXN0Lmh0dHBNZXRob2QpO1xuICAgIH1cbiAgICBwYXRjaEh0dHBPcHRpb25zKGJhc2VIdHRwT3B0aW9ucywgcmVxdWVzdEh0dHBPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHBhdGNoZWRIdHRwT3B0aW9ucyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYmFzZUh0dHBPcHRpb25zKSk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHJlcXVlc3RIdHRwT3B0aW9ucykpIHtcbiAgICAgICAgICAgIC8vIFJlY29yZHMgY29tcGlsZSB0byBvYmplY3RzLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRTMjM0NVRTNzA1MzogRWxlbWVudCBpbXBsaWNpdGx5IGhhcyBhbiAnYW55JyB0eXBlXG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBleHByZXNzaW9uIG9mIHR5cGUgJ3N0cmluZycgY2FuJ3QgYmUgdXNlZCB0byBpbmRleCB0eXBlXG4gICAgICAgICAgICAgICAgLy8gJ0h0dHBPcHRpb25zJy5cbiAgICAgICAgICAgICAgICBwYXRjaGVkSHR0cE9wdGlvbnNba2V5XSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGF0Y2hlZEh0dHBPcHRpb25zW2tleV0pLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUUzIzNDVUUzcwNTM6IEVsZW1lbnQgaW1wbGljaXRseSBoYXMgYW4gJ2FueScgdHlwZVxuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgZXhwcmVzc2lvbiBvZiB0eXBlICdzdHJpbmcnIGNhbid0IGJlIHVzZWQgdG8gaW5kZXggdHlwZVxuICAgICAgICAgICAgICAgIC8vICdIdHRwT3B0aW9ucycuXG4gICAgICAgICAgICAgICAgcGF0Y2hlZEh0dHBPcHRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0Y2hlZEh0dHBPcHRpb25zO1xuICAgIH1cbiAgICBhc3luYyByZXF1ZXN0U3RyZWFtKHJlcXVlc3QpIHtcbiAgICAgICAgbGV0IHBhdGNoZWRIdHRwT3B0aW9ucyA9IHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucztcbiAgICAgICAgaWYgKHJlcXVlc3QuaHR0cE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHBhdGNoZWRIdHRwT3B0aW9ucyA9IHRoaXMucGF0Y2hIdHRwT3B0aW9ucyh0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMsIHJlcXVlc3QuaHR0cE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXBlbmRQcm9qZWN0TG9jYXRpb24gPSB0aGlzLnNob3VsZFByZXBlbmRWZXJ0ZXhQcm9qZWN0UGF0aChyZXF1ZXN0KTtcbiAgICAgICAgY29uc3QgdXJsID0gdGhpcy5jb25zdHJ1Y3RVcmwocmVxdWVzdC5wYXRoLCBwYXRjaGVkSHR0cE9wdGlvbnMsIHByZXBlbmRQcm9qZWN0TG9jYXRpb24pO1xuICAgICAgICBpZiAoIXVybC5zZWFyY2hQYXJhbXMuaGFzKCdhbHQnKSB8fCB1cmwuc2VhcmNoUGFyYW1zLmdldCgnYWx0JykgIT09ICdzc2UnKSB7XG4gICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnYWx0JywgJ3NzZScpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXF1ZXN0SW5pdCA9IHt9O1xuICAgICAgICByZXF1ZXN0SW5pdC5ib2R5ID0gcmVxdWVzdC5ib2R5O1xuICAgICAgICByZXF1ZXN0SW5pdCA9IGF3YWl0IHRoaXMuaW5jbHVkZUV4dHJhSHR0cE9wdGlvbnNUb1JlcXVlc3RJbml0KHJlcXVlc3RJbml0LCBwYXRjaGVkSHR0cE9wdGlvbnMsIHVybC50b1N0cmluZygpLCByZXF1ZXN0LmFib3J0U2lnbmFsKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQXBpQ2FsbCh1cmwsIHJlcXVlc3RJbml0LCByZXF1ZXN0Lmh0dHBNZXRob2QpO1xuICAgIH1cbiAgICBhc3luYyBpbmNsdWRlRXh0cmFIdHRwT3B0aW9uc1RvUmVxdWVzdEluaXQocmVxdWVzdEluaXQsIGh0dHBPcHRpb25zLCB1cmwsIGFib3J0U2lnbmFsKSB7XG4gICAgICAgIGlmICgoaHR0cE9wdGlvbnMgJiYgaHR0cE9wdGlvbnMudGltZW91dCkgfHwgYWJvcnRTaWduYWwpIHtcbiAgICAgICAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hbCA9IGFib3J0Q29udHJvbGxlci5zaWduYWw7XG4gICAgICAgICAgICBpZiAoaHR0cE9wdGlvbnMudGltZW91dCAmJiAoaHR0cE9wdGlvbnMgPT09IG51bGwgfHwgaHR0cE9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGh0dHBPcHRpb25zLnRpbWVvdXQpID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IGFib3J0Q29udHJvbGxlci5hYm9ydCgpLCBodHRwT3B0aW9ucy50aW1lb3V0KTtcbiAgICAgICAgICAgICAgICBpZiAodGltZW91dEhhbmRsZSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgdGltZW91dEhhbmRsZS51bnJlZiA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsbCB1bnJlZiB0byBwcmV2ZW50IG5vZGVqcyBwcm9jZXNzIGZyb20gaGFuZ2luZywgc2VlXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvdGltZXJzLmh0bWwjdGltZW91dHVucmVmXG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXRIYW5kbGUudW5yZWYoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWJvcnRTaWduYWwpIHtcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXF1ZXN0SW5pdC5zaWduYWwgPSBzaWduYWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGh0dHBPcHRpb25zICYmIGh0dHBPcHRpb25zLmV4dHJhQm9keSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5jbHVkZUV4dHJhQm9keVRvUmVxdWVzdEluaXQocmVxdWVzdEluaXQsIGh0dHBPcHRpb25zLmV4dHJhQm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdEluaXQuaGVhZGVycyA9IGF3YWl0IHRoaXMuZ2V0SGVhZGVyc0ludGVybmFsKGh0dHBPcHRpb25zLCB1cmwpO1xuICAgICAgICByZXR1cm4gcmVxdWVzdEluaXQ7XG4gICAgfVxuICAgIGFzeW5jIHVuYXJ5QXBpQ2FsbCh1cmwsIHJlcXVlc3RJbml0LCBodHRwTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwaUNhbGwodXJsLnRvU3RyaW5nKCksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdEluaXQpLCB7IG1ldGhvZDogaHR0cE1ldGhvZCB9KSlcbiAgICAgICAgICAgIC50aGVuKGFzeW5jIChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgdGhyb3dFcnJvcklmTm90T0socmVzcG9uc2UpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBIdHRwUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeShlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBzdHJlYW1BcGlDYWxsKHVybCwgcmVxdWVzdEluaXQsIGh0dHBNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2FsbCh1cmwudG9TdHJpbmcoKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0SW5pdCksIHsgbWV0aG9kOiBodHRwTWV0aG9kIH0pKVxuICAgICAgICAgICAgLnRoZW4oYXN5bmMgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aHJvd0Vycm9ySWZOb3RPSyhyZXNwb25zZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzU3RyZWFtUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeShlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwcm9jZXNzU3RyZWFtUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiBwcm9jZXNzU3RyZWFtUmVzcG9uc2VfMSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IChfYSA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5ib2R5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0UmVhZGVyKCk7XG4gICAgICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcpO1xuICAgICAgICAgICAgaWYgKCFyZWFkZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc3BvbnNlIGJvZHkgaXMgZW1wdHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IGJ1ZmZlciA9ICcnO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IHlpZWxkIF9fYXdhaXQocmVhZGVyLnJlYWQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVyLnRyaW0oKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvbXBsZXRlIEpTT04gc2VnbWVudCBhdCB0aGUgZW5kJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVua1N0cmluZyA9IGRlY29kZXIuZGVjb2RlKHZhbHVlLCB7IHN0cmVhbTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgYW5kIHRocm93IGFuIGVycm9yIGlmIHRoZSBjaHVuayBjb250YWlucyBhbiBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rSnNvbiA9IEpTT04ucGFyc2UoY2h1bmtTdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCdlcnJvcicgaW4gY2h1bmtKc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JKc29uID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjaHVua0pzb25bJ2Vycm9yJ10pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXMgPSBlcnJvckpzb25bJ3N0YXR1cyddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBlcnJvckpzb25bJ2NvZGUnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgZ290IHN0YXR1czogJHtzdGF0dXN9LiAke0pTT04uc3RyaW5naWZ5KGNodW5rSnNvbil9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSA+PSA0MDAgJiYgY29kZSA8IDYwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhcGlFcnJvciA9IG5ldyBBcGlFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvck1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IGNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBhcGlFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5uYW1lID09PSAnQXBpRXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBidWZmZXIgKz0gY2h1bmtTdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IGJ1ZmZlci5tYXRjaChyZXNwb25zZUxpbmVSRSk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkQ2h1bmtTdHJpbmcgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFydGlhbFJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKHByb2Nlc3NlZENodW5rU3RyaW5nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQobmV3IEh0dHBSZXNwb25zZShwYXJ0aWFsUmVzcG9uc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UobWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IGJ1ZmZlci5tYXRjaChyZXNwb25zZUxpbmVSRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhjZXB0aW9uIHBhcnNpbmcgc3RyZWFtIGNodW5rICR7cHJvY2Vzc2VkQ2h1bmtTdHJpbmd9LiAke2V9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGFwaUNhbGwodXJsLCByZXF1ZXN0SW5pdCkge1xuICAgICAgICByZXR1cm4gZmV0Y2godXJsLCByZXF1ZXN0SW5pdCkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhjZXB0aW9uICR7ZX0gc2VuZGluZyByZXF1ZXN0YCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXREZWZhdWx0SGVhZGVycygpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgICAgICBjb25zdCB2ZXJzaW9uSGVhZGVyVmFsdWUgPSBMSUJSQVJZX0xBQkVMICsgJyAnICsgdGhpcy5jbGllbnRPcHRpb25zLnVzZXJBZ2VudEV4dHJhO1xuICAgICAgICBoZWFkZXJzW1VTRVJfQUdFTlRfSEVBREVSXSA9IHZlcnNpb25IZWFkZXJWYWx1ZTtcbiAgICAgICAgaGVhZGVyc1tHT09HTEVfQVBJX0NMSUVOVF9IRUFERVJdID0gdmVyc2lvbkhlYWRlclZhbHVlO1xuICAgICAgICBoZWFkZXJzW0NPTlRFTlRfVFlQRV9IRUFERVJdID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG4gICAgYXN5bmMgZ2V0SGVhZGVyc0ludGVybmFsKGh0dHBPcHRpb25zLCB1cmwpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgICAgIGlmIChodHRwT3B0aW9ucyAmJiBodHRwT3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhodHRwT3B0aW9ucy5oZWFkZXJzKSkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQXBwZW5kIGEgdGltZW91dCBoZWFkZXIgaWYgaXQgaXMgc2V0LCBub3RlIHRoYXQgdGhlIHRpbWVvdXQgb3B0aW9uIGlzXG4gICAgICAgICAgICAvLyBpbiBtaWxsaXNlY29uZHMgYnV0IHRoZSBoZWFkZXIgaXMgaW4gc2Vjb25kcy5cbiAgICAgICAgICAgIGlmIChodHRwT3B0aW9ucy50aW1lb3V0ICYmIGh0dHBPcHRpb25zLnRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVycy5hcHBlbmQoU0VSVkVSX1RJTUVPVVRfSEVBREVSLCBTdHJpbmcoTWF0aC5jZWlsKGh0dHBPcHRpb25zLnRpbWVvdXQgLyAxMDAwKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuY2xpZW50T3B0aW9ucy5hdXRoLmFkZEF1dGhIZWFkZXJzKGhlYWRlcnMsIHVybCk7XG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH1cbiAgICBnZXRGaWxlTmFtZShmaWxlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGZpbGVOYW1lID0gJyc7XG4gICAgICAgIGlmICh0eXBlb2YgZmlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGZpbGVOYW1lID0gZmlsZS5yZXBsYWNlKC9bL1xcXFxdKyQvLCAnJyk7XG4gICAgICAgICAgICBmaWxlTmFtZSA9IChfYSA9IGZpbGVOYW1lLnNwbGl0KC9bL1xcXFxdLykucG9wKCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWxlTmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBsb2FkcyBhIGZpbGUgYXN5bmNocm9ub3VzbHkgdXNpbmcgR2VtaW5pIEFQSSBvbmx5LCB0aGlzIGlzIG5vdCBzdXBwb3J0ZWRcbiAgICAgKiBpbiBWZXJ0ZXggQUkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlsZSBUaGUgc3RyaW5nIHBhdGggdG8gdGhlIGZpbGUgdG8gYmUgdXBsb2FkZWQgb3IgYSBCbG9iIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gY29uZmlnIE9wdGlvbmFsIHBhcmFtZXRlcnMgc3BlY2lmaWVkIGluIHRoZSBgVXBsb2FkRmlsZUNvbmZpZ2BcbiAgICAgKiAgICAgaW50ZXJmYWNlLiBAc2VlIHtAbGluayB0eXBlcy5VcGxvYWRGaWxlQ29uZmlnfVxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmlsZWAgb2JqZWN0LlxuICAgICAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgY2FsbGVkIG9uIGEgVmVydGV4IEFJIGNsaWVudC5cbiAgICAgKiBAdGhyb3dzIEFuIGVycm9yIGlmIHRoZSBgbWltZVR5cGVgIGlzIG5vdCBwcm92aWRlZCBhbmQgY2FuIG5vdCBiZSBpbmZlcnJlZCxcbiAgICAgKi9cbiAgICBhc3luYyB1cGxvYWRGaWxlKGZpbGUsIGNvbmZpZykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGZpbGVUb1VwbG9hZCA9IHt9O1xuICAgICAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZpbGVUb1VwbG9hZC5taW1lVHlwZSA9IGNvbmZpZy5taW1lVHlwZTtcbiAgICAgICAgICAgIGZpbGVUb1VwbG9hZC5uYW1lID0gY29uZmlnLm5hbWU7XG4gICAgICAgICAgICBmaWxlVG9VcGxvYWQuZGlzcGxheU5hbWUgPSBjb25maWcuZGlzcGxheU5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbGVUb1VwbG9hZC5uYW1lICYmICFmaWxlVG9VcGxvYWQubmFtZS5zdGFydHNXaXRoKCdmaWxlcy8nKSkge1xuICAgICAgICAgICAgZmlsZVRvVXBsb2FkLm5hbWUgPSBgZmlsZXMvJHtmaWxlVG9VcGxvYWQubmFtZX1gO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVwbG9hZGVyID0gdGhpcy5jbGllbnRPcHRpb25zLnVwbG9hZGVyO1xuICAgICAgICBjb25zdCBmaWxlU3RhdCA9IGF3YWl0IHVwbG9hZGVyLnN0YXQoZmlsZSk7XG4gICAgICAgIGZpbGVUb1VwbG9hZC5zaXplQnl0ZXMgPSBTdHJpbmcoZmlsZVN0YXQuc2l6ZSk7XG4gICAgICAgIGNvbnN0IG1pbWVUeXBlID0gKF9hID0gY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLm1pbWVUeXBlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmaWxlU3RhdC50eXBlO1xuICAgICAgICBpZiAobWltZVR5cGUgPT09IHVuZGVmaW5lZCB8fCBtaW1lVHlwZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBkZXRlcm1pbmUgbWltZVR5cGUuIFBsZWFzZSBwcm92aWRlIG1pbWVUeXBlIGluIHRoZSBjb25maWcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZmlsZVRvVXBsb2FkLm1pbWVUeXBlID0gbWltZVR5cGU7XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBmaWxlOiBmaWxlVG9VcGxvYWQsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGZpbGVOYW1lID0gdGhpcy5nZXRGaWxlTmFtZShmaWxlKTtcbiAgICAgICAgY29uc3QgcGF0aCA9IGZvcm1hdE1hcCgndXBsb2FkL3YxYmV0YS9maWxlcycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgIGNvbnN0IHVwbG9hZFVybCA9IGF3YWl0IHRoaXMuZmV0Y2hVcGxvYWRVcmwocGF0aCwgZmlsZVRvVXBsb2FkLnNpemVCeXRlcywgZmlsZVRvVXBsb2FkLm1pbWVUeXBlLCBmaWxlTmFtZSwgYm9keSwgY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmh0dHBPcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHVwbG9hZGVyLnVwbG9hZChmaWxlLCB1cGxvYWRVcmwsIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIGEgZmlsZSB0byBhIGdpdmVuIGZpbGUgc2VhcmNoIHN0b3JlIGFzeW5jaHJvbm91c2x5IHVzaW5nIEdlbWluaSBBUEkgb25seSwgdGhpcyBpcyBub3Qgc3VwcG9ydGVkXG4gICAgICogaW4gVmVydGV4IEFJLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZpbGVTZWFyY2hTdG9yZU5hbWUgVGhlIG5hbWUgb2YgdGhlIGZpbGUgc2VhcmNoIHN0b3JlIHRvIHVwbG9hZCB0aGUgZmlsZSB0by5cbiAgICAgKiBAcGFyYW0gZmlsZSBUaGUgc3RyaW5nIHBhdGggdG8gdGhlIGZpbGUgdG8gYmUgdXBsb2FkZWQgb3IgYSBCbG9iIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gY29uZmlnIE9wdGlvbmFsIHBhcmFtZXRlcnMgc3BlY2lmaWVkIGluIHRoZSBgVXBsb2FkRmlsZUNvbmZpZ2BcbiAgICAgKiAgICAgaW50ZXJmYWNlLiBAc2VlIHtAbGluayBVcGxvYWRGaWxlQ29uZmlnfVxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmlsZWAgb2JqZWN0LlxuICAgICAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgY2FsbGVkIG9uIGEgVmVydGV4IEFJIGNsaWVudC5cbiAgICAgKiBAdGhyb3dzIEFuIGVycm9yIGlmIHRoZSBgbWltZVR5cGVgIGlzIG5vdCBwcm92aWRlZCBhbmQgY2FuIG5vdCBiZSBpbmZlcnJlZCxcbiAgICAgKi9cbiAgICBhc3luYyB1cGxvYWRGaWxlVG9GaWxlU2VhcmNoU3RvcmUoZmlsZVNlYXJjaFN0b3JlTmFtZSwgZmlsZSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgdXBsb2FkZXIgPSB0aGlzLmNsaWVudE9wdGlvbnMudXBsb2FkZXI7XG4gICAgICAgIGNvbnN0IGZpbGVTdGF0ID0gYXdhaXQgdXBsb2FkZXIuc3RhdChmaWxlKTtcbiAgICAgICAgY29uc3Qgc2l6ZUJ5dGVzID0gU3RyaW5nKGZpbGVTdGF0LnNpemUpO1xuICAgICAgICBjb25zdCBtaW1lVHlwZSA9IChfYSA9IGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5taW1lVHlwZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmlsZVN0YXQudHlwZTtcbiAgICAgICAgaWYgKG1pbWVUeXBlID09PSB1bmRlZmluZWQgfHwgbWltZVR5cGUgPT09ICcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgZGV0ZXJtaW5lIG1pbWVUeXBlLiBQbGVhc2UgcHJvdmlkZSBtaW1lVHlwZSBpbiB0aGUgY29uZmlnLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhdGggPSBgdXBsb2FkL3YxYmV0YS8ke2ZpbGVTZWFyY2hTdG9yZU5hbWV9OnVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlYDtcbiAgICAgICAgY29uc3QgZmlsZU5hbWUgPSB0aGlzLmdldEZpbGVOYW1lKGZpbGUpO1xuICAgICAgICBjb25zdCBib2R5ID0ge307XG4gICAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVDb25maWdUb01sZGV2KGNvbmZpZywgYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXBsb2FkVXJsID0gYXdhaXQgdGhpcy5mZXRjaFVwbG9hZFVybChwYXRoLCBzaXplQnl0ZXMsIG1pbWVUeXBlLCBmaWxlTmFtZSwgYm9keSwgY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmh0dHBPcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHVwbG9hZGVyLnVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlKGZpbGUsIHVwbG9hZFVybCwgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERvd25sb2FkcyBhIGZpbGUgYXN5bmNocm9ub3VzbHkgdG8gdGhlIHNwZWNpZmllZCBwYXRoLlxuICAgICAqXG4gICAgICogQHBhcmFtcyBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGRvd25sb2FkIHJlcXVlc3QsIHNlZSB7QGxpbmtcbiAgICAgKiB0eXBlcy5Eb3dubG9hZEZpbGVQYXJhbWV0ZXJzfVxuICAgICAqL1xuICAgIGFzeW5jIGRvd25sb2FkRmlsZShwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgZG93bmxvYWRlciA9IHRoaXMuY2xpZW50T3B0aW9ucy5kb3dubG9hZGVyO1xuICAgICAgICBhd2FpdCBkb3dubG9hZGVyLmRvd25sb2FkKHBhcmFtcywgdGhpcyk7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoVXBsb2FkVXJsKHBhdGgsIHNpemVCeXRlcywgbWltZVR5cGUsIGZpbGVOYW1lLCBib2R5LCBjb25maWdIdHRwT3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBodHRwT3B0aW9ucyA9IHt9O1xuICAgICAgICBpZiAoY29uZmlnSHR0cE9wdGlvbnMpIHtcbiAgICAgICAgICAgIGh0dHBPcHRpb25zID0gY29uZmlnSHR0cE9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBodHRwT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBhcGlWZXJzaW9uOiAnJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJywgJ1gtR29vZy1VcGxvYWQtUHJvdG9jb2wnOiAncmVzdW1hYmxlJywgJ1gtR29vZy1VcGxvYWQtQ29tbWFuZCc6ICdzdGFydCcsICdYLUdvb2ctVXBsb2FkLUhlYWRlci1Db250ZW50LUxlbmd0aCc6IGAke3NpemVCeXRlc31gLCAnWC1Hb29nLVVwbG9hZC1IZWFkZXItQ29udGVudC1UeXBlJzogYCR7bWltZVR5cGV9YCB9LCAoZmlsZU5hbWUgPyB7ICdYLUdvb2ctVXBsb2FkLUZpbGUtTmFtZSc6IGZpbGVOYW1lIH0gOiB7fSkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBodHRwUmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaHR0cE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWh0dHBSZXNwb25zZSB8fCAhKGh0dHBSZXNwb25zZSA9PT0gbnVsbCB8fCBodHRwUmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGh0dHBSZXNwb25zZS5oZWFkZXJzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXJ2ZXIgZGlkIG5vdCByZXR1cm4gYW4gSHR0cFJlc3BvbnNlIG9yIHRoZSByZXR1cm5lZCBIdHRwUmVzcG9uc2UgZGlkIG5vdCBoYXZlIGhlYWRlcnMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXBsb2FkVXJsID0gKF9hID0gaHR0cFJlc3BvbnNlID09PSBudWxsIHx8IGh0dHBSZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaHR0cFJlc3BvbnNlLmhlYWRlcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVsneC1nb29nLXVwbG9hZC11cmwnXTtcbiAgICAgICAgaWYgKHVwbG9hZFVybCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZXQgdXBsb2FkIHVybC4gU2VydmVyIGRpZCBub3QgcmV0dXJuIHRoZSB4LWdvb2dsZS11cGxvYWQtdXJsIGluIHRoZSBoZWFkZXJzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVwbG9hZFVybDtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiB0aHJvd0Vycm9ySWZOb3RPSyhyZXNwb25zZSkge1xuICAgIHZhciBfYTtcbiAgICBpZiAocmVzcG9uc2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Jlc3BvbnNlIGlzIHVuZGVmaW5lZCcpO1xuICAgIH1cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1cztcbiAgICAgICAgbGV0IGVycm9yQm9keTtcbiAgICAgICAgaWYgKChfYSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluY2x1ZGVzKCdhcHBsaWNhdGlvbi9qc29uJykpIHtcbiAgICAgICAgICAgIGVycm9yQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yQm9keSA9IHtcbiAgICAgICAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBhd2FpdCByZXNwb25zZS50ZXh0KCksXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IEpTT04uc3RyaW5naWZ5KGVycm9yQm9keSk7XG4gICAgICAgIGlmIChzdGF0dXMgPj0gNDAwICYmIHN0YXR1cyA8IDYwMCkge1xuICAgICAgICAgICAgY29uc3QgYXBpRXJyb3IgPSBuZXcgQXBpRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yTWVzc2FnZSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhyb3cgYXBpRXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgfVxufVxuLyoqXG4gKiBSZWN1cnNpdmVseSB1cGRhdGVzIHRoZSBgcmVxdWVzdEluaXQuYm9keWAgd2l0aCB2YWx1ZXMgZnJvbSBhbiBgZXh0cmFCb2R5YCBvYmplY3QuXG4gKlxuICogSWYgYHJlcXVlc3RJbml0LmJvZHlgIGlzIGEgc3RyaW5nLCBpdCdzIGFzc3VtZWQgdG8gYmUgSlNPTiBhbmQgd2lsbCBiZSBwYXJzZWQuXG4gKiBUaGUgYGV4dHJhQm9keWAgaXMgdGhlbiBkZWVwbHkgbWVyZ2VkIGludG8gdGhpcyBwYXJzZWQgb2JqZWN0LlxuICogSWYgYHJlcXVlc3RJbml0LmJvZHlgIGlzIGEgQmxvYiwgYGV4dHJhQm9keWAgd2lsbCBiZSBpZ25vcmVkLCBhbmQgYSB3YXJuaW5nIGxvZ2dlZCxcbiAqIGFzIG1lcmdpbmcgc3RydWN0dXJlZCBkYXRhIGludG8gYW4gb3BhcXVlIEJsb2IgaXMgbm90IHN1cHBvcnRlZC5cbiAqXG4gKiBUaGUgZnVuY3Rpb24gZG9lcyBub3QgZW5mb3JjZSB0aGF0IHVwZGF0ZWQgdmFsdWVzIGZyb20gYGV4dHJhQm9keWAgaGF2ZSB0aGVcbiAqIHNhbWUgdHlwZSBhcyBleGlzdGluZyB2YWx1ZXMgaW4gYHJlcXVlc3RJbml0LmJvZHlgLiBUeXBlIG1pc21hdGNoZXMgZHVyaW5nXG4gKiB0aGUgbWVyZ2Ugd2lsbCByZXN1bHQgaW4gYSB3YXJuaW5nLCBidXQgdGhlIHZhbHVlIGZyb20gYGV4dHJhQm9keWAgd2lsbCBvdmVyd3JpdGVcbiAqIHRoZSBvcmlnaW5hbC4gYGV4dHJhQm9keWAgdXNlcnMgYXJlIHJlc3BvbnNpYmxlIGZvciBlbnN1cmluZyBgZXh0cmFCb2R5YCBoYXMgdGhlIGNvcnJlY3Qgc3RydWN0dXJlLlxuICpcbiAqIEBwYXJhbSByZXF1ZXN0SW5pdCBUaGUgUmVxdWVzdEluaXQgb2JqZWN0IHdob3NlIGJvZHkgd2lsbCBiZSB1cGRhdGVkLlxuICogQHBhcmFtIGV4dHJhQm9keSBUaGUgb2JqZWN0IGNvbnRhaW5pbmcgdXBkYXRlcyB0byBiZSBtZXJnZWQgaW50byBgcmVxdWVzdEluaXQuYm9keWAuXG4gKi9cbmZ1bmN0aW9uIGluY2x1ZGVFeHRyYUJvZHlUb1JlcXVlc3RJbml0KHJlcXVlc3RJbml0LCBleHRyYUJvZHkpIHtcbiAgICBpZiAoIWV4dHJhQm9keSB8fCBPYmplY3Qua2V5cyhleHRyYUJvZHkpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChyZXF1ZXN0SW5pdC5ib2R5IGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ2luY2x1ZGVFeHRyYUJvZHlUb1JlcXVlc3RJbml0OiBleHRyYUJvZHkgcHJvdmlkZWQgYnV0IGN1cnJlbnQgcmVxdWVzdCBib2R5IGlzIGEgQmxvYi4gZXh0cmFCb2R5IHdpbGwgYmUgaWdub3JlZCBhcyBtZXJnaW5nIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIEJsb2IgYm9kaWVzLicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBjdXJyZW50Qm9keU9iamVjdCA9IHt9O1xuICAgIC8vIElmIGFkZGluZyBuZXcgdHlwZSB0byBIdHRwUmVxdWVzdC5ib2R5LCBwbGVhc2UgY2hlY2sgdGhlIGNvZGUgYmVsb3cgdG9cbiAgICAvLyBzZWUgaWYgd2UgbmVlZCB0byB1cGRhdGUgdGhlIGxvZ2ljLlxuICAgIGlmICh0eXBlb2YgcmVxdWVzdEluaXQuYm9keSA9PT0gJ3N0cmluZycgJiYgcmVxdWVzdEluaXQuYm9keS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRCb2R5ID0gSlNPTi5wYXJzZShyZXF1ZXN0SW5pdC5ib2R5KTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyc2VkQm9keSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICBwYXJzZWRCb2R5ICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkocGFyc2VkQm9keSkpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qm9keU9iamVjdCA9IHBhcnNlZEJvZHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2luY2x1ZGVFeHRyYUJvZHlUb1JlcXVlc3RJbml0OiBPcmlnaW5hbCByZXF1ZXN0IGJvZHkgaXMgdmFsaWQgSlNPTiBidXQgbm90IGEgbm9uLWFycmF5IG9iamVjdC4gU2tpcCBhcHBseWluZyBleHRyYUJvZHkgdG8gdGhlIHJlcXVlc3QgYm9keS4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiAgZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAqL1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2luY2x1ZGVFeHRyYUJvZHlUb1JlcXVlc3RJbml0OiBPcmlnaW5hbCByZXF1ZXN0IGJvZHkgaXMgbm90IHZhbGlkIEpTT04uIFNraXAgYXBwbHlpbmcgZXh0cmFCb2R5IHRvIHRoZSByZXF1ZXN0IGJvZHkuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGVlcE1lcmdlKHRhcmdldCwgc291cmNlKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IE9iamVjdC5hc3NpZ24oe30sIHRhcmdldCk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldFZhbHVlID0gb3V0cHV0W2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZVZhbHVlICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBzb3VyY2VWYWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkoc291cmNlVmFsdWUpICYmXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFZhbHVlICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiB0YXJnZXRWYWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkodGFyZ2V0VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtrZXldID0gZGVlcE1lcmdlKHRhcmdldFZhbHVlLCBzb3VyY2VWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0VmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVZhbHVlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgdGFyZ2V0VmFsdWUgIT09IHR5cGVvZiBzb3VyY2VWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBpbmNsdWRlRXh0cmFCb2R5VG9SZXF1ZXN0SW5pdDpkZWVwTWVyZ2U6IFR5cGUgbWlzbWF0Y2ggZm9yIGtleSBcIiR7a2V5fVwiLiBPcmlnaW5hbCB0eXBlOiAke3R5cGVvZiB0YXJnZXRWYWx1ZX0sIE5ldyB0eXBlOiAke3R5cGVvZiBzb3VyY2VWYWx1ZX0uIE92ZXJ3cml0aW5nLmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtrZXldID0gc291cmNlVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIGNvbnN0IG1lcmdlZEJvZHkgPSBkZWVwTWVyZ2UoY3VycmVudEJvZHlPYmplY3QsIGV4dHJhQm9keSk7XG4gICAgcmVxdWVzdEluaXQuYm9keSA9IEpTT04uc3RyaW5naWZ5KG1lcmdlZEJvZHkpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vLyBUT0RPOiBiLzQxNjA0MTIyOSAtIERldGVybWluZSBob3cgdG8gcmV0cmlldmUgdGhlIE1DUCBwYWNrYWdlIHZlcnNpb24uXG5jb25zdCBNQ1BfTEFCRUwgPSAnbWNwX3VzZWQvdW5rbm93bic7XG4vLyBXaGV0aGVyIE1DUCB0b29sIHVzYWdlIGlzIGRldGVjdGVkIGZyb20gbWNwVG9Ub29sLiBUaGlzIGlzIHVzZWQgZm9yXG4vLyB0ZWxlbWV0cnkuXG5sZXQgaGFzTWNwVG9vbFVzYWdlRnJvbU1jcFRvVG9vbCA9IGZhbHNlO1xuLy8gQ2hlY2tzIHdoZXRoZXIgdGhlIGxpc3Qgb2YgdG9vbHMgY29udGFpbnMgYW55IE1DUCB0b29scy5cbmZ1bmN0aW9uIGhhc01jcFRvb2xVc2FnZSh0b29scykge1xuICAgIGZvciAoY29uc3QgdG9vbCBvZiB0b29scykge1xuICAgICAgICBpZiAoaXNNY3BDYWxsYWJsZVRvb2wodG9vbCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdG9vbCA9PT0gJ29iamVjdCcgJiYgJ2lucHV0U2NoZW1hJyBpbiB0b29sKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGFzTWNwVG9vbFVzYWdlRnJvbU1jcFRvVG9vbDtcbn1cbi8vIFNldHMgdGhlIE1DUCB2ZXJzaW9uIGxhYmVsIGluIHRoZSBHb29nbGUgQVBJIGNsaWVudCBoZWFkZXIuXG5mdW5jdGlvbiBzZXRNY3BVc2FnZUhlYWRlcihoZWFkZXJzKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGV4aXN0aW5nSGVhZGVyID0gKF9hID0gaGVhZGVyc1tHT09HTEVfQVBJX0NMSUVOVF9IRUFERVJdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJztcbiAgICBoZWFkZXJzW0dPT0dMRV9BUElfQ0xJRU5UX0hFQURFUl0gPSAoZXhpc3RpbmdIZWFkZXIgKyBgICR7TUNQX0xBQkVMfWApLnRyaW1TdGFydCgpO1xufVxuLy8gUmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaXMgYSBNQ1AgQ2FsbGFibGVUb29sLCBvdGhlcndpc2UgZmFsc2UuXG5mdW5jdGlvbiBpc01jcENhbGxhYmxlVG9vbChvYmplY3QpIHtcbiAgICByZXR1cm4gKG9iamVjdCAhPT0gbnVsbCAmJlxuICAgICAgICB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBvYmplY3QgaW5zdGFuY2VvZiBNY3BDYWxsYWJsZVRvb2wpO1xufVxuLy8gTGlzdCBhbGwgdG9vbHMgZnJvbSB0aGUgTUNQIGNsaWVudC5cbmZ1bmN0aW9uIGxpc3RBbGxUb29scyhtY3BDbGllbnQsIG1heFRvb2xzID0gMTAwKSB7XG4gICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogbGlzdEFsbFRvb2xzXzEoKSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBudW1Ub29scyA9IDA7XG4gICAgICAgIHdoaWxlIChudW1Ub29scyA8IG1heFRvb2xzKSB7XG4gICAgICAgICAgICBjb25zdCB0ID0geWllbGQgX19hd2FpdChtY3BDbGllbnQubGlzdFRvb2xzKHsgY3Vyc29yIH0pKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdG9vbCBvZiB0LnRvb2xzKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdCh0b29sKTtcbiAgICAgICAgICAgICAgICBudW1Ub29scysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0Lm5leHRDdXJzb3IpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnNvciA9IHQubmV4dEN1cnNvcjtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLyoqXG4gKiBNY3BDYWxsYWJsZVRvb2wgY2FuIGJlIHVzZWQgZm9yIG1vZGVsIGluZmVyZW5jZSBhbmQgaW52b2tpbmcgTUNQIGNsaWVudHMgd2l0aFxuICogZ2l2ZW4gZnVuY3Rpb24gY2FsbCBhcmd1bWVudHMuXG4gKlxuICogQGV4cGVyaW1lbnRhbCBCdWlsdC1pbiBNQ1Agc3VwcG9ydCBpcyBhbiBleHBlcmltZW50YWwgZmVhdHVyZSwgbWF5IGNoYW5nZSBpbiBmdXR1cmVcbiAqIHZlcnNpb25zLlxuICovXG5jbGFzcyBNY3BDYWxsYWJsZVRvb2wge1xuICAgIGNvbnN0cnVjdG9yKG1jcENsaWVudHMgPSBbXSwgY29uZmlnKSB7XG4gICAgICAgIHRoaXMubWNwVG9vbHMgPSBbXTtcbiAgICAgICAgdGhpcy5mdW5jdGlvbk5hbWVUb01jcENsaWVudCA9IHt9O1xuICAgICAgICB0aGlzLm1jcENsaWVudHMgPSBtY3BDbGllbnRzO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIE1jcENhbGxhYmxlVG9vbC5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKG1jcENsaWVudHMsIGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IE1jcENhbGxhYmxlVG9vbChtY3BDbGllbnRzLCBjb25maWcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgdGhlIGZ1bmN0aW9uIG5hbWVzIGFyZSBub3QgZHVwbGljYXRlIGFuZCBpbml0aWFsaXplIHRoZSBmdW5jdGlvblxuICAgICAqIG5hbWUgdG8gTUNQIGNsaWVudCBtYXBwaW5nLlxuICAgICAqXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBNQ1AgdG9vbHMgZnJvbSB0aGUgTUNQIGNsaWVudHMgaGF2ZSBkdXBsaWNhdGUgdG9vbFxuICAgICAqICAgICBuYW1lcy5cbiAgICAgKi9cbiAgICBhc3luYyBpbml0aWFsaXplKCkge1xuICAgICAgICB2YXIgX2EsIGVfMSwgX2IsIF9jO1xuICAgICAgICBpZiAodGhpcy5tY3BUb29scy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnVuY3Rpb25NYXAgPSB7fTtcbiAgICAgICAgY29uc3QgbWNwVG9vbHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBtY3BDbGllbnQgb2YgdGhpcy5tY3BDbGllbnRzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9kID0gdHJ1ZSwgX2UgPSAoZV8xID0gdm9pZCAwLCBfX2FzeW5jVmFsdWVzKGxpc3RBbGxUb29scyhtY3BDbGllbnQpKSksIF9mOyBfZiA9IGF3YWl0IF9lLm5leHQoKSwgX2EgPSBfZi5kb25lLCAhX2E7IF9kID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBfYyA9IF9mLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBfZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtY3BUb29sID0gX2M7XG4gICAgICAgICAgICAgICAgICAgIG1jcFRvb2xzLnB1c2gobWNwVG9vbCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1jcFRvb2xOYW1lID0gbWNwVG9vbC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnVuY3Rpb25NYXBbbWNwVG9vbE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBmdW5jdGlvbiBuYW1lICR7bWNwVG9vbE5hbWV9IGZvdW5kIGluIE1DUCB0b29scy4gUGxlYXNlIGVuc3VyZSBmdW5jdGlvbiBuYW1lcyBhcmUgdW5pcXVlLmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uTWFwW21jcFRvb2xOYW1lXSA9IG1jcENsaWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfZCAmJiAhX2EgJiYgKF9iID0gX2UucmV0dXJuKSkgYXdhaXQgX2IuY2FsbChfZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1jcFRvb2xzID0gbWNwVG9vbHM7XG4gICAgICAgIHRoaXMuZnVuY3Rpb25OYW1lVG9NY3BDbGllbnQgPSBmdW5jdGlvbk1hcDtcbiAgICB9XG4gICAgYXN5bmMgdG9vbCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIHJldHVybiBtY3BUb29sc1RvR2VtaW5pVG9vbCh0aGlzLm1jcFRvb2xzLCB0aGlzLmNvbmZpZyk7XG4gICAgfVxuICAgIGFzeW5jIGNhbGxUb29sKGZ1bmN0aW9uQ2FsbHMpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbFJlc3BvbnNlUGFydHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBmdW5jdGlvbkNhbGwgb2YgZnVuY3Rpb25DYWxscykge1xuICAgICAgICAgICAgaWYgKGZ1bmN0aW9uQ2FsbC5uYW1lIGluIHRoaXMuZnVuY3Rpb25OYW1lVG9NY3BDbGllbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtY3BDbGllbnQgPSB0aGlzLmZ1bmN0aW9uTmFtZVRvTWNwQ2xpZW50W2Z1bmN0aW9uQ2FsbC5uYW1lXTtcbiAgICAgICAgICAgICAgICBsZXQgcmVxdWVzdE9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogYi80MjQyMzg2NTQgLSBBZGQgc3VwcG9ydCBmb3IgZmluZXIgZ3JhaW5lZCB0aW1lb3V0IGNvbnRyb2wuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLnRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0OiB0aGlzLmNvbmZpZy50aW1lb3V0LFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsVG9vbFJlc3BvbnNlID0gYXdhaXQgbWNwQ2xpZW50LmNhbGxUb29sKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZnVuY3Rpb25DYWxsLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogZnVuY3Rpb25DYWxsLmFyZ3MsXG4gICAgICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAgICAgLy8gU2V0IHRoZSByZXN1bHQgc2NoZW1hIHRvIHVuZGVmaW5lZCB0byBhbGxvdyBNQ1AgdG8gcmVseSBvbiB0aGVcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IHNjaGVtYS5cbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsIHJlcXVlc3RPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbkNhbGxSZXNwb25zZVBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBmdW5jdGlvbkNhbGwubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBjYWxsVG9vbFJlc3BvbnNlLmlzRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHsgZXJyb3I6IGNhbGxUb29sUmVzcG9uc2UgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY2FsbFRvb2xSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb25DYWxsUmVzcG9uc2VQYXJ0cztcbiAgICB9XG59XG5mdW5jdGlvbiBpc01jcENsaWVudChjbGllbnQpIHtcbiAgICByZXR1cm4gKGNsaWVudCAhPT0gbnVsbCAmJlxuICAgICAgICB0eXBlb2YgY2xpZW50ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAnbGlzdFRvb2xzJyBpbiBjbGllbnQgJiZcbiAgICAgICAgdHlwZW9mIGNsaWVudC5saXN0VG9vbHMgPT09ICdmdW5jdGlvbicpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgTWNwQ2FsbGFibGVUb29sIGZyb20gTUNQIGNsaWVudHMgYW5kIGFuIG9wdGlvbmFsIGNvbmZpZy5cbiAqXG4gKiBUaGUgY2FsbGFibGUgdG9vbCBjYW4gaW52b2tlIHRoZSBNQ1AgY2xpZW50cyB3aXRoIGdpdmVuIGZ1bmN0aW9uIGNhbGxcbiAqIGFyZ3VtZW50cy4gKG9mdGVuIGZvciBhdXRvbWF0aWMgZnVuY3Rpb24gY2FsbGluZykuXG4gKiBVc2UgdGhlIGNvbmZpZyB0byBtb2RpZnkgdG9vbCBwYXJhbWV0ZXJzIHN1Y2ggYXMgYmVoYXZpb3IuXG4gKlxuICogQGV4cGVyaW1lbnRhbCBCdWlsdC1pbiBNQ1Agc3VwcG9ydCBpcyBhbiBleHBlcmltZW50YWwgZmVhdHVyZSwgbWF5IGNoYW5nZSBpbiBmdXR1cmVcbiAqIHZlcnNpb25zLlxuICovXG5mdW5jdGlvbiBtY3BUb1Rvb2woLi4uYXJncykge1xuICAgIC8vIFNldCBNQ1AgdXNhZ2UgZm9yIHRlbGVtZXRyeS5cbiAgICBoYXNNY3BUb29sVXNhZ2VGcm9tTWNwVG9Ub29sID0gdHJ1ZTtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBNQ1AgY2xpZW50cyBwcm92aWRlZCcpO1xuICAgIH1cbiAgICBjb25zdCBtYXliZUNvbmZpZyA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICBpZiAoaXNNY3BDbGllbnQobWF5YmVDb25maWcpKSB7XG4gICAgICAgIHJldHVybiBNY3BDYWxsYWJsZVRvb2wuY3JlYXRlKGFyZ3MsIHt9KTtcbiAgICB9XG4gICAgcmV0dXJuIE1jcENhbGxhYmxlVG9vbC5jcmVhdGUoYXJncy5zbGljZSgwLCBhcmdzLmxlbmd0aCAtIDEpLCBtYXliZUNvbmZpZyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8qKlxuICogSGFuZGxlcyBpbmNvbWluZyBtZXNzYWdlcyBmcm9tIHRoZSBXZWJTb2NrZXQuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgZnVuY3Rpb24gaXMgcmVzcG9uc2libGUgZm9yIHBhcnNpbmcgaW5jb21pbmcgbWVzc2FnZXMsIHRyYW5zZm9ybWluZyB0aGVtXG4gKiBpbnRvIExpdmVNdXNpY1NlcnZlck1lc3NhZ2UsIGFuZCB0aGVuIGNhbGxpbmcgdGhlIG9ubWVzc2FnZSBjYWxsYmFjay5cbiAqIE5vdGUgdGhhdCB0aGUgZmlyc3QgbWVzc2FnZSB3aGljaCBpcyByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIgaXMgYVxuICogc2V0dXBDb21wbGV0ZSBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSBhcGlDbGllbnQgVGhlIEFwaUNsaWVudCBpbnN0YW5jZS5cbiAqIEBwYXJhbSBvbm1lc3NhZ2UgVGhlIHVzZXItcHJvdmlkZWQgb25tZXNzYWdlIGNhbGxiYWNrIChpZiBhbnkpLlxuICogQHBhcmFtIGV2ZW50IFRoZSBNZXNzYWdlRXZlbnQgZnJvbSB0aGUgV2ViU29ja2V0LlxuICovXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVXZWJTb2NrZXRNZXNzYWdlJDEoYXBpQ2xpZW50LCBvbm1lc3NhZ2UsIGV2ZW50KSB7XG4gICAgY29uc3Qgc2VydmVyTWVzc2FnZSA9IG5ldyBMaXZlTXVzaWNTZXJ2ZXJNZXNzYWdlKCk7XG4gICAgbGV0IGRhdGE7XG4gICAgaWYgKGV2ZW50LmRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGF3YWl0IGV2ZW50LmRhdGEudGV4dCgpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHNlcnZlck1lc3NhZ2UsIGRhdGEpO1xuICAgIG9ubWVzc2FnZShzZXJ2ZXJNZXNzYWdlKTtcbn1cbi8qKlxuICAgTGl2ZU11c2ljIGNsYXNzIGVuY2Fwc3VsYXRlcyB0aGUgY29uZmlndXJhdGlvbiBmb3IgbGl2ZSBtdXNpY1xuICAgZ2VuZXJhdGlvbiB2aWEgTHlyaWEgTGl2ZSBtb2RlbHMuXG5cbiAgIEBleHBlcmltZW50YWxcbiAgKi9cbmNsYXNzIExpdmVNdXNpYyB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50LCBhdXRoLCB3ZWJTb2NrZXRGYWN0b3J5KSB7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgICAgICB0aGlzLmF1dGggPSBhdXRoO1xuICAgICAgICB0aGlzLndlYlNvY2tldEZhY3RvcnkgPSB3ZWJTb2NrZXRGYWN0b3J5O1xuICAgIH1cbiAgICAvKipcbiAgICAgICBFc3RhYmxpc2hlcyBhIGNvbm5lY3Rpb24gdG8gdGhlIHNwZWNpZmllZCBtb2RlbCBhbmQgcmV0dXJucyBhXG4gICAgICAgTGl2ZU11c2ljU2Vzc2lvbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoYXQgY29ubmVjdGlvbi5cbiAgXG4gICAgICAgQGV4cGVyaW1lbnRhbFxuICBcbiAgICAgICBAcmVtYXJrc1xuICBcbiAgICAgICBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGVzdGFibGlzaGluZyBhIGNvbm5lY3Rpb24gdG8gdGhlIG1vZGVsLlxuICAgICAgIEByZXR1cm4gQSBsaXZlIHNlc3Npb24uXG4gIFxuICAgICAgIEBleGFtcGxlXG4gICAgICAgYGBgdHNcbiAgICAgICBsZXQgbW9kZWwgPSAnbW9kZWxzL2x5cmlhLXJlYWx0aW1lLWV4cCc7XG4gICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IGFpLmxpdmUubXVzaWMuY29ubmVjdCh7XG4gICAgICAgICBtb2RlbDogbW9kZWwsXG4gICAgICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgICAgb25tZXNzYWdlOiAoZTogTWVzc2FnZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgY29uc29sZS5sb2coJ1JlY2VpdmVkIG1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyOiAlc1xcbicsIGRlYnVnKGUuZGF0YSkpO1xuICAgICAgICAgICB9LFxuICAgICAgICAgICBvbmVycm9yOiAoZTogRXJyb3JFdmVudCkgPT4ge1xuICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFcnJvciBvY2N1cnJlZDogJXNcXG4nLCBkZWJ1ZyhlLmVycm9yKSk7XG4gICAgICAgICAgIH0sXG4gICAgICAgICAgIG9uY2xvc2U6IChlOiBDbG9zZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgY29uc29sZS5sb2coJ0Nvbm5lY3Rpb24gY2xvc2VkLicpO1xuICAgICAgICAgICB9LFxuICAgICAgICAgfSxcbiAgICAgICB9KTtcbiAgICAgICBgYGBcbiAgICAgICovXG4gICAgYXN5bmMgY29ubmVjdChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMaXZlIG11c2ljIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIFZlcnRleCBBSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLndhcm4oJ0xpdmUgbXVzaWMgZ2VuZXJhdGlvbiBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UgaW4gZnV0dXJlIHZlcnNpb25zLicpO1xuICAgICAgICBjb25zdCB3ZWJzb2NrZXRCYXNlVXJsID0gdGhpcy5hcGlDbGllbnQuZ2V0V2Vic29ja2V0QmFzZVVybCgpO1xuICAgICAgICBjb25zdCBhcGlWZXJzaW9uID0gdGhpcy5hcGlDbGllbnQuZ2V0QXBpVmVyc2lvbigpO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gbWFwVG9IZWFkZXJzJDEodGhpcy5hcGlDbGllbnQuZ2V0RGVmYXVsdEhlYWRlcnMoKSk7XG4gICAgICAgIGNvbnN0IGFwaUtleSA9IHRoaXMuYXBpQ2xpZW50LmdldEFwaUtleSgpO1xuICAgICAgICBjb25zdCB1cmwgPSBgJHt3ZWJzb2NrZXRCYXNlVXJsfS93cy9nb29nbGUuYWkuZ2VuZXJhdGl2ZWxhbmd1YWdlLiR7YXBpVmVyc2lvbn0uR2VuZXJhdGl2ZVNlcnZpY2UuQmlkaUdlbmVyYXRlTXVzaWM/a2V5PSR7YXBpS2V5fWA7XG4gICAgICAgIGxldCBvbm9wZW5SZXNvbHZlID0gKCkgPT4geyB9O1xuICAgICAgICBjb25zdCBvbm9wZW5Qcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIG9ub3BlblJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gcGFyYW1zLmNhbGxiYWNrcztcbiAgICAgICAgY29uc3Qgb25vcGVuQXdhaXRlZENhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb25vcGVuUmVzb2x2ZSh7fSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFwaUNsaWVudCA9IHRoaXMuYXBpQ2xpZW50O1xuICAgICAgICBjb25zdCB3ZWJzb2NrZXRDYWxsYmFja3MgPSB7XG4gICAgICAgICAgICBvbm9wZW46IG9ub3BlbkF3YWl0ZWRDYWxsYmFjayxcbiAgICAgICAgICAgIG9ubWVzc2FnZTogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdm9pZCBoYW5kbGVXZWJTb2NrZXRNZXNzYWdlJDEoYXBpQ2xpZW50LCBjYWxsYmFja3Mub25tZXNzYWdlLCBldmVudCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25lcnJvcjogKF9hID0gY2FsbGJhY2tzID09PSBudWxsIHx8IGNhbGxiYWNrcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uZXJyb3IpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25jbG9zZTogKF9iID0gY2FsbGJhY2tzID09PSBudWxsIHx8IGNhbGxiYWNrcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uY2xvc2UpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb25uID0gdGhpcy53ZWJTb2NrZXRGYWN0b3J5LmNyZWF0ZSh1cmwsIGhlYWRlcnNUb01hcCQxKGhlYWRlcnMpLCB3ZWJzb2NrZXRDYWxsYmFja3MpO1xuICAgICAgICBjb25uLmNvbm5lY3QoKTtcbiAgICAgICAgLy8gV2FpdCBmb3IgdGhlIHdlYnNvY2tldCB0byBvcGVuIGJlZm9yZSBzZW5kaW5nIHJlcXVlc3RzLlxuICAgICAgICBhd2FpdCBvbm9wZW5Qcm9taXNlO1xuICAgICAgICBjb25zdCBtb2RlbCA9IHRNb2RlbCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zLm1vZGVsKTtcbiAgICAgICAgY29uc3Qgc2V0dXAgPSB7IG1vZGVsIH07XG4gICAgICAgIGNvbnN0IGNsaWVudE1lc3NhZ2UgPSB7IHNldHVwIH07XG4gICAgICAgIGNvbm4uc2VuZChKU09OLnN0cmluZ2lmeShjbGllbnRNZXNzYWdlKSk7XG4gICAgICAgIHJldHVybiBuZXcgTGl2ZU11c2ljU2Vzc2lvbihjb25uLCB0aGlzLmFwaUNsaWVudCk7XG4gICAgfVxufVxuLyoqXG4gICBSZXByZXNlbnRzIGEgY29ubmVjdGlvbiB0byB0aGUgQVBJLlxuXG4gICBAZXhwZXJpbWVudGFsXG4gICovXG5jbGFzcyBMaXZlTXVzaWNTZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25uLCBhcGlDbGllbnQpIHtcbiAgICAgICAgdGhpcy5jb25uID0gY29ubjtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAgU2V0cyBpbnB1dHMgdG8gc3RlZXIgbXVzaWMgZ2VuZXJhdGlvbi4gVXBkYXRlcyB0aGUgc2Vzc2lvbidzIGN1cnJlbnRcbiAgICAgIHdlaWdodGVkIHByb21wdHMuXG4gIFxuICAgICAgQHBhcmFtIHBhcmFtcyAtIENvbnRhaW5zIG9uZSBwcm9wZXJ0eSwgYHdlaWdodGVkUHJvbXB0c2AuXG4gIFxuICAgICAgICAtIGB3ZWlnaHRlZFByb21wdHNgIHRvIHNlbmQgdG8gdGhlIG1vZGVsOyB3ZWlnaHRzIGFyZSBub3JtYWxpemVkIHRvXG4gICAgICAgICAgc3VtIHRvIDEuMC5cbiAgXG4gICAgICBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgYXN5bmMgc2V0V2VpZ2h0ZWRQcm9tcHRzKHBhcmFtcykge1xuICAgICAgICBpZiAoIXBhcmFtcy53ZWlnaHRlZFByb21wdHMgfHxcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHBhcmFtcy53ZWlnaHRlZFByb21wdHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWlnaHRlZCBwcm9tcHRzIG11c3QgYmUgc2V0IGFuZCBjb250YWluIGF0IGxlYXN0IG9uZSBlbnRyeS4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbGllbnRDb250ZW50ID0gbGl2ZU11c2ljU2V0V2VpZ2h0ZWRQcm9tcHRzUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgdGhpcy5jb25uLnNlbmQoSlNPTi5zdHJpbmdpZnkoeyBjbGllbnRDb250ZW50IH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICBTZXRzIGEgY29uZmlndXJhdGlvbiB0byB0aGUgbW9kZWwuIFVwZGF0ZXMgdGhlIHNlc3Npb24ncyBjdXJyZW50XG4gICAgICBtdXNpYyBnZW5lcmF0aW9uIGNvbmZpZy5cbiAgXG4gICAgICBAcGFyYW0gcGFyYW1zIC0gQ29udGFpbnMgb25lIHByb3BlcnR5LCBgbXVzaWNHZW5lcmF0aW9uQ29uZmlnYC5cbiAgXG4gICAgICAgIC0gYG11c2ljR2VuZXJhdGlvbkNvbmZpZ2AgdG8gc2V0IGluIHRoZSBtb2RlbC4gUGFzc2luZyBhbiBlbXB0eSBvclxuICAgICAgdW5kZWZpbmVkIGNvbmZpZyB0byB0aGUgbW9kZWwgd2lsbCByZXNldCB0aGUgY29uZmlnIHRvIGRlZmF1bHRzLlxuICBcbiAgICAgIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBhc3luYyBzZXRNdXNpY0dlbmVyYXRpb25Db25maWcocGFyYW1zKSB7XG4gICAgICAgIGlmICghcGFyYW1zLm11c2ljR2VuZXJhdGlvbkNvbmZpZykge1xuICAgICAgICAgICAgcGFyYW1zLm11c2ljR2VuZXJhdGlvbkNvbmZpZyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNldENvbmZpZ1BhcmFtZXRlcnMgPSBsaXZlTXVzaWNTZXRDb25maWdQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICB0aGlzLmNvbm4uc2VuZChKU09OLnN0cmluZ2lmeShzZXRDb25maWdQYXJhbWV0ZXJzKSk7XG4gICAgfVxuICAgIHNlbmRQbGF5YmFja0NvbnRyb2wocGxheWJhY2tDb250cm9sKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudE1lc3NhZ2UgPSB7IHBsYXliYWNrQ29udHJvbCB9O1xuICAgICAgICB0aGlzLmNvbm4uc2VuZChKU09OLnN0cmluZ2lmeShjbGllbnRNZXNzYWdlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0IHRoZSBtdXNpYyBzdHJlYW0uXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgcGxheSgpIHtcbiAgICAgICAgdGhpcy5zZW5kUGxheWJhY2tDb250cm9sKExpdmVNdXNpY1BsYXliYWNrQ29udHJvbC5QTEFZKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVtcG9yYXJpbHkgaGFsdCB0aGUgbXVzaWMgc3RyZWFtLiBVc2UgYHBsYXlgIHRvIHJlc3VtZSBmcm9tIHRoZSBjdXJyZW50XG4gICAgICogcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgcGF1c2UoKSB7XG4gICAgICAgIHRoaXMuc2VuZFBsYXliYWNrQ29udHJvbChMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2wuUEFVU0UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wIHRoZSBtdXNpYyBzdHJlYW0gYW5kIHJlc2V0IHRoZSBzdGF0ZS4gUmV0YWlucyB0aGUgY3VycmVudCBwcm9tcHRzXG4gICAgICogYW5kIGNvbmZpZy5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBzdG9wKCkge1xuICAgICAgICB0aGlzLnNlbmRQbGF5YmFja0NvbnRyb2woTGl2ZU11c2ljUGxheWJhY2tDb250cm9sLlNUT1ApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIGNvbnRleHQgb2YgdGhlIG11c2ljIGdlbmVyYXRpb24gd2l0aG91dCBzdG9wcGluZyBpdC5cbiAgICAgKiBSZXRhaW5zIHRoZSBjdXJyZW50IHByb21wdHMgYW5kIGNvbmZpZy5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICByZXNldENvbnRleHQoKSB7XG4gICAgICAgIHRoaXMuc2VuZFBsYXliYWNrQ29udHJvbChMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2wuUkVTRVRfQ09OVEVYVCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAgIFRlcm1pbmF0ZXMgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICBcbiAgICAgICBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuY29ubi5jbG9zZSgpO1xuICAgIH1cbn1cbi8vIENvbnZlcnRzIGFuIGhlYWRlcnMgb2JqZWN0IHRvIGEgXCJtYXBcIiBvYmplY3QgYXMgZXhwZWN0ZWQgYnkgdGhlIFdlYlNvY2tldFxuLy8gY29uc3RydWN0b3IuIFdlIHVzZSB0aGlzIGFzIHRoZSBBdXRoIGludGVyZmFjZSB3b3JrcyB3aXRoIEhlYWRlcnMgb2JqZWN0c1xuLy8gd2hpbGUgdGhlIFdlYlNvY2tldCBjb25zdHJ1Y3RvciB0YWtlcyBhIG1hcC5cbmZ1bmN0aW9uIGhlYWRlcnNUb01hcCQxKGhlYWRlcnMpIHtcbiAgICBjb25zdCBoZWFkZXJNYXAgPSB7fTtcbiAgICBoZWFkZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgaGVhZGVyTWFwW2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gaGVhZGVyTWFwO1xufVxuLy8gQ29udmVydHMgYSBcIm1hcFwiIG9iamVjdCB0byBhIGhlYWRlcnMgb2JqZWN0LiBXZSB1c2UgdGhpcyBhcyB0aGUgQXV0aFxuLy8gaW50ZXJmYWNlIHdvcmtzIHdpdGggSGVhZGVycyBvYmplY3RzIHdoaWxlIHRoZSBBUEkgY2xpZW50IGRlZmF1bHQgaGVhZGVyc1xuLy8gcmV0dXJucyBhIG1hcC5cbmZ1bmN0aW9uIG1hcFRvSGVhZGVycyQxKG1hcCkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG1hcCkpIHtcbiAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBoZWFkZXJzO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jb25zdCBGVU5DVElPTl9SRVNQT05TRV9SRVFVSVJFU19JRCA9ICdGdW5jdGlvblJlc3BvbnNlIHJlcXVlc3QgbXVzdCBoYXZlIGFuIGBpZGAgZmllbGQgZnJvbSB0aGUgcmVzcG9uc2Ugb2YgYSBUb29sQ2FsbC5GdW5jdGlvbmFsQ2FsbHMgaW4gR29vZ2xlIEFJLic7XG4vKipcbiAqIEhhbmRsZXMgaW5jb21pbmcgbWVzc2FnZXMgZnJvbSB0aGUgV2ViU29ja2V0LlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHJlc3BvbnNpYmxlIGZvciBwYXJzaW5nIGluY29taW5nIG1lc3NhZ2VzLCB0cmFuc2Zvcm1pbmcgdGhlbVxuICogaW50byBMaXZlU2VydmVyTWVzc2FnZXMsIGFuZCB0aGVuIGNhbGxpbmcgdGhlIG9ubWVzc2FnZSBjYWxsYmFjay4gTm90ZSB0aGF0XG4gKiB0aGUgZmlyc3QgbWVzc2FnZSB3aGljaCBpcyByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIgaXMgYSBzZXR1cENvbXBsZXRlXG4gKiBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSBhcGlDbGllbnQgVGhlIEFwaUNsaWVudCBpbnN0YW5jZS5cbiAqIEBwYXJhbSBvbm1lc3NhZ2UgVGhlIHVzZXItcHJvdmlkZWQgb25tZXNzYWdlIGNhbGxiYWNrIChpZiBhbnkpLlxuICogQHBhcmFtIGV2ZW50IFRoZSBNZXNzYWdlRXZlbnQgZnJvbSB0aGUgV2ViU29ja2V0LlxuICovXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVXZWJTb2NrZXRNZXNzYWdlKGFwaUNsaWVudCwgb25tZXNzYWdlLCBldmVudCkge1xuICAgIGNvbnN0IHNlcnZlck1lc3NhZ2UgPSBuZXcgTGl2ZVNlcnZlck1lc3NhZ2UoKTtcbiAgICBsZXQganNvbkRhdGE7XG4gICAgaWYgKGV2ZW50LmRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIGpzb25EYXRhID0gYXdhaXQgZXZlbnQuZGF0YS50ZXh0KCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV2ZW50LmRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICBqc29uRGF0YSA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShldmVudC5kYXRhKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGpzb25EYXRhID0gZXZlbnQuZGF0YTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoanNvbkRhdGEpO1xuICAgIGlmIChhcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgIGNvbnN0IHJlc3AgPSBsaXZlU2VydmVyTWVzc2FnZUZyb21WZXJ0ZXgoZGF0YSk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oc2VydmVyTWVzc2FnZSwgcmVzcCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCByZXNwID0gZGF0YTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihzZXJ2ZXJNZXNzYWdlLCByZXNwKTtcbiAgICB9XG4gICAgb25tZXNzYWdlKHNlcnZlck1lc3NhZ2UpO1xufVxuLyoqXG4gICBMaXZlIGNsYXNzIGVuY2Fwc3VsYXRlcyB0aGUgY29uZmlndXJhdGlvbiBmb3IgbGl2ZSBpbnRlcmFjdGlvbiB3aXRoIHRoZVxuICAgR2VuZXJhdGl2ZSBMYW5ndWFnZSBBUEkuIEl0IGVtYmVkcyBBcGlDbGllbnQgZm9yIGdlbmVyYWwgQVBJIHNldHRpbmdzLlxuXG4gICBAZXhwZXJpbWVudGFsXG4gICovXG5jbGFzcyBMaXZlIHtcbiAgICBjb25zdHJ1Y3RvcihhcGlDbGllbnQsIGF1dGgsIHdlYlNvY2tldEZhY3RvcnkpIHtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgICAgIHRoaXMuYXV0aCA9IGF1dGg7XG4gICAgICAgIHRoaXMud2ViU29ja2V0RmFjdG9yeSA9IHdlYlNvY2tldEZhY3Rvcnk7XG4gICAgICAgIHRoaXMubXVzaWMgPSBuZXcgTGl2ZU11c2ljKHRoaXMuYXBpQ2xpZW50LCB0aGlzLmF1dGgsIHRoaXMud2ViU29ja2V0RmFjdG9yeSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAgIEVzdGFibGlzaGVzIGEgY29ubmVjdGlvbiB0byB0aGUgc3BlY2lmaWVkIG1vZGVsIHdpdGggdGhlIGdpdmVuXG4gICAgICAgY29uZmlndXJhdGlvbiBhbmQgcmV0dXJucyBhIFNlc3Npb24gb2JqZWN0IHJlcHJlc2VudGluZyB0aGF0IGNvbm5lY3Rpb24uXG4gIFxuICAgICAgIEBleHBlcmltZW50YWwgQnVpbHQtaW4gTUNQIHN1cHBvcnQgaXMgYW4gZXhwZXJpbWVudGFsIGZlYXR1cmUsIG1heSBjaGFuZ2UgaW5cbiAgICAgICBmdXR1cmUgdmVyc2lvbnMuXG4gIFxuICAgICAgIEByZW1hcmtzXG4gIFxuICAgICAgIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZXN0YWJsaXNoaW5nIGEgY29ubmVjdGlvbiB0byB0aGUgbW9kZWwuXG4gICAgICAgQHJldHVybiBBIGxpdmUgc2Vzc2lvbi5cbiAgXG4gICAgICAgQGV4YW1wbGVcbiAgICAgICBgYGB0c1xuICAgICAgIGxldCBtb2RlbDogc3RyaW5nO1xuICAgICAgIGlmIChHT09HTEVfR0VOQUlfVVNFX1ZFUlRFWEFJKSB7XG4gICAgICAgICBtb2RlbCA9ICdnZW1pbmktMi4wLWZsYXNoLWxpdmUtcHJldmlldy0wNC0wOSc7XG4gICAgICAgfSBlbHNlIHtcbiAgICAgICAgIG1vZGVsID0gJ2dlbWluaS1saXZlLTIuNS1mbGFzaC1wcmV2aWV3JztcbiAgICAgICB9XG4gICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IGFpLmxpdmUuY29ubmVjdCh7XG4gICAgICAgICBtb2RlbDogbW9kZWwsXG4gICAgICAgICBjb25maWc6IHtcbiAgICAgICAgICAgcmVzcG9uc2VNb2RhbGl0aWVzOiBbTW9kYWxpdHkuQVVESU9dLFxuICAgICAgICAgfSxcbiAgICAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICAgICBvbm9wZW46ICgpID0+IHtcbiAgICAgICAgICAgICBjb25zb2xlLmxvZygnQ29ubmVjdGVkIHRvIHRoZSBzb2NrZXQuJyk7XG4gICAgICAgICAgIH0sXG4gICAgICAgICAgIG9ubWVzc2FnZTogKGU6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZWNlaXZlZCBtZXNzYWdlIGZyb20gdGhlIHNlcnZlcjogJXNcXG4nLCBkZWJ1ZyhlLmRhdGEpKTtcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgb25lcnJvcjogKGU6IEVycm9yRXZlbnQpID0+IHtcbiAgICAgICAgICAgICBjb25zb2xlLmxvZygnRXJyb3Igb2NjdXJyZWQ6ICVzXFxuJywgZGVidWcoZS5lcnJvcikpO1xuICAgICAgICAgICB9LFxuICAgICAgICAgICBvbmNsb3NlOiAoZTogQ2xvc2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDb25uZWN0aW9uIGNsb3NlZC4nKTtcbiAgICAgICAgICAgfSxcbiAgICAgICAgIH0sXG4gICAgICAgfSk7XG4gICAgICAgYGBgXG4gICAgICAqL1xuICAgIGFzeW5jIGNvbm5lY3QocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICAvLyBUT0RPOiBiLzQwNDk0Njc0NiAtIFN1cHBvcnQgcGVyIHJlcXVlc3QgSFRUUCBvcHRpb25zLlxuICAgICAgICBpZiAocGFyYW1zLmNvbmZpZyAmJiBwYXJhbXMuY29uZmlnLmh0dHBPcHRpb25zKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBMaXZlIG1vZHVsZSBkb2VzIG5vdCBzdXBwb3J0IGh0dHBPcHRpb25zIGF0IHJlcXVlc3QtbGV2ZWwgaW4nICtcbiAgICAgICAgICAgICAgICAnIExpdmVDb25uZWN0Q29uZmlnIHlldC4gUGxlYXNlIHVzZSB0aGUgY2xpZW50LWxldmVsIGh0dHBPcHRpb25zJyArXG4gICAgICAgICAgICAgICAgJyBjb25maWd1cmF0aW9uIGluc3RlYWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2Vic29ja2V0QmFzZVVybCA9IHRoaXMuYXBpQ2xpZW50LmdldFdlYnNvY2tldEJhc2VVcmwoKTtcbiAgICAgICAgY29uc3QgYXBpVmVyc2lvbiA9IHRoaXMuYXBpQ2xpZW50LmdldEFwaVZlcnNpb24oKTtcbiAgICAgICAgbGV0IHVybDtcbiAgICAgICAgY29uc3QgY2xpZW50SGVhZGVycyA9IHRoaXMuYXBpQ2xpZW50LmdldEhlYWRlcnMoKTtcbiAgICAgICAgaWYgKHBhcmFtcy5jb25maWcgJiZcbiAgICAgICAgICAgIHBhcmFtcy5jb25maWcudG9vbHMgJiZcbiAgICAgICAgICAgIGhhc01jcFRvb2xVc2FnZShwYXJhbXMuY29uZmlnLnRvb2xzKSkge1xuICAgICAgICAgICAgc2V0TWNwVXNhZ2VIZWFkZXIoY2xpZW50SGVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG1hcFRvSGVhZGVycyhjbGllbnRIZWFkZXJzKTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdXJsID0gYCR7d2Vic29ja2V0QmFzZVVybH0vd3MvZ29vZ2xlLmNsb3VkLmFpcGxhdGZvcm0uJHthcGlWZXJzaW9ufS5MbG1CaWRpU2VydmljZS9CaWRpR2VuZXJhdGVDb250ZW50YDtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXV0aC5hZGRBdXRoSGVhZGVycyhoZWFkZXJzLCB1cmwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYXBpS2V5ID0gdGhpcy5hcGlDbGllbnQuZ2V0QXBpS2V5KCk7XG4gICAgICAgICAgICBsZXQgbWV0aG9kID0gJ0JpZGlHZW5lcmF0ZUNvbnRlbnQnO1xuICAgICAgICAgICAgbGV0IGtleU5hbWUgPSAna2V5JztcbiAgICAgICAgICAgIGlmIChhcGlLZXkgPT09IG51bGwgfHwgYXBpS2V5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcGlLZXkuc3RhcnRzV2l0aCgnYXV0aF90b2tlbnMvJykpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dhcm5pbmc6IEVwaGVtZXJhbCB0b2tlbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZSBpbiBmdXR1cmUgdmVyc2lvbnMuJyk7XG4gICAgICAgICAgICAgICAgaWYgKGFwaVZlcnNpb24gIT09ICd2MWFscGhhJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJXYXJuaW5nOiBUaGUgU0RLJ3MgZXBoZW1lcmFsIHRva2VuIHN1cHBvcnQgaXMgaW4gdjFhbHBoYSBvbmx5LiBQbGVhc2UgdXNlIGNvbnN0IGFpID0gbmV3IEdvb2dsZUdlbkFJKHthcGlLZXk6IHRva2VuLm5hbWUsIGh0dHBPcHRpb25zOiB7IGFwaVZlcnNpb246ICd2MWFscGhhJyB9fSk7IGJlZm9yZSBzZXNzaW9uIGNvbm5lY3Rpb24uXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZXRob2QgPSAnQmlkaUdlbmVyYXRlQ29udGVudENvbnN0cmFpbmVkJztcbiAgICAgICAgICAgICAgICBrZXlOYW1lID0gJ2FjY2Vzc190b2tlbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cmwgPSBgJHt3ZWJzb2NrZXRCYXNlVXJsfS93cy9nb29nbGUuYWkuZ2VuZXJhdGl2ZWxhbmd1YWdlLiR7YXBpVmVyc2lvbn0uR2VuZXJhdGl2ZVNlcnZpY2UuJHttZXRob2R9PyR7a2V5TmFtZX09JHthcGlLZXl9YDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb25vcGVuUmVzb2x2ZSA9ICgpID0+IHsgfTtcbiAgICAgICAgY29uc3Qgb25vcGVuUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBvbm9wZW5SZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHBhcmFtcy5jYWxsYmFja3M7XG4gICAgICAgIGNvbnN0IG9ub3BlbkF3YWl0ZWRDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIChfYSA9IGNhbGxiYWNrcyA9PT0gbnVsbCB8fCBjYWxsYmFja3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vbm9wZW4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGNhbGxiYWNrcyk7XG4gICAgICAgICAgICBvbm9wZW5SZXNvbHZlKHt9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYXBpQ2xpZW50ID0gdGhpcy5hcGlDbGllbnQ7XG4gICAgICAgIGNvbnN0IHdlYnNvY2tldENhbGxiYWNrcyA9IHtcbiAgICAgICAgICAgIG9ub3Blbjogb25vcGVuQXdhaXRlZENhbGxiYWNrLFxuICAgICAgICAgICAgb25tZXNzYWdlOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB2b2lkIGhhbmRsZVdlYlNvY2tldE1lc3NhZ2UoYXBpQ2xpZW50LCBjYWxsYmFja3Mub25tZXNzYWdlLCBldmVudCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25lcnJvcjogKF9hID0gY2FsbGJhY2tzID09PSBudWxsIHx8IGNhbGxiYWNrcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uZXJyb3IpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25jbG9zZTogKF9iID0gY2FsbGJhY2tzID09PSBudWxsIHx8IGNhbGxiYWNrcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uY2xvc2UpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb25uID0gdGhpcy53ZWJTb2NrZXRGYWN0b3J5LmNyZWF0ZSh1cmwsIGhlYWRlcnNUb01hcChoZWFkZXJzKSwgd2Vic29ja2V0Q2FsbGJhY2tzKTtcbiAgICAgICAgY29ubi5jb25uZWN0KCk7XG4gICAgICAgIC8vIFdhaXQgZm9yIHRoZSB3ZWJzb2NrZXQgdG8gb3BlbiBiZWZvcmUgc2VuZGluZyByZXF1ZXN0cy5cbiAgICAgICAgYXdhaXQgb25vcGVuUHJvbWlzZTtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTW9kZWwgPSB0TW9kZWwodGhpcy5hcGlDbGllbnQsIHBhcmFtcy5tb2RlbCk7XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkgJiZcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTW9kZWwuc3RhcnRzV2l0aCgncHVibGlzaGVycy8nKSkge1xuICAgICAgICAgICAgY29uc3QgcHJvamVjdCA9IHRoaXMuYXBpQ2xpZW50LmdldFByb2plY3QoKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5hcGlDbGllbnQuZ2V0TG9jYXRpb24oKTtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTW9kZWwgPVxuICAgICAgICAgICAgICAgIGBwcm9qZWN0cy8ke3Byb2plY3R9L2xvY2F0aW9ucy8ke2xvY2F0aW9ufS9gICsgdHJhbnNmb3JtZWRNb2RlbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2xpZW50TWVzc2FnZSA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpICYmXG4gICAgICAgICAgICAoKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJlc3BvbnNlTW9kYWxpdGllcykgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gU2V0IGRlZmF1bHQgdG8gQVVESU8gdG8gYWxpZ24gd2l0aCBNTERldiBBUEkuXG4gICAgICAgICAgICBpZiAocGFyYW1zLmNvbmZpZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmNvbmZpZyA9IHsgcmVzcG9uc2VNb2RhbGl0aWVzOiBbTW9kYWxpdHkuQVVESU9dIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuY29uZmlnLnJlc3BvbnNlTW9kYWxpdGllcyA9IFtNb2RhbGl0eS5BVURJT107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5nZW5lcmF0aW9uQ29uZmlnKSB7XG4gICAgICAgICAgICAvLyBSYWlzZSBkZXByZWNhdGlvbiB3YXJuaW5nIGZvciBnZW5lcmF0aW9uQ29uZmlnLlxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdTZXR0aW5nIGBMaXZlQ29ubmVjdENvbmZpZy5nZW5lcmF0aW9uX2NvbmZpZ2AgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHNldCB0aGUgZmllbGRzIG9uIGBMaXZlQ29ubmVjdENvbmZpZ2AgZGlyZWN0bHkuIFRoaXMgd2lsbCBiZWNvbWUgYW4gZXJyb3IgaW4gYSBmdXR1cmUgdmVyc2lvbiAobm90IGJlZm9yZSBRMyAyMDI1KS4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnB1dFRvb2xzID0gKF9mID0gKF9lID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnRvb2xzKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBbXTtcbiAgICAgICAgY29uc3QgY29udmVydGVkVG9vbHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB0b29sIG9mIGlucHV0VG9vbHMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ2FsbGFibGVUb29sKHRvb2wpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbGFibGVUb29sID0gdG9vbDtcbiAgICAgICAgICAgICAgICBjb252ZXJ0ZWRUb29scy5wdXNoKGF3YWl0IGNhbGxhYmxlVG9vbC50b29sKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udmVydGVkVG9vbHMucHVzaCh0b29sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udmVydGVkVG9vbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcGFyYW1zLmNvbmZpZy50b29scyA9IGNvbnZlcnRlZFRvb2xzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpdmVDb25uZWN0UGFyYW1ldGVycyA9IHtcbiAgICAgICAgICAgIG1vZGVsOiB0cmFuc2Zvcm1lZE1vZGVsLFxuICAgICAgICAgICAgY29uZmlnOiBwYXJhbXMuY29uZmlnLFxuICAgICAgICAgICAgY2FsbGJhY2tzOiBwYXJhbXMuY2FsbGJhY2tzLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjbGllbnRNZXNzYWdlID0gbGl2ZUNvbm5lY3RQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIGxpdmVDb25uZWN0UGFyYW1ldGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbGllbnRNZXNzYWdlID0gbGl2ZUNvbm5lY3RQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgbGl2ZUNvbm5lY3RQYXJhbWV0ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgY2xpZW50TWVzc2FnZVsnY29uZmlnJ107XG4gICAgICAgIGNvbm4uc2VuZChKU09OLnN0cmluZ2lmeShjbGllbnRNZXNzYWdlKSk7XG4gICAgICAgIHJldHVybiBuZXcgU2Vzc2lvbihjb25uLCB0aGlzLmFwaUNsaWVudCk7XG4gICAgfVxuICAgIC8vIFRPRE86IGIvNDE2MDQxMjI5IC0gQWJzdHJhY3QgdGhpcyBtZXRob2QgdG8gYSBjb21tb24gcGxhY2UuXG4gICAgaXNDYWxsYWJsZVRvb2wodG9vbCkge1xuICAgICAgICByZXR1cm4gJ2NhbGxUb29sJyBpbiB0b29sICYmIHR5cGVvZiB0b29sLmNhbGxUb29sID09PSAnZnVuY3Rpb24nO1xuICAgIH1cbn1cbmNvbnN0IGRlZmF1bHRMaXZlU2VuZENsaWVudENvbnRlbnRQYXJhbWVydGVycyA9IHtcbiAgICB0dXJuQ29tcGxldGU6IHRydWUsXG59O1xuLyoqXG4gICBSZXByZXNlbnRzIGEgY29ubmVjdGlvbiB0byB0aGUgQVBJLlxuXG4gICBAZXhwZXJpbWVudGFsXG4gICovXG5jbGFzcyBTZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25uLCBhcGlDbGllbnQpIHtcbiAgICAgICAgdGhpcy5jb25uID0gY29ubjtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgfVxuICAgIHRMaXZlQ2xpZW50Q29udGVudChhcGlDbGllbnQsIHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zLnR1cm5zICE9PSBudWxsICYmIHBhcmFtcy50dXJucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgY29udGVudHMgPSBbXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29udGVudHMgPSB0Q29udGVudHMocGFyYW1zLnR1cm5zKTtcbiAgICAgICAgICAgICAgICBpZiAoIWFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudHMgPSBjb250ZW50cy5tYXAoKGl0ZW0pID0+IGNvbnRlbnRUb01sZGV2JDEoaXRlbSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIGNsaWVudCBjb250ZW50IFwidHVybnNcIiwgdHlwZTogJyR7dHlwZW9mIHBhcmFtcy50dXJuc30nYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNsaWVudENvbnRlbnQ6IHsgdHVybnM6IGNvbnRlbnRzLCB0dXJuQ29tcGxldGU6IHBhcmFtcy50dXJuQ29tcGxldGUgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNsaWVudENvbnRlbnQ6IHsgdHVybkNvbXBsZXRlOiBwYXJhbXMudHVybkNvbXBsZXRlIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRMaXZlQ2xpZW50dFRvb2xSZXNwb25zZShhcGlDbGllbnQsIHBhcmFtcykge1xuICAgICAgICBsZXQgZnVuY3Rpb25SZXNwb25zZXMgPSBbXTtcbiAgICAgICAgaWYgKHBhcmFtcy5mdW5jdGlvblJlc3BvbnNlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Z1bmN0aW9uUmVzcG9uc2VzIGlzIHJlcXVpcmVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShwYXJhbXMuZnVuY3Rpb25SZXNwb25zZXMpKSB7XG4gICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlcyA9IFtwYXJhbXMuZnVuY3Rpb25SZXNwb25zZXNdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnVuY3Rpb25SZXNwb25zZXMgPSBwYXJhbXMuZnVuY3Rpb25SZXNwb25zZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZ1bmN0aW9uUmVzcG9uc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmdW5jdGlvblJlc3BvbnNlcyBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGZ1bmN0aW9uUmVzcG9uc2Ugb2YgZnVuY3Rpb25SZXNwb25zZXMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZnVuY3Rpb25SZXNwb25zZSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgISgnbmFtZScgaW4gZnVuY3Rpb25SZXNwb25zZSkgfHxcbiAgICAgICAgICAgICAgICAhKCdyZXNwb25zZScgaW4gZnVuY3Rpb25SZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBwYXJzZSBmdW5jdGlvbiByZXNwb25zZSwgdHlwZSAnJHt0eXBlb2YgZnVuY3Rpb25SZXNwb25zZX0nLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhcGlDbGllbnQuaXNWZXJ0ZXhBSSgpICYmICEoJ2lkJyBpbiBmdW5jdGlvblJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihGVU5DVElPTl9SRVNQT05TRV9SRVFVSVJFU19JRCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xpZW50TWVzc2FnZSA9IHtcbiAgICAgICAgICAgIHRvb2xSZXNwb25zZTogeyBmdW5jdGlvblJlc3BvbnNlczogZnVuY3Rpb25SZXNwb25zZXMgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNsaWVudE1lc3NhZ2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAgU2VuZCBhIG1lc3NhZ2Ugb3ZlciB0aGUgZXN0YWJsaXNoZWQgY29ubmVjdGlvbi5cbiAgXG4gICAgICBAcGFyYW0gcGFyYW1zIC0gQ29udGFpbnMgdHdvICoqb3B0aW9uYWwqKiBwcm9wZXJ0aWVzLCBgdHVybnNgIGFuZFxuICAgICAgICAgIGB0dXJuQ29tcGxldGVgLlxuICBcbiAgICAgICAgLSBgdHVybnNgIHdpbGwgYmUgY29udmVydGVkIHRvIGEgYENvbnRlbnRbXWBcbiAgICAgICAgLSBgdHVybkNvbXBsZXRlOiB0cnVlYCBbZGVmYXVsdF0gaW5kaWNhdGVzIHRoYXQgeW91IGFyZSBkb25lIHNlbmRpbmdcbiAgICAgICAgICBjb250ZW50IGFuZCBleHBlY3QgYSByZXNwb25zZS4gSWYgYHR1cm5Db21wbGV0ZTogZmFsc2VgLCB0aGUgc2VydmVyXG4gICAgICAgICAgd2lsbCB3YWl0IGZvciBhZGRpdGlvbmFsIG1lc3NhZ2VzIGJlZm9yZSBzdGFydGluZyBnZW5lcmF0aW9uLlxuICBcbiAgICAgIEBleHBlcmltZW50YWxcbiAgXG4gICAgICBAcmVtYXJrc1xuICAgICAgVGhlcmUgYXJlIHR3byB3YXlzIHRvIHNlbmQgbWVzc2FnZXMgdG8gdGhlIGxpdmUgQVBJOlxuICAgICAgYHNlbmRDbGllbnRDb250ZW50YCBhbmQgYHNlbmRSZWFsdGltZUlucHV0YC5cbiAgXG4gICAgICBgc2VuZENsaWVudENvbnRlbnRgIG1lc3NhZ2VzIGFyZSBhZGRlZCB0byB0aGUgbW9kZWwgY29udGV4dCAqKmluIG9yZGVyKiouXG4gICAgICBIYXZpbmcgYSBjb252ZXJzYXRpb24gdXNpbmcgYHNlbmRDbGllbnRDb250ZW50YCBtZXNzYWdlcyBpcyByb3VnaGx5XG4gICAgICBlcXVpdmFsZW50IHRvIHVzaW5nIHRoZSBgQ2hhdC5zZW5kTWVzc2FnZVN0cmVhbWAsIGV4Y2VwdCB0aGF0IHRoZSBzdGF0ZSBvZlxuICAgICAgdGhlIGBjaGF0YCBoaXN0b3J5IGlzIHN0b3JlZCBvbiB0aGUgQVBJIHNlcnZlciBpbnN0ZWFkIG9mIGxvY2FsbHkuXG4gIFxuICAgICAgQmVjYXVzZSBvZiBgc2VuZENsaWVudENvbnRlbnRgJ3Mgb3JkZXIgZ3VhcmFudGVlLCB0aGUgbW9kZWwgY2Fubm90IHJlc3BvbnNcbiAgICAgIGFzIHF1aWNrbHkgdG8gYHNlbmRDbGllbnRDb250ZW50YCBtZXNzYWdlcyBhcyB0byBgc2VuZFJlYWx0aW1lSW5wdXRgXG4gICAgICBtZXNzYWdlcy4gVGhpcyBtYWtlcyB0aGUgYmlnZ2VzdCBkaWZmZXJlbmNlIHdoZW4gc2VuZGluZyBvYmplY3RzIHRoYXQgaGF2ZVxuICAgICAgc2lnbmlmaWNhbnQgcHJlcHJvY2Vzc2luZyB0aW1lICh0eXBpY2FsbHkgaW1hZ2VzKS5cbiAgXG4gICAgICBUaGUgYHNlbmRDbGllbnRDb250ZW50YCBtZXNzYWdlIHNlbmRzIGEgYENvbnRlbnRbXWBcbiAgICAgIHdoaWNoIGhhcyBtb3JlIG9wdGlvbnMgdGhhbiB0aGUgYEJsb2JgIHNlbnQgYnkgYHNlbmRSZWFsdGltZUlucHV0YC5cbiAgXG4gICAgICBTbyB0aGUgbWFpbiB1c2UtY2FzZXMgZm9yIGBzZW5kQ2xpZW50Q29udGVudGAgb3ZlciBgc2VuZFJlYWx0aW1lSW5wdXRgIGFyZTpcbiAgXG4gICAgICAtIFNlbmRpbmcgYW55dGhpbmcgdGhhdCBjYW4ndCBiZSByZXByZXNlbnRlZCBhcyBhIGBCbG9iYCAodGV4dCxcbiAgICAgIGBzZW5kQ2xpZW50Q29udGVudCh7dHVybnM9XCJIZWxsbz9cIn1gKSkuXG4gICAgICAtIE1hbmFnaW5nIHR1cm5zIHdoZW4gbm90IHVzaW5nIGF1ZGlvIGlucHV0IGFuZCB2b2ljZSBhY3Rpdml0eSBkZXRlY3Rpb24uXG4gICAgICAgIChgc2VuZENsaWVudENvbnRlbnQoe3R1cm5Db21wbGV0ZTp0cnVlfSlgIG9yIHRoZSBzaG9ydCBmb3JtXG4gICAgICBgc2VuZENsaWVudENvbnRlbnQoKWApXG4gICAgICAtIFByZWZpbGxpbmcgYSBjb252ZXJzYXRpb24gY29udGV4dFxuICAgICAgICBgYGBcbiAgICAgICAgc2VuZENsaWVudENvbnRlbnQoe1xuICAgICAgICAgICAgdHVybnM6IFtcbiAgICAgICAgICAgICAgQ29udGVudCh7cm9sZTp1c2VyLCBwYXJ0czouLi59KSxcbiAgICAgICAgICAgICAgQ29udGVudCh7cm9sZTp1c2VyLCBwYXJ0czouLi59KSxcbiAgICAgICAgICAgICAgLi4uXG4gICAgICAgICAgICBdXG4gICAgICAgIH0pXG4gICAgICAgIGBgYFxuICAgICAgQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHNlbmRDbGllbnRDb250ZW50KHBhcmFtcykge1xuICAgICAgICBwYXJhbXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRMaXZlU2VuZENsaWVudENvbnRlbnRQYXJhbWVydGVycyksIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IGNsaWVudE1lc3NhZ2UgPSB0aGlzLnRMaXZlQ2xpZW50Q29udGVudCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgdGhpcy5jb25uLnNlbmQoSlNPTi5zdHJpbmdpZnkoY2xpZW50TWVzc2FnZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgIFNlbmQgYSByZWFsdGltZSBtZXNzYWdlIG92ZXIgdGhlIGVzdGFibGlzaGVkIGNvbm5lY3Rpb24uXG4gIFxuICAgICAgQHBhcmFtIHBhcmFtcyAtIENvbnRhaW5zIG9uZSBwcm9wZXJ0eSwgYG1lZGlhYC5cbiAgXG4gICAgICAgIC0gYG1lZGlhYCB3aWxsIGJlIGNvbnZlcnRlZCB0byBhIGBCbG9iYFxuICBcbiAgICAgIEBleHBlcmltZW50YWxcbiAgXG4gICAgICBAcmVtYXJrc1xuICAgICAgVXNlIGBzZW5kUmVhbHRpbWVJbnB1dGAgZm9yIHJlYWx0aW1lIGF1ZGlvIGNodW5rcyBhbmQgdmlkZW8gZnJhbWVzIChpbWFnZXMpLlxuICBcbiAgICAgIFdpdGggYHNlbmRSZWFsdGltZUlucHV0YCB0aGUgYXBpIHdpbGwgcmVzcG9uZCB0byBhdWRpbyBhdXRvbWF0aWNhbGx5XG4gICAgICBiYXNlZCBvbiB2b2ljZSBhY3Rpdml0eSBkZXRlY3Rpb24gKFZBRCkuXG4gIFxuICAgICAgYHNlbmRSZWFsdGltZUlucHV0YCBpcyBvcHRpbWl6ZWQgZm9yIHJlc3BvbnNpdm5lc3MgYXQgdGhlIGV4cGVuc2Ugb2ZcbiAgICAgIGRldGVybWluaXN0aWMgb3JkZXJpbmcgZ3VhcmFudGVlcy4gQXVkaW8gYW5kIHZpZGVvIHRva2VucyBhcmUgdG8gdGhlXG4gICAgICBjb250ZXh0IHdoZW4gdGhleSBiZWNvbWUgYXZhaWxhYmxlLlxuICBcbiAgICAgIE5vdGU6IFRoZSBDYWxsIHNpZ25hdHVyZSBleHBlY3RzIGEgYEJsb2JgIG9iamVjdCwgYnV0IG9ubHkgYSBzdWJzZXRcbiAgICAgIG9mIGF1ZGlvIGFuZCBpbWFnZSBtaW1ldHlwZXMgYXJlIGFsbG93ZWQuXG4gICAgICovXG4gICAgc2VuZFJlYWx0aW1lSW5wdXQocGFyYW1zKSB7XG4gICAgICAgIGxldCBjbGllbnRNZXNzYWdlID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNsaWVudE1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgJ3JlYWx0aW1lSW5wdXQnOiBsaXZlU2VuZFJlYWx0aW1lSW5wdXRQYXJhbWV0ZXJzVG9WZXJ0ZXgocGFyYW1zKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbGllbnRNZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgICdyZWFsdGltZUlucHV0JzogbGl2ZVNlbmRSZWFsdGltZUlucHV0UGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uLnNlbmQoSlNPTi5zdHJpbmdpZnkoY2xpZW50TWVzc2FnZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgIFNlbmQgYSBmdW5jdGlvbiByZXNwb25zZSBtZXNzYWdlIG92ZXIgdGhlIGVzdGFibGlzaGVkIGNvbm5lY3Rpb24uXG4gIFxuICAgICAgQHBhcmFtIHBhcmFtcyAtIENvbnRhaW5zIHByb3BlcnR5IGBmdW5jdGlvblJlc3BvbnNlc2AuXG4gIFxuICAgICAgICAtIGBmdW5jdGlvblJlc3BvbnNlc2Agd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSBgZnVuY3Rpb25SZXNwb25zZXNbXWBcbiAgXG4gICAgICBAcmVtYXJrc1xuICAgICAgVXNlIGBzZW5kRnVuY3Rpb25SZXNwb25zZWAgdG8gcmVwbHkgdG8gYExpdmVTZXJ2ZXJUb29sQ2FsbGAgZnJvbSB0aGUgc2VydmVyLlxuICBcbiAgICAgIFVzZSB7QGxpbmsgdHlwZXMuTGl2ZUNvbm5lY3RDb25maWcjdG9vbHN9IHRvIGNvbmZpZ3VyZSB0aGUgY2FsbGFibGUgZnVuY3Rpb25zLlxuICBcbiAgICAgIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBzZW5kVG9vbFJlc3BvbnNlKHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zLmZ1bmN0aW9uUmVzcG9uc2VzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG9vbCByZXNwb25zZSBwYXJhbWV0ZXJzIGFyZSByZXF1aXJlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbGllbnRNZXNzYWdlID0gdGhpcy50TGl2ZUNsaWVudHRUb29sUmVzcG9uc2UodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgIHRoaXMuY29ubi5zZW5kKEpTT04uc3RyaW5naWZ5KGNsaWVudE1lc3NhZ2UpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICAgVGVybWluYXRlcyB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24uXG4gIFxuICAgICAgIEBleHBlcmltZW50YWxcbiAgXG4gICAgICAgQGV4YW1wbGVcbiAgICAgICBgYGB0c1xuICAgICAgIGxldCBtb2RlbDogc3RyaW5nO1xuICAgICAgIGlmIChHT09HTEVfR0VOQUlfVVNFX1ZFUlRFWEFJKSB7XG4gICAgICAgICBtb2RlbCA9ICdnZW1pbmktMi4wLWZsYXNoLWxpdmUtcHJldmlldy0wNC0wOSc7XG4gICAgICAgfSBlbHNlIHtcbiAgICAgICAgIG1vZGVsID0gJ2dlbWluaS1saXZlLTIuNS1mbGFzaC1wcmV2aWV3JztcbiAgICAgICB9XG4gICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IGFpLmxpdmUuY29ubmVjdCh7XG4gICAgICAgICBtb2RlbDogbW9kZWwsXG4gICAgICAgICBjb25maWc6IHtcbiAgICAgICAgICAgcmVzcG9uc2VNb2RhbGl0aWVzOiBbTW9kYWxpdHkuQVVESU9dLFxuICAgICAgICAgfVxuICAgICAgIH0pO1xuICBcbiAgICAgICBzZXNzaW9uLmNsb3NlKCk7XG4gICAgICAgYGBgXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuY29ubi5jbG9zZSgpO1xuICAgIH1cbn1cbi8vIENvbnZlcnRzIGFuIGhlYWRlcnMgb2JqZWN0IHRvIGEgXCJtYXBcIiBvYmplY3QgYXMgZXhwZWN0ZWQgYnkgdGhlIFdlYlNvY2tldFxuLy8gY29uc3RydWN0b3IuIFdlIHVzZSB0aGlzIGFzIHRoZSBBdXRoIGludGVyZmFjZSB3b3JrcyB3aXRoIEhlYWRlcnMgb2JqZWN0c1xuLy8gd2hpbGUgdGhlIFdlYlNvY2tldCBjb25zdHJ1Y3RvciB0YWtlcyBhIG1hcC5cbmZ1bmN0aW9uIGhlYWRlcnNUb01hcChoZWFkZXJzKSB7XG4gICAgY29uc3QgaGVhZGVyTWFwID0ge307XG4gICAgaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGhlYWRlck1hcFtrZXldID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIGhlYWRlck1hcDtcbn1cbi8vIENvbnZlcnRzIGEgXCJtYXBcIiBvYmplY3QgdG8gYSBoZWFkZXJzIG9iamVjdC4gV2UgdXNlIHRoaXMgYXMgdGhlIEF1dGhcbi8vIGludGVyZmFjZSB3b3JrcyB3aXRoIEhlYWRlcnMgb2JqZWN0cyB3aGlsZSB0aGUgQVBJIGNsaWVudCBkZWZhdWx0IGhlYWRlcnNcbi8vIHJldHVybnMgYSBtYXAuXG5mdW5jdGlvbiBtYXBUb0hlYWRlcnMobWFwKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobWFwKSkge1xuICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGhlYWRlcnM7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNvbnN0IERFRkFVTFRfTUFYX1JFTU9URV9DQUxMUyA9IDEwO1xuLyoqIFJldHVybnMgd2hldGhlciBhdXRvbWF0aWMgZnVuY3Rpb24gY2FsbGluZyBpcyBkaXNhYmxlZC4gKi9cbmZ1bmN0aW9uIHNob3VsZERpc2FibGVBZmMoY29uZmlnKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgaWYgKChfYSA9IGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5hdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNhYmxlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsZXQgY2FsbGFibGVUb29sc1ByZXNlbnQgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IHRvb2wgb2YgKF9iID0gY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLnRvb2xzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSkge1xuICAgICAgICBpZiAoaXNDYWxsYWJsZVRvb2wodG9vbCkpIHtcbiAgICAgICAgICAgIGNhbGxhYmxlVG9vbHNQcmVzZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghY2FsbGFibGVUb29sc1ByZXNlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IG1heENhbGxzID0gKF9jID0gY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLm1heGltdW1SZW1vdGVDYWxscztcbiAgICBpZiAoKG1heENhbGxzICYmIChtYXhDYWxscyA8IDAgfHwgIU51bWJlci5pc0ludGVnZXIobWF4Q2FsbHMpKSkgfHxcbiAgICAgICAgbWF4Q2FsbHMgPT0gMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0ludmFsaWQgbWF4aW11bVJlbW90ZUNhbGxzIHZhbHVlIHByb3ZpZGVkIGZvciBhdXRvbWF0aWMgZnVuY3Rpb24gY2FsbGluZy4gRGlzYWJsZWQgYXV0b21hdGljIGZ1bmN0aW9uIGNhbGxpbmcuIFBsZWFzZSBwcm92aWRlIGEgdmFsaWQgaW50ZWdlciB2YWx1ZSBncmVhdGVyIHRoYW4gMC4gbWF4aW11bVJlbW90ZUNhbGxzIHByb3ZpZGVkOicsIG1heENhbGxzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzQ2FsbGFibGVUb29sKHRvb2wpIHtcbiAgICByZXR1cm4gJ2NhbGxUb29sJyBpbiB0b29sICYmIHR5cGVvZiB0b29sLmNhbGxUb29sID09PSAnZnVuY3Rpb24nO1xufVxuLy8gQ2hlY2tzIHdoZXRoZXIgdGhlIGxpc3Qgb2YgdG9vbHMgY29udGFpbnMgYW55IENhbGxhYmxlVG9vbHMuIFdpbGwgcmV0dXJuIHRydWVcbi8vIGlmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBDYWxsYWJsZVRvb2wuXG5mdW5jdGlvbiBoYXNDYWxsYWJsZVRvb2xzKHBhcmFtcykge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIHJldHVybiAoX2MgPSAoX2IgPSAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9vbHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zb21lKCh0b29sKSA9PiBpc0NhbGxhYmxlVG9vbCh0b29sKSkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGZhbHNlO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbmRleGVzIG9mIHRoZSB0b29scyB0aGF0IGFyZSBub3QgY29tcGF0aWJsZSB3aXRoIEFGQy5cbiAqL1xuZnVuY3Rpb24gZmluZEFmY0luY29tcGF0aWJsZVRvb2xJbmRleGVzKHBhcmFtcykge1xuICAgIHZhciBfYTtcbiAgICAvLyBVc2UgbnVtYmVyW10gZm9yIGFuIGFycmF5IG9mIG51bWJlcnMgaW4gVHlwZVNjcmlwdFxuICAgIGNvbnN0IGFmY0luY29tcGF0aWJsZVRvb2xJbmRleGVzID0gW107XG4gICAgaWYgKCEoKF9hID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvb2xzKSkge1xuICAgICAgICByZXR1cm4gYWZjSW5jb21wYXRpYmxlVG9vbEluZGV4ZXM7XG4gICAgfVxuICAgIHBhcmFtcy5jb25maWcudG9vbHMuZm9yRWFjaCgodG9vbCwgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKGlzQ2FsbGFibGVUb29sKHRvb2wpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZ2VtaW5pVG9vbCA9IHRvb2w7XG4gICAgICAgIGlmIChnZW1pbmlUb29sLmZ1bmN0aW9uRGVjbGFyYXRpb25zICYmXG4gICAgICAgICAgICBnZW1pbmlUb29sLmZ1bmN0aW9uRGVjbGFyYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGFmY0luY29tcGF0aWJsZVRvb2xJbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGFmY0luY29tcGF0aWJsZVRvb2xJbmRleGVzO1xufVxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdG8gYXBwZW5kIGF1dG9tYXRpYyBmdW5jdGlvbiBjYWxsaW5nIGhpc3RvcnkgdG8gdGhlXG4gKiByZXNwb25zZS5cbiAqL1xuZnVuY3Rpb24gc2hvdWxkQXBwZW5kQWZjSGlzdG9yeShjb25maWcpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICEoKF9hID0gY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlnbm9yZUNhbGxIaXN0b3J5KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgTW9kZWxzIGV4dGVuZHMgQmFzZU1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFrZXMgYW4gQVBJIHJlcXVlc3QgdG8gZ2VuZXJhdGUgY29udGVudCB3aXRoIGEgZ2l2ZW4gbW9kZWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciB0aGUgYG1vZGVsYCBwYXJhbWV0ZXIsIHN1cHBvcnRlZCBmb3JtYXRzIGZvciBWZXJ0ZXggQUkgQVBJIGluY2x1ZGU6XG4gICAgICAgICAqIC0gVGhlIEdlbWluaSBtb2RlbCBJRCwgZm9yIGV4YW1wbGU6ICdnZW1pbmktMi4wLWZsYXNoJ1xuICAgICAgICAgKiAtIFRoZSBmdWxsIHJlc291cmNlIG5hbWUgc3RhcnRzIHdpdGggJ3Byb2plY3RzLycsIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAgJ3Byb2plY3RzL215LXByb2plY3QtaWQvbG9jYXRpb25zL3VzLWNlbnRyYWwxL3B1Ymxpc2hlcnMvZ29vZ2xlL21vZGVscy9nZW1pbmktMi4wLWZsYXNoJ1xuICAgICAgICAgKiAtIFRoZSBwYXJ0aWFsIHJlc291cmNlIG5hbWUgd2l0aCAncHVibGlzaGVycy8nLCBmb3IgZXhhbXBsZTpcbiAgICAgICAgICogICdwdWJsaXNoZXJzL2dvb2dsZS9tb2RlbHMvZ2VtaW5pLTIuMC1mbGFzaCcgb3JcbiAgICAgICAgICogICdwdWJsaXNoZXJzL21ldGEvbW9kZWxzL2xsYW1hLTMuMS00MDViLWluc3RydWN0LW1hYXMnXG4gICAgICAgICAqIC0gYC9gIHNlcGFyYXRlZCBwdWJsaXNoZXIgYW5kIG1vZGVsIG5hbWUsIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAnZ29vZ2xlL2dlbWluaS0yLjAtZmxhc2gnIG9yICdtZXRhL2xsYW1hLTMuMS00MDViLWluc3RydWN0LW1hYXMnXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciB0aGUgYG1vZGVsYCBwYXJhbWV0ZXIsIHN1cHBvcnRlZCBmb3JtYXRzIGZvciBHZW1pbmkgQVBJIGluY2x1ZGU6XG4gICAgICAgICAqIC0gVGhlIEdlbWluaSBtb2RlbCBJRCwgZm9yIGV4YW1wbGU6ICdnZW1pbmktMi4wLWZsYXNoJ1xuICAgICAgICAgKiAtIFRoZSBtb2RlbCBuYW1lIHN0YXJ0cyB3aXRoICdtb2RlbHMvJywgZm9yIGV4YW1wbGU6XG4gICAgICAgICAqICAnbW9kZWxzL2dlbWluaS0yLjAtZmxhc2gnXG4gICAgICAgICAqIC0gRm9yIHR1bmVkIG1vZGVscywgdGhlIG1vZGVsIG5hbWUgc3RhcnRzIHdpdGggJ3R1bmVkTW9kZWxzLycsXG4gICAgICAgICAqIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAndHVuZWRNb2RlbHMvMTIzNDU2Nzg5MDEyMzQ1Njc4OSdcbiAgICAgICAgICpcbiAgICAgICAgICogU29tZSBtb2RlbHMgc3VwcG9ydCBtdWx0aW1vZGFsIGlucHV0IGFuZCBvdXRwdXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZ2VuZXJhdGluZyBjb250ZW50LlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSByZXNwb25zZSBmcm9tIGdlbmVyYXRpbmcgY29udGVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5tb2RlbHMuZ2VuZXJhdGVDb250ZW50KHtcbiAgICAgICAgICogICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnLFxuICAgICAgICAgKiAgIGNvbnRlbnRzOiAnd2h5IGlzIHRoZSBza3kgYmx1ZT8nLFxuICAgICAgICAgKiAgIGNvbmZpZzoge1xuICAgICAgICAgKiAgICAgY2FuZGlkYXRlQ291bnQ6IDIsXG4gICAgICAgICAqICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICogY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2VuZXJhdGVDb250ZW50ID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkUGFyYW1zID0gYXdhaXQgdGhpcy5wcm9jZXNzUGFyYW1zTWF5YmVBZGRNY3BVc2FnZShwYXJhbXMpO1xuICAgICAgICAgICAgdGhpcy5tYXliZU1vdmVUb1Jlc3BvbnNlSnNvblNjaGVtKHBhcmFtcyk7XG4gICAgICAgICAgICBpZiAoIWhhc0NhbGxhYmxlVG9vbHMocGFyYW1zKSB8fCBzaG91bGREaXNhYmxlQWZjKHBhcmFtcy5jb25maWcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2VuZXJhdGVDb250ZW50SW50ZXJuYWwodHJhbnNmb3JtZWRQYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW5jb21wYXRpYmxlVG9vbEluZGV4ZXMgPSBmaW5kQWZjSW5jb21wYXRpYmxlVG9vbEluZGV4ZXMocGFyYW1zKTtcbiAgICAgICAgICAgIGlmIChpbmNvbXBhdGlibGVUb29sSW5kZXhlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVkSW5kZXhlcyA9IGluY29tcGF0aWJsZVRvb2xJbmRleGVzXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKGluZGV4KSA9PiBgdG9vbHNbJHtpbmRleH1dYClcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJywgJyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdXRvbWF0aWMgZnVuY3Rpb24gY2FsbGluZyB3aXRoIENhbGxhYmxlVG9vbHMgKG9yIE1DUCBvYmplY3RzKSBhbmQgYmFzaWMgRnVuY3Rpb25EZWNsYXJhdGlvbnMgaXMgbm90IHlldCBzdXBwb3J0ZWQuIEluY29tcGF0aWJsZSB0b29scyBmb3VuZCBhdCAke2Zvcm1hdHRlZEluZGV4ZXN9LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICAgICAgbGV0IGZ1bmN0aW9uUmVzcG9uc2VDb250ZW50O1xuICAgICAgICAgICAgY29uc3QgYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSA9IHRDb250ZW50cyh0cmFuc2Zvcm1lZFBhcmFtcy5jb250ZW50cyk7XG4gICAgICAgICAgICBjb25zdCBtYXhSZW1vdGVDYWxscyA9IChfYyA9IChfYiA9IChfYSA9IHRyYW5zZm9ybWVkUGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm1heGltdW1SZW1vdGVDYWxscykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogREVGQVVMVF9NQVhfUkVNT1RFX0NBTExTO1xuICAgICAgICAgICAgbGV0IHJlbW90ZUNhbGxzID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChyZW1vdGVDYWxscyA8IG1heFJlbW90ZUNhbGxzKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdlbmVyYXRlQ29udGVudEludGVybmFsKHRyYW5zZm9ybWVkUGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLmZ1bmN0aW9uQ2FsbHMgfHwgcmVzcG9uc2UuZnVuY3Rpb25DYWxscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQ29udGVudCA9IHJlc3BvbnNlLmNhbmRpZGF0ZXNbMF0uY29udGVudDtcbiAgICAgICAgICAgICAgICBjb25zdCBmdW5jdGlvblJlc3BvbnNlUGFydHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2wgb2YgKF9lID0gKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnRvb2xzKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBbXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNDYWxsYWJsZVRvb2wodG9vbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxhYmxlVG9vbCA9IHRvb2w7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGF3YWl0IGNhbGxhYmxlVG9vbC5jYWxsVG9vbChyZXNwb25zZS5mdW5jdGlvbkNhbGxzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2VQYXJ0cy5wdXNoKC4uLnBhcnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZW1vdGVDYWxscysrO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2VDb250ZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgICAgICAgICAgICAgIHBhcnRzOiBmdW5jdGlvblJlc3BvbnNlUGFydHMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFBhcmFtcy5jb250ZW50cyA9IHRDb250ZW50cyh0cmFuc2Zvcm1lZFBhcmFtcy5jb250ZW50cyk7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRQYXJhbXMuY29udGVudHMucHVzaChyZXNwb25zZUNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkUGFyYW1zLmNvbnRlbnRzLnB1c2goZnVuY3Rpb25SZXNwb25zZUNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRBcHBlbmRBZmNIaXN0b3J5KHRyYW5zZm9ybWVkUGFyYW1zLmNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICAgICAgYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeS5wdXNoKHJlc3BvbnNlQ29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgIGF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3RvcnkucHVzaChmdW5jdGlvblJlc3BvbnNlQ29udGVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNob3VsZEFwcGVuZEFmY0hpc3RvcnkodHJhbnNmb3JtZWRQYXJhbXMuY29uZmlnKSkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLmF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3RvcnkgPVxuICAgICAgICAgICAgICAgICAgICBhdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFrZXMgYW4gQVBJIHJlcXVlc3QgdG8gZ2VuZXJhdGUgY29udGVudCB3aXRoIGEgZ2l2ZW4gbW9kZWwgYW5kIHlpZWxkcyB0aGVcbiAgICAgICAgICogcmVzcG9uc2UgaW4gY2h1bmtzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgdGhlIGBtb2RlbGAgcGFyYW1ldGVyLCBzdXBwb3J0ZWQgZm9ybWF0cyBmb3IgVmVydGV4IEFJIEFQSSBpbmNsdWRlOlxuICAgICAgICAgKiAtIFRoZSBHZW1pbmkgbW9kZWwgSUQsIGZvciBleGFtcGxlOiAnZ2VtaW5pLTIuMC1mbGFzaCdcbiAgICAgICAgICogLSBUaGUgZnVsbCByZXNvdXJjZSBuYW1lIHN0YXJ0cyB3aXRoICdwcm9qZWN0cy8nLCBmb3IgZXhhbXBsZTpcbiAgICAgICAgICogICdwcm9qZWN0cy9teS1wcm9qZWN0LWlkL2xvY2F0aW9ucy91cy1jZW50cmFsMS9wdWJsaXNoZXJzL2dvb2dsZS9tb2RlbHMvZ2VtaW5pLTIuMC1mbGFzaCdcbiAgICAgICAgICogLSBUaGUgcGFydGlhbCByZXNvdXJjZSBuYW1lIHdpdGggJ3B1Ymxpc2hlcnMvJywgZm9yIGV4YW1wbGU6XG4gICAgICAgICAqICAncHVibGlzaGVycy9nb29nbGUvbW9kZWxzL2dlbWluaS0yLjAtZmxhc2gnIG9yXG4gICAgICAgICAqICAncHVibGlzaGVycy9tZXRhL21vZGVscy9sbGFtYS0zLjEtNDA1Yi1pbnN0cnVjdC1tYWFzJ1xuICAgICAgICAgKiAtIGAvYCBzZXBhcmF0ZWQgcHVibGlzaGVyIGFuZCBtb2RlbCBuYW1lLCBmb3IgZXhhbXBsZTpcbiAgICAgICAgICogJ2dvb2dsZS9nZW1pbmktMi4wLWZsYXNoJyBvciAnbWV0YS9sbGFtYS0zLjEtNDA1Yi1pbnN0cnVjdC1tYWFzJ1xuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgdGhlIGBtb2RlbGAgcGFyYW1ldGVyLCBzdXBwb3J0ZWQgZm9ybWF0cyBmb3IgR2VtaW5pIEFQSSBpbmNsdWRlOlxuICAgICAgICAgKiAtIFRoZSBHZW1pbmkgbW9kZWwgSUQsIGZvciBleGFtcGxlOiAnZ2VtaW5pLTIuMC1mbGFzaCdcbiAgICAgICAgICogLSBUaGUgbW9kZWwgbmFtZSBzdGFydHMgd2l0aCAnbW9kZWxzLycsIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAgJ21vZGVscy9nZW1pbmktMi4wLWZsYXNoJ1xuICAgICAgICAgKiAtIEZvciB0dW5lZCBtb2RlbHMsIHRoZSBtb2RlbCBuYW1lIHN0YXJ0cyB3aXRoICd0dW5lZE1vZGVscy8nLFxuICAgICAgICAgKiBmb3IgZXhhbXBsZTpcbiAgICAgICAgICogICd0dW5lZE1vZGVscy8xMjM0NTY3ODkwMTIzNDU2Nzg5J1xuICAgICAgICAgKlxuICAgICAgICAgKiBTb21lIG1vZGVscyBzdXBwb3J0IG11bHRpbW9kYWwgaW5wdXQgYW5kIG91dHB1dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBnZW5lcmF0aW5nIGNvbnRlbnQgd2l0aCBzdHJlYW1pbmcgcmVzcG9uc2UuXG4gICAgICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gZ2VuZXJhdGluZyBjb250ZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy5nZW5lcmF0ZUNvbnRlbnRTdHJlYW0oe1xuICAgICAgICAgKiAgIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaCcsXG4gICAgICAgICAqICAgY29udGVudHM6ICd3aHkgaXMgdGhlIHNreSBibHVlPycsXG4gICAgICAgICAqICAgY29uZmlnOiB7XG4gICAgICAgICAqICAgICBtYXhPdXRwdXRUb2tlbnM6IDIwMCxcbiAgICAgICAgICogICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHJlc3BvbnNlKSB7XG4gICAgICAgICAqICAgY29uc29sZS5sb2coY2h1bmspO1xuICAgICAgICAgKiB9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZW5lcmF0ZUNvbnRlbnRTdHJlYW0gPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgICAgICAgdGhpcy5tYXliZU1vdmVUb1Jlc3BvbnNlSnNvblNjaGVtKHBhcmFtcyk7XG4gICAgICAgICAgICBpZiAoc2hvdWxkRGlzYWJsZUFmYyhwYXJhbXMuY29uZmlnKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkUGFyYW1zID0gYXdhaXQgdGhpcy5wcm9jZXNzUGFyYW1zTWF5YmVBZGRNY3BVc2FnZShwYXJhbXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdlbmVyYXRlQ29udGVudFN0cmVhbUludGVybmFsKHRyYW5zZm9ybWVkUGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGluY29tcGF0aWJsZVRvb2xJbmRleGVzID0gZmluZEFmY0luY29tcGF0aWJsZVRvb2xJbmRleGVzKHBhcmFtcyk7XG4gICAgICAgICAgICBpZiAoaW5jb21wYXRpYmxlVG9vbEluZGV4ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZEluZGV4ZXMgPSBpbmNvbXBhdGlibGVUb29sSW5kZXhlc1xuICAgICAgICAgICAgICAgICAgICAubWFwKChpbmRleCkgPT4gYHRvb2xzWyR7aW5kZXh9XWApXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCcsICcpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5jb21wYXRpYmxlIHRvb2xzIGZvdW5kIGF0ICR7Zm9ybWF0dGVkSW5kZXhlc30uIEF1dG9tYXRpYyBmdW5jdGlvbiBjYWxsaW5nIHdpdGggQ2FsbGFibGVUb29scyAob3IgTUNQIG9iamVjdHMpIGFuZCBiYXNpYyBGdW5jdGlvbkRlY2xhcmF0aW9uc1wiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2l0aCB0b29sIGNvbXBhdGliaWxpdHkgY29uZmlybWVkLCB2YWxpZGF0ZSB0aGF0IHRoZSBjb25maWd1cmF0aW9uIGFyZVxuICAgICAgICAgICAgLy8gY29tcGF0aWJsZSB3aXRoIGVhY2ggb3RoZXIgYW5kIHJhaXNlIGFuIGVycm9yIGlmIGludmFsaWQuXG4gICAgICAgICAgICBjb25zdCBzdHJlYW1GdW5jdGlvbkNhbGwgPSAoX2MgPSAoX2IgPSAoX2EgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9vbENvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmZ1bmN0aW9uQ2FsbGluZ0NvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnN0cmVhbUZ1bmN0aW9uQ2FsbEFyZ3VtZW50cztcbiAgICAgICAgICAgIGNvbnN0IGRpc2FibGVBZmMgPSAoX2UgPSAoX2QgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuZGlzYWJsZTtcbiAgICAgICAgICAgIGlmIChzdHJlYW1GdW5jdGlvbkNhbGwgJiYgIWRpc2FibGVBZmMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSdW5uaW5nIGluIHN0cmVhbWluZyBtb2RlIHdpdGggJ3N0cmVhbUZ1bmN0aW9uQ2FsbEFyZ3VtZW50cycgZW5hYmxlZCwgXCIgK1xuICAgICAgICAgICAgICAgICAgICAndGhpcyBmZWF0dXJlIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggYXV0b21hdGljIGZ1bmN0aW9uIGNhbGxpbmcgKEFGQykuICcgK1xuICAgICAgICAgICAgICAgICAgICBcIlBsZWFzZSBzZXQgJ2NvbmZpZy5hdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmcuZGlzYWJsZScgdG8gdHJ1ZSB0byBkaXNhYmxlIEFGQyBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwib3IgbGVhdmUgJ2NvbmZpZy50b29sQ29uZmlnLmZ1bmN0aW9uQ2FsbGluZ0NvbmZpZy5zdHJlYW1GdW5jdGlvbkNhbGxBcmd1bWVudHMnIFwiICtcbiAgICAgICAgICAgICAgICAgICAgJ3RvIGJlIHVuZGVmaW5lZCBvciBzZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSBzdHJlYW1pbmcgZnVuY3Rpb24gY2FsbCBhcmd1bWVudHMgZmVhdHVyZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByb2Nlc3NBZmNTdHJlYW0ocGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdlbmVyYXRlcyBhbiBpbWFnZSBiYXNlZCBvbiBhIHRleHQgZGVzY3JpcHRpb24gYW5kIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZ2VuZXJhdGluZyBpbWFnZXMuXG4gICAgICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjbGllbnQubW9kZWxzLmdlbmVyYXRlSW1hZ2VzKHtcbiAgICAgICAgICogIG1vZGVsOiAnaW1hZ2VuLTMuMC1nZW5lcmF0ZS0wMDInLFxuICAgICAgICAgKiAgcHJvbXB0OiAnUm9ib3QgaG9sZGluZyBhIHJlZCBza2F0ZWJvYXJkJyxcbiAgICAgICAgICogIGNvbmZpZzoge1xuICAgICAgICAgKiAgICBudW1iZXJPZkltYWdlczogMSxcbiAgICAgICAgICogICAgaW5jbHVkZVJhaVJlYXNvbjogdHJ1ZSxcbiAgICAgICAgICogIH0sXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZT8uZ2VuZXJhdGVkSW1hZ2VzPy5bMF0/LmltYWdlPy5pbWFnZUJ5dGVzKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdlbmVyYXRlSW1hZ2VzID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2VuZXJhdGVJbWFnZXNJbnRlcm5hbChwYXJhbXMpLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGxldCBwb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2VuZXJhdGVkSW1hZ2VzID0gW107XG4gICAgICAgICAgICAgICAgaWYgKGFwaVJlc3BvbnNlID09PSBudWxsIHx8IGFwaVJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcGlSZXNwb25zZS5nZW5lcmF0ZWRJbWFnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBnZW5lcmF0ZWRJbWFnZSBvZiBhcGlSZXNwb25zZS5nZW5lcmF0ZWRJbWFnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnZW5lcmF0ZWRJbWFnZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChnZW5lcmF0ZWRJbWFnZSA9PT0gbnVsbCB8fCBnZW5lcmF0ZWRJbWFnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2VuZXJhdGVkSW1hZ2Uuc2FmZXR5QXR0cmlidXRlcykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKF9hID0gZ2VuZXJhdGVkSW1hZ2UgPT09IG51bGwgfHwgZ2VuZXJhdGVkSW1hZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdlbmVyYXRlZEltYWdlLnNhZmV0eUF0dHJpYnV0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250ZW50VHlwZSkgPT09ICdQb3NpdGl2ZSBQcm9tcHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzID0gZ2VuZXJhdGVkSW1hZ2UgPT09IG51bGwgfHwgZ2VuZXJhdGVkSW1hZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdlbmVyYXRlZEltYWdlLnNhZmV0eUF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZWRJbWFnZXMucHVzaChnZW5lcmF0ZWRJbWFnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZWRJbWFnZXM6IGdlbmVyYXRlZEltYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlczogcG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2RrSHR0cFJlc3BvbnNlOiBhcGlSZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlZEltYWdlczogZ2VuZXJhdGVkSW1hZ2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2RrSHR0cFJlc3BvbnNlOiBhcGlSZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxpc3QgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0Q29uZmlnID0ge1xuICAgICAgICAgICAgICAgIHF1ZXJ5QmFzZTogdHJ1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBhY3R1YWxDb25maWcgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRDb25maWcpLCBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuY29uZmlnKTtcbiAgICAgICAgICAgIGNvbnN0IGFjdHVhbFBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBjb25maWc6IGFjdHVhbENvbmZpZyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhY3R1YWxQYXJhbXMuY29uZmlnLnF1ZXJ5QmFzZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKF9hID0gYWN0dWFsUGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaWx0ZXJpbmcgdHVuZWQgbW9kZWxzIGxpc3QgZm9yIFZlcnRleCBBSSBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsUGFyYW1zLmNvbmZpZy5maWx0ZXIgPSAnbGFiZWxzLnR1bmUtdHlwZToqJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUGFnZXIoUGFnZWRJdGVtLlBBR0VEX0lURU1fTU9ERUxTLCAoeCkgPT4gdGhpcy5saXN0SW50ZXJuYWwoeCksIGF3YWl0IHRoaXMubGlzdEludGVybmFsKGFjdHVhbFBhcmFtcyksIGFjdHVhbFBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFZGl0cyBhbiBpbWFnZSBiYXNlZCBvbiBhIHByb21wdCwgbGlzdCBvZiByZWZlcmVuY2UgaW1hZ2VzLCBhbmQgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBlZGl0aW5nIGFuIGltYWdlLlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSByZXNwb25zZSBmcm9tIHRoZSBBUEkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2xpZW50Lm1vZGVscy5lZGl0SW1hZ2Uoe1xuICAgICAgICAgKiAgbW9kZWw6ICdpbWFnZW4tMy4wLWNhcGFiaWxpdHktMDAxJyxcbiAgICAgICAgICogIHByb21wdDogJ0dlbmVyYXRlIGFuIGltYWdlIGNvbnRhaW5pbmcgYSBtdWcgd2l0aCB0aGUgcHJvZHVjdCBsb2dvIFsxXSB2aXNpYmxlIG9uIHRoZSBzaWRlIG9mIHRoZSBtdWcuJyxcbiAgICAgICAgICogIHJlZmVyZW5jZUltYWdlczogW3N1YmplY3RSZWZlcmVuY2VJbWFnZV1cbiAgICAgICAgICogIGNvbmZpZzoge1xuICAgICAgICAgKiAgICBudW1iZXJPZkltYWdlczogMSxcbiAgICAgICAgICogICAgaW5jbHVkZVJhaVJlYXNvbjogdHJ1ZSxcbiAgICAgICAgICogIH0sXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZT8uZ2VuZXJhdGVkSW1hZ2VzPy5bMF0/LmltYWdlPy5pbWFnZUJ5dGVzKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVkaXRJbWFnZSA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtc0ludGVybmFsID0ge1xuICAgICAgICAgICAgICAgIG1vZGVsOiBwYXJhbXMubW9kZWwsXG4gICAgICAgICAgICAgICAgcHJvbXB0OiBwYXJhbXMucHJvbXB0LFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZUltYWdlczogW10sXG4gICAgICAgICAgICAgICAgY29uZmlnOiBwYXJhbXMuY29uZmlnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChwYXJhbXMucmVmZXJlbmNlSW1hZ2VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5yZWZlcmVuY2VJbWFnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zSW50ZXJuYWwucmVmZXJlbmNlSW1hZ2VzID0gcGFyYW1zLnJlZmVyZW5jZUltYWdlcy5tYXAoKGltZykgPT4gaW1nLnRvUmVmZXJlbmNlSW1hZ2VBUEkoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZWRpdEltYWdlSW50ZXJuYWwocGFyYW1zSW50ZXJuYWwpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBzY2FsZXMgYW4gaW1hZ2UgYmFzZWQgb24gYW4gaW1hZ2UsIHVwc2NhbGUgZmFjdG9yLCBhbmQgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICogT25seSBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJIGN1cnJlbnRseS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB1cHNjYWxpbmcgYW4gaW1hZ2UuXG4gICAgICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjbGllbnQubW9kZWxzLnVwc2NhbGVJbWFnZSh7XG4gICAgICAgICAqICBtb2RlbDogJ2ltYWdlbi0zLjAtZ2VuZXJhdGUtMDAyJyxcbiAgICAgICAgICogIGltYWdlOiBpbWFnZSxcbiAgICAgICAgICogIHVwc2NhbGVGYWN0b3I6ICd4MicsXG4gICAgICAgICAqICBjb25maWc6IHtcbiAgICAgICAgICogICAgaW5jbHVkZVJhaVJlYXNvbjogdHJ1ZSxcbiAgICAgICAgICogIH0sXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZT8uZ2VuZXJhdGVkSW1hZ2VzPy5bMF0/LmltYWdlPy5pbWFnZUJ5dGVzKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVwc2NhbGVJbWFnZSA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIGxldCBhcGlDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyT2ZJbWFnZXM6IDEsXG4gICAgICAgICAgICAgICAgbW9kZTogJ3Vwc2NhbGUnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChwYXJhbXMuY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgYXBpQ29uZmlnID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhcGlDb25maWcpLCBwYXJhbXMuY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFwaVBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBtb2RlbDogcGFyYW1zLm1vZGVsLFxuICAgICAgICAgICAgICAgIGltYWdlOiBwYXJhbXMuaW1hZ2UsXG4gICAgICAgICAgICAgICAgdXBzY2FsZUZhY3RvcjogcGFyYW1zLnVwc2NhbGVGYWN0b3IsXG4gICAgICAgICAgICAgICAgY29uZmlnOiBhcGlDb25maWcsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudXBzY2FsZUltYWdlSW50ZXJuYWwoYXBpUGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqICBHZW5lcmF0ZXMgdmlkZW9zIGJhc2VkIG9uIGEgdGV4dCBkZXNjcmlwdGlvbiBhbmQgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBnZW5lcmF0aW5nIHZpZGVvcy5cbiAgICAgICAgICogQHJldHVybiBBIFByb21pc2U8R2VuZXJhdGVWaWRlb3NPcGVyYXRpb24+IHdoaWNoIGFsbG93cyB5b3UgdG8gdHJhY2sgdGhlIHByb2dyZXNzIGFuZCBldmVudHVhbGx5IHJldHJpZXZlIHRoZSBnZW5lcmF0ZWQgdmlkZW9zIHVzaW5nIHRoZSBvcGVyYXRpb25zLmdldCBtZXRob2QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IG9wZXJhdGlvbiA9IGF3YWl0IGFpLm1vZGVscy5nZW5lcmF0ZVZpZGVvcyh7XG4gICAgICAgICAqICBtb2RlbDogJ3Zlby0yLjAtZ2VuZXJhdGUtMDAxJyxcbiAgICAgICAgICogIHNvdXJjZToge1xuICAgICAgICAgKiAgICBwcm9tcHQ6ICdBIG5lb24gaG9sb2dyYW0gb2YgYSBjYXQgZHJpdmluZyBhdCB0b3Agc3BlZWQnLFxuICAgICAgICAgKiAgfSxcbiAgICAgICAgICogIGNvbmZpZzoge1xuICAgICAgICAgKiAgICBudW1iZXJPZlZpZGVvczogMVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogd2hpbGUgKCFvcGVyYXRpb24uZG9uZSkge1xuICAgICAgICAgKiAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwMCkpO1xuICAgICAgICAgKiAgIG9wZXJhdGlvbiA9IGF3YWl0IGFpLm9wZXJhdGlvbnMuZ2V0VmlkZW9zT3BlcmF0aW9uKHtvcGVyYXRpb246IG9wZXJhdGlvbn0pO1xuICAgICAgICAgKiB9XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnNvbGUubG9nKG9wZXJhdGlvbi5yZXNwb25zZT8uZ2VuZXJhdGVkVmlkZW9zPy5bMF0/LnZpZGVvPy51cmkpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2VuZXJhdGVWaWRlb3MgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgICAgIGlmICgocGFyYW1zLnByb21wdCB8fCBwYXJhbXMuaW1hZ2UgfHwgcGFyYW1zLnZpZGVvKSAmJiBwYXJhbXMuc291cmNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTb3VyY2UgYW5kIHByb21wdC9pbWFnZS92aWRlbyBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlLiBQbGVhc2Ugb25seSB1c2Ugc291cmNlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2VtaW5pIEFQSSBkb2VzIG5vdCBzdXBwb3J0IHZpZGVvIGJ5dGVzLlxuICAgICAgICAgICAgaWYgKCF0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoKChfYSA9IHBhcmFtcy52aWRlbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVyaSkgJiYgKChfYiA9IHBhcmFtcy52aWRlbykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnZpZGVvQnl0ZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy52aWRlbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVyaTogcGFyYW1zLnZpZGVvLnVyaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBwYXJhbXMudmlkZW8ubWltZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCgoX2QgPSAoX2MgPSBwYXJhbXMuc291cmNlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudmlkZW8pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC51cmkpICYmXG4gICAgICAgICAgICAgICAgICAgICgoX2YgPSAoX2UgPSBwYXJhbXMuc291cmNlKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UudmlkZW8pID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi52aWRlb0J5dGVzKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuc291cmNlLnZpZGVvID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJpOiBwYXJhbXMuc291cmNlLnZpZGVvLnVyaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBwYXJhbXMuc291cmNlLnZpZGVvLm1pbWVUeXBlLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdlbmVyYXRlVmlkZW9zSW50ZXJuYWwocGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBsb2dpYyBpcyBuZWVkZWQgZm9yIEdlbmVyYXRlQ29udGVudENvbmZpZyBvbmx5LlxuICAgICAqIFByZXZpb3VzbHkgd2UgbWFkZSBHZW5lcmF0ZUNvbnRlbnRDb25maWcucmVzcG9uc2VTY2hlbWEgZmllbGQgdG8gYWNjZXB0XG4gICAgICogdW5rbm93bi4gU2luY2UgdjEuOS4wLCB3ZSBzd2l0Y2ggdG8gdXNlIGJhY2tlbmQgSlNPTiBzY2hlbWEgc3VwcG9ydC5cbiAgICAgKiBUbyBtYWludGFpbiBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB3ZSBtb3ZlIHRoZSBkYXRhIHRoYXQgd2FzIHRyZWF0ZWQgYXNcbiAgICAgKiBKU09OIHNjaGVtYSBmcm9tIHRoZSByZXNwb25zZVNjaGVtYSBmaWVsZCB0byB0aGUgcmVzcG9uc2VKc29uU2NoZW1hIGZpZWxkLlxuICAgICAqL1xuICAgIG1heWJlTW92ZVRvUmVzcG9uc2VKc29uU2NoZW0ocGFyYW1zKSB7XG4gICAgICAgIGlmIChwYXJhbXMuY29uZmlnICYmIHBhcmFtcy5jb25maWcucmVzcG9uc2VTY2hlbWEpIHtcbiAgICAgICAgICAgIGlmICghcGFyYW1zLmNvbmZpZy5yZXNwb25zZUpzb25TY2hlbWEpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMocGFyYW1zLmNvbmZpZy5yZXNwb25zZVNjaGVtYSkuaW5jbHVkZXMoJyRzY2hlbWEnKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuY29uZmlnLnJlc3BvbnNlSnNvblNjaGVtYSA9IHBhcmFtcy5jb25maWcucmVzcG9uc2VTY2hlbWE7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXJhbXMuY29uZmlnLnJlc3BvbnNlU2NoZW1hO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgdGhlIENhbGxhYmxlVG9vbHMgaW4gdGhlIHBhcmFtZXRlcnMgdG8gYmUgc2ltcGx5IFRvb2xzLCBpdFxuICAgICAqIGNvcGllcyB0aGUgcGFyYW1zIGludG8gYSBuZXcgb2JqZWN0IGFuZCByZXBsYWNlcyB0aGUgdG9vbHMsIGl0IGRvZXMgbm90XG4gICAgICogbW9kaWZ5IHRoZSBvcmlnaW5hbCBwYXJhbXMuIEFsc28gc2V0cyB0aGUgTUNQIHVzYWdlIGhlYWRlciBpZiB0aGVyZSBhcmVcbiAgICAgKiBNQ1AgdG9vbHMgaW4gdGhlIHBhcmFtZXRlcnMuXG4gICAgICovXG4gICAgYXN5bmMgcHJvY2Vzc1BhcmFtc01heWJlQWRkTWNwVXNhZ2UocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCB0b29scyA9IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b29scztcbiAgICAgICAgaWYgKCF0b29scykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFRvb2xzID0gYXdhaXQgUHJvbWlzZS5hbGwodG9vbHMubWFwKGFzeW5jICh0b29sKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNDYWxsYWJsZVRvb2wodG9vbCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsYWJsZVRvb2wgPSB0b29sO1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBjYWxsYWJsZVRvb2wudG9vbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRvb2w7XG4gICAgICAgIH0pKTtcbiAgICAgICAgY29uc3QgbmV3UGFyYW1zID0ge1xuICAgICAgICAgICAgbW9kZWw6IHBhcmFtcy5tb2RlbCxcbiAgICAgICAgICAgIGNvbnRlbnRzOiBwYXJhbXMuY29udGVudHMsXG4gICAgICAgICAgICBjb25maWc6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zLmNvbmZpZyksIHsgdG9vbHM6IHRyYW5zZm9ybWVkVG9vbHMgfSksXG4gICAgICAgIH07XG4gICAgICAgIG5ld1BhcmFtcy5jb25maWcudG9vbHMgPSB0cmFuc2Zvcm1lZFRvb2xzO1xuICAgICAgICBpZiAocGFyYW1zLmNvbmZpZyAmJlxuICAgICAgICAgICAgcGFyYW1zLmNvbmZpZy50b29scyAmJlxuICAgICAgICAgICAgaGFzTWNwVG9vbFVzYWdlKHBhcmFtcy5jb25maWcudG9vbHMpKSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gKF9jID0gKF9iID0gcGFyYW1zLmNvbmZpZy5odHRwT3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmhlYWRlcnMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHt9O1xuICAgICAgICAgICAgbGV0IG5ld0hlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCBoZWFkZXJzKTtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhuZXdIZWFkZXJzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBuZXdIZWFkZXJzID0gdGhpcy5hcGlDbGllbnQuZ2V0RGVmYXVsdEhlYWRlcnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldE1jcFVzYWdlSGVhZGVyKG5ld0hlYWRlcnMpO1xuICAgICAgICAgICAgbmV3UGFyYW1zLmNvbmZpZy5odHRwT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zLmNvbmZpZy5odHRwT3B0aW9ucyksIHsgaGVhZGVyczogbmV3SGVhZGVycyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3UGFyYW1zO1xuICAgIH1cbiAgICBhc3luYyBpbml0QWZjVG9vbHNNYXAocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBhZmNUb29scyA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCB0b29sIG9mIChfYiA9IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b29scykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10pIHtcbiAgICAgICAgICAgIGlmIChpc0NhbGxhYmxlVG9vbCh0b29sKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxhYmxlVG9vbCA9IHRvb2w7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vbERlY2xhcmF0aW9uID0gYXdhaXQgY2FsbGFibGVUb29sLnRvb2woKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRlY2xhcmF0aW9uIG9mIChfYyA9IHRvb2xEZWNsYXJhdGlvbi5mdW5jdGlvbkRlY2xhcmF0aW9ucykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogW10pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkZWNsYXJhdGlvbi5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIGRlY2xhcmF0aW9uIG5hbWUgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFmY1Rvb2xzLmhhcyhkZWNsYXJhdGlvbi5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgdG9vbCBkZWNsYXJhdGlvbiBuYW1lOiAke2RlY2xhcmF0aW9uLm5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYWZjVG9vbHMuc2V0KGRlY2xhcmF0aW9uLm5hbWUsIGNhbGxhYmxlVG9vbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhZmNUb29scztcbiAgICB9XG4gICAgYXN5bmMgcHJvY2Vzc0FmY1N0cmVhbShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IG1heFJlbW90ZUNhbGxzID0gKF9jID0gKF9iID0gKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm1heGltdW1SZW1vdGVDYWxscykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogREVGQVVMVF9NQVhfUkVNT1RFX0NBTExTO1xuICAgICAgICBsZXQgd2VyZUZ1bmN0aW9uc0NhbGxlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgcmVtb3RlQ2FsbENvdW50ID0gMDtcbiAgICAgICAgY29uc3QgYWZjVG9vbHNNYXAgPSBhd2FpdCB0aGlzLmluaXRBZmNUb29sc01hcChwYXJhbXMpO1xuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uIChtb2RlbHMsIGFmY1Rvb2xzLCBwYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9jLCBlXzEsIF9kLCBfZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocmVtb3RlQ2FsbENvdW50IDwgbWF4UmVtb3RlQ2FsbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdlcmVGdW5jdGlvbnNDYWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZUNhbGxDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2VyZUZ1bmN0aW9uc0NhbGxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkUGFyYW1zID0geWllbGQgX19hd2FpdChtb2RlbHMucHJvY2Vzc1BhcmFtc01heWJlQWRkTWNwVXNhZ2UocGFyYW1zKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgX19hd2FpdChtb2RlbHMuZ2VuZXJhdGVDb250ZW50U3RyZWFtSW50ZXJuYWwodHJhbnNmb3JtZWRQYXJhbXMpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZnVuY3Rpb25SZXNwb25zZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VDb250ZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2YgPSB0cnVlLCByZXNwb25zZV8xID0gKGVfMSA9IHZvaWQgMCwgX19hc3luY1ZhbHVlcyhyZXNwb25zZSkpLCByZXNwb25zZV8xXzE7IHJlc3BvbnNlXzFfMSA9IHlpZWxkIF9fYXdhaXQocmVzcG9uc2VfMS5uZXh0KCkpLCBfYyA9IHJlc3BvbnNlXzFfMS5kb25lLCAhX2M7IF9mID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9lID0gcmVzcG9uc2VfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBfZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmsuY2FuZGlkYXRlcyAmJiAoKF9hID0gY2h1bmsuY2FuZGlkYXRlc1swXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlQ29udGVudHMucHVzaChjaHVuay5jYW5kaWRhdGVzWzBdLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgKF9iID0gY2h1bmsuY2FuZGlkYXRlc1swXS5jb250ZW50LnBhcnRzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlbW90ZUNhbGxDb3VudCA8IG1heFJlbW90ZUNhbGxzICYmIHBhcnQuZnVuY3Rpb25DYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJ0LmZ1bmN0aW9uQ2FsbC5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gY2FsbCBuYW1lIHdhcyBub3QgcmV0dXJuZWQgYnkgdGhlIG1vZGVsLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFmY1Rvb2xzLmhhcyhwYXJ0LmZ1bmN0aW9uQ2FsbC5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEF1dG9tYXRpYyBmdW5jdGlvbiBjYWxsaW5nIHdhcyByZXF1ZXN0ZWQsIGJ1dCBub3QgYWxsIHRoZSB0b29scyB0aGUgbW9kZWwgdXNlZCBpbXBsZW1lbnQgdGhlIENhbGxhYmxlVG9vbCBpbnRlcmZhY2UuIEF2YWlsYWJsZSB0b29sczogJHthZmNUb29scy5rZXlzKCl9LCBtaXNpbmcgdG9vbDogJHtwYXJ0LmZ1bmN0aW9uQ2FsbC5uYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VQYXJ0cyA9IHlpZWxkIF9fYXdhaXQoYWZjVG9vbHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5nZXQocGFydC5mdW5jdGlvbkNhbGwubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYWxsVG9vbChbcGFydC5mdW5jdGlvbkNhbGxdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2VzLnB1c2goLi4ucmVzcG9uc2VQYXJ0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9mICYmICFfYyAmJiAoX2QgPSByZXNwb25zZV8xLnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2QuY2FsbChyZXNwb25zZV8xKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bmN0aW9uUmVzcG9uc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlcmVGdW5jdGlvbnNDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwb25zZUNodW5rID0gbmV3IEdlbmVyYXRlQ29udGVudFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlZFJlc3BvbnNlQ2h1bmsuY2FuZGlkYXRlcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzOiBmdW5jdGlvblJlc3BvbnNlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQodHlwZWRSZXNwb25zZUNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0NvbnRlbnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDb250ZW50cy5wdXNoKC4uLnJlc3BvbnNlQ29udGVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q29udGVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzOiBmdW5jdGlvblJlc3BvbnNlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZENvbnRlbnRzID0gdENvbnRlbnRzKHBhcmFtcy5jb250ZW50cykuY29uY2F0KG5ld0NvbnRlbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5jb250ZW50cyA9IHVwZGF0ZWRDb250ZW50cztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKHRoaXMsIGFmY1Rvb2xzTWFwLCBwYXJhbXMpO1xuICAgIH1cbiAgICBhc3luYyBnZW5lcmF0ZUNvbnRlbnRJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2VuZXJhdGVDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpnZW5lcmF0ZUNvbnRlbnQnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBnZW5lcmF0ZUNvbnRlbnRSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2VuZXJhdGVDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OmdlbmVyYXRlQ29udGVudCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGdlbmVyYXRlQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgR2VuZXJhdGVDb250ZW50UmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdlbmVyYXRlQ29udGVudFN0cmVhbUludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZW5lcmF0ZUNvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnN0cmVhbUdlbmVyYXRlQ29udGVudD9hbHQ9c3NlJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgY29uc3QgYXBpQ2xpZW50ID0gdGhpcy5hcGlDbGllbnQ7XG4gICAgICAgICAgICByZXNwb25zZSA9IGFwaUNsaWVudC5yZXF1ZXN0U3RyZWFtKHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbihmdW5jdGlvbiAoYXBpUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSwgZV8yLCBfYiwgX2M7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfZCA9IHRydWUsIGFwaVJlc3BvbnNlXzEgPSBfX2FzeW5jVmFsdWVzKGFwaVJlc3BvbnNlKSwgYXBpUmVzcG9uc2VfMV8xOyBhcGlSZXNwb25zZV8xXzEgPSB5aWVsZCBfX2F3YWl0KGFwaVJlc3BvbnNlXzEubmV4dCgpKSwgX2EgPSBhcGlSZXNwb25zZV8xXzEuZG9uZSwgIV9hOyBfZCA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYyA9IGFwaVJlc3BvbnNlXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gX2M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGdlbmVyYXRlQ29udGVudFJlc3BvbnNlRnJvbVZlcnRleCgoeWllbGQgX19hd2FpdChjaHVuay5qc29uKCkpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcFsnc2RrSHR0cFJlc3BvbnNlJ10gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGNodW5rLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgR2VuZXJhdGVDb250ZW50UmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdCh0eXBlZFJlc3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBhcGlSZXNwb25zZV8xLnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2IuY2FsbChhcGlSZXNwb25zZV8xKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdlbmVyYXRlQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpzdHJlYW1HZW5lcmF0ZUNvbnRlbnQ/YWx0PXNzZScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGNvbnN0IGFwaUNsaWVudCA9IHRoaXMuYXBpQ2xpZW50O1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBhcGlDbGllbnQucmVxdWVzdFN0cmVhbSh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oZnVuY3Rpb24gKGFwaVJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIGVfMywgX2IsIF9jO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBhcGlSZXNwb25zZV8yID0gX19hc3luY1ZhbHVlcyhhcGlSZXNwb25zZSksIGFwaVJlc3BvbnNlXzJfMTsgYXBpUmVzcG9uc2VfMl8xID0geWllbGQgX19hd2FpdChhcGlSZXNwb25zZV8yLm5leHQoKSksIF9hID0gYXBpUmVzcG9uc2VfMl8xLmRvbmUsICFfYTsgX2QgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MgPSBhcGlSZXNwb25zZV8yXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IF9jO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBnZW5lcmF0ZUNvbnRlbnRSZXNwb25zZUZyb21NbGRldigoeWllbGQgX19hd2FpdChjaHVuay5qc29uKCkpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcFsnc2RrSHR0cFJlc3BvbnNlJ10gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGNodW5rLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgR2VuZXJhdGVDb250ZW50UmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdCh0eXBlZFJlc3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlXzNfMSkgeyBlXzMgPSB7IGVycm9yOiBlXzNfMSB9OyB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBhcGlSZXNwb25zZV8yLnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2IuY2FsbChhcGlSZXNwb25zZV8yKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgZW1iZWRkaW5ncyBmb3IgdGhlIGdpdmVuIGNvbnRlbnRzLiBPbmx5IHRleHQgaXMgc3VwcG9ydGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBlbWJlZGRpbmcgY29udGVudHMuXG4gICAgICogQHJldHVybiBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmVtYmVkQ29udGVudCh7XG4gICAgICogIG1vZGVsOiAndGV4dC1lbWJlZGRpbmctMDA0JyxcbiAgICAgKiAgY29udGVudHM6IFtcbiAgICAgKiAgICAnV2hhdCBpcyB5b3VyIG5hbWU/JyxcbiAgICAgKiAgICAnV2hhdCBpcyB5b3VyIGZhdm9yaXRlIGNvbG9yPycsXG4gICAgICogIF0sXG4gICAgICogIGNvbmZpZzoge1xuICAgICAqICAgIG91dHB1dERpbWVuc2lvbmFsaXR5OiA2NCxcbiAgICAgKiAgfSxcbiAgICAgKiB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgZW1iZWRDb250ZW50KHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBlbWJlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnByZWRpY3QnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBlbWJlZENvbnRlbnRSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBFbWJlZENvbnRlbnRSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZW1iZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OmJhdGNoRW1iZWRDb250ZW50cycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGVtYmVkQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgRW1iZWRDb250ZW50UmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByaXZhdGUgbWV0aG9kIGZvciBnZW5lcmF0aW5nIGltYWdlcy5cbiAgICAgKi9cbiAgICBhc3luYyBnZW5lcmF0ZUltYWdlc0ludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZW5lcmF0ZUltYWdlc1BhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06cHJlZGljdCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGdlbmVyYXRlSW1hZ2VzUmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgR2VuZXJhdGVJbWFnZXNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2VuZXJhdGVJbWFnZXNQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06cHJlZGljdCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGdlbmVyYXRlSW1hZ2VzUmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBHZW5lcmF0ZUltYWdlc1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcml2YXRlIG1ldGhvZCBmb3IgZWRpdGluZyBhbiBpbWFnZS5cbiAgICAgKi9cbiAgICBhc3luYyBlZGl0SW1hZ2VJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGVkaXRJbWFnZVBhcmFtZXRlcnNJbnRlcm5hbFRvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpwcmVkaWN0JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZWRpdEltYWdlUmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgRWRpdEltYWdlUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgVmVydGV4IEFJLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByaXZhdGUgbWV0aG9kIGZvciB1cHNjYWxpbmcgYW4gaW1hZ2UuXG4gICAgICovXG4gICAgYXN5bmMgdXBzY2FsZUltYWdlSW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSB1cHNjYWxlSW1hZ2VBUElQYXJhbWV0ZXJzSW50ZXJuYWxUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06cHJlZGljdCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IHVwc2NhbGVJbWFnZVJlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IFVwc2NhbGVJbWFnZVJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIFZlcnRleCBBSS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWNvbnRleHR1YWxpemVzIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogVGhlcmUgYXJlIHR3byB0eXBlcyBvZiByZWNvbnRleHR1YWxpemF0aW9uIGN1cnJlbnRseSBzdXBwb3J0ZWQ6XG4gICAgICogMSkgSW1hZ2VuIFByb2R1Y3QgUmVjb250ZXh0IC0gR2VuZXJhdGUgaW1hZ2VzIG9mIHByb2R1Y3RzIGluIG5ldyBzY2VuZXNcbiAgICAgKiAgICBhbmQgY29udGV4dHMuXG4gICAgICogMikgVmlydHVhbCBUcnktT246IEdlbmVyYXRlIGltYWdlcyBvZiBwZXJzb25zIG1vZGVsaW5nIGZhc2hpb24gcHJvZHVjdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHJlY29udGV4dHVhbGl6aW5nIGFuIGltYWdlLlxuICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCByZXNwb25zZTEgPSBhd2FpdCBhaS5tb2RlbHMucmVjb250ZXh0SW1hZ2Uoe1xuICAgICAqICBtb2RlbDogJ2ltYWdlbi1wcm9kdWN0LXJlY29udGV4dC1wcmV2aWV3LTA2LTMwJyxcbiAgICAgKiAgc291cmNlOiB7XG4gICAgICogICAgcHJvbXB0OiAnSW4gYSBtb2Rlcm4ga2l0Y2hlbiBzZXR0aW5nLicsXG4gICAgICogICAgcHJvZHVjdEltYWdlczogW3Byb2R1Y3RJbWFnZV0sXG4gICAgICogIH0sXG4gICAgICogIGNvbmZpZzoge1xuICAgICAqICAgIG51bWJlck9mSW1hZ2VzOiAxLFxuICAgICAqICB9LFxuICAgICAqIH0pO1xuICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlMT8uZ2VuZXJhdGVkSW1hZ2VzPy5bMF0/LmltYWdlPy5pbWFnZUJ5dGVzKTtcbiAgICAgKlxuICAgICAqIGNvbnN0IHJlc3BvbnNlMiA9IGF3YWl0IGFpLm1vZGVscy5yZWNvbnRleHRJbWFnZSh7XG4gICAgICogIG1vZGVsOiAndmlydHVhbC10cnktb24tcHJldmlldy0wOC0wNCcsXG4gICAgICogIHNvdXJjZToge1xuICAgICAqICAgIHBlcnNvbkltYWdlOiBwZXJzb25JbWFnZSxcbiAgICAgKiAgICBwcm9kdWN0SW1hZ2VzOiBbcHJvZHVjdEltYWdlXSxcbiAgICAgKiAgfSxcbiAgICAgKiAgY29uZmlnOiB7XG4gICAgICogICAgbnVtYmVyT2ZJbWFnZXM6IDEsXG4gICAgICogIH0sXG4gICAgICogfSk7XG4gICAgICogY29uc29sZS5sb2cocmVzcG9uc2UyPy5nZW5lcmF0ZWRJbWFnZXM/LlswXT8uaW1hZ2U/LmltYWdlQnl0ZXMpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIHJlY29udGV4dEltYWdlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gcmVjb250ZXh0SW1hZ2VQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnByZWRpY3QnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IHJlY29udGV4dEltYWdlUmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgUmVjb250ZXh0SW1hZ2VSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBWZXJ0ZXggQUkuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VnbWVudHMgYW4gaW1hZ2UsIGNyZWF0aW5nIGEgbWFzayBvZiBhIHNwZWNpZmllZCBhcmVhLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBzZWdtZW50aW5nIGFuIGltYWdlLlxuICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy5zZWdtZW50SW1hZ2Uoe1xuICAgICAqICBtb2RlbDogJ2ltYWdlLXNlZ21lbnRhdGlvbi0wMDEnLFxuICAgICAqICBzb3VyY2U6IHtcbiAgICAgKiAgICBpbWFnZTogaW1hZ2UsXG4gICAgICogIH0sXG4gICAgICogIGNvbmZpZzoge1xuICAgICAqICAgIG1vZGU6ICdmb3JlZ3JvdW5kJyxcbiAgICAgKiAgfSxcbiAgICAgKiB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZT8uZ2VuZXJhdGVkTWFza3M/LlswXT8ubWFzaz8uaW1hZ2VCeXRlcyk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgc2VnbWVudEltYWdlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gc2VnbWVudEltYWdlUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpwcmVkaWN0JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBzZWdtZW50SW1hZ2VSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBTZWdtZW50SW1hZ2VSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBWZXJ0ZXggQUkuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBpbmZvcm1hdGlvbiBhYm91dCBhIG1vZGVsIGJ5IG5hbWUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgbW9kZWxJbmZvID0gYXdhaXQgYWkubW9kZWxzLmdldCh7bW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJ30pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGdldChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2V0TW9kZWxQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gbW9kZWxGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldE1vZGVsUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gbW9kZWxGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbGlzdEludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBsaXN0TW9kZWxzUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsc191cmx9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0TW9kZWxzUmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgTGlzdE1vZGVsc1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBsaXN0TW9kZWxzUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWxzX3VybH0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGxpc3RNb2RlbHNSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IExpc3RNb2RlbHNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBhIHR1bmVkIG1vZGVsIGJ5IGl0cyBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB1cGRhdGluZyB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybiBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLnVwZGF0ZSh7XG4gICAgICogICBtb2RlbDogJ3R1bmVkLW1vZGVsLW5hbWUnLFxuICAgICAqICAgY29uZmlnOiB7XG4gICAgICogICAgIGRpc3BsYXlOYW1lOiAnTmV3IGRpc3BsYXkgbmFtZScsXG4gICAgICogICAgIGRlc2NyaXB0aW9uOiAnTmV3IGRlc2NyaXB0aW9uJyxcbiAgICAgKiAgIH0sXG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSB1cGRhdGVNb2RlbFBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQQVRDSCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBtb2RlbEZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gdXBkYXRlTW9kZWxQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BBVENIJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IG1vZGVsRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYSB0dW5lZCBtb2RlbCBieSBpdHMgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZGVsZXRpbmcgdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy5kZWxldGUoe21vZGVsOiAndHVuZWQtbW9kZWwtbmFtZSd9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGRlbGV0ZU1vZGVsUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBkZWxldGVNb2RlbFJlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IERlbGV0ZU1vZGVsUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGRlbGV0ZU1vZGVsUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGRlbGV0ZU1vZGVsUmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBEZWxldGVNb2RlbFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3VudHMgdGhlIG51bWJlciBvZiB0b2tlbnMgaW4gdGhlIGdpdmVuIGNvbnRlbnRzLiBNdWx0aW1vZGFsIGlucHV0IGlzXG4gICAgICogc3VwcG9ydGVkIGZvciBHZW1pbmkgbW9kZWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBjb3VudGluZyB0b2tlbnMuXG4gICAgICogQHJldHVybiBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmNvdW50VG9rZW5zKHtcbiAgICAgKiAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJyxcbiAgICAgKiAgY29udGVudHM6ICdUaGUgcXVpY2sgYnJvd24gZm94IGp1bXBzIG92ZXIgdGhlIGxhenkgZG9nLidcbiAgICAgKiB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgY291bnRUb2tlbnMocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNvdW50VG9rZW5zUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpjb3VudFRva2VucycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGNvdW50VG9rZW5zUmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgQ291bnRUb2tlbnNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY291bnRUb2tlbnNQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06Y291bnRUb2tlbnMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBjb3VudFRva2Vuc1Jlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgQ291bnRUb2tlbnNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBsaXN0IG9mIGNvbnRlbnRzLCByZXR1cm5zIGEgY29ycmVzcG9uZGluZyBUb2tlbnNJbmZvIGNvbnRhaW5pbmdcbiAgICAgKiB0aGUgbGlzdCBvZiB0b2tlbnMgYW5kIGxpc3Qgb2YgdG9rZW4gaWRzLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGNvbXB1dGluZyB0b2tlbnMuXG4gICAgICogQHJldHVybiBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmNvbXB1dGVUb2tlbnMoe1xuICAgICAqICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnLFxuICAgICAqICBjb250ZW50czogJ1doYXQgaXMgeW91ciBuYW1lPydcbiAgICAgKiB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgY29tcHV0ZVRva2VucyhwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNvbXB1dGVUb2tlbnNQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OmNvbXB1dGVUb2tlbnMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBjb21wdXRlVG9rZW5zUmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgQ29tcHV0ZVRva2Vuc1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIFZlcnRleCBBSS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcml2YXRlIG1ldGhvZCBmb3IgZ2VuZXJhdGluZyB2aWRlb3MuXG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGVWaWRlb3NJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2VuZXJhdGVWaWRlb3NQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnByZWRpY3RMb25nUnVubmluZycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZ2VuZXJhdGVWaWRlb3NPcGVyYXRpb25Gcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgR2VuZXJhdGVWaWRlb3NPcGVyYXRpb24oKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdlbmVyYXRlVmlkZW9zUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnByZWRpY3RMb25nUnVubmluZycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZ2VuZXJhdGVWaWRlb3NPcGVyYXRpb25Gcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBHZW5lcmF0ZVZpZGVvc09wZXJhdGlvbigpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNsYXNzIE9wZXJhdGlvbnMgZXh0ZW5kcyBCYXNlTW9kdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcGlDbGllbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHN0YXR1cyBvZiBhIGxvbmctcnVubmluZyBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1ldGVycyBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGdldCBvcGVyYXRpb24gcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSB1cGRhdGVkIE9wZXJhdGlvbiBvYmplY3QsIHdpdGggdGhlIGxhdGVzdCBzdGF0dXMgb3IgcmVzdWx0LlxuICAgICAqL1xuICAgIGFzeW5jIGdldFZpZGVvc09wZXJhdGlvbihwYXJhbWV0ZXJzKSB7XG4gICAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IHBhcmFtZXRlcnMub3BlcmF0aW9uO1xuICAgICAgICBjb25zdCBjb25maWcgPSBwYXJhbWV0ZXJzLmNvbmZpZztcbiAgICAgICAgaWYgKG9wZXJhdGlvbi5uYW1lID09PSB1bmRlZmluZWQgfHwgb3BlcmF0aW9uLm5hbWUgPT09ICcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wZXJhdGlvbiBuYW1lIGlzIHJlcXVpcmVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc291cmNlTmFtZSA9IG9wZXJhdGlvbi5uYW1lLnNwbGl0KCcvb3BlcmF0aW9ucy8nKVswXTtcbiAgICAgICAgICAgIGxldCBodHRwT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChjb25maWcgJiYgJ2h0dHBPcHRpb25zJyBpbiBjb25maWcpIHtcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9ucyA9IGNvbmZpZy5odHRwT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJhd09wZXJhdGlvbiA9IGF3YWl0IHRoaXMuZmV0Y2hQcmVkaWN0VmlkZW9zT3BlcmF0aW9uSW50ZXJuYWwoe1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbk5hbWU6IG9wZXJhdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgIHJlc291cmNlTmFtZTogcmVzb3VyY2VOYW1lLFxuICAgICAgICAgICAgICAgIGNvbmZpZzogeyBodHRwT3B0aW9uczogaHR0cE9wdGlvbnMgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG9wZXJhdGlvbi5fZnJvbUFQSVJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICBhcGlSZXNwb25zZTogcmF3T3BlcmF0aW9uLFxuICAgICAgICAgICAgICAgIF9pc1ZlcnRleEFJOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByYXdPcGVyYXRpb24gPSBhd2FpdCB0aGlzLmdldFZpZGVvc09wZXJhdGlvbkludGVybmFsKHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb25OYW1lOiBvcGVyYXRpb24ubmFtZSxcbiAgICAgICAgICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG9wZXJhdGlvbi5fZnJvbUFQSVJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICBhcGlSZXNwb25zZTogcmF3T3BlcmF0aW9uLFxuICAgICAgICAgICAgICAgIF9pc1ZlcnRleEFJOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHN0YXR1cyBvZiBhIGxvbmctcnVubmluZyBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1ldGVycyBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGdldCBvcGVyYXRpb24gcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSB1cGRhdGVkIE9wZXJhdGlvbiBvYmplY3QsIHdpdGggdGhlIGxhdGVzdCBzdGF0dXMgb3IgcmVzdWx0LlxuICAgICAqL1xuICAgIGFzeW5jIGdldChwYXJhbWV0ZXJzKSB7XG4gICAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IHBhcmFtZXRlcnMub3BlcmF0aW9uO1xuICAgICAgICBjb25zdCBjb25maWcgPSBwYXJhbWV0ZXJzLmNvbmZpZztcbiAgICAgICAgaWYgKG9wZXJhdGlvbi5uYW1lID09PSB1bmRlZmluZWQgfHwgb3BlcmF0aW9uLm5hbWUgPT09ICcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wZXJhdGlvbiBuYW1lIGlzIHJlcXVpcmVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc291cmNlTmFtZSA9IG9wZXJhdGlvbi5uYW1lLnNwbGl0KCcvb3BlcmF0aW9ucy8nKVswXTtcbiAgICAgICAgICAgIGxldCBodHRwT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChjb25maWcgJiYgJ2h0dHBPcHRpb25zJyBpbiBjb25maWcpIHtcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9ucyA9IGNvbmZpZy5odHRwT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJhd09wZXJhdGlvbiA9IGF3YWl0IHRoaXMuZmV0Y2hQcmVkaWN0VmlkZW9zT3BlcmF0aW9uSW50ZXJuYWwoe1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbk5hbWU6IG9wZXJhdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgIHJlc291cmNlTmFtZTogcmVzb3VyY2VOYW1lLFxuICAgICAgICAgICAgICAgIGNvbmZpZzogeyBodHRwT3B0aW9uczogaHR0cE9wdGlvbnMgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG9wZXJhdGlvbi5fZnJvbUFQSVJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICBhcGlSZXNwb25zZTogcmF3T3BlcmF0aW9uLFxuICAgICAgICAgICAgICAgIF9pc1ZlcnRleEFJOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByYXdPcGVyYXRpb24gPSBhd2FpdCB0aGlzLmdldFZpZGVvc09wZXJhdGlvbkludGVybmFsKHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb25OYW1lOiBvcGVyYXRpb24ubmFtZSxcbiAgICAgICAgICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG9wZXJhdGlvbi5fZnJvbUFQSVJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICBhcGlSZXNwb25zZTogcmF3T3BlcmF0aW9uLFxuICAgICAgICAgICAgICAgIF9pc1ZlcnRleEFJOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFZpZGVvc09wZXJhdGlvbkludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXRPcGVyYXRpb25QYXJhbWV0ZXJzVG9WZXJ0ZXgocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tvcGVyYXRpb25OYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXRPcGVyYXRpb25QYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne29wZXJhdGlvbk5hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGZldGNoUHJlZGljdFZpZGVvc09wZXJhdGlvbkludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZmV0Y2hQcmVkaWN0T3BlcmF0aW9uUGFyYW1ldGVyc1RvVmVydGV4KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7cmVzb3VyY2VOYW1lfTpmZXRjaFByZWRpY3RPcGVyYXRpb24nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgVmVydGV4IEFJLicpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5mdW5jdGlvbiBibG9iVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGF0YSddKTtcbiAgICBpZiAoZnJvbURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkYXRhJ10sIGZyb21EYXRhKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3BsYXlOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYXJ0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFydHMnXSk7XG4gICAgaWYgKGZyb21QYXJ0cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUGFydHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydFRvTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm9sZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm9sZSddKTtcbiAgICBpZiAoZnJvbVJvbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb2xlJ10sIGZyb21Sb2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQXV0aFRva2VuQ29uZmlnVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUV4cGlyZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FeHBpcmVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSwgZnJvbUV4cGlyZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmV3U2Vzc2lvbkV4cGlyZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXdTZXNzaW9uRXhwaXJlVGltZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OZXdTZXNzaW9uRXhwaXJlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyduZXdTZXNzaW9uRXhwaXJlVGltZSddLCBmcm9tTmV3U2Vzc2lvbkV4cGlyZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXNlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXNlcyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVVzZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndXNlcyddLCBmcm9tVXNlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MaXZlQ29ubmVjdENvbnN0cmFpbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbGl2ZUNvbm5lY3RDb25zdHJhaW50cycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MaXZlQ29ubmVjdENvbnN0cmFpbnRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2JpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cCddLCBsaXZlQ29ubmVjdENvbnN0cmFpbnRzVG9NbGRldihhcGlDbGllbnQsIGZyb21MaXZlQ29ubmVjdENvbnN0cmFpbnRzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Mb2NrQWRkaXRpb25hbEZpZWxkcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2xvY2tBZGRpdGlvbmFsRmllbGRzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUxvY2tBZGRpdGlvbmFsRmllbGRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2ZpZWxkTWFzayddLCBmcm9tTG9ja0FkZGl0aW9uYWxGaWVsZHMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVBdXRoVG9rZW5QYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBjcmVhdGVBdXRoVG9rZW5Db25maWdUb01sZGV2KGFwaUNsaWVudCwgZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZmlsZURhdGFUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaXNwbGF5TmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZVVyaSddKTtcbiAgICBpZiAoZnJvbUZpbGVVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlVXJpJ10sIGZyb21GaWxlVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25DYWxsVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lkJ10pO1xuICAgIGlmIChmcm9tSWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpZCddLCBmcm9tSWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXJncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXJncyddKTtcbiAgICBpZiAoZnJvbUFyZ3MgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhcmdzJ10sIGZyb21BcmdzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRpYWxBcmdzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXJ0aWFsQXJncyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd3aWxsQ29udGludWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dpbGxDb250aW51ZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVNYXBzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdXRoQ29uZmlnJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdXRoQ29uZmlnIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmFibGVXaWRnZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuYWJsZVdpZGdldCddKTtcbiAgICBpZiAoZnJvbUVuYWJsZVdpZGdldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuYWJsZVdpZGdldCddLCBmcm9tRW5hYmxlV2lkZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlU2VhcmNoVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleGNsdWRlRG9tYWlucyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhjbHVkZURvbWFpbnMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmxvY2tpbmdDb25maWRlbmNlJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdibG9ja2luZ0NvbmZpZGVuY2UgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRpbWVSYW5nZUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RpbWVSYW5nZUZpbHRlcicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaW1lUmFuZ2VGaWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aW1lUmFuZ2VGaWx0ZXInXSwgZnJvbVRpbWVSYW5nZUZpbHRlcik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVDb25uZWN0Q29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21HZW5lcmF0aW9uQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ2VuZXJhdGlvbkNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21HZW5lcmF0aW9uQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnXSwgZnJvbUdlbmVyYXRpb25Db25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNb2RhbGl0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3Jlc3BvbnNlTW9kYWxpdGllcyddLCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRlbXBlcmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZW1wZXJhdHVyZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRlbXBlcmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAndGVtcGVyYXR1cmUnXSwgZnJvbVRlbXBlcmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcFAgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcFAnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub3BQICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAndG9wUCddLCBmcm9tVG9wUCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BLID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BLJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9wSyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3RvcEsnXSwgZnJvbVRvcEspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4T3V0cHV0VG9rZW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWF4T3V0cHV0VG9rZW5zJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU1heE91dHB1dFRva2VucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ21heE91dHB1dFRva2VucyddLCBmcm9tTWF4T3V0cHV0VG9rZW5zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1lZGlhUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21lZGlhUmVzb2x1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21NZWRpYVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdtZWRpYVJlc29sdXRpb24nXSwgZnJvbU1lZGlhUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2VlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3NlZWQnXSwgZnJvbVNlZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3BlZWNoQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzcGVlY2hDb25maWcnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TcGVlY2hDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdzcGVlY2hDb25maWcnXSwgdExpdmVTcGVlY2hDb25maWcoZnJvbVNwZWVjaENvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhpbmtpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aGlua2luZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UaGlua2luZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3RoaW5raW5nQ29uZmlnJ10sIGZyb21UaGlua2luZ0NvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmFibGVBZmZlY3RpdmVEaWFsb2cnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRW5hYmxlQWZmZWN0aXZlRGlhbG9nICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnZW5hYmxlQWZmZWN0aXZlRGlhbG9nJ10sIGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TeXN0ZW1JbnN0cnVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdzeXN0ZW1JbnN0cnVjdGlvbiddLCBjb250ZW50VG9NbGRldih0Q29udGVudChmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24pKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29scyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29scyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0VG9vbHMoZnJvbVRvb2xzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b29sVG9NbGRldih0VG9vbChpdGVtKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAndG9vbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlc3Npb25SZXN1bXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2Vzc2lvblJlc3VtcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2Vzc2lvblJlc3VtcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnc2Vzc2lvblJlc3VtcHRpb24nXSwgc2Vzc2lvblJlc3VtcHRpb25Db25maWdUb01sZGV2KGZyb21TZXNzaW9uUmVzdW1wdGlvbikpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5wdXRBdWRpb1RyYW5zY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdpbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiddLCBmcm9tSW5wdXRBdWRpb1RyYW5zY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdvdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24nXSwgZnJvbU91dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZWFsdGltZUlucHV0Q29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVhbHRpbWVJbnB1dENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21SZWFsdGltZUlucHV0Q29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3JlYWx0aW1lSW5wdXRDb25maWcnXSwgZnJvbVJlYWx0aW1lSW5wdXRDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGV4dFdpbmRvd0NvbXByZXNzaW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29udGV4dFdpbmRvd0NvbXByZXNzaW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUNvbnRleHRXaW5kb3dDb21wcmVzc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdjb250ZXh0V2luZG93Q29tcHJlc3Npb24nXSwgZnJvbUNvbnRleHRXaW5kb3dDb21wcmVzc2lvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9hY3Rpdml0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvYWN0aXZpdHknXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Qcm9hY3Rpdml0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdwcm9hY3Rpdml0eSddLCBmcm9tUHJvYWN0aXZpdHkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlQ29ubmVjdENvbnN0cmFpbnRzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NldHVwJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgbGl2ZUNvbm5lY3RDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHBhcnRUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21NZWRpYVJlc29sdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtZWRpYVJlc29sdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWVkaWFSZXNvbHV0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWVkaWFSZXNvbHV0aW9uJ10sIGZyb21NZWRpYVJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb25SZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb25SZXN1bHQnXSwgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhlY3V0YWJsZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleGVjdXRhYmxlQ29kZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeGVjdXRhYmxlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4ZWN1dGFibGVDb2RlJ10sIGZyb21FeGVjdXRhYmxlQ29kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZURhdGEnXSk7XG4gICAgaWYgKGZyb21GaWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVEYXRhJ10sIGZpbGVEYXRhVG9NbGRldihmcm9tRmlsZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10sIGZ1bmN0aW9uQ2FsbFRvTWxkZXYoZnJvbUZ1bmN0aW9uQ2FsbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uUmVzcG9uc2UnXSwgZnJvbUZ1bmN0aW9uUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5saW5lRGF0YSddKTtcbiAgICBpZiAoZnJvbUlubGluZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmxpbmVEYXRhJ10sIGJsb2JUb01sZGV2KGZyb21JbmxpbmVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGhvdWdodCddKTtcbiAgICBpZiAoZnJvbVRob3VnaHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0J10sIGZyb21UaG91Z2h0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHRTaWduYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aG91Z2h0U2lnbmF0dXJlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRob3VnaHRTaWduYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0U2lnbmF0dXJlJ10sIGZyb21UaG91Z2h0U2lnbmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2aWRlb01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb01ldGFkYXRhJ10sIGZyb21WaWRlb01ldGFkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2Vzc2lvblJlc3VtcHRpb25Db25maWdUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21IYW5kbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2hhbmRsZSddKTtcbiAgICBpZiAoZnJvbUhhbmRsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2hhbmRsZSddLCBmcm9tSGFuZGxlKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHJhbnNwYXJlbnQnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zcGFyZW50IHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25EZWNsYXJhdGlvbnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmV0cmlldmFsJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXRyaWV2YWwgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2hSZXRyaWV2YWwnXSwgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db21wdXRlclVzZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSk7XG4gICAgaWYgKGZyb21Db21wdXRlclVzZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10sIGZyb21Db21wdXRlclVzZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlU2VhcmNoJ10pO1xuICAgIGlmIChmcm9tRmlsZVNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVTZWFyY2gnXSwgZnJvbUZpbGVTZWFyY2gpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb24nXSwgZnJvbUNvZGVFeGVjdXRpb24pO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbnRlcnByaXNlV2ViU2VhcmNoJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbnRlcnByaXNlV2ViU2VhcmNoIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVNYXBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVNYXBzJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlTWFwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSwgZ29vZ2xlTWFwc1RvTWxkZXYoZnJvbUdvb2dsZU1hcHMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10sIGdvb2dsZVNlYXJjaFRvTWxkZXYoZnJvbUdvb2dsZVNlYXJjaCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJsQ29udGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXJsQ29udGV4dCddKTtcbiAgICBpZiAoZnJvbVVybENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmxDb250ZXh0J10sIGZyb21VcmxDb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vKipcbiAqIFJldHVybnMgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBmaWVsZCBtYXNrcyBmcm9tIGEgZ2l2ZW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBzZXR1cCBUaGUgb2JqZWN0IHRvIGV4dHJhY3QgZmllbGQgbWFza3MgZnJvbS5cbiAqIEByZXR1cm4gQSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBmaWVsZCBtYXNrcy5cbiAqL1xuZnVuY3Rpb24gZ2V0RmllbGRNYXNrcyhzZXR1cCkge1xuICAgIGNvbnN0IGZpZWxkcyA9IFtdO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNldHVwKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dXAsIGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gc2V0dXBba2V5XTtcbiAgICAgICAgICAgIC8vIDJuZCBsYXllciwgcmVjdXJzaXZlbHkgZ2V0IGZpZWxkIG1hc2tzIHNlZSBUT0RPKGIvNDE4MjkwMTAwKVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZCA9IE9iamVjdC5rZXlzKHZhbHVlKS5tYXAoKGtrKSA9PiBgJHtrZXl9LiR7a2t9YCk7XG4gICAgICAgICAgICAgICAgZmllbGRzLnB1c2goLi4uZmllbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmllbGRzLnB1c2goa2V5KTsgLy8gMXN0IGxheWVyXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkcy5qb2luKCcsJyk7XG59XG4vKipcbiAqIENvbnZlcnRzIGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cC5cbiAqIEBwYXJhbSByZXF1ZXN0RGljdCAtIFRoZSByZXF1ZXN0IGRpY3Rpb25hcnkuXG4gKiBAcGFyYW0gY29uZmlnIC0gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICogQHJldHVybiAtIFRoZSBtb2RpZmllZCByZXF1ZXN0IGRpY3Rpb25hcnkuXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRCaWRpU2V0dXBUb1Rva2VuU2V0dXAocmVxdWVzdERpY3QsIGNvbmZpZykge1xuICAgIC8vIENvbnZlcnQgYmlkaUdlbmVyYXRlQ29udGVudFNldHVwIGZyb20gYmlkaUdlbmVyYXRlQ29udGVudFNldHVwLnNldHVwLlxuICAgIGxldCBzZXR1cEZvck1hc2tHZW5lcmF0aW9uID0gbnVsbDtcbiAgICBjb25zdCBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXBWYWx1ZSA9IHJlcXVlc3REaWN0WydiaWRpR2VuZXJhdGVDb250ZW50U2V0dXAnXTtcbiAgICBpZiAodHlwZW9mIGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cFZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXBWYWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgICAnc2V0dXAnIGluIGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cFZhbHVlKSB7XG4gICAgICAgIC8vIE5vdyB3ZSBrbm93IGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cFZhbHVlIGlzIGFuIG9iamVjdCBhbmQgaGFzIGEgJ3NldHVwJ1xuICAgICAgICAvLyBwcm9wZXJ0eS5cbiAgICAgICAgY29uc3QgaW5uZXJTZXR1cCA9IGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cFZhbHVlXG4gICAgICAgICAgICAuc2V0dXA7XG4gICAgICAgIGlmICh0eXBlb2YgaW5uZXJTZXR1cCA9PT0gJ29iamVjdCcgJiYgaW5uZXJTZXR1cCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVmFsaWQgaW5uZXIgc2V0dXAgZm91bmQuXG4gICAgICAgICAgICByZXF1ZXN0RGljdFsnYmlkaUdlbmVyYXRlQ29udGVudFNldHVwJ10gPSBpbm5lclNldHVwO1xuICAgICAgICAgICAgc2V0dXBGb3JNYXNrR2VuZXJhdGlvbiA9IGlubmVyU2V0dXA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBgYmlkaUdlbmVyYXRlQ29udGVudFNldHVwVmFsdWUuc2V0dXBgIGlzIG5vdCBhIHZhbGlkIG9iamVjdDsgdHJlYXQgYXNcbiAgICAgICAgICAgIC8vIGlmIGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cCBpcyBpbnZhbGlkLlxuICAgICAgICAgICAgZGVsZXRlIHJlcXVlc3REaWN0WydiaWRpR2VuZXJhdGVDb250ZW50U2V0dXAnXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChiaWRpR2VuZXJhdGVDb250ZW50U2V0dXBWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXBgIGV4aXN0cyBidXQgbm90IGluIHRoZSBleHBlY3RlZFxuICAgICAgICAvLyBzaGFwZSB7c2V0dXA6IHsuLi59fTsgdHJlYXQgYXMgaW52YWxpZC5cbiAgICAgICAgZGVsZXRlIHJlcXVlc3REaWN0WydiaWRpR2VuZXJhdGVDb250ZW50U2V0dXAnXTtcbiAgICB9XG4gICAgY29uc3QgcHJlRXhpc3RpbmdGaWVsZE1hc2sgPSByZXF1ZXN0RGljdFsnZmllbGRNYXNrJ107XG4gICAgLy8gSGFuZGxlIG1hc2sgZ2VuZXJhdGlvbiBzZXR1cC5cbiAgICBpZiAoc2V0dXBGb3JNYXNrR2VuZXJhdGlvbikge1xuICAgICAgICBjb25zdCBnZW5lcmF0ZWRNYXNrRnJvbUJpZGkgPSBnZXRGaWVsZE1hc2tzKHNldHVwRm9yTWFza0dlbmVyYXRpb24pO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcubG9ja0FkZGl0aW9uYWxGaWVsZHMpICYmXG4gICAgICAgICAgICAoY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmxvY2tBZGRpdGlvbmFsRmllbGRzLmxlbmd0aCkgPT09IDApIHtcbiAgICAgICAgICAgIC8vIENhc2UgMTogbG9ja0FkZGl0aW9uYWxGaWVsZHMgaXMgYW4gZW1wdHkgYXJyYXkuIExvY2sgb25seSBmaWVsZHMgZnJvbVxuICAgICAgICAgICAgLy8gYmlkaSBzZXR1cC5cbiAgICAgICAgICAgIGlmIChnZW5lcmF0ZWRNYXNrRnJvbUJpZGkpIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGFzc2lnbiBpZiBtYXNrIGlzIG5vdCBlbXB0eVxuICAgICAgICAgICAgICAgIHJlcXVlc3REaWN0WydmaWVsZE1hc2snXSA9IGdlbmVyYXRlZE1hc2tGcm9tQmlkaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0RGljdFsnZmllbGRNYXNrJ107IC8vIElmIG1hc2sgaXMgZW1wdHksIGVmZmVjdGl2ZWx5IG5vXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lmaWMgZmllbGRzIGxvY2tlZCBieSBiaWRpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5sb2NrQWRkaXRpb25hbEZpZWxkcykgJiZcbiAgICAgICAgICAgIGNvbmZpZy5sb2NrQWRkaXRpb25hbEZpZWxkcy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICBwcmVFeGlzdGluZ0ZpZWxkTWFzayAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShwcmVFeGlzdGluZ0ZpZWxkTWFzaykgJiZcbiAgICAgICAgICAgIHByZUV4aXN0aW5nRmllbGRNYXNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIENhc2UgMjogTG9jayBmaWVsZHMgZnJvbSBiaWRpIHNldHVwICsgYWRkaXRpb25hbCBmaWVsZHNcbiAgICAgICAgICAgIC8vIChwcmVFeGlzdGluZ0ZpZWxkTWFzaykuXG4gICAgICAgICAgICBjb25zdCBnZW5lcmF0aW9uQ29uZmlnRmllbGRzID0gW1xuICAgICAgICAgICAgICAgICd0ZW1wZXJhdHVyZScsXG4gICAgICAgICAgICAgICAgJ3RvcEsnLFxuICAgICAgICAgICAgICAgICd0b3BQJyxcbiAgICAgICAgICAgICAgICAnbWF4T3V0cHV0VG9rZW5zJyxcbiAgICAgICAgICAgICAgICAncmVzcG9uc2VNb2RhbGl0aWVzJyxcbiAgICAgICAgICAgICAgICAnc2VlZCcsXG4gICAgICAgICAgICAgICAgJ3NwZWVjaENvbmZpZycsXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgbGV0IG1hcHBlZEZpZWxkc0Zyb21QcmVFeGlzdGluZyA9IFtdO1xuICAgICAgICAgICAgaWYgKHByZUV4aXN0aW5nRmllbGRNYXNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBtYXBwZWRGaWVsZHNGcm9tUHJlRXhpc3RpbmcgPSBwcmVFeGlzdGluZ0ZpZWxkTWFzay5tYXAoKGZpZWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnZW5lcmF0aW9uQ29uZmlnRmllbGRzLmluY2x1ZGVzKGZpZWxkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBnZW5lcmF0aW9uQ29uZmlnLiR7ZmllbGR9YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmllbGQ7IC8vIEtlZXAgb3JpZ2luYWwgZmllbGQgbmFtZSBpZiBub3QgaW5cbiAgICAgICAgICAgICAgICAgICAgLy8gZ2VuZXJhdGlvbkNvbmZpZ0ZpZWxkc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmluYWxNYXNrUGFydHMgPSBbXTtcbiAgICAgICAgICAgIGlmIChnZW5lcmF0ZWRNYXNrRnJvbUJpZGkpIHtcbiAgICAgICAgICAgICAgICBmaW5hbE1hc2tQYXJ0cy5wdXNoKGdlbmVyYXRlZE1hc2tGcm9tQmlkaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWFwcGVkRmllbGRzRnJvbVByZUV4aXN0aW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBmaW5hbE1hc2tQYXJ0cy5wdXNoKC4uLm1hcHBlZEZpZWxkc0Zyb21QcmVFeGlzdGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmluYWxNYXNrUGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3REaWN0WydmaWVsZE1hc2snXSA9IGZpbmFsTWFza1BhcnRzLmpvaW4oJywnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIG5vIGZpZWxkcyBmcm9tIGJpZGkgYW5kIG5vIHZhbGlkIGFkZGl0aW9uYWwgZmllbGRzIGZyb21cbiAgICAgICAgICAgICAgICAvLyBwcmUtZXhpc3RpbmcgbWFzay5cbiAgICAgICAgICAgICAgICBkZWxldGUgcmVxdWVzdERpY3RbJ2ZpZWxkTWFzayddO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2FzZSAzOiBcIkxvY2sgYWxsIGZpZWxkc1wiIChtZWFuaW5nLCBkb24ndCBzZW5kIGEgZmllbGRfbWFzaywgbGV0IHNlcnZlclxuICAgICAgICAgICAgLy8gZGVmYXVsdHMgYXBwbHkgb3IgYWxsIGFyZSBtdXRhYmxlKS4gVGhpcyBpcyBoaXQgaWY6XG4gICAgICAgICAgICAvLyAgLSBgY29uZmlnLmxvY2tBZGRpdGlvbmFsRmllbGRzYCBpcyB1bmRlZmluZWQuXG4gICAgICAgICAgICAvLyAgLSBgY29uZmlnLmxvY2tBZGRpdGlvbmFsRmllbGRzYCBpcyBub24tZW1wdHksIEJVVFxuICAgICAgICAgICAgLy8gIGBwcmVFeGlzdGluZ0ZpZWxkTWFza2AgaXMgbnVsbCwgbm90IGEgc3RyaW5nLCBvciBhbiBlbXB0eSBzdHJpbmcuXG4gICAgICAgICAgICBkZWxldGUgcmVxdWVzdERpY3RbJ2ZpZWxkTWFzayddO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBObyB2YWxpZCBgYmlkaUdlbmVyYXRlQ29udGVudFNldHVwYCB3YXMgZm91bmQgb3IgZXh0cmFjdGVkLlxuICAgICAgICAvLyBcIkxvY2sgYWRkaXRpb25hbCBudWxsIGZpZWxkcyBpZiBhbnlcIi5cbiAgICAgICAgaWYgKHByZUV4aXN0aW5nRmllbGRNYXNrICE9PSBudWxsICYmXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHByZUV4aXN0aW5nRmllbGRNYXNrKSAmJlxuICAgICAgICAgICAgcHJlRXhpc3RpbmdGaWVsZE1hc2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhIHByZS1leGlzdGluZyBmaWVsZCBtYXNrLCBpdCdzIGEgc3RyaW5nLCBhbmQgaXQncyBub3RcbiAgICAgICAgICAgIC8vIGVtcHR5LCB0aGVuIHdlIHNob3VsZCBsb2NrIGFsbCBmaWVsZHMuXG4gICAgICAgICAgICByZXF1ZXN0RGljdFsnZmllbGRNYXNrJ10gPSBwcmVFeGlzdGluZ0ZpZWxkTWFzay5qb2luKCcsJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgcmVxdWVzdERpY3RbJ2ZpZWxkTWFzayddO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXF1ZXN0RGljdDtcbn1cbmNsYXNzIFRva2VucyBleHRlbmRzIEJhc2VNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBlcGhlbWVyYWwgYXV0aCB0b2tlbiByZXNvdXJjZS5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogRXBoZW1lcmFsIGF1dGggdG9rZW5zIGlzIG9ubHkgc3VwcG9ydGVkIGluIHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS5cbiAgICAgKiBJdCBjYW4gYmUgdXNlZCBmb3IgdGhlIHNlc3Npb24gY29ubmVjdGlvbiB0byB0aGUgTGl2ZSBjb25zdHJhaW5lZCBBUEkuXG4gICAgICogU3VwcG9ydCBpbiB2MWFscGhhIG9ubHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBjcmVhdGUgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSBjcmVhdGVkIGF1dGggdG9rZW4uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgYWkgPSBuZXcgR29vZ2xlR2VuQUkoe1xuICAgICAqICAgICBhcGlLZXk6IHRva2VuLm5hbWUsXG4gICAgICogICAgIGh0dHBPcHRpb25zOiB7IGFwaVZlcnNpb246ICd2MWFscGhhJyB9ICAvLyBTdXBwb3J0IGluIHYxYWxwaGEgb25seS5cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIENhc2UgMTogSWYgTGl2ZUVwaGVtZXJhbFBhcmFtZXRlcnMgaXMgdW5zZXQsIHVubG9jayBMaXZlQ29ubmVjdENvbmZpZ1xuICAgICAqIC8vIHdoZW4gdXNpbmcgdGhlIHRva2VuIGluIExpdmUgQVBJIHNlc3Npb25zLiBFYWNoIHNlc3Npb24gY29ubmVjdGlvbiBjYW5cbiAgICAgKiAvLyB1c2UgYSBkaWZmZXJlbnQgY29uZmlndXJhdGlvbi5cbiAgICAgKiBjb25zdCBjb25maWc6IENyZWF0ZUF1dGhUb2tlbkNvbmZpZyA9IHtcbiAgICAgKiAgICAgdXNlczogMyxcbiAgICAgKiAgICAgZXhwaXJlVGltZTogJzIwMjUtMDUtMDFUMDA6MDA6MDBaJyxcbiAgICAgKiB9XG4gICAgICogY29uc3QgdG9rZW4gPSBhd2FpdCBhaS50b2tlbnMuY3JlYXRlKGNvbmZpZyk7XG4gICAgICpcbiAgICAgKiAvLyBDYXNlIDI6IElmIExpdmVFcGhlbWVyYWxQYXJhbWV0ZXJzIGlzIHNldCwgbG9jayBhbGwgZmllbGRzIGluXG4gICAgICogLy8gTGl2ZUNvbm5lY3RDb25maWcgd2hlbiB1c2luZyB0aGUgdG9rZW4gaW4gTGl2ZSBBUEkgc2Vzc2lvbnMuIEZvclxuICAgICAqIC8vIGV4YW1wbGUsIGNoYW5naW5nIGBvdXRwdXRBdWRpb1RyYW5zY3JpcHRpb25gIGluIHRoZSBMaXZlIEFQSVxuICAgICAqIC8vIGNvbm5lY3Rpb24gd2lsbCBiZSBpZ25vcmVkIGJ5IHRoZSBBUEkuXG4gICAgICogY29uc3QgY29uZmlnOiBDcmVhdGVBdXRoVG9rZW5Db25maWcgPVxuICAgICAqICAgICB1c2VzOiAzLFxuICAgICAqICAgICBleHBpcmVUaW1lOiAnMjAyNS0wNS0wMVQwMDowMDowMFonLFxuICAgICAqICAgICBMaXZlRXBoZW1lcmFsUGFyYW1ldGVyczoge1xuICAgICAqICAgICAgICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gtMDAxJyxcbiAgICAgKiAgICAgICAgY29uZmlnOiB7XG4gICAgICogICAgICAgICAgICdyZXNwb25zZU1vZGFsaXRpZXMnOiBbJ0FVRElPJ10sXG4gICAgICogICAgICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbic6ICdBbHdheXMgYW5zd2VyIGluIEVuZ2xpc2guJyxcbiAgICAgKiAgICAgICAgfVxuICAgICAqICAgICB9XG4gICAgICogfVxuICAgICAqIGNvbnN0IHRva2VuID0gYXdhaXQgYWkudG9rZW5zLmNyZWF0ZShjb25maWcpO1xuICAgICAqXG4gICAgICogLy8gQ2FzZSAzOiBJZiBMaXZlRXBoZW1lcmFsUGFyYW1ldGVycyBpcyBzZXQgYW5kIGxvY2tBZGRpdGlvbmFsRmllbGRzIGlzXG4gICAgICogLy8gc2V0LCBsb2NrIExpdmVDb25uZWN0Q29uZmlnIHdpdGggc2V0IGFuZCBhZGRpdGlvbmFsIGZpZWxkcyAoZS5nLlxuICAgICAqIC8vIHJlc3BvbnNlTW9kYWxpdGllcywgc3lzdGVtSW5zdHJ1Y3Rpb24sIHRlbXBlcmF0dXJlIGluIHRoaXMgZXhhbXBsZSkgd2hlblxuICAgICAqIC8vIHVzaW5nIHRoZSB0b2tlbiBpbiBMaXZlIEFQSSBzZXNzaW9ucy5cbiAgICAgKiBjb25zdCBjb25maWc6IENyZWF0ZUF1dGhUb2tlbkNvbmZpZyA9XG4gICAgICogICAgIHVzZXM6IDMsXG4gICAgICogICAgIGV4cGlyZVRpbWU6ICcyMDI1LTA1LTAxVDAwOjAwOjAwWicsXG4gICAgICogICAgIExpdmVFcGhlbWVyYWxQYXJhbWV0ZXJzOiB7XG4gICAgICogICAgICAgIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaC0wMDEnLFxuICAgICAqICAgICAgICBjb25maWc6IHtcbiAgICAgKiAgICAgICAgICAgJ3Jlc3BvbnNlTW9kYWxpdGllcyc6IFsnQVVESU8nXSxcbiAgICAgKiAgICAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJzogJ0Fsd2F5cyBhbnN3ZXIgaW4gRW5nbGlzaC4nLFxuICAgICAqICAgICAgICB9XG4gICAgICogICAgIH0sXG4gICAgICogICAgIGxvY2tBZGRpdGlvbmFsRmllbGRzOiBbJ3RlbXBlcmF0dXJlJ10sXG4gICAgICogfVxuICAgICAqIGNvbnN0IHRva2VuID0gYXdhaXQgYWkudG9rZW5zLmNyZWF0ZShjb25maWcpO1xuICAgICAqXG4gICAgICogLy8gQ2FzZSA0OiBJZiBMaXZlRXBoZW1lcmFsUGFyYW1ldGVycyBpcyBzZXQgYW5kIGxvY2tBZGRpdGlvbmFsRmllbGRzIGlzXG4gICAgICogLy8gZW1wdHkgYXJyYXksIGxvY2sgTGl2ZUNvbm5lY3RDb25maWcgd2l0aCBzZXQgZmllbGRzIChlLmcuXG4gICAgICogLy8gcmVzcG9uc2VNb2RhbGl0aWVzLCBzeXN0ZW1JbnN0cnVjdGlvbiBpbiB0aGlzIGV4YW1wbGUpIHdoZW4gdXNpbmcgdGhlXG4gICAgICogLy8gdG9rZW4gaW4gTGl2ZSBBUEkgc2Vzc2lvbnMuXG4gICAgICogY29uc3QgY29uZmlnOiBDcmVhdGVBdXRoVG9rZW5Db25maWcgPVxuICAgICAqICAgICB1c2VzOiAzLFxuICAgICAqICAgICBleHBpcmVUaW1lOiAnMjAyNS0wNS0wMVQwMDowMDowMFonLFxuICAgICAqICAgICBMaXZlRXBoZW1lcmFsUGFyYW1ldGVyczoge1xuICAgICAqICAgICAgICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gtMDAxJyxcbiAgICAgKiAgICAgICAgY29uZmlnOiB7XG4gICAgICogICAgICAgICAgICdyZXNwb25zZU1vZGFsaXRpZXMnOiBbJ0FVRElPJ10sXG4gICAgICogICAgICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbic6ICdBbHdheXMgYW5zd2VyIGluIEVuZ2xpc2guJyxcbiAgICAgKiAgICAgICAgfVxuICAgICAqICAgICB9LFxuICAgICAqICAgICBsb2NrQWRkaXRpb25hbEZpZWxkczogW10sXG4gICAgICogfVxuICAgICAqIGNvbnN0IHRva2VuID0gYXdhaXQgYWkudG9rZW5zLmNyZWF0ZShjb25maWcpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY2xpZW50LnRva2Vucy5jcmVhdGUgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjcmVhdGVBdXRoVG9rZW5QYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2F1dGhfdG9rZW5zJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRCb2R5ID0gY29udmVydEJpZGlTZXR1cFRvVG9rZW5TZXR1cChib2R5LCBwYXJhbXMuY29uZmlnKTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkodHJhbnNmb3JtZWRCb2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChyZXNwKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuLy8gQ29kZSBnZW5lcmF0ZWQgYnkgdGhlIEdvb2dsZSBHZW4gQUkgU0RLIGdlbmVyYXRvciBETyBOT1QgRURJVC5cbmZ1bmN0aW9uIGRlbGV0ZURvY3VtZW50Q29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Gb3JjZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZm9yY2UnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Gb3JjZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAnZm9yY2UnXSwgZnJvbUZvcmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlRG9jdW1lbnRQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBkZWxldGVEb2N1bWVudENvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZXREb2N1bWVudFBhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3REb2N1bWVudHNDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlU2l6ZSddLCBmcm9tUGFnZVNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlVG9rZW4nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VUb2tlbiddLCBmcm9tUGFnZVRva2VuKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdERvY3VtZW50c1BhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYXJlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcmVudCddKTtcbiAgICBpZiAoZnJvbVBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAncGFyZW50J10sIGZyb21QYXJlbnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBsaXN0RG9jdW1lbnRzQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3REb2N1bWVudHNSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5leHRQYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXh0UGFnZVRva2VuJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU5leHRQYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXh0UGFnZVRva2VuJ10sIGZyb21OZXh0UGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvY3VtZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZG9jdW1lbnRzJ10pO1xuICAgIGlmIChmcm9tRG9jdW1lbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21Eb2N1bWVudHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RvY3VtZW50cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNsYXNzIERvY3VtZW50cyBleHRlbmRzIEJhc2VNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3RzIGRvY3VtZW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgbGlzdCByZXF1ZXN0LlxuICAgICAgICAgKiBAcmV0dXJuIC0gQSBwYWdlciBvZiBkb2N1bWVudHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IGRvY3VtZW50cyA9IGF3YWl0IGFpLmRvY3VtZW50cy5saXN0KHtwYXJlbnQ6J3JhZ19zdG9yZV9uYW1lJywgY29uZmlnOiB7J3BhZ2VTaXplJzogMn19KTtcbiAgICAgICAgICogZm9yIGF3YWl0IChjb25zdCBkb2N1bWVudCBvZiBkb2N1bWVudHMpIHtcbiAgICAgICAgICogICBjb25zb2xlLmxvZyhkb2N1bWVudCk7XG4gICAgICAgICAqIH1cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxpc3QgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhZ2VyKFBhZ2VkSXRlbS5QQUdFRF9JVEVNX0RPQ1VNRU5UUywgKHgpID0+IHRoaXMubGlzdEludGVybmFsKHsgcGFyZW50OiBwYXJhbXMucGFyZW50LCBjb25maWc6IHguY29uZmlnIH0pLCBhd2FpdCB0aGlzLmxpc3RJbnRlcm5hbChwYXJhbXMpLCBwYXJhbXMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgRG9jdW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGdldHRpbmcgYSBkb2N1bWVudC5cbiAgICAgKiBAcmV0dXJuIERvY3VtZW50LlxuICAgICAqL1xuICAgIGFzeW5jIGdldChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2V0RG9jdW1lbnRQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKHJlc3ApID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYSBEb2N1bWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZGVsZXRpbmcgYSBkb2N1bWVudC5cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBkZWxldGVEb2N1bWVudFBhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFwaUNsaWVudC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBsaXN0SW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGxpc3REb2N1bWVudHNQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne3BhcmVudH0vZG9jdW1lbnRzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGxpc3REb2N1bWVudHNSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IExpc3REb2N1bWVudHNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNsYXNzIEZpbGVTZWFyY2hTdG9yZXMgZXh0ZW5kcyBCYXNlTW9kdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcGlDbGllbnQsIGRvY3VtZW50cyA9IG5ldyBEb2N1bWVudHMoYXBpQ2xpZW50KSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICAgICAgdGhpcy5kb2N1bWVudHMgPSBkb2N1bWVudHM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0cyBmaWxlIHNlYXJjaCBzdG9yZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGxpc3QgcmVxdWVzdC5cbiAgICAgICAgICogQHJldHVybiAtIEEgcGFnZXIgb2YgZmlsZSBzZWFyY2ggc3RvcmVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBjb25zdCBmaWxlU2VhcmNoU3RvcmVzID0gYXdhaXQgYWkuZmlsZVNlYXJjaFN0b3Jlcy5saXN0KHtjb25maWc6IHsncGFnZVNpemUnOiAyfX0pO1xuICAgICAgICAgKiBmb3IgYXdhaXQgKGNvbnN0IGZpbGVTZWFyY2hTdG9yZSBvZiBmaWxlU2VhcmNoU3RvcmVzKSB7XG4gICAgICAgICAqICAgY29uc29sZS5sb2coZmlsZVNlYXJjaFN0b3JlKTtcbiAgICAgICAgICogfVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGlzdCA9IGFzeW5jIChwYXJhbXMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYWdlcihQYWdlZEl0ZW0uUEFHRURfSVRFTV9GSUxFX1NFQVJDSF9TVE9SRVMsICh4KSA9PiB0aGlzLmxpc3RJbnRlcm5hbCh4KSwgYXdhaXQgdGhpcy5saXN0SW50ZXJuYWwocGFyYW1zKSwgcGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBsb2FkcyBhIGZpbGUgYXN5bmNocm9ub3VzbHkgdG8gYSBnaXZlbiBGaWxlIFNlYXJjaCBTdG9yZS5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBub3QgYXZhaWxhYmxlIGluIFZlcnRleCBBSS5cbiAgICAgKiBTdXBwb3J0ZWQgdXBsb2FkIHNvdXJjZXM6XG4gICAgICogLSBOb2RlLmpzOiBGaWxlIHBhdGggKHN0cmluZykgb3IgQmxvYiBvYmplY3QuXG4gICAgICogLSBCcm93c2VyOiBCbG9iIG9iamVjdCAoZS5nLiwgRmlsZSkuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoZSBgbWltZVR5cGVgIGNhbiBiZSBzcGVjaWZpZWQgaW4gdGhlIGBjb25maWdgIHBhcmFtZXRlci4gSWYgb21pdHRlZDpcbiAgICAgKiAgLSBGb3IgZmlsZSBwYXRoIChzdHJpbmcpIGlucHV0cywgdGhlIGBtaW1lVHlwZWAgd2lsbCBiZSBpbmZlcnJlZCBmcm9tIHRoZVxuICAgICAqICAgICBmaWxlIGV4dGVuc2lvbi5cbiAgICAgKiAgLSBGb3IgQmxvYiBvYmplY3QgaW5wdXRzLCB0aGUgYG1pbWVUeXBlYCB3aWxsIGJlIHNldCB0byB0aGUgQmxvYidzIGB0eXBlYFxuICAgICAqICAgICBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIFRoaXMgc2VjdGlvbiBjYW4gY29udGFpbiBtdWx0aXBsZSBwYXJhZ3JhcGhzIGFuZCBjb2RlIGV4YW1wbGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIE9wdGlvbmFsIHBhcmFtZXRlcnMgc3BlY2lmaWVkIGluIHRoZVxuICAgICAqICAgICAgICBgdHlwZXMuVXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVQYXJhbWV0ZXJzYCBpbnRlcmZhY2UuXG4gICAgICogICAgICAgICBAc2VlIHtAbGluayB0eXBlcy5VcGxvYWRUb0ZpbGVTZWFyY2hTdG9yZVBhcmFtZXRlcnMjY29uZmlnfSBmb3IgdGhlIG9wdGlvbmFsXG4gICAgICogICAgICAgICBjb25maWcgaW4gdGhlIHBhcmFtZXRlcnMuXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGxvbmcgcnVubmluZyBvcGVyYXRpb24uXG4gICAgICogQHRocm93cyBBbiBlcnJvciBpZiBjYWxsZWQgb24gYSBWZXJ0ZXggQUkgY2xpZW50LlxuICAgICAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgdGhlIGBtaW1lVHlwZWAgaXMgbm90IHByb3ZpZGVkIGFuZCBjYW4gbm90IGJlIGluZmVycmVkLFxuICAgICAqIHRoZSBgbWltZVR5cGVgIGNhbiBiZSBwcm92aWRlZCBpbiB0aGUgYHBhcmFtcy5jb25maWdgIHBhcmFtZXRlci5cbiAgICAgKiBAdGhyb3dzIEFuIGVycm9yIG9jY3VycyBpZiBhIHN1aXRhYmxlIHVwbG9hZCBsb2NhdGlvbiBjYW5ub3QgYmUgZXN0YWJsaXNoZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIFRoZSBmb2xsb3dpbmcgY29kZSB1cGxvYWRzIGEgZmlsZSB0byBhIGdpdmVuIGZpbGUgc2VhcmNoIHN0b3JlLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBvcGVyYXRpb24gPSBhd2FpdCBhaS5maWxlU2VhcmNoU3RvcmVzLnVwbG9hZCh7ZmlsZVNlYXJjaFN0b3JlTmFtZTogJ2ZpbGVTZWFyY2hTdG9yZXMvZm9vLWJhcicsIGZpbGU6ICdmaWxlLnR4dCcsIGNvbmZpZzoge1xuICAgICAqICAgbWltZVR5cGU6ICd0ZXh0L3BsYWluJyxcbiAgICAgKiB9fSk7XG4gICAgICogY29uc29sZS5sb2cob3BlcmF0aW9uLm5hbWUpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIHVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlKHBhcmFtcykge1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZlcnRleCBBSSBkb2VzIG5vdCBzdXBwb3J0IHVwbG9hZGluZyBmaWxlcyB0byBhIGZpbGUgc2VhcmNoIHN0b3JlLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFwaUNsaWVudC51cGxvYWRGaWxlVG9GaWxlU2VhcmNoU3RvcmUocGFyYW1zLmZpbGVTZWFyY2hTdG9yZU5hbWUsIHBhcmFtcy5maWxlLCBwYXJhbXMuY29uZmlnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIEZpbGUgU2VhcmNoIFN0b3JlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBjcmVhdGluZyBhIEZpbGUgU2VhcmNoIFN0b3JlLlxuICAgICAqIEByZXR1cm4gRmlsZVNlYXJjaFN0b3JlLlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlRmlsZVNlYXJjaFN0b3JlUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2ZpbGVTZWFyY2hTdG9yZXMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKHJlc3ApID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBGaWxlIFNlYXJjaCBTdG9yZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZ2V0dGluZyBhIEZpbGUgU2VhcmNoIFN0b3JlLlxuICAgICAqIEByZXR1cm4gRmlsZVNlYXJjaFN0b3JlLlxuICAgICAqL1xuICAgIGFzeW5jIGdldChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2V0RmlsZVNlYXJjaFN0b3JlUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChyZXNwKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGEgRmlsZSBTZWFyY2ggU3RvcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGRlbGV0aW5nIGEgRmlsZSBTZWFyY2ggU3RvcmUuXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZGVsZXRlRmlsZVNlYXJjaFN0b3JlUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBpQ2xpZW50LnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGxpc3RJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbGlzdEZpbGVTZWFyY2hTdG9yZXNQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnZmlsZVNlYXJjaFN0b3JlcycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0RmlsZVNlYXJjaFN0b3Jlc1Jlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgTGlzdEZpbGVTZWFyY2hTdG9yZXNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gdXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgndXBsb2FkL3YxYmV0YS97ZmlsZV9zZWFyY2hfc3RvcmVfbmFtZX06dXBsb2FkVG9GaWxlU2VhcmNoU3RvcmUnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IHVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlUmVzdW1hYmxlUmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBVcGxvYWRUb0ZpbGVTZWFyY2hTdG9yZVJlc3VtYWJsZVJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbXBvcnRzIGEgRmlsZSBmcm9tIEZpbGUgU2VydmljZSB0byBhIEZpbGVTZWFyY2hTdG9yZS5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYSBsb25nLXJ1bm5pbmcgb3BlcmF0aW9uLCBzZWUgYWlwLmRldi8xNTFcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgaW1wb3J0aW5nIGEgZmlsZSB0byBhIGZpbGUgc2VhcmNoIHN0b3JlLlxuICAgICAqIEByZXR1cm4gSW1wb3J0RmlsZU9wZXJhdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyBpbXBvcnRGaWxlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBpbXBvcnRGaWxlUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tmaWxlX3NlYXJjaF9zdG9yZV9uYW1lfTppbXBvcnRGaWxlJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBpbXBvcnRGaWxlT3BlcmF0aW9uRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgSW1wb3J0RmlsZU9wZXJhdGlvbigpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8vIENvZGUgZ2VuZXJhdGVkIGJ5IHRoZSBHb29nbGUgR2VuIEFJIFNESyBnZW5lcmF0b3IgRE8gTk9UIEVESVQuXG5mdW5jdGlvbiBjYW5jZWxUdW5pbmdKb2JQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY2FuY2VsVHVuaW5nSm9iUGFyYW1ldGVyc1RvVmVydGV4KGZyb21PYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjYW5jZWxUdW5pbmdKb2JSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNhbmNlbFR1bmluZ0pvYlJlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVR1bmluZ0pvYkNvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmFsaWRhdGlvbkRhdGFzZXQnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbGlkYXRpb25EYXRhc2V0IHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0dW5lZE1vZGVsRGlzcGxheU5hbWUnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVHVuZWRNb2RlbERpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGVzY3JpcHRpb24gcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVwb2NoQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vwb2NoQ291bnQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FcG9jaENvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3R1bmluZ1Rhc2snLCAnaHlwZXJwYXJhbWV0ZXJzJywgJ2Vwb2NoQ291bnQnXSwgZnJvbUVwb2NoQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGVhcm5pbmdSYXRlTXVsdGlwbGllciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2xlYXJuaW5nUmF0ZU11bHRpcGxpZXInLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTGVhcm5pbmdSYXRlTXVsdGlwbGllciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1bmluZ1Rhc2snLCAnaHlwZXJwYXJhbWV0ZXJzJywgJ2xlYXJuaW5nUmF0ZU11bHRpcGxpZXInXSwgZnJvbUxlYXJuaW5nUmF0ZU11bHRpcGxpZXIpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleHBvcnRMYXN0Q2hlY2twb2ludE9ubHknXSkgIT09XG4gICAgICAgIHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cG9ydExhc3RDaGVja3BvaW50T25seSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcmVUdW5lZE1vZGVsQ2hlY2twb2ludElkJ10pICE9PVxuICAgICAgICB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcmVUdW5lZE1vZGVsQ2hlY2twb2ludElkIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FkYXB0ZXJTaXplJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZGFwdGVyU2l6ZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmF0Y2hTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiYXRjaFNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21CYXRjaFNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndHVuaW5nVGFzaycsICdoeXBlcnBhcmFtZXRlcnMnLCAnYmF0Y2hTaXplJ10sIGZyb21CYXRjaFNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGVhcm5pbmdSYXRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsZWFybmluZ1JhdGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MZWFybmluZ1JhdGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndHVuaW5nVGFzaycsICdoeXBlcnBhcmFtZXRlcnMnLCAnbGVhcm5pbmdSYXRlJ10sIGZyb21MZWFybmluZ1JhdGUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbHMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xhYmVscyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiZXRhJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiZXRhIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVR1bmluZ0pvYkNvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgbGV0IGRpc2NyaW1pbmF0b3JWYWxpZGF0aW9uRGF0YXNldCA9IGdldFZhbHVlQnlQYXRoKHJvb3RPYmplY3QsIFtcbiAgICAgICAgJ2NvbmZpZycsXG4gICAgICAgICdtZXRob2QnLFxuICAgIF0pO1xuICAgIGlmIChkaXNjcmltaW5hdG9yVmFsaWRhdGlvbkRhdGFzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkaXNjcmltaW5hdG9yVmFsaWRhdGlvbkRhdGFzZXQgPSAnU1VQRVJWSVNFRF9GSU5FX1RVTklORyc7XG4gICAgfVxuICAgIGlmIChkaXNjcmltaW5hdG9yVmFsaWRhdGlvbkRhdGFzZXQgPT09ICdTVVBFUlZJU0VEX0ZJTkVfVFVOSU5HJykge1xuICAgICAgICBjb25zdCBmcm9tVmFsaWRhdGlvbkRhdGFzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICAgICAndmFsaWRhdGlvbkRhdGFzZXQnLFxuICAgICAgICBdKTtcbiAgICAgICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21WYWxpZGF0aW9uRGF0YXNldCAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3VwZXJ2aXNlZFR1bmluZ1NwZWMnXSwgdHVuaW5nVmFsaWRhdGlvbkRhdGFzZXRUb1ZlcnRleChmcm9tVmFsaWRhdGlvbkRhdGFzZXQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChkaXNjcmltaW5hdG9yVmFsaWRhdGlvbkRhdGFzZXQgPT09ICdQUkVGRVJFTkNFX1RVTklORycpIHtcbiAgICAgICAgY29uc3QgZnJvbVZhbGlkYXRpb25EYXRhc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAgICAgJ3ZhbGlkYXRpb25EYXRhc2V0JyxcbiAgICAgICAgXSk7XG4gICAgICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVmFsaWRhdGlvbkRhdGFzZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3ByZWZlcmVuY2VPcHRpbWl6YXRpb25TcGVjJ10sIHR1bmluZ1ZhbGlkYXRpb25EYXRhc2V0VG9WZXJ0ZXgoZnJvbVZhbGlkYXRpb25EYXRhc2V0KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZnJvbVR1bmVkTW9kZWxEaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3R1bmVkTW9kZWxEaXNwbGF5TmFtZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndHVuZWRNb2RlbERpc3BsYXlOYW1lJ10sIGZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgbGV0IGRpc2NyaW1pbmF0b3JFcG9jaENvdW50ID0gZ2V0VmFsdWVCeVBhdGgocm9vdE9iamVjdCwgW1xuICAgICAgICAnY29uZmlnJyxcbiAgICAgICAgJ21ldGhvZCcsXG4gICAgXSk7XG4gICAgaWYgKGRpc2NyaW1pbmF0b3JFcG9jaENvdW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGlzY3JpbWluYXRvckVwb2NoQ291bnQgPSAnU1VQRVJWSVNFRF9GSU5FX1RVTklORyc7XG4gICAgfVxuICAgIGlmIChkaXNjcmltaW5hdG9yRXBvY2hDb3VudCA9PT0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnKSB7XG4gICAgICAgIGNvbnN0IGZyb21FcG9jaENvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcG9jaENvdW50J10pO1xuICAgICAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUVwb2NoQ291bnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N1cGVydmlzZWRUdW5pbmdTcGVjJywgJ2h5cGVyUGFyYW1ldGVycycsICdlcG9jaENvdW50J10sIGZyb21FcG9jaENvdW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChkaXNjcmltaW5hdG9yRXBvY2hDb3VudCA9PT0gJ1BSRUZFUkVOQ0VfVFVOSU5HJykge1xuICAgICAgICBjb25zdCBmcm9tRXBvY2hDb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXBvY2hDb3VudCddKTtcbiAgICAgICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FcG9jaENvdW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwcmVmZXJlbmNlT3B0aW1pemF0aW9uU3BlYycsICdoeXBlclBhcmFtZXRlcnMnLCAnZXBvY2hDb3VudCddLCBmcm9tRXBvY2hDb3VudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGRpc2NyaW1pbmF0b3JMZWFybmluZ1JhdGVNdWx0aXBsaWVyID0gZ2V0VmFsdWVCeVBhdGgocm9vdE9iamVjdCwgW1xuICAgICAgICAnY29uZmlnJyxcbiAgICAgICAgJ21ldGhvZCcsXG4gICAgXSk7XG4gICAgaWYgKGRpc2NyaW1pbmF0b3JMZWFybmluZ1JhdGVNdWx0aXBsaWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGlzY3JpbWluYXRvckxlYXJuaW5nUmF0ZU11bHRpcGxpZXIgPSAnU1VQRVJWSVNFRF9GSU5FX1RVTklORyc7XG4gICAgfVxuICAgIGlmIChkaXNjcmltaW5hdG9yTGVhcm5pbmdSYXRlTXVsdGlwbGllciA9PT0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnKSB7XG4gICAgICAgIGNvbnN0IGZyb21MZWFybmluZ1JhdGVNdWx0aXBsaWVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAgICAgJ2xlYXJuaW5nUmF0ZU11bHRpcGxpZXInLFxuICAgICAgICBdKTtcbiAgICAgICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MZWFybmluZ1JhdGVNdWx0aXBsaWVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzdXBlcnZpc2VkVHVuaW5nU3BlYycsICdoeXBlclBhcmFtZXRlcnMnLCAnbGVhcm5pbmdSYXRlTXVsdGlwbGllciddLCBmcm9tTGVhcm5pbmdSYXRlTXVsdGlwbGllcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZGlzY3JpbWluYXRvckxlYXJuaW5nUmF0ZU11bHRpcGxpZXIgPT09ICdQUkVGRVJFTkNFX1RVTklORycpIHtcbiAgICAgICAgY29uc3QgZnJvbUxlYXJuaW5nUmF0ZU11bHRpcGxpZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICAgICAnbGVhcm5pbmdSYXRlTXVsdGlwbGllcicsXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUxlYXJuaW5nUmF0ZU11bHRpcGxpZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbXG4gICAgICAgICAgICAgICAgJ3ByZWZlcmVuY2VPcHRpbWl6YXRpb25TcGVjJyxcbiAgICAgICAgICAgICAgICAnaHlwZXJQYXJhbWV0ZXJzJyxcbiAgICAgICAgICAgICAgICAnbGVhcm5pbmdSYXRlTXVsdGlwbGllcicsXG4gICAgICAgICAgICBdLCBmcm9tTGVhcm5pbmdSYXRlTXVsdGlwbGllcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGRpc2NyaW1pbmF0b3JFeHBvcnRMYXN0Q2hlY2twb2ludE9ubHkgPSBnZXRWYWx1ZUJ5UGF0aChyb290T2JqZWN0LCBbJ2NvbmZpZycsICdtZXRob2QnXSk7XG4gICAgaWYgKGRpc2NyaW1pbmF0b3JFeHBvcnRMYXN0Q2hlY2twb2ludE9ubHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkaXNjcmltaW5hdG9yRXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5ID0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnO1xuICAgIH1cbiAgICBpZiAoZGlzY3JpbWluYXRvckV4cG9ydExhc3RDaGVja3BvaW50T25seSA9PT0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnKSB7XG4gICAgICAgIGNvbnN0IGZyb21FeHBvcnRMYXN0Q2hlY2twb2ludE9ubHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICAgICAnZXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5JyxcbiAgICAgICAgXSk7XG4gICAgICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzdXBlcnZpc2VkVHVuaW5nU3BlYycsICdleHBvcnRMYXN0Q2hlY2twb2ludE9ubHknXSwgZnJvbUV4cG9ydExhc3RDaGVja3BvaW50T25seSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZGlzY3JpbWluYXRvckV4cG9ydExhc3RDaGVja3BvaW50T25seSA9PT0gJ1BSRUZFUkVOQ0VfVFVOSU5HJykge1xuICAgICAgICBjb25zdCBmcm9tRXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAgICAgJ2V4cG9ydExhc3RDaGVja3BvaW50T25seScsXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUV4cG9ydExhc3RDaGVja3BvaW50T25seSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncHJlZmVyZW5jZU9wdGltaXphdGlvblNwZWMnLCAnZXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5J10sIGZyb21FeHBvcnRMYXN0Q2hlY2twb2ludE9ubHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBkaXNjcmltaW5hdG9yQWRhcHRlclNpemUgPSBnZXRWYWx1ZUJ5UGF0aChyb290T2JqZWN0LCBbXG4gICAgICAgICdjb25maWcnLFxuICAgICAgICAnbWV0aG9kJyxcbiAgICBdKTtcbiAgICBpZiAoZGlzY3JpbWluYXRvckFkYXB0ZXJTaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGlzY3JpbWluYXRvckFkYXB0ZXJTaXplID0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnO1xuICAgIH1cbiAgICBpZiAoZGlzY3JpbWluYXRvckFkYXB0ZXJTaXplID09PSAnU1VQRVJWSVNFRF9GSU5FX1RVTklORycpIHtcbiAgICAgICAgY29uc3QgZnJvbUFkYXB0ZXJTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhZGFwdGVyU2l6ZSddKTtcbiAgICAgICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21BZGFwdGVyU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3VwZXJ2aXNlZFR1bmluZ1NwZWMnLCAnaHlwZXJQYXJhbWV0ZXJzJywgJ2FkYXB0ZXJTaXplJ10sIGZyb21BZGFwdGVyU2l6ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZGlzY3JpbWluYXRvckFkYXB0ZXJTaXplID09PSAnUFJFRkVSRU5DRV9UVU5JTkcnKSB7XG4gICAgICAgIGNvbnN0IGZyb21BZGFwdGVyU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYWRhcHRlclNpemUnXSk7XG4gICAgICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQWRhcHRlclNpemUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3ByZWZlcmVuY2VPcHRpbWl6YXRpb25TcGVjJywgJ2h5cGVyUGFyYW1ldGVycycsICdhZGFwdGVyU2l6ZSddLCBmcm9tQWRhcHRlclNpemUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JhdGNoU2l6ZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmF0Y2hTaXplIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGVhcm5pbmdSYXRlJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsZWFybmluZ1JhdGUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFiZWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MYWJlbHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnbGFiZWxzJ10sIGZyb21MYWJlbHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmV0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmV0YSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUJldGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncHJlZmVyZW5jZU9wdGltaXphdGlvblNwZWMnLCAnaHlwZXJQYXJhbWV0ZXJzJywgJ2JldGEnXSwgZnJvbUJldGEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVUdW5pbmdKb2JQYXJhbWV0ZXJzUHJpdmF0ZVRvTWxkZXYoZnJvbU9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUJhc2VNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmFzZU1vZGVsJ10pO1xuICAgIGlmIChmcm9tQmFzZU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmFzZU1vZGVsJ10sIGZyb21CYXNlTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJlVHVuZWRNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZVR1bmVkTW9kZWwnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlVHVuZWRNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZVR1bmVkTW9kZWwnXSwgZnJvbVByZVR1bmVkTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHJhaW5pbmdEYXRhc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndHJhaW5pbmdEYXRhc2V0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRyYWluaW5nRGF0YXNldCAhPSBudWxsKSB7XG4gICAgICAgIHR1bmluZ0RhdGFzZXRUb01sZGV2KGZyb21UcmFpbmluZ0RhdGFzZXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBjcmVhdGVUdW5pbmdKb2JDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlVHVuaW5nSm9iUGFyYW1ldGVyc1ByaXZhdGVUb1ZlcnRleChmcm9tT2JqZWN0LCByb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQmFzZU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiYXNlTW9kZWwnXSk7XG4gICAgaWYgKGZyb21CYXNlTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiYXNlTW9kZWwnXSwgZnJvbUJhc2VNb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QcmVUdW5lZE1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlVHVuZWRNb2RlbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QcmVUdW5lZE1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJlVHVuZWRNb2RlbCddLCBmcm9tUHJlVHVuZWRNb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UcmFpbmluZ0RhdGFzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0cmFpbmluZ0RhdGFzZXQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVHJhaW5pbmdEYXRhc2V0ICE9IG51bGwpIHtcbiAgICAgICAgdHVuaW5nRGF0YXNldFRvVmVydGV4KGZyb21UcmFpbmluZ0RhdGFzZXQsIHRvT2JqZWN0LCByb290T2JqZWN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgY3JlYXRlVHVuaW5nSm9iQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QsIHJvb3RPYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZXRUdW5pbmdKb2JQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0VHVuaW5nSm9iUGFyYW1ldGVyc1RvVmVydGV4KGZyb21PYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0VHVuaW5nSm9ic0NvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlU2l6ZSddLCBmcm9tUGFnZVNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlVG9rZW4nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VUb2tlbiddLCBmcm9tUGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsdGVyJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdmaWx0ZXInXSwgZnJvbUZpbHRlcik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RUdW5pbmdKb2JzQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlU2l6ZSddLCBmcm9tUGFnZVNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlVG9rZW4nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VUb2tlbiddLCBmcm9tUGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsdGVyJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdmaWx0ZXInXSwgZnJvbUZpbHRlcik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RUdW5pbmdKb2JzUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgbGlzdFR1bmluZ0pvYnNDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdFR1bmluZ0pvYnNQYXJhbWV0ZXJzVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgbGlzdFR1bmluZ0pvYnNDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RUdW5pbmdKb2JzUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZXh0UGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmV4dFBhZ2VUb2tlbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21OZXh0UGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmV4dFBhZ2VUb2tlbiddLCBmcm9tTmV4dFBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdW5pbmdKb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0dW5lZE1vZGVscyddKTtcbiAgICBpZiAoZnJvbVR1bmluZ0pvYnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVR1bmluZ0pvYnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHVuaW5nSm9iRnJvbU1sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVuaW5nSm9icyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0VHVuaW5nSm9ic1Jlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0LCByb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5leHRQYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXh0UGFnZVRva2VuJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU5leHRQYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXh0UGFnZVRva2VuJ10sIGZyb21OZXh0UGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR1bmluZ0pvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R1bmluZ0pvYnMnXSk7XG4gICAgaWYgKGZyb21UdW5pbmdKb2JzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21UdW5pbmdKb2JzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR1bmluZ0pvYkZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0dW5pbmdKb2JzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHR1bmVkTW9kZWxGcm9tTWxkZXYoZnJvbU9iamVjdCwgX3Jvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWwnXSwgZnJvbU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZHBvaW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tRW5kcG9pbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRwb2ludCddLCBmcm9tRW5kcG9pbnQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0dW5pbmdEYXRhc2V0VG9NbGRldihmcm9tT2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2NzVXJpJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnY3NVcmkgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmVydGV4RGF0YXNldFJlc291cmNlJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2ZXJ0ZXhEYXRhc2V0UmVzb3VyY2UgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4YW1wbGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleGFtcGxlcyddKTtcbiAgICBpZiAoZnJvbUV4YW1wbGVzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21FeGFtcGxlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhhbXBsZXMnLCAnZXhhbXBsZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdHVuaW5nRGF0YXNldFRvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgbGV0IGRpc2NyaW1pbmF0b3JHY3NVcmkgPSBnZXRWYWx1ZUJ5UGF0aChyb290T2JqZWN0LCBbXG4gICAgICAgICdjb25maWcnLFxuICAgICAgICAnbWV0aG9kJyxcbiAgICBdKTtcbiAgICBpZiAoZGlzY3JpbWluYXRvckdjc1VyaSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRpc2NyaW1pbmF0b3JHY3NVcmkgPSAnU1VQRVJWSVNFRF9GSU5FX1RVTklORyc7XG4gICAgfVxuICAgIGlmIChkaXNjcmltaW5hdG9yR2NzVXJpID09PSAnU1VQRVJWSVNFRF9GSU5FX1RVTklORycpIHtcbiAgICAgICAgY29uc3QgZnJvbUdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2NzVXJpJ10pO1xuICAgICAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3VwZXJ2aXNlZFR1bmluZ1NwZWMnLCAndHJhaW5pbmdEYXRhc2V0VXJpJ10sIGZyb21HY3NVcmkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGRpc2NyaW1pbmF0b3JHY3NVcmkgPT09ICdQUkVGRVJFTkNFX1RVTklORycpIHtcbiAgICAgICAgY29uc3QgZnJvbUdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2NzVXJpJ10pO1xuICAgICAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncHJlZmVyZW5jZU9wdGltaXphdGlvblNwZWMnLCAndHJhaW5pbmdEYXRhc2V0VXJpJ10sIGZyb21HY3NVcmkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBkaXNjcmltaW5hdG9yVmVydGV4RGF0YXNldFJlc291cmNlID0gZ2V0VmFsdWVCeVBhdGgocm9vdE9iamVjdCwgW1xuICAgICAgICAnY29uZmlnJyxcbiAgICAgICAgJ21ldGhvZCcsXG4gICAgXSk7XG4gICAgaWYgKGRpc2NyaW1pbmF0b3JWZXJ0ZXhEYXRhc2V0UmVzb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkaXNjcmltaW5hdG9yVmVydGV4RGF0YXNldFJlc291cmNlID0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnO1xuICAgIH1cbiAgICBpZiAoZGlzY3JpbWluYXRvclZlcnRleERhdGFzZXRSZXNvdXJjZSA9PT0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnKSB7XG4gICAgICAgIGNvbnN0IGZyb21WZXJ0ZXhEYXRhc2V0UmVzb3VyY2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICAgICAndmVydGV4RGF0YXNldFJlc291cmNlJyxcbiAgICAgICAgXSk7XG4gICAgICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVmVydGV4RGF0YXNldFJlc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzdXBlcnZpc2VkVHVuaW5nU3BlYycsICd0cmFpbmluZ0RhdGFzZXRVcmknXSwgZnJvbVZlcnRleERhdGFzZXRSZXNvdXJjZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZGlzY3JpbWluYXRvclZlcnRleERhdGFzZXRSZXNvdXJjZSA9PT0gJ1BSRUZFUkVOQ0VfVFVOSU5HJykge1xuICAgICAgICBjb25zdCBmcm9tVmVydGV4RGF0YXNldFJlc291cmNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAgICAgJ3ZlcnRleERhdGFzZXRSZXNvdXJjZScsXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVZlcnRleERhdGFzZXRSZXNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncHJlZmVyZW5jZU9wdGltaXphdGlvblNwZWMnLCAndHJhaW5pbmdEYXRhc2V0VXJpJ10sIGZyb21WZXJ0ZXhEYXRhc2V0UmVzb3VyY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4YW1wbGVzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleGFtcGxlcyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHR1bmluZ0pvYkZyb21NbGRldihmcm9tT2JqZWN0LCByb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGF0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhdGUnXSk7XG4gICAgaWYgKGZyb21TdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXRlJ10sIHRUdW5pbmdKb2JTdGF0dXMoZnJvbVN0YXRlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DcmVhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjcmVhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tQ3JlYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSwgZnJvbUNyZWF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhcnRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndHVuaW5nVGFzaycsXG4gICAgICAgICdzdGFydFRpbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3RhcnRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRUaW1lJ10sIGZyb21TdGFydFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3R1bmluZ1Rhc2snLFxuICAgICAgICAnY29tcGxldGVUaW1lJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUVuZFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRUaW1lJ10sIGZyb21FbmRUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVwZGF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21VcGRhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXBkYXRlVGltZSddLCBmcm9tVXBkYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CYXNlTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Jhc2VNb2RlbCddKTtcbiAgICBpZiAoZnJvbUJhc2VNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Jhc2VNb2RlbCddLCBmcm9tQmFzZU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR1bmVkTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tVHVuZWRNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1bmVkTW9kZWwnXSwgdHVuZWRNb2RlbEZyb21NbGRldihmcm9tVHVuZWRNb2RlbCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0dW5pbmdKb2JGcm9tVmVydGV4KGZyb21PYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGF0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhdGUnXSk7XG4gICAgaWYgKGZyb21TdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXRlJ10sIHRUdW5pbmdKb2JTdGF0dXMoZnJvbVN0YXRlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DcmVhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjcmVhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tQ3JlYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSwgZnJvbUNyZWF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhcnRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGFydFRpbWUnXSk7XG4gICAgaWYgKGZyb21TdGFydFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGFydFRpbWUnXSwgZnJvbVN0YXJ0VGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmRUaW1lJ10pO1xuICAgIGlmIChmcm9tRW5kVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZFRpbWUnXSwgZnJvbUVuZFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXBkYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXBkYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbVVwZGF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cGRhdGVUaW1lJ10sIGZyb21VcGRhdGVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgZnJvbUVycm9yKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAoZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJhc2VNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmFzZU1vZGVsJ10pO1xuICAgIGlmIChmcm9tQmFzZU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmFzZU1vZGVsJ10sIGZyb21CYXNlTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHVuZWRNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHVuZWRNb2RlbCddKTtcbiAgICBpZiAoZnJvbVR1bmVkTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0dW5lZE1vZGVsJ10sIGZyb21UdW5lZE1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByZVR1bmVkTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVUdW5lZE1vZGVsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByZVR1bmVkTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcmVUdW5lZE1vZGVsJ10sIGZyb21QcmVUdW5lZE1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN1cGVydmlzZWRUdW5pbmdTcGVjID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3VwZXJ2aXNlZFR1bmluZ1NwZWMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3VwZXJ2aXNlZFR1bmluZ1NwZWMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdXBlcnZpc2VkVHVuaW5nU3BlYyddLCBmcm9tU3VwZXJ2aXNlZFR1bmluZ1NwZWMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJlZmVyZW5jZU9wdGltaXphdGlvblNwZWMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVmZXJlbmNlT3B0aW1pemF0aW9uU3BlYycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QcmVmZXJlbmNlT3B0aW1pemF0aW9uU3BlYyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZWZlcmVuY2VPcHRpbWl6YXRpb25TcGVjJ10sIGZyb21QcmVmZXJlbmNlT3B0aW1pemF0aW9uU3BlYyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdW5pbmdEYXRhU3RhdHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0dW5pbmdEYXRhU3RhdHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVHVuaW5nRGF0YVN0YXRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVuaW5nRGF0YVN0YXRzJ10sIGZyb21UdW5pbmdEYXRhU3RhdHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5jcnlwdGlvblNwZWMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmNyeXB0aW9uU3BlYycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbmNyeXB0aW9uU3BlYyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuY3J5cHRpb25TcGVjJ10sIGZyb21FbmNyeXB0aW9uU3BlYyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJ0bmVyTW9kZWxUdW5pbmdTcGVjID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGFydG5lck1vZGVsVHVuaW5nU3BlYycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QYXJ0bmVyTW9kZWxUdW5pbmdTcGVjICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFydG5lck1vZGVsVHVuaW5nU3BlYyddLCBmcm9tUGFydG5lck1vZGVsVHVuaW5nU3BlYyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DdXN0b21CYXNlTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjdXN0b21CYXNlTW9kZWwnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ3VzdG9tQmFzZU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY3VzdG9tQmFzZU1vZGVsJ10sIGZyb21DdXN0b21CYXNlTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhwZXJpbWVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhwZXJpbWVudCddKTtcbiAgICBpZiAoZnJvbUV4cGVyaW1lbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleHBlcmltZW50J10sIGZyb21FeHBlcmltZW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhYmVscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pO1xuICAgIGlmIChmcm9tTGFiZWxzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbGFiZWxzJ10sIGZyb21MYWJlbHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0VXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRVcmknXSk7XG4gICAgaWYgKGZyb21PdXRwdXRVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydvdXRwdXRVcmknXSwgZnJvbU91dHB1dFVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QaXBlbGluZUpvYiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGlwZWxpbmVKb2InXSk7XG4gICAgaWYgKGZyb21QaXBlbGluZUpvYiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BpcGVsaW5lSm9iJ10sIGZyb21QaXBlbGluZUpvYik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZXJ2aWNlQWNjb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NlcnZpY2VBY2NvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNlcnZpY2VBY2NvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2VydmljZUFjY291bnQnXSwgZnJvbVNlcnZpY2VBY2NvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR1bmVkTW9kZWxEaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3R1bmVkTW9kZWxEaXNwbGF5TmFtZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0dW5lZE1vZGVsRGlzcGxheU5hbWUnXSwgZnJvbVR1bmVkTW9kZWxEaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WZW9UdW5pbmdTcGVjID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmVvVHVuaW5nU3BlYycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WZW9UdW5pbmdTcGVjICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmVvVHVuaW5nU3BlYyddLCBmcm9tVmVvVHVuaW5nU3BlYyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHR1bmluZ09wZXJhdGlvbkZyb21NbGRldihmcm9tT2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJ10pO1xuICAgIGlmIChmcm9tTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZXRhZGF0YSddLCBmcm9tTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRG9uZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZG9uZSddKTtcbiAgICBpZiAoZnJvbURvbmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkb25lJ10sIGZyb21Eb25lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgZnJvbUVycm9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdHVuaW5nVmFsaWRhdGlvbkRhdGFzZXRUb1ZlcnRleChmcm9tT2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2NzVXJpJ10pO1xuICAgIGlmIChmcm9tR2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmFsaWRhdGlvbkRhdGFzZXRVcmknXSwgZnJvbUdjc1VyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WZXJ0ZXhEYXRhc2V0UmVzb3VyY2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2ZXJ0ZXhEYXRhc2V0UmVzb3VyY2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmVydGV4RGF0YXNldFJlc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmFsaWRhdGlvbkRhdGFzZXRVcmknXSwgZnJvbVZlcnRleERhdGFzZXRSZXNvdXJjZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgVHVuaW5ncyBleHRlbmRzIEJhc2VNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3RzIHR1bmluZyBqb2JzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBsaXN0IHJlcXVlc3QuXG4gICAgICAgICAqIEByZXR1cm4gLSBBIHBhZ2VyIG9mIHR1bmluZyBqb2JzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBjb25zdCB0dW5pbmdKb2JzID0gYXdhaXQgYWkudHVuaW5ncy5saXN0KHtjb25maWc6IHsncGFnZVNpemUnOiAyfX0pO1xuICAgICAgICAgKiBmb3IgYXdhaXQgKGNvbnN0IHR1bmluZ0pvYiBvZiB0dW5pbmdKb2JzKSB7XG4gICAgICAgICAqICAgY29uc29sZS5sb2codHVuaW5nSm9iKTtcbiAgICAgICAgICogfVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGlzdCA9IGFzeW5jIChwYXJhbXMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYWdlcihQYWdlZEl0ZW0uUEFHRURfSVRFTV9UVU5JTkdfSk9CUywgKHgpID0+IHRoaXMubGlzdEludGVybmFsKHgpLCBhd2FpdCB0aGlzLmxpc3RJbnRlcm5hbChwYXJhbXMpLCBwYXJhbXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyBhIFR1bmluZ0pvYi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG5hbWUgLSBUaGUgcmVzb3VyY2UgbmFtZSBvZiB0aGUgdHVuaW5nIGpvYi5cbiAgICAgICAgICogQHJldHVybiAtIEEgVHVuaW5nSm9iIG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4cGVyaW1lbnRhbCAtIFRoZSBTREsncyB0dW5pbmcgaW1wbGVtZW50YXRpb24gaXMgZXhwZXJpbWVudGFsLCBhbmQgbWF5XG4gICAgICAgICAqIGNoYW5nZSBpbiBmdXR1cmUgdmVyc2lvbnMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldCA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdldEludGVybmFsKHBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgc3VwZXJ2aXNlZCBmaW5lLXR1bmluZyBqb2IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIHR1bmluZyBqb2IuXG4gICAgICAgICAqIEByZXR1cm4gLSBBIFR1bmluZ0pvYiBvcGVyYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleHBlcmltZW50YWwgLSBUaGUgU0RLJ3MgdHVuaW5nIGltcGxlbWVudGF0aW9uIGlzIGV4cGVyaW1lbnRhbCwgYW5kIG1heVxuICAgICAgICAgKiBjaGFuZ2UgaW4gZnV0dXJlIHZlcnNpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50dW5lID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuYmFzZU1vZGVsLnN0YXJ0c1dpdGgoJ3Byb2plY3RzLycpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZVR1bmVkTW9kZWwgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0dW5lZE1vZGVsTmFtZTogcGFyYW1zLmJhc2VNb2RlbCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wcmVUdW5lZE1vZGVsQ2hlY2twb2ludElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVUdW5lZE1vZGVsLmNoZWNrcG9pbnRJZCA9IHBhcmFtcy5jb25maWcucHJlVHVuZWRNb2RlbENoZWNrcG9pbnRJZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXNQcml2YXRlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpLCB7IHByZVR1bmVkTW9kZWw6IHByZVR1bmVkTW9kZWwgfSk7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtc1ByaXZhdGUuYmFzZU1vZGVsID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50dW5lSW50ZXJuYWwocGFyYW1zUHJpdmF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXNQcml2YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHVuZUludGVybmFsKHBhcmFtc1ByaXZhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtc1ByaXZhdGUgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IGF3YWl0IHRoaXMudHVuZU1sZGV2SW50ZXJuYWwocGFyYW1zUHJpdmF0ZSk7XG4gICAgICAgICAgICAgICAgbGV0IHR1bmVkTW9kZWxOYW1lID0gJyc7XG4gICAgICAgICAgICAgICAgaWYgKG9wZXJhdGlvblsnbWV0YWRhdGEnXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvblsnbWV0YWRhdGEnXVsndHVuZWRNb2RlbCddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHVuZWRNb2RlbE5hbWUgPSBvcGVyYXRpb25bJ21ldGFkYXRhJ11bJ3R1bmVkTW9kZWwnXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uWyduYW1lJ10gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25bJ25hbWUnXS5pbmNsdWRlcygnL29wZXJhdGlvbnMvJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdHVuZWRNb2RlbE5hbWUgPSBvcGVyYXRpb25bJ25hbWUnXS5zcGxpdCgnL29wZXJhdGlvbnMvJylbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHR1bmluZ0pvYiA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdHVuZWRNb2RlbE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiBKb2JTdGF0ZS5KT0JfU1RBVEVfUVVFVUVELFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR1bmluZ0pvYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0SW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldFR1bmluZ0pvYlBhcmFtZXRlcnNUb1ZlcnRleChwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSB0dW5pbmdKb2JGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldFR1bmluZ0pvYlBhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IHR1bmluZ0pvYkZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBsaXN0SW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGxpc3RUdW5pbmdKb2JzUGFyYW1ldGVyc1RvVmVydGV4KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd0dW5pbmdKb2JzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0VHVuaW5nSm9ic1Jlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IExpc3RUdW5pbmdKb2JzUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGxpc3RUdW5pbmdKb2JzUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3R1bmVkTW9kZWxzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0VHVuaW5nSm9ic1Jlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgTGlzdFR1bmluZ0pvYnNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FuY2VscyBhIHR1bmluZyBqb2IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBjYW5jZWwgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSBlbXB0eSByZXNwb25zZSByZXR1cm5lZCBieSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGF3YWl0IGFpLnR1bmluZ3MuY2FuY2VsKHtuYW1lOiAnLi4uJ30pOyAvLyBUaGUgc2VydmVyLWdlbmVyYXRlZCByZXNvdXJjZSBuYW1lLlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGNhbmNlbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY2FuY2VsVHVuaW5nSm9iUGFyYW1ldGVyc1RvVmVydGV4KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX06Y2FuY2VsJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gY2FuY2VsVHVuaW5nSm9iUmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgQ2FuY2VsVHVuaW5nSm9iUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNhbmNlbFR1bmluZ0pvYlBhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX06Y2FuY2VsJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gY2FuY2VsVHVuaW5nSm9iUmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBDYW5jZWxUdW5pbmdKb2JSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdHVuZUludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlVHVuaW5nSm9iUGFyYW1ldGVyc1ByaXZhdGVUb1ZlcnRleChwYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd0dW5pbmdKb2JzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gdHVuaW5nSm9iRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIFZlcnRleCBBSS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB0dW5lTWxkZXZJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlVHVuaW5nSm9iUGFyYW1ldGVyc1ByaXZhdGVUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd0dW5lZE1vZGVscycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IHR1bmluZ09wZXJhdGlvbkZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgQnJvd3NlckRvd25sb2FkZXIge1xuICAgIGFzeW5jIGRvd25sb2FkKF9wYXJhbXMsIF9hcGlDbGllbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEb3dubG9hZCB0byBmaWxlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGJyb3dzZXIsIHBsZWFzZSB1c2UgYSBicm93c2VyIGNvbXBsaWFudCBkb3dubG9hZCBsaWtlIGFuIDxhPiB0YWcuJyk7XG4gICAgfVxufVxuXG5jb25zdCBNQVhfQ0hVTktfU0laRSA9IDEwMjQgKiAxMDI0ICogODsgLy8gYnl0ZXNcbmNvbnN0IE1BWF9SRVRSWV9DT1VOVCA9IDM7XG5jb25zdCBJTklUSUFMX1JFVFJZX0RFTEFZX01TID0gMTAwMDtcbmNvbnN0IERFTEFZX01VTFRJUExJRVIgPSAyO1xuY29uc3QgWF9HT09HX1VQTE9BRF9TVEFUVVNfSEVBREVSX0ZJRUxEID0gJ3gtZ29vZy11cGxvYWQtc3RhdHVzJztcbmFzeW5jIGZ1bmN0aW9uIHVwbG9hZEJsb2IoZmlsZSwgdXBsb2FkVXJsLCBhcGlDbGllbnQpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB1cGxvYWRCbG9iSW50ZXJuYWwoZmlsZSwgdXBsb2FkVXJsLCBhcGlDbGllbnQpO1xuICAgIGNvbnN0IHJlc3BvbnNlSnNvbiA9IChhd2FpdCAocmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLmpzb24oKSkpO1xuICAgIGlmICgoKF9hID0gcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLmhlYWRlcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtYX0dPT0dfVVBMT0FEX1NUQVRVU19IRUFERVJfRklFTERdKSAhPT0gJ2ZpbmFsJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byB1cGxvYWQgZmlsZTogVXBsb2FkIHN0YXR1cyBpcyBub3QgZmluYWxpemVkLicpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2VKc29uWydmaWxlJ107XG59XG5hc3luYyBmdW5jdGlvbiB1cGxvYWRCbG9iVG9GaWxlU2VhcmNoU3RvcmUoZmlsZSwgdXBsb2FkVXJsLCBhcGlDbGllbnQpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB1cGxvYWRCbG9iSW50ZXJuYWwoZmlsZSwgdXBsb2FkVXJsLCBhcGlDbGllbnQpO1xuICAgIGNvbnN0IHJlc3BvbnNlSnNvbiA9IChhd2FpdCAocmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLmpzb24oKSkpO1xuICAgIGlmICgoKF9hID0gcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLmhlYWRlcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtYX0dPT0dfVVBMT0FEX1NUQVRVU19IRUFERVJfRklFTERdKSAhPT0gJ2ZpbmFsJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byB1cGxvYWQgZmlsZTogVXBsb2FkIHN0YXR1cyBpcyBub3QgZmluYWxpemVkLicpO1xuICAgIH1cbiAgICBjb25zdCByZXNwID0gdXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVPcGVyYXRpb25Gcm9tTWxkZXYocmVzcG9uc2VKc29uKTtcbiAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgVXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVPcGVyYXRpb24oKTtcbiAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgcmV0dXJuIHR5cGVkUmVzcDtcbn1cbmFzeW5jIGZ1bmN0aW9uIHVwbG9hZEJsb2JJbnRlcm5hbChmaWxlLCB1cGxvYWRVcmwsIGFwaUNsaWVudCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgbGV0IGZpbGVTaXplID0gMDtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBsZXQgcmVzcG9uc2UgPSBuZXcgSHR0cFJlc3BvbnNlKG5ldyBSZXNwb25zZSgpKTtcbiAgICBsZXQgdXBsb2FkQ29tbWFuZCA9ICd1cGxvYWQnO1xuICAgIGZpbGVTaXplID0gZmlsZS5zaXplO1xuICAgIHdoaWxlIChvZmZzZXQgPCBmaWxlU2l6ZSkge1xuICAgICAgICBjb25zdCBjaHVua1NpemUgPSBNYXRoLm1pbihNQVhfQ0hVTktfU0laRSwgZmlsZVNpemUgLSBvZmZzZXQpO1xuICAgICAgICBjb25zdCBjaHVuayA9IGZpbGUuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBjaHVua1NpemUpO1xuICAgICAgICBpZiAob2Zmc2V0ICsgY2h1bmtTaXplID49IGZpbGVTaXplKSB7XG4gICAgICAgICAgICB1cGxvYWRDb21tYW5kICs9ICcsIGZpbmFsaXplJztcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmV0cnlDb3VudCA9IDA7XG4gICAgICAgIGxldCBjdXJyZW50RGVsYXlNcyA9IElOSVRJQUxfUkVUUllfREVMQVlfTVM7XG4gICAgICAgIHdoaWxlIChyZXRyeUNvdW50IDwgTUFYX1JFVFJZX0NPVU5UKSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiAnJyxcbiAgICAgICAgICAgICAgICBib2R5OiBjaHVuayxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgYXBpVmVyc2lvbjogJycsXG4gICAgICAgICAgICAgICAgICAgIGJhc2VVcmw6IHVwbG9hZFVybCxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1gtR29vZy1VcGxvYWQtQ29tbWFuZCc6IHVwbG9hZENvbW1hbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnWC1Hb29nLVVwbG9hZC1PZmZzZXQnOiBTdHJpbmcob2Zmc2V0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdDb250ZW50LUxlbmd0aCc6IFN0cmluZyhjaHVua1NpemUpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICgoX2EgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuaGVhZGVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW1hfR09PR19VUExPQURfU1RBVFVTX0hFQURFUl9GSUVMRF0pIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHJ5Q291bnQrKztcbiAgICAgICAgICAgIGF3YWl0IHNsZWVwKGN1cnJlbnREZWxheU1zKTtcbiAgICAgICAgICAgIGN1cnJlbnREZWxheU1zID0gY3VycmVudERlbGF5TXMgKiBERUxBWV9NVUxUSVBMSUVSO1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldCArPSBjaHVua1NpemU7XG4gICAgICAgIC8vIFRoZSBgeC1nb29nLXVwbG9hZC1zdGF0dXNgIGhlYWRlciBmaWVsZCBjYW4gYmUgYGFjdGl2ZWAsIGBmaW5hbGAgYW5kXG4gICAgICAgIC8vYGNhbmNlbGxlZGAgaW4gcmVzcG9zbmUuXG4gICAgICAgIGlmICgoKF9iID0gcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLmhlYWRlcnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltYX0dPT0dfVVBMT0FEX1NUQVRVU19IRUFERVJfRklFTERdKSAhPT0gJ2FjdGl2ZScpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8oYi80MDEzOTE0MzApIEludmVzdGlnYXRlIHdoeSB0aGUgdXBsb2FkIHN0YXR1cyBpcyBub3QgZmluYWxpemVkXG4gICAgICAgIC8vIGV2ZW4gdGhvdWdoIGFsbCBjb250ZW50IGhhcyBiZWVuIHVwbG9hZGVkLlxuICAgICAgICBpZiAoZmlsZVNpemUgPD0gb2Zmc2V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FsbCBjb250ZW50IGhhcyBiZWVuIHVwbG9hZGVkLCBidXQgdGhlIHVwbG9hZCBzdGF0dXMgaXMgbm90IGZpbmFsaXplZC4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2U7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRCbG9iU3RhdChmaWxlKSB7XG4gICAgY29uc3QgZmlsZVN0YXQgPSB7IHNpemU6IGZpbGUuc2l6ZSwgdHlwZTogZmlsZS50eXBlIH07XG4gICAgcmV0dXJuIGZpbGVTdGF0O1xufVxuZnVuY3Rpb24gc2xlZXAobXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmVQcm9taXNlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmVQcm9taXNlLCBtcykpO1xufVxuXG5jbGFzcyBCcm93c2VyVXBsb2FkZXIge1xuICAgIGFzeW5jIHVwbG9hZChmaWxlLCB1cGxvYWRVcmwsIGFwaUNsaWVudCkge1xuICAgICAgICBpZiAodHlwZW9mIGZpbGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpbGUgcGF0aCBpcyBub3Qgc3VwcG9ydGVkIGluIGJyb3dzZXIgdXBsb2FkZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHVwbG9hZEJsb2IoZmlsZSwgdXBsb2FkVXJsLCBhcGlDbGllbnQpO1xuICAgIH1cbiAgICBhc3luYyB1cGxvYWRUb0ZpbGVTZWFyY2hTdG9yZShmaWxlLCB1cGxvYWRVcmwsIGFwaUNsaWVudCkge1xuICAgICAgICBpZiAodHlwZW9mIGZpbGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpbGUgcGF0aCBpcyBub3Qgc3VwcG9ydGVkIGluIGJyb3dzZXIgdXBsb2FkZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHVwbG9hZEJsb2JUb0ZpbGVTZWFyY2hTdG9yZShmaWxlLCB1cGxvYWRVcmwsIGFwaUNsaWVudCk7XG4gICAgfVxuICAgIGFzeW5jIHN0YXQoZmlsZSkge1xuICAgICAgICBpZiAodHlwZW9mIGZpbGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpbGUgcGF0aCBpcyBub3Qgc3VwcG9ydGVkIGluIGJyb3dzZXIgdXBsb2FkZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgZ2V0QmxvYlN0YXQoZmlsZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNsYXNzIEJyb3dzZXJXZWJTb2NrZXRGYWN0b3J5IHtcbiAgICBjcmVhdGUodXJsLCBoZWFkZXJzLCBjYWxsYmFja3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCcm93c2VyV2ViU29ja2V0KHVybCwgaGVhZGVycywgY2FsbGJhY2tzKTtcbiAgICB9XG59XG5jbGFzcyBCcm93c2VyV2ViU29ja2V0IHtcbiAgICBjb25zdHJ1Y3Rvcih1cmwsIGhlYWRlcnMsIGNhbGxiYWNrcykge1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSBjYWxsYmFja3M7XG4gICAgfVxuICAgIGNvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMud3MgPSBuZXcgV2ViU29ja2V0KHRoaXMudXJsKTtcbiAgICAgICAgdGhpcy53cy5vbm9wZW4gPSB0aGlzLmNhbGxiYWNrcy5vbm9wZW47XG4gICAgICAgIHRoaXMud3Mub25lcnJvciA9IHRoaXMuY2FsbGJhY2tzLm9uZXJyb3I7XG4gICAgICAgIHRoaXMud3Mub25jbG9zZSA9IHRoaXMuY2FsbGJhY2tzLm9uY2xvc2U7XG4gICAgICAgIHRoaXMud3Mub25tZXNzYWdlID0gdGhpcy5jYWxsYmFja3Mub25tZXNzYWdlO1xuICAgIH1cbiAgICBzZW5kKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRoaXMud3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXQgaXMgbm90IGNvbm5lY3RlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3Muc2VuZChtZXNzYWdlKTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLndzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBjb25uZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndzLmNsb3NlKCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jb25zdCBHT09HTEVfQVBJX0tFWV9IRUFERVIgPSAneC1nb29nLWFwaS1rZXknO1xuLy8gVE9ETyhiLzM5NTEyMjUzMyk6IFdlIG5lZWQgYSBzZWN1cmUgY2xpZW50IHNpZGUgYXV0aGVudGljYXRpb24gbWVjaGFuaXNtLlxuY2xhc3MgV2ViQXV0aCB7XG4gICAgY29uc3RydWN0b3IoYXBpS2V5KSB7XG4gICAgICAgIHRoaXMuYXBpS2V5ID0gYXBpS2V5O1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgYXN5bmMgYWRkQXV0aEhlYWRlcnMoaGVhZGVycywgdXJsKSB7XG4gICAgICAgIGlmIChoZWFkZXJzLmdldChHT09HTEVfQVBJX0tFWV9IRUFERVIpICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXBpS2V5LnN0YXJ0c1dpdGgoJ2F1dGhfdG9rZW5zLycpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VwaGVtZXJhbCB0b2tlbnMgYXJlIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBsaXZlIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBpZiBBUEkga2V5IGlzIGVtcHR5IG9yIG51bGxcbiAgICAgICAgaWYgKCF0aGlzLmFwaUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBUEkga2V5IGlzIG1pc3NpbmcuIFBsZWFzZSBwcm92aWRlIGEgdmFsaWQgQVBJIGtleS4nKTtcbiAgICAgICAgfVxuICAgICAgICBoZWFkZXJzLmFwcGVuZChHT09HTEVfQVBJX0tFWV9IRUFERVIsIHRoaXMuYXBpS2V5KTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNvbnN0IExBTkdVQUdFX0xBQkVMX1BSRUZJWCA9ICdnbC1ub2RlLyc7XG4vKipcbiAqIFRoZSBHb29nbGUgR2VuQUkgU0RLLlxuICpcbiAqIEByZW1hcmtzXG4gKiBQcm92aWRlcyBhY2Nlc3MgdG8gdGhlIEdlbkFJIGZlYXR1cmVzIHRocm91Z2ggZWl0aGVyIHRoZSB7QGxpbmtcbiAqIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS92ZXJ0ZXgtYWkvZG9jcy9yZWZlcmVuY2UvcmVzdCB8IEdlbWluaSBBUEl9IG9yXG4gKiB0aGUge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS92ZXJ0ZXgtYWkvZG9jcy9yZWZlcmVuY2UvcmVzdCB8IFZlcnRleCBBSVxuICogQVBJfS5cbiAqXG4gKiBUaGUge0BsaW5rIEdvb2dsZUdlbkFJT3B0aW9ucy52ZXJ0ZXhhaX0gdmFsdWUgZGV0ZXJtaW5lcyB3aGljaCBvZiB0aGUgQVBJXG4gKiBzZXJ2aWNlcyB0byB1c2UuXG4gKlxuICogV2hlbiB1c2luZyB0aGUgR2VtaW5pIEFQSSwgYSB7QGxpbmsgR29vZ2xlR2VuQUlPcHRpb25zLmFwaUtleX0gbXVzdCBhbHNvIGJlXG4gKiBzZXQuIFdoZW4gdXNpbmcgVmVydGV4IEFJLCBjdXJyZW50bHkgb25seSB7QGxpbmsgR29vZ2xlR2VuQUlPcHRpb25zLmFwaUtleX1cbiAqIGlzIHN1cHBvcnRlZCB2aWEgRXhwcmVzcyBtb2RlLiB7QGxpbmsgR29vZ2xlR2VuQUlPcHRpb25zLnByb2plY3R9IGFuZCB7QGxpbmtcbiAqIEdvb2dsZUdlbkFJT3B0aW9ucy5sb2NhdGlvbn0gc2hvdWxkIG5vdCBiZSBzZXQuXG4gKlxuICogQGV4YW1wbGVcbiAqIEluaXRpYWxpemluZyB0aGUgU0RLIGZvciB1c2luZyB0aGUgR2VtaW5pIEFQSTpcbiAqIGBgYHRzXG4gKiBpbXBvcnQge0dvb2dsZUdlbkFJfSBmcm9tICdAZ29vZ2xlL2dlbmFpJztcbiAqIGNvbnN0IGFpID0gbmV3IEdvb2dsZUdlbkFJKHthcGlLZXk6ICdHRU1JTklfQVBJX0tFWSd9KTtcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBJbml0aWFsaXppbmcgdGhlIFNESyBmb3IgdXNpbmcgdGhlIFZlcnRleCBBSSBBUEk6XG4gKiBgYGB0c1xuICogaW1wb3J0IHtHb29nbGVHZW5BSX0gZnJvbSAnQGdvb2dsZS9nZW5haSc7XG4gKiBjb25zdCBhaSA9IG5ldyBHb29nbGVHZW5BSSh7XG4gKiAgIHZlcnRleGFpOiB0cnVlLFxuICogICBwcm9qZWN0OiAnUFJPSkVDVF9JRCcsXG4gKiAgIGxvY2F0aW9uOiAnUFJPSkVDVF9MT0NBVElPTidcbiAqIH0pO1xuICogYGBgXG4gKlxuICovXG5jbGFzcyBHb29nbGVHZW5BSSB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChvcHRpb25zLmFwaUtleSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuIEFQSSBLZXkgbXVzdCBiZSBzZXQgd2hlbiBydW5uaW5nIGluIGEgYnJvd3NlcicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlYiBjbGllbnQgb25seSBzdXBwb3J0cyBBUEkga2V5IG1vZGUgZm9yIFZlcnRleCBBSS5cbiAgICAgICAgaWYgKG9wdGlvbnMucHJvamVjdCB8fCBvcHRpb25zLmxvY2F0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZlcnRleCBBSSBwcm9qZWN0IGJhc2VkIGF1dGhlbnRpY2F0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgb24gYnJvd3NlciBydW50aW1lcy4gUGxlYXNlIGRvIG5vdCBwcm92aWRlIGEgcHJvamVjdCBvciBsb2NhdGlvbi4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZlcnRleGFpID0gKF9hID0gb3B0aW9ucy52ZXJ0ZXhhaSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2U7XG4gICAgICAgIHRoaXMuYXBpS2V5ID0gb3B0aW9ucy5hcGlLZXk7XG4gICAgICAgIGNvbnN0IGJhc2VVcmwgPSBnZXRCYXNlVXJsKG9wdGlvbnMuaHR0cE9wdGlvbnMsIG9wdGlvbnMudmVydGV4YWksIFxuICAgICAgICAvKnZlcnRleEJhc2VVcmxGcm9tRW52Ki8gdW5kZWZpbmVkLCBcbiAgICAgICAgLypnZW1pbmlCYXNlVXJsRnJvbUVudiovIHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChiYXNlVXJsKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5odHRwT3B0aW9ucykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuaHR0cE9wdGlvbnMuYmFzZVVybCA9IGJhc2VVcmw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmh0dHBPcHRpb25zID0geyBiYXNlVXJsOiBiYXNlVXJsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcGlWZXJzaW9uID0gb3B0aW9ucy5hcGlWZXJzaW9uO1xuICAgICAgICB0aGlzLmh0dHBPcHRpb25zID0gb3B0aW9ucy5odHRwT3B0aW9ucztcbiAgICAgICAgY29uc3QgYXV0aCA9IG5ldyBXZWJBdXRoKHRoaXMuYXBpS2V5KTtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBuZXcgQXBpQ2xpZW50KHtcbiAgICAgICAgICAgIGF1dGg6IGF1dGgsXG4gICAgICAgICAgICBhcGlWZXJzaW9uOiB0aGlzLmFwaVZlcnNpb24sXG4gICAgICAgICAgICBhcGlLZXk6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgdmVydGV4YWk6IHRoaXMudmVydGV4YWksXG4gICAgICAgICAgICBodHRwT3B0aW9uczogdGhpcy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgIHVzZXJBZ2VudEV4dHJhOiBMQU5HVUFHRV9MQUJFTF9QUkVGSVggKyAnd2ViJyxcbiAgICAgICAgICAgIHVwbG9hZGVyOiBuZXcgQnJvd3NlclVwbG9hZGVyKCksXG4gICAgICAgICAgICBkb3dubG9hZGVyOiBuZXcgQnJvd3NlckRvd25sb2FkZXIoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubW9kZWxzID0gbmV3IE1vZGVscyh0aGlzLmFwaUNsaWVudCk7XG4gICAgICAgIHRoaXMubGl2ZSA9IG5ldyBMaXZlKHRoaXMuYXBpQ2xpZW50LCBhdXRoLCBuZXcgQnJvd3NlcldlYlNvY2tldEZhY3RvcnkoKSk7XG4gICAgICAgIHRoaXMuYmF0Y2hlcyA9IG5ldyBCYXRjaGVzKHRoaXMuYXBpQ2xpZW50KTtcbiAgICAgICAgdGhpcy5jaGF0cyA9IG5ldyBDaGF0cyh0aGlzLm1vZGVscywgdGhpcy5hcGlDbGllbnQpO1xuICAgICAgICB0aGlzLmNhY2hlcyA9IG5ldyBDYWNoZXModGhpcy5hcGlDbGllbnQpO1xuICAgICAgICB0aGlzLmZpbGVzID0gbmV3IEZpbGVzKHRoaXMuYXBpQ2xpZW50KTtcbiAgICAgICAgdGhpcy5vcGVyYXRpb25zID0gbmV3IE9wZXJhdGlvbnModGhpcy5hcGlDbGllbnQpO1xuICAgICAgICB0aGlzLmF1dGhUb2tlbnMgPSBuZXcgVG9rZW5zKHRoaXMuYXBpQ2xpZW50KTtcbiAgICAgICAgdGhpcy50dW5pbmdzID0gbmV3IFR1bmluZ3ModGhpcy5hcGlDbGllbnQpO1xuICAgICAgICB0aGlzLmZpbGVTZWFyY2hTdG9yZXMgPSBuZXcgRmlsZVNlYXJjaFN0b3Jlcyh0aGlzLmFwaUNsaWVudCk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBBY3Rpdml0eUhhbmRsaW5nLCBBZGFwdGVyU2l6ZSwgQXBpRXJyb3IsIEFwaVNwZWMsIEF1dGhUeXBlLCBCYXRjaGVzLCBCZWhhdmlvciwgQmxvY2tlZFJlYXNvbiwgQ2FjaGVzLCBDYW5jZWxUdW5pbmdKb2JSZXNwb25zZSwgQ2hhdCwgQ2hhdHMsIENvbXB1dGVUb2tlbnNSZXNwb25zZSwgQ29udGVudFJlZmVyZW5jZUltYWdlLCBDb250cm9sUmVmZXJlbmNlSW1hZ2UsIENvbnRyb2xSZWZlcmVuY2VUeXBlLCBDb3VudFRva2Vuc1Jlc3BvbnNlLCBDcmVhdGVGaWxlUmVzcG9uc2UsIERlbGV0ZUNhY2hlZENvbnRlbnRSZXNwb25zZSwgRGVsZXRlRmlsZVJlc3BvbnNlLCBEZWxldGVNb2RlbFJlc3BvbnNlLCBEb2N1bWVudFN0YXRlLCBEeW5hbWljUmV0cmlldmFsQ29uZmlnTW9kZSwgRWRpdEltYWdlUmVzcG9uc2UsIEVkaXRNb2RlLCBFbWJlZENvbnRlbnRSZXNwb25zZSwgRW5kU2Vuc2l0aXZpdHksIEVudmlyb25tZW50LCBGZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZSwgRmlsZVNvdXJjZSwgRmlsZVN0YXRlLCBGaWxlcywgRmluaXNoUmVhc29uLCBGdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlLCBGdW5jdGlvblJlc3BvbnNlLCBGdW5jdGlvblJlc3BvbnNlQmxvYiwgRnVuY3Rpb25SZXNwb25zZUZpbGVEYXRhLCBGdW5jdGlvblJlc3BvbnNlUGFydCwgRnVuY3Rpb25SZXNwb25zZVNjaGVkdWxpbmcsIEdlbmVyYXRlQ29udGVudFJlc3BvbnNlLCBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZVByb21wdEZlZWRiYWNrLCBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZVVzYWdlTWV0YWRhdGEsIEdlbmVyYXRlSW1hZ2VzUmVzcG9uc2UsIEdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uLCBHZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlLCBHb29nbGVHZW5BSSwgSGFybUJsb2NrTWV0aG9kLCBIYXJtQmxvY2tUaHJlc2hvbGQsIEhhcm1DYXRlZ29yeSwgSGFybVByb2JhYmlsaXR5LCBIYXJtU2V2ZXJpdHksIEh0dHBFbGVtZW50TG9jYXRpb24sIEh0dHBSZXNwb25zZSwgSW1hZ2VQcm9tcHRMYW5ndWFnZSwgSW1wb3J0RmlsZU9wZXJhdGlvbiwgSW1wb3J0RmlsZVJlc3BvbnNlLCBJbmxpbmVkRW1iZWRDb250ZW50UmVzcG9uc2UsIElubGluZWRSZXNwb25zZSwgSm9iU3RhdGUsIExhbmd1YWdlLCBMaXN0QmF0Y2hKb2JzUmVzcG9uc2UsIExpc3RDYWNoZWRDb250ZW50c1Jlc3BvbnNlLCBMaXN0RG9jdW1lbnRzUmVzcG9uc2UsIExpc3RGaWxlU2VhcmNoU3RvcmVzUmVzcG9uc2UsIExpc3RGaWxlc1Jlc3BvbnNlLCBMaXN0TW9kZWxzUmVzcG9uc2UsIExpc3RUdW5pbmdKb2JzUmVzcG9uc2UsIExpdmUsIExpdmVDbGllbnRUb29sUmVzcG9uc2UsIExpdmVNdXNpY1BsYXliYWNrQ29udHJvbCwgTGl2ZU11c2ljU2VydmVyTWVzc2FnZSwgTGl2ZVNlbmRUb29sUmVzcG9uc2VQYXJhbWV0ZXJzLCBMaXZlU2VydmVyTWVzc2FnZSwgTWFza1JlZmVyZW5jZUltYWdlLCBNYXNrUmVmZXJlbmNlTW9kZSwgTWVkaWFNb2RhbGl0eSwgTWVkaWFSZXNvbHV0aW9uLCBNb2RhbGl0eSwgTW9kZSwgTW9kZWxzLCBNdXNpY0dlbmVyYXRpb25Nb2RlLCBPcGVyYXRpb25zLCBPdXRjb21lLCBQYWdlZEl0ZW0sIFBhZ2VyLCBQYXJ0TWVkaWFSZXNvbHV0aW9uTGV2ZWwsIFBlcnNvbkdlbmVyYXRpb24sIFBoaXNoQmxvY2tUaHJlc2hvbGQsIFJhd1JlZmVyZW5jZUltYWdlLCBSZWNvbnRleHRJbWFnZVJlc3BvbnNlLCBSZXBsYXlSZXNwb25zZSwgU2FmZXR5RmlsdGVyTGV2ZWwsIFNjYWxlLCBTZWdtZW50SW1hZ2VSZXNwb25zZSwgU2VnbWVudE1vZGUsIFNlc3Npb24sIFNpbmdsZUVtYmVkQ29udGVudFJlc3BvbnNlLCBTdGFydFNlbnNpdGl2aXR5LCBTdHlsZVJlZmVyZW5jZUltYWdlLCBTdWJqZWN0UmVmZXJlbmNlSW1hZ2UsIFN1YmplY3RSZWZlcmVuY2VUeXBlLCBUaGlua2luZ0xldmVsLCBUb2tlbnMsIFRyYWZmaWNUeXBlLCBUdW5pbmdNZXRob2QsIFR1bmluZ01vZGUsIFR1bmluZ1Rhc2ssIFR1cm5Db21wbGV0ZVJlYXNvbiwgVHVybkNvdmVyYWdlLCBUeXBlLCBVcGxvYWRUb0ZpbGVTZWFyY2hTdG9yZU9wZXJhdGlvbiwgVXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVSZXNwb25zZSwgVXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVSZXN1bWFibGVSZXNwb25zZSwgVXBzY2FsZUltYWdlUmVzcG9uc2UsIFVybFJldHJpZXZhbFN0YXR1cywgVmlkZW9Db21wcmVzc2lvblF1YWxpdHksIFZpZGVvR2VuZXJhdGlvbk1hc2tNb2RlLCBWaWRlb0dlbmVyYXRpb25SZWZlcmVuY2VUeXBlLCBjcmVhdGVGdW5jdGlvblJlc3BvbnNlUGFydEZyb21CYXNlNjQsIGNyZWF0ZUZ1bmN0aW9uUmVzcG9uc2VQYXJ0RnJvbVVyaSwgY3JlYXRlTW9kZWxDb250ZW50LCBjcmVhdGVQYXJ0RnJvbUJhc2U2NCwgY3JlYXRlUGFydEZyb21Db2RlRXhlY3V0aW9uUmVzdWx0LCBjcmVhdGVQYXJ0RnJvbUV4ZWN1dGFibGVDb2RlLCBjcmVhdGVQYXJ0RnJvbUZ1bmN0aW9uQ2FsbCwgY3JlYXRlUGFydEZyb21GdW5jdGlvblJlc3BvbnNlLCBjcmVhdGVQYXJ0RnJvbVRleHQsIGNyZWF0ZVBhcnRGcm9tVXJpLCBjcmVhdGVVc2VyQ29udGVudCwgbWNwVG9Ub29sLCBzZXREZWZhdWx0QmFzZVVybHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6WyJfZGVmYXVsdEJhc2VHZW1pbmlVcmwiLCJ1bmRlZmluZWQiLCJfZGVmYXVsdEJhc2VWZXJ0ZXhVcmwiLCJzZXREZWZhdWx0QmFzZVVybHMiLCJiYXNlVXJsUGFyYW1zIiwiZ2VtaW5pVXJsIiwidmVydGV4VXJsIiwiZ2V0RGVmYXVsdEJhc2VVcmxzIiwiZ2V0QmFzZVVybCIsImh0dHBPcHRpb25zIiwidmVydGV4YWkiLCJ2ZXJ0ZXhCYXNlVXJsRnJvbUVudiIsImdlbWluaUJhc2VVcmxGcm9tRW52IiwiX2EiLCJfYiIsImJhc2VVcmwiLCJkZWZhdWx0QmFzZVVybHMiLCJCYXNlTW9kdWxlIiwiZm9ybWF0TWFwIiwidGVtcGxhdGVTdHJpbmciLCJ2YWx1ZU1hcCIsInJlZ2V4IiwicmVwbGFjZSIsIm1hdGNoIiwia2V5IiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwidmFsdWUiLCJTdHJpbmciLCJFcnJvciIsInNldFZhbHVlQnlQYXRoIiwiZGF0YSIsImtleXMiLCJpIiwibGVuZ3RoIiwiZW5kc1dpdGgiLCJrZXlOYW1lIiwic2xpY2UiLCJBcnJheSIsImlzQXJyYXkiLCJmcm9tIiwiYXJyYXlEYXRhIiwiaiIsImVudHJ5IiwiZCIsImtleVRvU2V0IiwiZXhpc3RpbmdEYXRhIiwiYXNzaWduIiwidmFsdWVBc1JlY29yZCIsImdldFZhbHVlQnlQYXRoIiwiZGVmYXVsdFZhbHVlIiwibWFwIiwiZXJyb3IiLCJUeXBlRXJyb3IiLCJtb3ZlVmFsdWVCeVBhdGgiLCJwYXRocyIsInNvdXJjZVBhdGgiLCJkZXN0UGF0aCIsImVudHJpZXMiLCJzb3VyY2VLZXlzIiwic3BsaXQiLCJkZXN0S2V5cyIsImV4Y2x1ZGVLZXlzIiwiU2V0Iiwid2lsZGNhcmRJZHgiLCJhZGQiLCJfbW92ZVZhbHVlUmVjdXJzaXZlIiwia2V5SWR4IiwiZGF0YVJlY29yZCIsIml0ZW0iLCJrZXlzVG9Nb3ZlIiwiZmlsdGVyIiwiayIsInN0YXJ0c1dpdGgiLCJoYXMiLCJ2YWx1ZXNUb01vdmUiLCJ2IiwibmV3RGVzdEtleXMiLCJkayIsInB1c2giLCJ0Qnl0ZXMkMSIsImZyb21CeXRlcyIsImZldGNoUHJlZGljdE9wZXJhdGlvblBhcmFtZXRlcnNUb1ZlcnRleCIsImZyb21PYmplY3QiLCJ0b09iamVjdCIsImZyb21PcGVyYXRpb25OYW1lIiwiZnJvbVJlc291cmNlTmFtZSIsImdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uRnJvbU1sZGV2JDEiLCJmcm9tTmFtZSIsImZyb21NZXRhZGF0YSIsImZyb21Eb25lIiwiZnJvbUVycm9yIiwiZnJvbVJlc3BvbnNlIiwiZ2VuZXJhdGVWaWRlb3NSZXNwb25zZUZyb21NbGRldiQxIiwiZ2VuZXJhdGVWaWRlb3NPcGVyYXRpb25Gcm9tVmVydGV4JDEiLCJnZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlRnJvbVZlcnRleCQxIiwiZnJvbUdlbmVyYXRlZFZpZGVvcyIsInRyYW5zZm9ybWVkTGlzdCIsImdlbmVyYXRlZFZpZGVvRnJvbU1sZGV2JDEiLCJmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50IiwiZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zIiwiZ2VuZXJhdGVkVmlkZW9Gcm9tVmVydGV4JDEiLCJmcm9tVmlkZW8iLCJ2aWRlb0Zyb21NbGRldiQxIiwidmlkZW9Gcm9tVmVydGV4JDEiLCJnZXRPcGVyYXRpb25QYXJhbWV0ZXJzVG9NbGRldiIsImdldE9wZXJhdGlvblBhcmFtZXRlcnNUb1ZlcnRleCIsImltcG9ydEZpbGVPcGVyYXRpb25Gcm9tTWxkZXYkMSIsImltcG9ydEZpbGVSZXNwb25zZUZyb21NbGRldiQxIiwiZnJvbVNka0h0dHBSZXNwb25zZSIsImZyb21QYXJlbnQiLCJmcm9tRG9jdW1lbnROYW1lIiwidXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVPcGVyYXRpb25Gcm9tTWxkZXYiLCJ1cGxvYWRUb0ZpbGVTZWFyY2hTdG9yZVJlc3BvbnNlRnJvbU1sZGV2IiwiZnJvbVVyaSIsImZyb21WaWRlb0J5dGVzIiwiZnJvbU1pbWVUeXBlIiwiT3V0Y29tZSIsIkxhbmd1YWdlIiwiRnVuY3Rpb25SZXNwb25zZVNjaGVkdWxpbmciLCJUeXBlIiwiTW9kZSIsIkFwaVNwZWMiLCJBdXRoVHlwZSIsIkh0dHBFbGVtZW50TG9jYXRpb24iLCJQaGlzaEJsb2NrVGhyZXNob2xkIiwiVGhpbmtpbmdMZXZlbCIsIkhhcm1DYXRlZ29yeSIsIkhhcm1CbG9ja01ldGhvZCIsIkhhcm1CbG9ja1RocmVzaG9sZCIsIkZpbmlzaFJlYXNvbiIsIkhhcm1Qcm9iYWJpbGl0eSIsIkhhcm1TZXZlcml0eSIsIlVybFJldHJpZXZhbFN0YXR1cyIsIkJsb2NrZWRSZWFzb24iLCJUcmFmZmljVHlwZSIsIk1vZGFsaXR5IiwiTWVkaWFSZXNvbHV0aW9uIiwiVHVuaW5nTW9kZSIsIkFkYXB0ZXJTaXplIiwiSm9iU3RhdGUiLCJUdW5pbmdUYXNrIiwiUGFydE1lZGlhUmVzb2x1dGlvbkxldmVsIiwiRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2UiLCJCZWhhdmlvciIsIkR5bmFtaWNSZXRyaWV2YWxDb25maWdNb2RlIiwiRW52aXJvbm1lbnQiLCJGdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlIiwiU2FmZXR5RmlsdGVyTGV2ZWwiLCJQZXJzb25HZW5lcmF0aW9uIiwiSW1hZ2VQcm9tcHRMYW5ndWFnZSIsIk1hc2tSZWZlcmVuY2VNb2RlIiwiQ29udHJvbFJlZmVyZW5jZVR5cGUiLCJTdWJqZWN0UmVmZXJlbmNlVHlwZSIsIkVkaXRNb2RlIiwiU2VnbWVudE1vZGUiLCJWaWRlb0dlbmVyYXRpb25SZWZlcmVuY2VUeXBlIiwiVmlkZW9HZW5lcmF0aW9uTWFza01vZGUiLCJWaWRlb0NvbXByZXNzaW9uUXVhbGl0eSIsIlR1bmluZ01ldGhvZCIsIkRvY3VtZW50U3RhdGUiLCJGaWxlU3RhdGUiLCJGaWxlU291cmNlIiwiVHVybkNvbXBsZXRlUmVhc29uIiwiTWVkaWFNb2RhbGl0eSIsIlN0YXJ0U2Vuc2l0aXZpdHkiLCJFbmRTZW5zaXRpdml0eSIsIkFjdGl2aXR5SGFuZGxpbmciLCJUdXJuQ292ZXJhZ2UiLCJTY2FsZSIsIk11c2ljR2VuZXJhdGlvbk1vZGUiLCJMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2wiLCJGdW5jdGlvblJlc3BvbnNlQmxvYiIsIkZ1bmN0aW9uUmVzcG9uc2VGaWxlRGF0YSIsIkZ1bmN0aW9uUmVzcG9uc2VQYXJ0IiwiY3JlYXRlRnVuY3Rpb25SZXNwb25zZVBhcnRGcm9tQmFzZTY0IiwibWltZVR5cGUiLCJpbmxpbmVEYXRhIiwiY3JlYXRlRnVuY3Rpb25SZXNwb25zZVBhcnRGcm9tVXJpIiwidXJpIiwiZmlsZURhdGEiLCJmaWxlVXJpIiwiRnVuY3Rpb25SZXNwb25zZSIsImNyZWF0ZVBhcnRGcm9tVXJpIiwibWVkaWFSZXNvbHV0aW9uIiwibGV2ZWwiLCJjcmVhdGVQYXJ0RnJvbVRleHQiLCJ0ZXh0IiwiY3JlYXRlUGFydEZyb21GdW5jdGlvbkNhbGwiLCJuYW1lIiwiYXJncyIsImZ1bmN0aW9uQ2FsbCIsImNyZWF0ZVBhcnRGcm9tRnVuY3Rpb25SZXNwb25zZSIsImlkIiwicmVzcG9uc2UiLCJwYXJ0cyIsImZ1bmN0aW9uUmVzcG9uc2UiLCJjcmVhdGVQYXJ0RnJvbUJhc2U2NCIsImNyZWF0ZVBhcnRGcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCIsIm91dGNvbWUiLCJvdXRwdXQiLCJjb2RlRXhlY3V0aW9uUmVzdWx0IiwiY3JlYXRlUGFydEZyb21FeGVjdXRhYmxlQ29kZSIsImNvZGUiLCJsYW5ndWFnZSIsImV4ZWN1dGFibGVDb2RlIiwiX2lzUGFydCIsIm9iaiIsIl90b1BhcnRzIiwicGFydE9yU3RyaW5nIiwicGFydCIsImNyZWF0ZVVzZXJDb250ZW50Iiwicm9sZSIsImNyZWF0ZU1vZGVsQ29udGVudCIsIkh0dHBSZXNwb25zZSIsImpzb24iLCJyZXNwb25zZUludGVybmFsIiwiY29uc3RydWN0b3IiLCJoZWFkZXJzIiwicGFpciIsIkdlbmVyYXRlQ29udGVudFJlc3BvbnNlUHJvbXB0RmVlZGJhY2siLCJHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZVVzYWdlTWV0YWRhdGEiLCJHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZSIsIl9jIiwiX2QiLCJfZSIsIl9mIiwiX2ciLCJfaCIsImNhbmRpZGF0ZXMiLCJjb250ZW50IiwiY29uc29sZSIsIndhcm4iLCJhbnlUZXh0UGFydFRleHQiLCJub25UZXh0UGFydHMiLCJmaWVsZE5hbWUiLCJmaWVsZFZhbHVlIiwidGhvdWdodCIsIm5vbkRhdGFQYXJ0cyIsImF0b2IiLCJidG9hIiwiZnVuY3Rpb25DYWxscyIsIl9qIiwiRW1iZWRDb250ZW50UmVzcG9uc2UiLCJHZW5lcmF0ZUltYWdlc1Jlc3BvbnNlIiwiRWRpdEltYWdlUmVzcG9uc2UiLCJVcHNjYWxlSW1hZ2VSZXNwb25zZSIsIlJlY29udGV4dEltYWdlUmVzcG9uc2UiLCJTZWdtZW50SW1hZ2VSZXNwb25zZSIsIkxpc3RNb2RlbHNSZXNwb25zZSIsIkRlbGV0ZU1vZGVsUmVzcG9uc2UiLCJDb3VudFRva2Vuc1Jlc3BvbnNlIiwiQ29tcHV0ZVRva2Vuc1Jlc3BvbnNlIiwiR2VuZXJhdGVWaWRlb3NSZXNwb25zZSIsIkdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uIiwiX2Zyb21BUElSZXNwb25zZSIsImFwaVJlc3BvbnNlIiwiX2lzVmVydGV4QUkiLCJvcGVyYXRpb24iLCJvcCIsIkxpc3RUdW5pbmdKb2JzUmVzcG9uc2UiLCJDYW5jZWxUdW5pbmdKb2JSZXNwb25zZSIsIkRlbGV0ZUNhY2hlZENvbnRlbnRSZXNwb25zZSIsIkxpc3RDYWNoZWRDb250ZW50c1Jlc3BvbnNlIiwiTGlzdERvY3VtZW50c1Jlc3BvbnNlIiwiTGlzdEZpbGVTZWFyY2hTdG9yZXNSZXNwb25zZSIsIlVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlUmVzdW1hYmxlUmVzcG9uc2UiLCJJbXBvcnRGaWxlUmVzcG9uc2UiLCJJbXBvcnRGaWxlT3BlcmF0aW9uIiwiTGlzdEZpbGVzUmVzcG9uc2UiLCJDcmVhdGVGaWxlUmVzcG9uc2UiLCJEZWxldGVGaWxlUmVzcG9uc2UiLCJJbmxpbmVkUmVzcG9uc2UiLCJTaW5nbGVFbWJlZENvbnRlbnRSZXNwb25zZSIsIklubGluZWRFbWJlZENvbnRlbnRSZXNwb25zZSIsIkxpc3RCYXRjaEpvYnNSZXNwb25zZSIsIlJlcGxheVJlc3BvbnNlIiwiUmF3UmVmZXJlbmNlSW1hZ2UiLCJ0b1JlZmVyZW5jZUltYWdlQVBJIiwicmVmZXJlbmNlSW1hZ2VBUEkiLCJyZWZlcmVuY2VUeXBlIiwicmVmZXJlbmNlSW1hZ2UiLCJyZWZlcmVuY2VJZCIsIk1hc2tSZWZlcmVuY2VJbWFnZSIsIm1hc2tJbWFnZUNvbmZpZyIsImNvbmZpZyIsIkNvbnRyb2xSZWZlcmVuY2VJbWFnZSIsImNvbnRyb2xJbWFnZUNvbmZpZyIsIlN0eWxlUmVmZXJlbmNlSW1hZ2UiLCJzdHlsZUltYWdlQ29uZmlnIiwiU3ViamVjdFJlZmVyZW5jZUltYWdlIiwic3ViamVjdEltYWdlQ29uZmlnIiwiQ29udGVudFJlZmVyZW5jZUltYWdlIiwiTGl2ZVNlcnZlck1lc3NhZ2UiLCJhbnlUZXh0UGFydEZvdW5kIiwic2VydmVyQ29udGVudCIsIm1vZGVsVHVybiIsIkxpdmVDbGllbnRUb29sUmVzcG9uc2UiLCJMaXZlU2VuZFRvb2xSZXNwb25zZVBhcmFtZXRlcnMiLCJmdW5jdGlvblJlc3BvbnNlcyIsIkxpdmVNdXNpY1NlcnZlck1lc3NhZ2UiLCJhdWRpb0NodW5rIiwiYXVkaW9DaHVua3MiLCJVcGxvYWRUb0ZpbGVTZWFyY2hTdG9yZVJlc3BvbnNlIiwiVXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVPcGVyYXRpb24iLCJ0TW9kZWwiLCJhcGlDbGllbnQiLCJtb2RlbCIsImluY2x1ZGVzIiwiaXNWZXJ0ZXhBSSIsImluZGV4T2YiLCJ0Q2FjaGVzTW9kZWwiLCJ0cmFuc2Zvcm1lZE1vZGVsIiwiZ2V0UHJvamVjdCIsImdldExvY2F0aW9uIiwidEJsb2JzIiwiYmxvYnMiLCJibG9iIiwidEJsb2IiLCJ0SW1hZ2VCbG9iIiwidHJhbnNmb3JtZWRCbG9iIiwidEF1ZGlvQmxvYiIsInRQYXJ0Iiwib3JpZ2luIiwidFBhcnRzIiwiX2lzQ29udGVudCIsIl9pc0Z1bmN0aW9uQ2FsbFBhcnQiLCJfaXNGdW5jdGlvblJlc3BvbnNlUGFydCIsInRDb250ZW50IiwidENvbnRlbnRzRm9yRW1iZWQiLCJmbGF0TWFwIiwidENvbnRlbnRzIiwicmVzdWx0IiwiYWNjdW11bGF0ZWRQYXJ0cyIsImlzQ29udGVudEFycmF5IiwiaXNDb250ZW50IiwiZmxhdHRlblR5cGVBcnJheVRvQW55T2YiLCJ0eXBlTGlzdCIsInJlc3VsdGluZ1NjaGVtYSIsImxpc3RXaXRob3V0TnVsbCIsInR5cGUiLCJ2YWx1ZXMiLCJ0b1VwcGVyQ2FzZSIsIlRZUEVfVU5TUEVDSUZJRUQiLCJwcm9jZXNzSnNvblNjaGVtYSIsIl9qc29uU2NoZW1hIiwiZ2VuQUlTY2hlbWEiLCJzY2hlbWFGaWVsZE5hbWVzIiwibGlzdFNjaGVtYUZpZWxkTmFtZXMiLCJkaWN0U2NoZW1hRmllbGROYW1lcyIsImluY29taW5nQW55T2YiLCJsaXN0U2NoZW1hRmllbGRWYWx1ZSIsImRpY3RTY2hlbWFGaWVsZFZhbHVlIiwidFNjaGVtYSIsInNjaGVtYSIsInRTcGVlY2hDb25maWciLCJzcGVlY2hDb25maWciLCJ2b2ljZUNvbmZpZyIsInByZWJ1aWx0Vm9pY2VDb25maWciLCJ2b2ljZU5hbWUiLCJ0TGl2ZVNwZWVjaENvbmZpZyIsInRUb29sIiwidG9vbCIsImZ1bmN0aW9uRGVjbGFyYXRpb25zIiwiZnVuY3Rpb25EZWNsYXJhdGlvbiIsInBhcmFtZXRlcnMiLCJwYXJhbWV0ZXJzSnNvblNjaGVtYSIsInJlc3BvbnNlSnNvblNjaGVtYSIsInRUb29scyIsInRvb2xzIiwicmVzb3VyY2VOYW1lIiwiY2xpZW50IiwicmVzb3VyY2VQcmVmaXgiLCJzcGxpdHNBZnRlclByZWZpeCIsInNob3VsZEFwcGVuZFByZWZpeCIsInRDYWNoZWRDb250ZW50TmFtZSIsInRUdW5pbmdKb2JTdGF0dXMiLCJzdGF0dXMiLCJ0Qnl0ZXMiLCJmcm9tSW1hZ2VCeXRlcyIsIl9pc0ZpbGUiLCJpc0dlbmVyYXRlZFZpZGVvIiwiaXNWaWRlbyIsInRGaWxlTmFtZSIsInZpZGVvIiwic3VmZml4IiwidE1vZGVsc1VybCIsImJhc2VNb2RlbHMiLCJyZXMiLCJ0RXh0cmFjdE1vZGVscyIsImhhc0ZpZWxkIiwibWNwVG9HZW1pbmlUb29sIiwibWNwVG9vbCIsIm1jcFRvb2xTY2hlbWEiLCJkZXNjcmlwdGlvbiIsImJlaGF2aW9yIiwiZ2VtaW5pVG9vbCIsIm1jcFRvb2xzVG9HZW1pbmlUb29sIiwibWNwVG9vbHMiLCJ0b29sTmFtZXMiLCJtY3BUb29sTmFtZSIsInRCYXRjaEpvYlNvdXJjZSIsInNyYyIsInNvdXJjZU9iaiIsImZvcm1hdCIsImdjc1VyaSIsImJpZ3F1ZXJ5VXJpIiwiZmlsZU5hbWUiLCJpbmxpbmVkUmVxdWVzdHMiLCJ2ZXJ0ZXhTb3VyY2VzQ291bnQiLCJCb29sZWFuIiwibWxkZXZTb3VyY2VzQ291bnQiLCJ0QmF0Y2hKb2JEZXN0aW5hdGlvbiIsImRlc3QiLCJkZXN0U3RyaW5nIiwidFJlY3ZCYXRjaEpvYkRlc3RpbmF0aW9uIiwiaW5saW5lUmVzcG9uc2VzVmFsIiwiaW5saW5lUmVzcG9uc2VzT2JqIiwicmVzcG9uc2VzQXJyYXkiLCJoYXNFbWJlZGRpbmciLCJyZXNwb25zZUl0ZW0iLCJyZXNwb25zZUl0ZW1PYmoiLCJyZXNwb25zZVZhbCIsInJlc3BvbnNlT2JqIiwidEJhdGNoSm9iTmFtZSIsIm5hbWVTdHJpbmciLCJtbGRldlBhdHRlcm4iLCJ0ZXN0IiwicG9wIiwidmVydGV4UGF0dGVybiIsInRKb2JTdGF0ZSIsInN0YXRlIiwic3RhdGVTdHJpbmciLCJiYXRjaEpvYkRlc3RpbmF0aW9uRnJvbU1sZGV2IiwiZnJvbUZpbGVOYW1lIiwiZnJvbUlubGluZWRSZXNwb25zZXMiLCJpbmxpbmVkUmVzcG9uc2VGcm9tTWxkZXYiLCJmcm9tSW5saW5lZEVtYmVkQ29udGVudFJlc3BvbnNlcyIsImJhdGNoSm9iRGVzdGluYXRpb25Gcm9tVmVydGV4IiwiZnJvbUZvcm1hdCIsImZyb21HY3NVcmkiLCJmcm9tQmlncXVlcnlVcmkiLCJiYXRjaEpvYkRlc3RpbmF0aW9uVG9WZXJ0ZXgiLCJiYXRjaEpvYkZyb21NbGRldiIsImZyb21EaXNwbGF5TmFtZSIsImZyb21TdGF0ZSIsImZyb21DcmVhdGVUaW1lIiwiZnJvbUVuZFRpbWUiLCJmcm9tVXBkYXRlVGltZSIsImZyb21Nb2RlbCIsImZyb21EZXN0IiwiYmF0Y2hKb2JGcm9tVmVydGV4IiwiZnJvbVN0YXJ0VGltZSIsImZyb21TcmMiLCJiYXRjaEpvYlNvdXJjZUZyb21WZXJ0ZXgiLCJmcm9tQ29tcGxldGlvblN0YXRzIiwiYmF0Y2hKb2JTb3VyY2VUb01sZGV2IiwiZnJvbUlubGluZWRSZXF1ZXN0cyIsImlubGluZWRSZXF1ZXN0VG9NbGRldiIsImJhdGNoSm9iU291cmNlVG9WZXJ0ZXgiLCJibG9iVG9NbGRldiQ0IiwiZnJvbURhdGEiLCJjYW5jZWxCYXRjaEpvYlBhcmFtZXRlcnNUb01sZGV2IiwiY2FuY2VsQmF0Y2hKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJjYW5kaWRhdGVGcm9tTWxkZXYkMSIsImZyb21Db250ZW50IiwiZnJvbUNpdGF0aW9uTWV0YWRhdGEiLCJjaXRhdGlvbk1ldGFkYXRhRnJvbU1sZGV2JDEiLCJmcm9tVG9rZW5Db3VudCIsImZyb21GaW5pc2hSZWFzb24iLCJmcm9tQXZnTG9ncHJvYnMiLCJmcm9tR3JvdW5kaW5nTWV0YWRhdGEiLCJmcm9tSW5kZXgiLCJmcm9tTG9ncHJvYnNSZXN1bHQiLCJmcm9tU2FmZXR5UmF0aW5ncyIsImZyb21VcmxDb250ZXh0TWV0YWRhdGEiLCJmcm9tQ2l0YXRpb25zIiwiY29udGVudFRvTWxkZXYkNCIsImZyb21QYXJ0cyIsInBhcnRUb01sZGV2JDQiLCJmcm9tUm9sZSIsImNyZWF0ZUJhdGNoSm9iQ29uZmlnVG9NbGRldiIsInBhcmVudE9iamVjdCIsImNyZWF0ZUJhdGNoSm9iQ29uZmlnVG9WZXJ0ZXgiLCJjcmVhdGVCYXRjaEpvYlBhcmFtZXRlcnNUb01sZGV2IiwiZnJvbUNvbmZpZyIsImNyZWF0ZUJhdGNoSm9iUGFyYW1ldGVyc1RvVmVydGV4IiwiY3JlYXRlRW1iZWRkaW5nc0JhdGNoSm9iQ29uZmlnVG9NbGRldiIsImNyZWF0ZUVtYmVkZGluZ3NCYXRjaEpvYlBhcmFtZXRlcnNUb01sZGV2IiwiZW1iZWRkaW5nc0JhdGNoSm9iU291cmNlVG9NbGRldiIsImRlbGV0ZUJhdGNoSm9iUGFyYW1ldGVyc1RvTWxkZXYiLCJkZWxldGVCYXRjaEpvYlBhcmFtZXRlcnNUb1ZlcnRleCIsImRlbGV0ZVJlc291cmNlSm9iRnJvbU1sZGV2IiwiZGVsZXRlUmVzb3VyY2VKb2JGcm9tVmVydGV4IiwiZW1iZWRDb250ZW50QmF0Y2hUb01sZGV2IiwiZnJvbUNvbnRlbnRzIiwiZW1iZWRDb250ZW50Q29uZmlnVG9NbGRldiQxIiwiZnJvbVRhc2tUeXBlIiwiZnJvbVRpdGxlIiwiZnJvbU91dHB1dERpbWVuc2lvbmFsaXR5IiwiZmlsZURhdGFUb01sZGV2JDQiLCJmcm9tRmlsZVVyaSIsImZ1bmN0aW9uQ2FsbFRvTWxkZXYkNCIsImZyb21JZCIsImZyb21BcmdzIiwiZnVuY3Rpb25DYWxsaW5nQ29uZmlnVG9NbGRldiQyIiwiZnJvbU1vZGUiLCJmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMiLCJnZW5lcmF0ZUNvbnRlbnRDb25maWdUb01sZGV2JDEiLCJmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24iLCJmcm9tVGVtcGVyYXR1cmUiLCJmcm9tVG9wUCIsImZyb21Ub3BLIiwiZnJvbUNhbmRpZGF0ZUNvdW50IiwiZnJvbU1heE91dHB1dFRva2VucyIsImZyb21TdG9wU2VxdWVuY2VzIiwiZnJvbVJlc3BvbnNlTG9ncHJvYnMiLCJmcm9tTG9ncHJvYnMiLCJmcm9tUHJlc2VuY2VQZW5hbHR5IiwiZnJvbUZyZXF1ZW5jeVBlbmFsdHkiLCJmcm9tU2VlZCIsImZyb21SZXNwb25zZU1pbWVUeXBlIiwiZnJvbVJlc3BvbnNlU2NoZW1hIiwiZnJvbVJlc3BvbnNlSnNvblNjaGVtYSIsImZyb21TYWZldHlTZXR0aW5ncyIsInNhZmV0eVNldHRpbmdUb01sZGV2JDEiLCJmcm9tVG9vbHMiLCJ0b29sVG9NbGRldiQ0IiwiZnJvbVRvb2xDb25maWciLCJ0b29sQ29uZmlnVG9NbGRldiQyIiwiZnJvbUNhY2hlZENvbnRlbnQiLCJmcm9tUmVzcG9uc2VNb2RhbGl0aWVzIiwiZnJvbU1lZGlhUmVzb2x1dGlvbiIsImZyb21TcGVlY2hDb25maWciLCJmcm9tVGhpbmtpbmdDb25maWciLCJmcm9tSW1hZ2VDb25maWciLCJpbWFnZUNvbmZpZ1RvTWxkZXYkMSIsImdlbmVyYXRlQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2JDEiLCJmcm9tQ2FuZGlkYXRlcyIsImZyb21Nb2RlbFZlcnNpb24iLCJmcm9tUHJvbXB0RmVlZGJhY2siLCJmcm9tUmVzcG9uc2VJZCIsImZyb21Vc2FnZU1ldGFkYXRhIiwiZ2V0QmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldiIsImdldEJhdGNoSm9iUGFyYW1ldGVyc1RvVmVydGV4IiwiZ29vZ2xlTWFwc1RvTWxkZXYkNCIsImZyb21FbmFibGVXaWRnZXQiLCJnb29nbGVTZWFyY2hUb01sZGV2JDQiLCJmcm9tVGltZVJhbmdlRmlsdGVyIiwiZnJvbUFzcGVjdFJhdGlvIiwiZnJvbUltYWdlU2l6ZSIsImxpc3RCYXRjaEpvYnNDb25maWdUb01sZGV2IiwiZnJvbVBhZ2VTaXplIiwiZnJvbVBhZ2VUb2tlbiIsImxpc3RCYXRjaEpvYnNDb25maWdUb1ZlcnRleCIsImZyb21GaWx0ZXIiLCJsaXN0QmF0Y2hKb2JzUGFyYW1ldGVyc1RvTWxkZXYiLCJsaXN0QmF0Y2hKb2JzUGFyYW1ldGVyc1RvVmVydGV4IiwibGlzdEJhdGNoSm9ic1Jlc3BvbnNlRnJvbU1sZGV2IiwiZnJvbU5leHRQYWdlVG9rZW4iLCJmcm9tQmF0Y2hKb2JzIiwibGlzdEJhdGNoSm9ic1Jlc3BvbnNlRnJvbVZlcnRleCIsImZyb21Db2RlRXhlY3V0aW9uUmVzdWx0IiwiZnJvbUV4ZWN1dGFibGVDb2RlIiwiZnJvbUZpbGVEYXRhIiwiZnJvbUZ1bmN0aW9uQ2FsbCIsImZyb21GdW5jdGlvblJlc3BvbnNlIiwiZnJvbUlubGluZURhdGEiLCJmcm9tVGV4dCIsImZyb21UaG91Z2h0IiwiZnJvbVRob3VnaHRTaWduYXR1cmUiLCJmcm9tVmlkZW9NZXRhZGF0YSIsImZyb21DYXRlZ29yeSIsImZyb21UaHJlc2hvbGQiLCJmcm9tRnVuY3Rpb25DYWxsaW5nQ29uZmlnIiwiZnJvbVJldHJpZXZhbENvbmZpZyIsImZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyIsImZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwiLCJmcm9tQ29tcHV0ZXJVc2UiLCJmcm9tRmlsZVNlYXJjaCIsImZyb21Db2RlRXhlY3V0aW9uIiwiZnJvbUdvb2dsZU1hcHMiLCJmcm9tR29vZ2xlU2VhcmNoIiwiZnJvbVVybENvbnRleHQiLCJQYWdlZEl0ZW0iLCJQYWdlciIsImluaXQiLCJwYXJhbXMiLCJuYW1lSW50ZXJuYWwiLCJwYWdlSW50ZXJuYWwiLCJzZGtIdHRwUmVzcG9uc2VJbnRlcm5hbCIsInNka0h0dHBSZXNwb25zZSIsImlkeEludGVybmFsIiwicmVxdWVzdFBhcmFtcyIsInBhcmFtc0ludGVybmFsIiwicGFnZUludGVybmFsU2l6ZSIsImluaXROZXh0UGFnZSIsInBhZ2UiLCJwYWdlU2l6ZSIsInBhZ2VMZW5ndGgiLCJnZXRJdGVtIiwiaW5kZXgiLCJTeW1ib2wiLCJhc3luY0l0ZXJhdG9yIiwibmV4dCIsImhhc05leHRQYWdlIiwibmV4dFBhZ2UiLCJkb25lIiwicmV0dXJuIiwicmVxdWVzdEludGVybmFsIiwicmVxdWVzdCIsIkJhdGNoZXMiLCJjcmVhdGVJbmxpbmVkR2VuZXJhdGVDb250ZW50UmVxdWVzdCIsImJvZHkiLCJ1cmxQYXJhbXMiLCJwYXRoIiwiYmF0Y2giLCJpbnB1dENvbmZpZyIsInJlcXVlc3RzV3JhcHBlciIsInJlcXVlc3RzIiwibmV3UmVxdWVzdHMiLCJyZXF1ZXN0RGljdCIsInN5c3RlbUluc3RydWN0aW9uVmFsdWUiLCJyZXF1ZXN0Q29udGVudCIsImdldEdjc1VyaSIsImdldEJpZ3F1ZXJ5VXJpIiwiZm9ybWF0RGVzdGluYXRpb24iLCJuZXdDb25maWciLCJ0aW1lc3RhbXBTdHIiLCJEYXRlIiwibm93IiwidG9TdHJpbmciLCJkaXNwbGF5TmFtZSIsImNyZWF0ZUludGVybmFsIiwicXVlcnlQYXJhbXMiLCJKU09OIiwic3RyaW5naWZ5IiwiaHR0cE1ldGhvZCIsImFib3J0U2lnbmFsIiwidGhlbiIsImh0dHBSZXNwb25zZSIsInJlc3AiLCJjcmVhdGVFbWJlZGRpbmdzSW50ZXJuYWwiLCJnZXQiLCJjYW5jZWwiLCJsaXN0SW50ZXJuYWwiLCJqc29uUmVzcG9uc2UiLCJ0eXBlZFJlc3AiLCJkZWxldGUiLCJsaXN0IiwiUEFHRURfSVRFTV9CQVRDSF9KT0JTIiwieCIsImNyZWF0ZSIsImNyZWF0ZUVtYmVkZGluZ3MiLCJibG9iVG9NbGRldiQzIiwiY29udGVudFRvTWxkZXYkMyIsInBhcnRUb01sZGV2JDMiLCJjcmVhdGVDYWNoZWRDb250ZW50Q29uZmlnVG9NbGRldiIsImZyb21UdGwiLCJmcm9tRXhwaXJlVGltZSIsInRvb2xUb01sZGV2JDMiLCJ0b29sQ29uZmlnVG9NbGRldiQxIiwiY3JlYXRlQ2FjaGVkQ29udGVudENvbmZpZ1RvVmVydGV4IiwidG9vbFRvVmVydGV4JDIiLCJmcm9tS21zS2V5TmFtZSIsImNyZWF0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldiIsImNyZWF0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJkZWxldGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYiLCJkZWxldGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4IiwiZGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2IiwiZGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlRnJvbVZlcnRleCIsImZpbGVEYXRhVG9NbGRldiQzIiwiZnVuY3Rpb25DYWxsVG9NbGRldiQzIiwiZnVuY3Rpb25DYWxsaW5nQ29uZmlnVG9NbGRldiQxIiwiZnVuY3Rpb25EZWNsYXJhdGlvblRvVmVydGV4JDIiLCJmcm9tRGVzY3JpcHRpb24iLCJmcm9tUGFyYW1ldGVycyIsImZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSIsImdldENhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldiIsImdldENhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJnb29nbGVNYXBzVG9NbGRldiQzIiwiZ29vZ2xlU2VhcmNoVG9NbGRldiQzIiwibGlzdENhY2hlZENvbnRlbnRzQ29uZmlnVG9NbGRldiIsImxpc3RDYWNoZWRDb250ZW50c0NvbmZpZ1RvVmVydGV4IiwibGlzdENhY2hlZENvbnRlbnRzUGFyYW1ldGVyc1RvTWxkZXYiLCJsaXN0Q2FjaGVkQ29udGVudHNQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJsaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZUZyb21NbGRldiIsImZyb21DYWNoZWRDb250ZW50cyIsImxpc3RDYWNoZWRDb250ZW50c1Jlc3BvbnNlRnJvbVZlcnRleCIsImZyb21SZXRyaWV2YWwiLCJmcm9tRW50ZXJwcmlzZVdlYlNlYXJjaCIsInVwZGF0ZUNhY2hlZENvbnRlbnRDb25maWdUb01sZGV2IiwidXBkYXRlQ2FjaGVkQ29udGVudENvbmZpZ1RvVmVydGV4IiwidXBkYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2IiwidXBkYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCIsIkNhY2hlcyIsInVwZGF0ZSIsIlBBR0VEX0lURU1fQ0FDSEVEX0NPTlRFTlRTIiwiX192YWx1ZXMiLCJvIiwicyIsIml0ZXJhdG9yIiwibSIsIl9fYXdhaXQiLCJfX2FzeW5jR2VuZXJhdG9yIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJnZW5lcmF0b3IiLCJnIiwiYXBwbHkiLCJxIiwiQXN5bmNJdGVyYXRvciIsInZlcmIiLCJhd2FpdFJldHVybiIsImYiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIm4iLCJhIiwiYiIsInJlc3VtZSIsInN0ZXAiLCJlIiwic2V0dGxlIiwiciIsImZ1bGZpbGwiLCJzaGlmdCIsIl9fYXN5bmNWYWx1ZXMiLCJTdXBwcmVzc2VkRXJyb3IiLCJzdXBwcmVzc2VkIiwibWVzc2FnZSIsImlzVmFsaWRSZXNwb25zZSIsImlzVmFsaWRDb250ZW50IiwidmFsaWRhdGVIaXN0b3J5IiwiaGlzdG9yeSIsImV4dHJhY3RDdXJhdGVkSGlzdG9yeSIsImNvbXByZWhlbnNpdmVIaXN0b3J5IiwiY3VyYXRlZEhpc3RvcnkiLCJtb2RlbE91dHB1dCIsImlzVmFsaWQiLCJDaGF0cyIsIkNoYXQiLCJtb2RlbHNNb2R1bGUiLCJzdHJ1Y3R1cmVkQ2xvbmUiLCJzZW5kTWVzc2FnZSIsInNlbmRQcm9taXNlIiwiaW5wdXRDb250ZW50IiwicmVzcG9uc2VQcm9taXNlIiwiZ2VuZXJhdGVDb250ZW50IiwiY29udGVudHMiLCJnZXRIaXN0b3J5IiwiY29uY2F0Iiwib3V0cHV0Q29udGVudCIsImZ1bGxBdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5IiwiYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSIsInJlY29yZEhpc3RvcnkiLCJjYXRjaCIsInNlbmRNZXNzYWdlU3RyZWFtIiwic3RyZWFtUmVzcG9uc2UiLCJnZW5lcmF0ZUNvbnRlbnRTdHJlYW0iLCJwcm9jZXNzU3RyZWFtUmVzcG9uc2UiLCJjdXJhdGVkIiwiYXJndW1lbnRzIiwicHJvY2Vzc1N0cmVhbVJlc3BvbnNlXzEiLCJlXzEiLCJzdHJlYW1SZXNwb25zZV8xIiwic3RyZWFtUmVzcG9uc2VfMV8xIiwiY2h1bmsiLCJlXzFfMSIsInVzZXJJbnB1dCIsIm91dHB1dENvbnRlbnRzIiwiZXZlcnkiLCJBcGlFcnJvciIsIm9wdGlvbnMiLCJzZXRQcm90b3R5cGVPZiIsImNyZWF0ZUZpbGVQYXJhbWV0ZXJzVG9NbGRldiIsImZyb21GaWxlIiwiY3JlYXRlRmlsZVJlc3BvbnNlRnJvbU1sZGV2IiwiZGVsZXRlRmlsZVBhcmFtZXRlcnNUb01sZGV2IiwiZGVsZXRlRmlsZVJlc3BvbnNlRnJvbU1sZGV2IiwiZ2V0RmlsZVBhcmFtZXRlcnNUb01sZGV2IiwibGlzdEZpbGVzQ29uZmlnVG9NbGRldiIsImxpc3RGaWxlc1BhcmFtZXRlcnNUb01sZGV2IiwibGlzdEZpbGVzUmVzcG9uc2VGcm9tTWxkZXYiLCJmcm9tRmlsZXMiLCJGaWxlcyIsInVwbG9hZCIsInVwbG9hZEZpbGUiLCJmaWxlIiwiZG93bmxvYWQiLCJkb3dubG9hZEZpbGUiLCJQQUdFRF9JVEVNX0ZJTEVTIiwiYmxvYlRvTWxkZXYkMiIsImNvbnRlbnRUb01sZGV2JDIiLCJwYXJ0VG9NbGRldiQyIiwiZmlsZURhdGFUb01sZGV2JDIiLCJmdW5jdGlvbkNhbGxUb01sZGV2JDIiLCJmdW5jdGlvbkRlY2xhcmF0aW9uVG9WZXJ0ZXgkMSIsImdlbmVyYXRpb25Db25maWdUb1ZlcnRleCQxIiwiZnJvbU1vZGVsU2VsZWN0aW9uQ29uZmlnIiwiZnJvbUF1ZGlvVGltZXN0YW1wIiwiZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyIsImZyb21Sb3V0aW5nQ29uZmlnIiwic3BlZWNoQ29uZmlnVG9WZXJ0ZXgkMSIsImdvb2dsZU1hcHNUb01sZGV2JDIiLCJnb29nbGVTZWFyY2hUb01sZGV2JDIiLCJsaXZlQ29ubmVjdENvbmZpZ1RvTWxkZXYkMSIsImZyb21HZW5lcmF0aW9uQ29uZmlnIiwidG9vbFRvTWxkZXYkMiIsImZyb21TZXNzaW9uUmVzdW1wdGlvbiIsInNlc3Npb25SZXN1bXB0aW9uQ29uZmlnVG9NbGRldiQxIiwiZnJvbUlucHV0QXVkaW9UcmFuc2NyaXB0aW9uIiwiZnJvbU91dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbiIsImZyb21SZWFsdGltZUlucHV0Q29uZmlnIiwiZnJvbUNvbnRleHRXaW5kb3dDb21wcmVzc2lvbiIsImZyb21Qcm9hY3Rpdml0eSIsImxpdmVDb25uZWN0Q29uZmlnVG9WZXJ0ZXgiLCJ0b29sVG9WZXJ0ZXgkMSIsImxpdmVDb25uZWN0UGFyYW1ldGVyc1RvTWxkZXYiLCJsaXZlQ29ubmVjdFBhcmFtZXRlcnNUb1ZlcnRleCIsImxpdmVNdXNpY1NldENvbmZpZ1BhcmFtZXRlcnNUb01sZGV2IiwiZnJvbU11c2ljR2VuZXJhdGlvbkNvbmZpZyIsImxpdmVNdXNpY1NldFdlaWdodGVkUHJvbXB0c1BhcmFtZXRlcnNUb01sZGV2IiwiZnJvbVdlaWdodGVkUHJvbXB0cyIsImxpdmVTZW5kUmVhbHRpbWVJbnB1dFBhcmFtZXRlcnNUb01sZGV2IiwiZnJvbU1lZGlhIiwiZnJvbUF1ZGlvIiwiZnJvbUF1ZGlvU3RyZWFtRW5kIiwiZnJvbUFjdGl2aXR5U3RhcnQiLCJmcm9tQWN0aXZpdHlFbmQiLCJsaXZlU2VuZFJlYWx0aW1lSW5wdXRQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJsaXZlU2VydmVyTWVzc2FnZUZyb21WZXJ0ZXgiLCJmcm9tU2V0dXBDb21wbGV0ZSIsImZyb21TZXJ2ZXJDb250ZW50IiwiZnJvbVRvb2xDYWxsIiwiZnJvbVRvb2xDYWxsQ2FuY2VsbGF0aW9uIiwidXNhZ2VNZXRhZGF0YUZyb21WZXJ0ZXgiLCJmcm9tR29Bd2F5IiwiZnJvbVNlc3Npb25SZXN1bXB0aW9uVXBkYXRlIiwiZnJvbUhhbmRsZSIsImZyb21MYW5ndWFnZUNvZGUiLCJmcm9tVm9pY2VDb25maWciLCJmcm9tUHJvbXB0VG9rZW5Db3VudCIsImZyb21DYWNoZWRDb250ZW50VG9rZW5Db3VudCIsImZyb21SZXNwb25zZVRva2VuQ291bnQiLCJmcm9tVG9vbFVzZVByb21wdFRva2VuQ291bnQiLCJmcm9tVGhvdWdodHNUb2tlbkNvdW50IiwiZnJvbVRvdGFsVG9rZW5Db3VudCIsImZyb21Qcm9tcHRUb2tlbnNEZXRhaWxzIiwiZnJvbUNhY2hlVG9rZW5zRGV0YWlscyIsImZyb21SZXNwb25zZVRva2Vuc0RldGFpbHMiLCJmcm9tVG9vbFVzZVByb21wdFRva2Vuc0RldGFpbHMiLCJmcm9tVHJhZmZpY1R5cGUiLCJibG9iVG9NbGRldiQxIiwiY2FuZGlkYXRlRnJvbU1sZGV2IiwiY2l0YXRpb25NZXRhZGF0YUZyb21NbGRldiIsImNvbXB1dGVUb2tlbnNQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJjb21wdXRlVG9rZW5zUmVzcG9uc2VGcm9tVmVydGV4IiwiZnJvbVRva2Vuc0luZm8iLCJjb250ZW50RW1iZWRkaW5nRnJvbVZlcnRleCIsImZyb21WYWx1ZXMiLCJmcm9tU3RhdGlzdGljcyIsImNvbnRlbnRFbWJlZGRpbmdTdGF0aXN0aWNzRnJvbVZlcnRleCIsImZyb21UcnVuY2F0ZWQiLCJjb250ZW50VG9NbGRldiQxIiwicGFydFRvTWxkZXYkMSIsImNvbnRyb2xSZWZlcmVuY2VDb25maWdUb1ZlcnRleCIsImZyb21Db250cm9sVHlwZSIsImZyb21FbmFibGVDb250cm9sSW1hZ2VDb21wdXRhdGlvbiIsImNvdW50VG9rZW5zQ29uZmlnVG9NbGRldiIsImNvdW50VG9rZW5zQ29uZmlnVG9WZXJ0ZXgiLCJ0b29sVG9WZXJ0ZXgiLCJnZW5lcmF0aW9uQ29uZmlnVG9WZXJ0ZXgiLCJjb3VudFRva2Vuc1BhcmFtZXRlcnNUb01sZGV2IiwiY291bnRUb2tlbnNQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJjb3VudFRva2Vuc1Jlc3BvbnNlRnJvbU1sZGV2IiwiZnJvbVRvdGFsVG9rZW5zIiwiY291bnRUb2tlbnNSZXNwb25zZUZyb21WZXJ0ZXgiLCJkZWxldGVNb2RlbFBhcmFtZXRlcnNUb01sZGV2IiwiZGVsZXRlTW9kZWxQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJkZWxldGVNb2RlbFJlc3BvbnNlRnJvbU1sZGV2IiwiZGVsZXRlTW9kZWxSZXNwb25zZUZyb21WZXJ0ZXgiLCJlZGl0SW1hZ2VDb25maWdUb1ZlcnRleCIsImZyb21PdXRwdXRHY3NVcmkiLCJmcm9tTmVnYXRpdmVQcm9tcHQiLCJmcm9tTnVtYmVyT2ZJbWFnZXMiLCJmcm9tR3VpZGFuY2VTY2FsZSIsImZyb21TYWZldHlGaWx0ZXJMZXZlbCIsImZyb21QZXJzb25HZW5lcmF0aW9uIiwiZnJvbUluY2x1ZGVTYWZldHlBdHRyaWJ1dGVzIiwiZnJvbUluY2x1ZGVSYWlSZWFzb24iLCJmcm9tTGFuZ3VhZ2UiLCJmcm9tT3V0cHV0TWltZVR5cGUiLCJmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5IiwiZnJvbUFkZFdhdGVybWFyayIsImZyb21MYWJlbHMiLCJmcm9tRWRpdE1vZGUiLCJmcm9tQmFzZVN0ZXBzIiwiZWRpdEltYWdlUGFyYW1ldGVyc0ludGVybmFsVG9WZXJ0ZXgiLCJmcm9tUHJvbXB0IiwiZnJvbVJlZmVyZW5jZUltYWdlcyIsInJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWxUb1ZlcnRleCIsImVkaXRJbWFnZVJlc3BvbnNlRnJvbVZlcnRleCIsImZyb21HZW5lcmF0ZWRJbWFnZXMiLCJnZW5lcmF0ZWRJbWFnZUZyb21WZXJ0ZXgiLCJlbWJlZENvbnRlbnRDb25maWdUb01sZGV2IiwiZW1iZWRDb250ZW50Q29uZmlnVG9WZXJ0ZXgiLCJmcm9tQXV0b1RydW5jYXRlIiwiZW1iZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYiLCJmcm9tTW9kZWxGb3JFbWJlZENvbnRlbnQiLCJlbWJlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJlbWJlZENvbnRlbnRSZXNwb25zZUZyb21NbGRldiIsImZyb21FbWJlZGRpbmdzIiwiZW1iZWRDb250ZW50UmVzcG9uc2VGcm9tVmVydGV4IiwiZW5kcG9pbnRGcm9tVmVydGV4IiwiZnJvbURlcGxveWVkTW9kZWxJZCIsImZpbGVEYXRhVG9NbGRldiQxIiwiZnVuY3Rpb25DYWxsVG9NbGRldiQxIiwiZnVuY3Rpb25DYWxsaW5nQ29uZmlnVG9NbGRldiIsImZ1bmN0aW9uRGVjbGFyYXRpb25Ub1ZlcnRleCIsImdlbmVyYXRlQ29udGVudENvbmZpZ1RvTWxkZXYiLCJzYWZldHlTZXR0aW5nVG9NbGRldiIsInRvb2xUb01sZGV2JDEiLCJ0b29sQ29uZmlnVG9NbGRldiIsImltYWdlQ29uZmlnVG9NbGRldiIsImdlbmVyYXRlQ29udGVudENvbmZpZ1RvVmVydGV4Iiwic3BlZWNoQ29uZmlnVG9WZXJ0ZXgiLCJpbWFnZUNvbmZpZ1RvVmVydGV4IiwiZ2VuZXJhdGVDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYiLCJnZW5lcmF0ZUNvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJnZW5lcmF0ZUNvbnRlbnRSZXNwb25zZUZyb21NbGRldiIsImdlbmVyYXRlQ29udGVudFJlc3BvbnNlRnJvbVZlcnRleCIsImdlbmVyYXRlSW1hZ2VzQ29uZmlnVG9NbGRldiIsImdlbmVyYXRlSW1hZ2VzQ29uZmlnVG9WZXJ0ZXgiLCJmcm9tRW5oYW5jZVByb21wdCIsImdlbmVyYXRlSW1hZ2VzUGFyYW1ldGVyc1RvTWxkZXYiLCJnZW5lcmF0ZUltYWdlc1BhcmFtZXRlcnNUb1ZlcnRleCIsImdlbmVyYXRlSW1hZ2VzUmVzcG9uc2VGcm9tTWxkZXYiLCJnZW5lcmF0ZWRJbWFnZUZyb21NbGRldiIsImZyb21Qb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMiLCJzYWZldHlBdHRyaWJ1dGVzRnJvbU1sZGV2IiwiZ2VuZXJhdGVJbWFnZXNSZXNwb25zZUZyb21WZXJ0ZXgiLCJzYWZldHlBdHRyaWJ1dGVzRnJvbVZlcnRleCIsImdlbmVyYXRlVmlkZW9zQ29uZmlnVG9NbGRldiIsImZyb21OdW1iZXJPZlZpZGVvcyIsImZyb21EdXJhdGlvblNlY29uZHMiLCJmcm9tUmVzb2x1dGlvbiIsImZyb21MYXN0RnJhbWUiLCJpbWFnZVRvTWxkZXYiLCJ2aWRlb0dlbmVyYXRpb25SZWZlcmVuY2VJbWFnZVRvTWxkZXYiLCJnZW5lcmF0ZVZpZGVvc0NvbmZpZ1RvVmVydGV4IiwiZnJvbUZwcyIsImZyb21QdWJzdWJUb3BpYyIsImZyb21HZW5lcmF0ZUF1ZGlvIiwiaW1hZ2VUb1ZlcnRleCIsInZpZGVvR2VuZXJhdGlvblJlZmVyZW5jZUltYWdlVG9WZXJ0ZXgiLCJmcm9tTWFzayIsInZpZGVvR2VuZXJhdGlvbk1hc2tUb1ZlcnRleCIsImZyb21Db21wcmVzc2lvblF1YWxpdHkiLCJnZW5lcmF0ZVZpZGVvc09wZXJhdGlvbkZyb21NbGRldiIsImdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tTWxkZXYiLCJnZW5lcmF0ZVZpZGVvc09wZXJhdGlvbkZyb21WZXJ0ZXgiLCJnZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlRnJvbVZlcnRleCIsImdlbmVyYXRlVmlkZW9zUGFyYW1ldGVyc1RvTWxkZXYiLCJmcm9tSW1hZ2UiLCJ2aWRlb1RvTWxkZXYiLCJmcm9tU291cmNlIiwiZ2VuZXJhdGVWaWRlb3NTb3VyY2VUb01sZGV2IiwiZ2VuZXJhdGVWaWRlb3NQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJ2aWRlb1RvVmVydGV4IiwiZ2VuZXJhdGVWaWRlb3NTb3VyY2VUb1ZlcnRleCIsImdlbmVyYXRlZFZpZGVvRnJvbU1sZGV2IiwiZ2VuZXJhdGVkVmlkZW9Gcm9tVmVydGV4IiwiaW1hZ2VGcm9tTWxkZXYiLCJmcm9tUmFpRmlsdGVyZWRSZWFzb24iLCJmcm9tU2FmZXR5QXR0cmlidXRlcyIsImltYWdlRnJvbVZlcnRleCIsImZyb21FbmhhbmNlZFByb21wdCIsImdlbmVyYXRlZEltYWdlTWFza0Zyb21WZXJ0ZXgiLCJ2aWRlb0Zyb21NbGRldiIsInZpZGVvRnJvbVZlcnRleCIsImdldE1vZGVsUGFyYW1ldGVyc1RvTWxkZXYiLCJnZXRNb2RlbFBhcmFtZXRlcnNUb1ZlcnRleCIsImdvb2dsZU1hcHNUb01sZGV2JDEiLCJnb29nbGVTZWFyY2hUb01sZGV2JDEiLCJsaXN0TW9kZWxzQ29uZmlnVG9NbGRldiIsImZyb21RdWVyeUJhc2UiLCJsaXN0TW9kZWxzQ29uZmlnVG9WZXJ0ZXgiLCJsaXN0TW9kZWxzUGFyYW1ldGVyc1RvTWxkZXYiLCJsaXN0TW9kZWxzUGFyYW1ldGVyc1RvVmVydGV4IiwibGlzdE1vZGVsc1Jlc3BvbnNlRnJvbU1sZGV2IiwiZnJvbU1vZGVscyIsIm1vZGVsRnJvbU1sZGV2IiwibGlzdE1vZGVsc1Jlc3BvbnNlRnJvbVZlcnRleCIsIm1vZGVsRnJvbVZlcnRleCIsIm1hc2tSZWZlcmVuY2VDb25maWdUb1ZlcnRleCIsImZyb21NYXNrTW9kZSIsImZyb21TZWdtZW50YXRpb25DbGFzc2VzIiwiZnJvbU1hc2tEaWxhdGlvbiIsImZyb21WZXJzaW9uIiwiZnJvbVR1bmVkTW9kZWxJbmZvIiwidHVuZWRNb2RlbEluZm9Gcm9tTWxkZXYiLCJmcm9tSW5wdXRUb2tlbkxpbWl0IiwiZnJvbU91dHB1dFRva2VuTGltaXQiLCJmcm9tU3VwcG9ydGVkQWN0aW9ucyIsImZyb21NYXhUZW1wZXJhdHVyZSIsImZyb21UaGlua2luZyIsImZyb21FbmRwb2ludHMiLCJ0dW5lZE1vZGVsSW5mb0Zyb21WZXJ0ZXgiLCJmcm9tRGVmYXVsdENoZWNrcG9pbnRJZCIsImZyb21DaGVja3BvaW50cyIsInByb2R1Y3RJbWFnZVRvVmVydGV4IiwiZnJvbVByb2R1Y3RJbWFnZSIsInJlY29udGV4dEltYWdlQ29uZmlnVG9WZXJ0ZXgiLCJyZWNvbnRleHRJbWFnZVBhcmFtZXRlcnNUb1ZlcnRleCIsInJlY29udGV4dEltYWdlU291cmNlVG9WZXJ0ZXgiLCJyZWNvbnRleHRJbWFnZVJlc3BvbnNlRnJvbVZlcnRleCIsImZyb21QZXJzb25JbWFnZSIsImZyb21Qcm9kdWN0SW1hZ2VzIiwiZnJvbVJlZmVyZW5jZUltYWdlIiwiZnJvbVJlZmVyZW5jZUlkIiwiZnJvbVJlZmVyZW5jZVR5cGUiLCJmcm9tTWFza0ltYWdlQ29uZmlnIiwiZnJvbUNvbnRyb2xJbWFnZUNvbmZpZyIsImZyb21TdHlsZUltYWdlQ29uZmlnIiwiZnJvbVN1YmplY3RJbWFnZUNvbmZpZyIsImZyb21DYXRlZ29yaWVzIiwiZnJvbVNjb3JlcyIsImZyb21Db250ZW50VHlwZSIsInNjcmliYmxlSW1hZ2VUb1ZlcnRleCIsInNlZ21lbnRJbWFnZUNvbmZpZ1RvVmVydGV4IiwiZnJvbU1heFByZWRpY3Rpb25zIiwiZnJvbUNvbmZpZGVuY2VUaHJlc2hvbGQiLCJmcm9tQmluYXJ5Q29sb3JUaHJlc2hvbGQiLCJzZWdtZW50SW1hZ2VQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJzZWdtZW50SW1hZ2VTb3VyY2VUb1ZlcnRleCIsInNlZ21lbnRJbWFnZVJlc3BvbnNlRnJvbVZlcnRleCIsImZyb21HZW5lcmF0ZWRNYXNrcyIsImZyb21TY3JpYmJsZUltYWdlIiwiZnJvbUJhc2VNb2RlbCIsInVwZGF0ZU1vZGVsQ29uZmlnVG9NbGRldiIsInVwZGF0ZU1vZGVsQ29uZmlnVG9WZXJ0ZXgiLCJ1cGRhdGVNb2RlbFBhcmFtZXRlcnNUb01sZGV2IiwidXBkYXRlTW9kZWxQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJ1cHNjYWxlSW1hZ2VBUElDb25maWdJbnRlcm5hbFRvVmVydGV4IiwiZnJvbUVuaGFuY2VJbnB1dEltYWdlIiwiZnJvbUltYWdlUHJlc2VydmF0aW9uRmFjdG9yIiwidXBzY2FsZUltYWdlQVBJUGFyYW1ldGVyc0ludGVybmFsVG9WZXJ0ZXgiLCJmcm9tVXBzY2FsZUZhY3RvciIsInVwc2NhbGVJbWFnZVJlc3BvbnNlRnJvbVZlcnRleCIsImNyZWF0ZUZpbGVTZWFyY2hTdG9yZUNvbmZpZ1RvTWxkZXYiLCJjcmVhdGVGaWxlU2VhcmNoU3RvcmVQYXJhbWV0ZXJzVG9NbGRldiIsImRlbGV0ZUZpbGVTZWFyY2hTdG9yZUNvbmZpZ1RvTWxkZXYiLCJmcm9tRm9yY2UiLCJkZWxldGVGaWxlU2VhcmNoU3RvcmVQYXJhbWV0ZXJzVG9NbGRldiIsImdldEZpbGVTZWFyY2hTdG9yZVBhcmFtZXRlcnNUb01sZGV2IiwiaW1wb3J0RmlsZUNvbmZpZ1RvTWxkZXYiLCJmcm9tQ3VzdG9tTWV0YWRhdGEiLCJmcm9tQ2h1bmtpbmdDb25maWciLCJpbXBvcnRGaWxlT3BlcmF0aW9uRnJvbU1sZGV2IiwiaW1wb3J0RmlsZVJlc3BvbnNlRnJvbU1sZGV2IiwiaW1wb3J0RmlsZVBhcmFtZXRlcnNUb01sZGV2IiwiZnJvbUZpbGVTZWFyY2hTdG9yZU5hbWUiLCJsaXN0RmlsZVNlYXJjaFN0b3Jlc0NvbmZpZ1RvTWxkZXYiLCJsaXN0RmlsZVNlYXJjaFN0b3Jlc1BhcmFtZXRlcnNUb01sZGV2IiwibGlzdEZpbGVTZWFyY2hTdG9yZXNSZXNwb25zZUZyb21NbGRldiIsImZyb21GaWxlU2VhcmNoU3RvcmVzIiwidXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVDb25maWdUb01sZGV2IiwidXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVQYXJhbWV0ZXJzVG9NbGRldiIsInVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlUmVzdW1hYmxlUmVzcG9uc2VGcm9tTWxkZXYiLCJDT05URU5UX1RZUEVfSEVBREVSIiwiU0VSVkVSX1RJTUVPVVRfSEVBREVSIiwiVVNFUl9BR0VOVF9IRUFERVIiLCJHT09HTEVfQVBJX0NMSUVOVF9IRUFERVIiLCJTREtfVkVSU0lPTiIsIkxJQlJBUllfTEFCRUwiLCJWRVJURVhfQUlfQVBJX0RFRkFVTFRfVkVSU0lPTiIsIkdPT0dMRV9BSV9BUElfREVGQVVMVF9WRVJTSU9OIiwicmVzcG9uc2VMaW5lUkUiLCJBcGlDbGllbnQiLCJiYXNlVXJsRnJvbVByb2plY3RMb2NhdGlvbiIsImNsaWVudE9wdGlvbnMiLCJwcm9qZWN0IiwibG9jYXRpb24iLCJub3JtYWxpemVBdXRoUGFyYW1ldGVycyIsImFwaUtleSIsImdldEFwaVZlcnNpb24iLCJhcGlWZXJzaW9uIiwiZ2V0UmVxdWVzdFVybCIsImdldFJlcXVlc3RVcmxJbnRlcm5hbCIsImdldEhlYWRlcnMiLCJ1cmxFbGVtZW50Iiwiam9pbiIsImdldEJhc2VSZXNvdXJjZVBhdGgiLCJnZXRBcGlLZXkiLCJnZXRXZWJzb2NrZXRCYXNlVXJsIiwidXJsUGFydHMiLCJVUkwiLCJwcm90b2NvbCIsInNldEJhc2VVcmwiLCJ1cmwiLCJjb25zdHJ1Y3RVcmwiLCJwcmVwZW5kUHJvamVjdExvY2F0aW9uIiwic2hvdWxkUHJlcGVuZFZlcnRleFByb2plY3RQYXRoIiwicGF0Y2hlZEh0dHBPcHRpb25zIiwicGF0Y2hIdHRwT3B0aW9ucyIsInNlYXJjaFBhcmFtcyIsImFwcGVuZCIsInJlcXVlc3RJbml0IiwiaW5jbHVkZUV4dHJhSHR0cE9wdGlvbnNUb1JlcXVlc3RJbml0IiwidW5hcnlBcGlDYWxsIiwiYmFzZUh0dHBPcHRpb25zIiwicmVxdWVzdEh0dHBPcHRpb25zIiwicGFyc2UiLCJyZXF1ZXN0U3RyZWFtIiwic2V0Iiwic3RyZWFtQXBpQ2FsbCIsInRpbWVvdXQiLCJhYm9ydENvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJzaWduYWwiLCJ0aW1lb3V0SGFuZGxlIiwic2V0VGltZW91dCIsImFib3J0IiwidW5yZWYiLCJhZGRFdmVudExpc3RlbmVyIiwiZXh0cmFCb2R5IiwiaW5jbHVkZUV4dHJhQm9keVRvUmVxdWVzdEluaXQiLCJnZXRIZWFkZXJzSW50ZXJuYWwiLCJhcGlDYWxsIiwibWV0aG9kIiwidGhyb3dFcnJvcklmTm90T0siLCJyZWFkZXIiLCJnZXRSZWFkZXIiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJidWZmZXIiLCJyZWFkIiwidHJpbSIsImNodW5rU3RyaW5nIiwiZGVjb2RlIiwic3RyZWFtIiwiY2h1bmtKc29uIiwiZXJyb3JKc29uIiwiZXJyb3JNZXNzYWdlIiwiYXBpRXJyb3IiLCJwcm9jZXNzZWRDaHVua1N0cmluZyIsInBhcnRpYWxSZXNwb25zZSIsIlJlc3BvbnNlIiwic3RhdHVzVGV4dCIsInJlbGVhc2VMb2NrIiwiZmV0Y2giLCJnZXREZWZhdWx0SGVhZGVycyIsInZlcnNpb25IZWFkZXJWYWx1ZSIsInVzZXJBZ2VudEV4dHJhIiwiSGVhZGVycyIsIk1hdGgiLCJjZWlsIiwiYXV0aCIsImFkZEF1dGhIZWFkZXJzIiwiZ2V0RmlsZU5hbWUiLCJmaWxlVG9VcGxvYWQiLCJ1cGxvYWRlciIsImZpbGVTdGF0Iiwic3RhdCIsInNpemVCeXRlcyIsInNpemUiLCJ1cGxvYWRVcmwiLCJmZXRjaFVwbG9hZFVybCIsInVwbG9hZEZpbGVUb0ZpbGVTZWFyY2hTdG9yZSIsImZpbGVTZWFyY2hTdG9yZU5hbWUiLCJ1cGxvYWRUb0ZpbGVTZWFyY2hTdG9yZSIsImRvd25sb2FkZXIiLCJjb25maWdIdHRwT3B0aW9ucyIsIm9wdHMiLCJpbml0SHR0cE9wdGlvbnMiLCJvayIsImVycm9yQm9keSIsIkJsb2IiLCJjdXJyZW50Qm9keU9iamVjdCIsInBhcnNlZEJvZHkiLCJkZWVwTWVyZ2UiLCJ0YXJnZXQiLCJzb3VyY2UiLCJzb3VyY2VWYWx1ZSIsInRhcmdldFZhbHVlIiwibWVyZ2VkQm9keSIsIk1DUF9MQUJFTCIsImhhc01jcFRvb2xVc2FnZUZyb21NY3BUb1Rvb2wiLCJoYXNNY3BUb29sVXNhZ2UiLCJpc01jcENhbGxhYmxlVG9vbCIsInNldE1jcFVzYWdlSGVhZGVyIiwiZXhpc3RpbmdIZWFkZXIiLCJ0cmltU3RhcnQiLCJvYmplY3QiLCJNY3BDYWxsYWJsZVRvb2wiLCJsaXN0QWxsVG9vbHMiLCJtY3BDbGllbnQiLCJtYXhUb29scyIsImxpc3RBbGxUb29sc18xIiwiY3Vyc29yIiwibnVtVG9vbHMiLCJ0IiwibGlzdFRvb2xzIiwibmV4dEN1cnNvciIsIm1jcENsaWVudHMiLCJpbml0aWFsaXplIiwiZnVuY3Rpb25NYXAiLCJmdW5jdGlvbk5hbWVUb01jcENsaWVudCIsImNhbGxUb29sIiwiZnVuY3Rpb25DYWxsUmVzcG9uc2VQYXJ0cyIsInJlcXVlc3RPcHRpb25zIiwiY2FsbFRvb2xSZXNwb25zZSIsImlzRXJyb3IiLCJpc01jcENsaWVudCIsIm1jcFRvVG9vbCIsIm1heWJlQ29uZmlnIiwiaGFuZGxlV2ViU29ja2V0TWVzc2FnZSQxIiwib25tZXNzYWdlIiwiZXZlbnQiLCJzZXJ2ZXJNZXNzYWdlIiwiTGl2ZU11c2ljIiwiY29ubmVjdCIsIndlYnNvY2tldEJhc2VVcmwiLCJtYXBUb0hlYWRlcnMkMSIsIm9ub3BlblJlc29sdmUiLCJvbm9wZW5Qcm9taXNlIiwiY2FsbGJhY2tzIiwib25vcGVuQXdhaXRlZENhbGxiYWNrIiwid2Vic29ja2V0Q2FsbGJhY2tzIiwib25vcGVuIiwib25lcnJvciIsIm9uY2xvc2UiLCJjb25uIiwid2ViU29ja2V0RmFjdG9yeSIsImhlYWRlcnNUb01hcCQxIiwic2V0dXAiLCJjbGllbnRNZXNzYWdlIiwic2VuZCIsIkxpdmVNdXNpY1Nlc3Npb24iLCJzZXRXZWlnaHRlZFByb21wdHMiLCJ3ZWlnaHRlZFByb21wdHMiLCJjbGllbnRDb250ZW50Iiwic2V0TXVzaWNHZW5lcmF0aW9uQ29uZmlnIiwibXVzaWNHZW5lcmF0aW9uQ29uZmlnIiwic2V0Q29uZmlnUGFyYW1ldGVycyIsInNlbmRQbGF5YmFja0NvbnRyb2wiLCJwbGF5YmFja0NvbnRyb2wiLCJwbGF5IiwiUExBWSIsInBhdXNlIiwiUEFVU0UiLCJzdG9wIiwiU1RPUCIsInJlc2V0Q29udGV4dCIsIlJFU0VUX0NPTlRFWFQiLCJjbG9zZSIsImhlYWRlck1hcCIsImZvckVhY2giLCJGVU5DVElPTl9SRVNQT05TRV9SRVFVSVJFU19JRCIsImhhbmRsZVdlYlNvY2tldE1lc3NhZ2UiLCJqc29uRGF0YSIsIkFycmF5QnVmZmVyIiwiTGl2ZSIsImNsaWVudEhlYWRlcnMiLCJtYXBUb0hlYWRlcnMiLCJoZWFkZXJzVG9NYXAiLCJyZXNwb25zZU1vZGFsaXRpZXMiLCJBVURJTyIsImdlbmVyYXRpb25Db25maWciLCJpbnB1dFRvb2xzIiwiY29udmVydGVkVG9vbHMiLCJpc0NhbGxhYmxlVG9vbCIsImNhbGxhYmxlVG9vbCIsImxpdmVDb25uZWN0UGFyYW1ldGVycyIsIlNlc3Npb24iLCJtdXNpYyIsImRlZmF1bHRMaXZlU2VuZENsaWVudENvbnRlbnRQYXJhbWVydGVycyIsInR1cm5Db21wbGV0ZSIsInRMaXZlQ2xpZW50Q29udGVudCIsInR1cm5zIiwidExpdmVDbGllbnR0VG9vbFJlc3BvbnNlIiwidG9vbFJlc3BvbnNlIiwic2VuZENsaWVudENvbnRlbnQiLCJzZW5kUmVhbHRpbWVJbnB1dCIsInNlbmRUb29sUmVzcG9uc2UiLCJERUZBVUxUX01BWF9SRU1PVEVfQ0FMTFMiLCJzaG91bGREaXNhYmxlQWZjIiwiYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nIiwiZGlzYWJsZSIsImNhbGxhYmxlVG9vbHNQcmVzZW50IiwibWF4Q2FsbHMiLCJtYXhpbXVtUmVtb3RlQ2FsbHMiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJoYXNDYWxsYWJsZVRvb2xzIiwic29tZSIsImZpbmRBZmNJbmNvbXBhdGlibGVUb29sSW5kZXhlcyIsImFmY0luY29tcGF0aWJsZVRvb2xJbmRleGVzIiwic2hvdWxkQXBwZW5kQWZjSGlzdG9yeSIsImlnbm9yZUNhbGxIaXN0b3J5IiwiTW9kZWxzIiwibWF5YmVNb3ZlVG9SZXNwb25zZUpzb25TY2hlbSIsInJlc3BvbnNlU2NoZW1hIiwicHJvY2Vzc1BhcmFtc01heWJlQWRkTWNwVXNhZ2UiLCJ0cmFuc2Zvcm1lZFRvb2xzIiwiYWxsIiwibmV3UGFyYW1zIiwibmV3SGVhZGVycyIsImluaXRBZmNUb29sc01hcCIsImFmY1Rvb2xzIiwiTWFwIiwidG9vbERlY2xhcmF0aW9uIiwiZGVjbGFyYXRpb24iLCJwcm9jZXNzQWZjU3RyZWFtIiwibWF4UmVtb3RlQ2FsbHMiLCJ3ZXJlRnVuY3Rpb25zQ2FsbGVkIiwicmVtb3RlQ2FsbENvdW50IiwiYWZjVG9vbHNNYXAiLCJtb2RlbHMiLCJ0cmFuc2Zvcm1lZFBhcmFtcyIsImdlbmVyYXRlQ29udGVudFN0cmVhbUludGVybmFsIiwicmVzcG9uc2VDb250ZW50cyIsInJlc3BvbnNlXzEiLCJyZXNwb25zZV8xXzEiLCJyZXNwb25zZVBhcnRzIiwidHlwZWRSZXNwb25zZUNodW5rIiwibmV3Q29udGVudHMiLCJ1cGRhdGVkQ29udGVudHMiLCJnZW5lcmF0ZUNvbnRlbnRJbnRlcm5hbCIsImVfMiIsImFwaVJlc3BvbnNlXzEiLCJhcGlSZXNwb25zZV8xXzEiLCJlXzJfMSIsImVfMyIsImFwaVJlc3BvbnNlXzIiLCJhcGlSZXNwb25zZV8yXzEiLCJlXzNfMSIsImVtYmVkQ29udGVudCIsImdlbmVyYXRlSW1hZ2VzSW50ZXJuYWwiLCJlZGl0SW1hZ2VJbnRlcm5hbCIsInVwc2NhbGVJbWFnZUludGVybmFsIiwicmVjb250ZXh0SW1hZ2UiLCJzZWdtZW50SW1hZ2UiLCJjb3VudFRva2VucyIsImNvbXB1dGVUb2tlbnMiLCJnZW5lcmF0ZVZpZGVvc0ludGVybmFsIiwiaW5jb21wYXRpYmxlVG9vbEluZGV4ZXMiLCJmb3JtYXR0ZWRJbmRleGVzIiwiZnVuY3Rpb25SZXNwb25zZUNvbnRlbnQiLCJyZW1vdGVDYWxscyIsInJlc3BvbnNlQ29udGVudCIsImZ1bmN0aW9uUmVzcG9uc2VQYXJ0cyIsInN0cmVhbUZ1bmN0aW9uQ2FsbCIsInRvb2xDb25maWciLCJmdW5jdGlvbkNhbGxpbmdDb25maWciLCJzdHJlYW1GdW5jdGlvbkNhbGxBcmd1bWVudHMiLCJkaXNhYmxlQWZjIiwiZ2VuZXJhdGVJbWFnZXMiLCJwb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMiLCJnZW5lcmF0ZWRJbWFnZXMiLCJnZW5lcmF0ZWRJbWFnZSIsInNhZmV0eUF0dHJpYnV0ZXMiLCJjb250ZW50VHlwZSIsImRlZmF1bHRDb25maWciLCJxdWVyeUJhc2UiLCJhY3R1YWxDb25maWciLCJhY3R1YWxQYXJhbXMiLCJQQUdFRF9JVEVNX01PREVMUyIsImVkaXRJbWFnZSIsInByb21wdCIsInJlZmVyZW5jZUltYWdlcyIsImltZyIsInVwc2NhbGVJbWFnZSIsImFwaUNvbmZpZyIsIm51bWJlck9mSW1hZ2VzIiwibW9kZSIsImFwaVBhcmFtcyIsImltYWdlIiwidXBzY2FsZUZhY3RvciIsImdlbmVyYXRlVmlkZW9zIiwidmlkZW9CeXRlcyIsIk9wZXJhdGlvbnMiLCJnZXRWaWRlb3NPcGVyYXRpb24iLCJyYXdPcGVyYXRpb24iLCJmZXRjaFByZWRpY3RWaWRlb3NPcGVyYXRpb25JbnRlcm5hbCIsIm9wZXJhdGlvbk5hbWUiLCJnZXRWaWRlb3NPcGVyYXRpb25JbnRlcm5hbCIsImJsb2JUb01sZGV2IiwiY29udGVudFRvTWxkZXYiLCJwYXJ0VG9NbGRldiIsImNyZWF0ZUF1dGhUb2tlbkNvbmZpZ1RvTWxkZXYiLCJmcm9tTmV3U2Vzc2lvbkV4cGlyZVRpbWUiLCJmcm9tVXNlcyIsImZyb21MaXZlQ29ubmVjdENvbnN0cmFpbnRzIiwibGl2ZUNvbm5lY3RDb25zdHJhaW50c1RvTWxkZXYiLCJmcm9tTG9ja0FkZGl0aW9uYWxGaWVsZHMiLCJjcmVhdGVBdXRoVG9rZW5QYXJhbWV0ZXJzVG9NbGRldiIsImZpbGVEYXRhVG9NbGRldiIsImZ1bmN0aW9uQ2FsbFRvTWxkZXYiLCJnb29nbGVNYXBzVG9NbGRldiIsImdvb2dsZVNlYXJjaFRvTWxkZXYiLCJsaXZlQ29ubmVjdENvbmZpZ1RvTWxkZXYiLCJ0b29sVG9NbGRldiIsInNlc3Npb25SZXN1bXB0aW9uQ29uZmlnVG9NbGRldiIsImdldEZpZWxkTWFza3MiLCJmaWVsZHMiLCJmaWVsZCIsImtrIiwiY29udmVydEJpZGlTZXR1cFRvVG9rZW5TZXR1cCIsInNldHVwRm9yTWFza0dlbmVyYXRpb24iLCJiaWRpR2VuZXJhdGVDb250ZW50U2V0dXBWYWx1ZSIsImlubmVyU2V0dXAiLCJwcmVFeGlzdGluZ0ZpZWxkTWFzayIsImdlbmVyYXRlZE1hc2tGcm9tQmlkaSIsImxvY2tBZGRpdGlvbmFsRmllbGRzIiwiZ2VuZXJhdGlvbkNvbmZpZ0ZpZWxkcyIsIm1hcHBlZEZpZWxkc0Zyb21QcmVFeGlzdGluZyIsImZpbmFsTWFza1BhcnRzIiwiVG9rZW5zIiwidHJhbnNmb3JtZWRCb2R5IiwiZGVsZXRlRG9jdW1lbnRDb25maWdUb01sZGV2IiwiZGVsZXRlRG9jdW1lbnRQYXJhbWV0ZXJzVG9NbGRldiIsImdldERvY3VtZW50UGFyYW1ldGVyc1RvTWxkZXYiLCJsaXN0RG9jdW1lbnRzQ29uZmlnVG9NbGRldiIsImxpc3REb2N1bWVudHNQYXJhbWV0ZXJzVG9NbGRldiIsImxpc3REb2N1bWVudHNSZXNwb25zZUZyb21NbGRldiIsImZyb21Eb2N1bWVudHMiLCJEb2N1bWVudHMiLCJQQUdFRF9JVEVNX0RPQ1VNRU5UUyIsInBhcmVudCIsIkZpbGVTZWFyY2hTdG9yZXMiLCJ1cGxvYWRUb0ZpbGVTZWFyY2hTdG9yZUludGVybmFsIiwiaW1wb3J0RmlsZSIsImRvY3VtZW50cyIsIlBBR0VEX0lURU1fRklMRV9TRUFSQ0hfU1RPUkVTIiwiY2FuY2VsVHVuaW5nSm9iUGFyYW1ldGVyc1RvTWxkZXYiLCJfcm9vdE9iamVjdCIsImNhbmNlbFR1bmluZ0pvYlBhcmFtZXRlcnNUb1ZlcnRleCIsImNhbmNlbFR1bmluZ0pvYlJlc3BvbnNlRnJvbU1sZGV2IiwiY2FuY2VsVHVuaW5nSm9iUmVzcG9uc2VGcm9tVmVydGV4IiwiY3JlYXRlVHVuaW5nSm9iQ29uZmlnVG9NbGRldiIsImZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUiLCJmcm9tRXBvY2hDb3VudCIsImZyb21MZWFybmluZ1JhdGVNdWx0aXBsaWVyIiwiZnJvbUJhdGNoU2l6ZSIsImZyb21MZWFybmluZ1JhdGUiLCJjcmVhdGVUdW5pbmdKb2JDb25maWdUb1ZlcnRleCIsInJvb3RPYmplY3QiLCJkaXNjcmltaW5hdG9yVmFsaWRhdGlvbkRhdGFzZXQiLCJmcm9tVmFsaWRhdGlvbkRhdGFzZXQiLCJ0dW5pbmdWYWxpZGF0aW9uRGF0YXNldFRvVmVydGV4IiwiZGlzY3JpbWluYXRvckVwb2NoQ291bnQiLCJkaXNjcmltaW5hdG9yTGVhcm5pbmdSYXRlTXVsdGlwbGllciIsImRpc2NyaW1pbmF0b3JFeHBvcnRMYXN0Q2hlY2twb2ludE9ubHkiLCJmcm9tRXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5IiwiZGlzY3JpbWluYXRvckFkYXB0ZXJTaXplIiwiZnJvbUFkYXB0ZXJTaXplIiwiZnJvbUJldGEiLCJjcmVhdGVUdW5pbmdKb2JQYXJhbWV0ZXJzUHJpdmF0ZVRvTWxkZXYiLCJmcm9tUHJlVHVuZWRNb2RlbCIsImZyb21UcmFpbmluZ0RhdGFzZXQiLCJ0dW5pbmdEYXRhc2V0VG9NbGRldiIsImNyZWF0ZVR1bmluZ0pvYlBhcmFtZXRlcnNQcml2YXRlVG9WZXJ0ZXgiLCJ0dW5pbmdEYXRhc2V0VG9WZXJ0ZXgiLCJnZXRUdW5pbmdKb2JQYXJhbWV0ZXJzVG9NbGRldiIsImdldFR1bmluZ0pvYlBhcmFtZXRlcnNUb1ZlcnRleCIsImxpc3RUdW5pbmdKb2JzQ29uZmlnVG9NbGRldiIsImxpc3RUdW5pbmdKb2JzQ29uZmlnVG9WZXJ0ZXgiLCJsaXN0VHVuaW5nSm9ic1BhcmFtZXRlcnNUb01sZGV2IiwibGlzdFR1bmluZ0pvYnNQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJsaXN0VHVuaW5nSm9ic1Jlc3BvbnNlRnJvbU1sZGV2IiwiZnJvbVR1bmluZ0pvYnMiLCJ0dW5pbmdKb2JGcm9tTWxkZXYiLCJsaXN0VHVuaW5nSm9ic1Jlc3BvbnNlRnJvbVZlcnRleCIsInR1bmluZ0pvYkZyb21WZXJ0ZXgiLCJ0dW5lZE1vZGVsRnJvbU1sZGV2IiwiZnJvbUVuZHBvaW50IiwiZnJvbUV4YW1wbGVzIiwiZGlzY3JpbWluYXRvckdjc1VyaSIsImRpc2NyaW1pbmF0b3JWZXJ0ZXhEYXRhc2V0UmVzb3VyY2UiLCJmcm9tVmVydGV4RGF0YXNldFJlc291cmNlIiwiZnJvbVR1bmVkTW9kZWwiLCJmcm9tU3VwZXJ2aXNlZFR1bmluZ1NwZWMiLCJmcm9tUHJlZmVyZW5jZU9wdGltaXphdGlvblNwZWMiLCJmcm9tVHVuaW5nRGF0YVN0YXRzIiwiZnJvbUVuY3J5cHRpb25TcGVjIiwiZnJvbVBhcnRuZXJNb2RlbFR1bmluZ1NwZWMiLCJmcm9tQ3VzdG9tQmFzZU1vZGVsIiwiZnJvbUV4cGVyaW1lbnQiLCJmcm9tT3V0cHV0VXJpIiwiZnJvbVBpcGVsaW5lSm9iIiwiZnJvbVNlcnZpY2VBY2NvdW50IiwiZnJvbVZlb1R1bmluZ1NwZWMiLCJ0dW5pbmdPcGVyYXRpb25Gcm9tTWxkZXYiLCJUdW5pbmdzIiwiZ2V0SW50ZXJuYWwiLCJ0dW5lSW50ZXJuYWwiLCJ0dW5lTWxkZXZJbnRlcm5hbCIsIlBBR0VEX0lURU1fVFVOSU5HX0pPQlMiLCJ0dW5lIiwiYmFzZU1vZGVsIiwicHJlVHVuZWRNb2RlbCIsInR1bmVkTW9kZWxOYW1lIiwicHJlVHVuZWRNb2RlbENoZWNrcG9pbnRJZCIsImNoZWNrcG9pbnRJZCIsInBhcmFtc1ByaXZhdGUiLCJ0dW5pbmdKb2IiLCJKT0JfU1RBVEVfUVVFVUVEIiwiQnJvd3NlckRvd25sb2FkZXIiLCJfcGFyYW1zIiwiX2FwaUNsaWVudCIsIk1BWF9DSFVOS19TSVpFIiwiTUFYX1JFVFJZX0NPVU5UIiwiSU5JVElBTF9SRVRSWV9ERUxBWV9NUyIsIkRFTEFZX01VTFRJUExJRVIiLCJYX0dPT0dfVVBMT0FEX1NUQVRVU19IRUFERVJfRklFTEQiLCJ1cGxvYWRCbG9iIiwidXBsb2FkQmxvYkludGVybmFsIiwicmVzcG9uc2VKc29uIiwidXBsb2FkQmxvYlRvRmlsZVNlYXJjaFN0b3JlIiwiZmlsZVNpemUiLCJvZmZzZXQiLCJ1cGxvYWRDb21tYW5kIiwiY2h1bmtTaXplIiwibWluIiwicmV0cnlDb3VudCIsImN1cnJlbnREZWxheU1zIiwic2xlZXAiLCJnZXRCbG9iU3RhdCIsIm1zIiwicmVzb2x2ZVByb21pc2UiLCJCcm93c2VyVXBsb2FkZXIiLCJCcm93c2VyV2ViU29ja2V0RmFjdG9yeSIsIkJyb3dzZXJXZWJTb2NrZXQiLCJ3cyIsIldlYlNvY2tldCIsIkdPT0dMRV9BUElfS0VZX0hFQURFUiIsIldlYkF1dGgiLCJMQU5HVUFHRV9MQUJFTF9QUkVGSVgiLCJHb29nbGVHZW5BSSIsImxpdmUiLCJiYXRjaGVzIiwiY2hhdHMiLCJjYWNoZXMiLCJmaWxlcyIsIm9wZXJhdGlvbnMiLCJhdXRoVG9rZW5zIiwidHVuaW5ncyIsImZpbGVTZWFyY2hTdG9yZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@google/genai/dist/web/index.mjs\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5CUsers%5CDream%5Cray-egypt-8%5Capp%5Cglobals.css&modules=C%3A%5CUsers%5CDream%5Cray-egypt-8%5Ccomponents%5Ccommon%5CGeminiAssistant.tsx&modules=C%3A%5CUsers%5CDream%5Cray-egypt-8%5Ccomponents%5Ccommon%5CThemeContext.tsx&modules=C%3A%5CUsers%5CDream%5Cray-egypt-8%5Ccomponents%5Ccommon%5CToastContext.tsx&modules=C%3A%5CUsers%5CDream%5Cray-egypt-8%5Ccontext%5CAuthContext.tsx&modules=C%3A%5CUsers%5CDream%5Cray-egypt-8%5Ccontext%5CLanguageContext.tsx&modules=C%3A%5CUsers%5CDream%5Cray-egypt-8%5Cnode_modules%5Cnext%5Cfont%5Cgoogle%5Ctarget.css%3F%7B%22path%22%3A%22app%5C%5Clayout.tsx%22%2C%22import%22%3A%22Cairo%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22arabic%22%2C%22latin%22%5D%2C%22variable%22%3A%22--font-cairo%22%7D%5D%2C%22variableName%22%3A%22cairo%22%7D&modules=C%3A%5CUsers%5CDream%5Cray-egypt-8%5Cnode_modules%5Cnext%5Cfont%5Cgoogle%5Ctarget.css%3F%7B%22path%22%3A%22app%5C%5Clayout.tsx%22%2C%22import%22%3A%22Dancing_Script%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22latin%22%5D%2C%22variable%22%3A%22--font-dancing%22%7D%5D%2C%22variableName%22%3A%22dancing%22%7D&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);