"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@google";
exports.ids = ["vendor-chunks/@google"];
exports.modules = {

/***/ "(ssr)/./node_modules/@google/genai/dist/node/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@google/genai/dist/node/index.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActivityHandling: () => (/* binding */ ActivityHandling),\n/* harmony export */   AdapterSize: () => (/* binding */ AdapterSize),\n/* harmony export */   ApiError: () => (/* binding */ ApiError),\n/* harmony export */   ApiSpec: () => (/* binding */ ApiSpec),\n/* harmony export */   AuthType: () => (/* binding */ AuthType),\n/* harmony export */   Batches: () => (/* binding */ Batches),\n/* harmony export */   Behavior: () => (/* binding */ Behavior),\n/* harmony export */   BlockedReason: () => (/* binding */ BlockedReason),\n/* harmony export */   Caches: () => (/* binding */ Caches),\n/* harmony export */   CancelTuningJobResponse: () => (/* binding */ CancelTuningJobResponse),\n/* harmony export */   Chat: () => (/* binding */ Chat),\n/* harmony export */   Chats: () => (/* binding */ Chats),\n/* harmony export */   ComputeTokensResponse: () => (/* binding */ ComputeTokensResponse),\n/* harmony export */   ContentReferenceImage: () => (/* binding */ ContentReferenceImage),\n/* harmony export */   ControlReferenceImage: () => (/* binding */ ControlReferenceImage),\n/* harmony export */   ControlReferenceType: () => (/* binding */ ControlReferenceType),\n/* harmony export */   CountTokensResponse: () => (/* binding */ CountTokensResponse),\n/* harmony export */   CreateFileResponse: () => (/* binding */ CreateFileResponse),\n/* harmony export */   DeleteCachedContentResponse: () => (/* binding */ DeleteCachedContentResponse),\n/* harmony export */   DeleteFileResponse: () => (/* binding */ DeleteFileResponse),\n/* harmony export */   DeleteModelResponse: () => (/* binding */ DeleteModelResponse),\n/* harmony export */   DocumentState: () => (/* binding */ DocumentState),\n/* harmony export */   DynamicRetrievalConfigMode: () => (/* binding */ DynamicRetrievalConfigMode),\n/* harmony export */   EditImageResponse: () => (/* binding */ EditImageResponse),\n/* harmony export */   EditMode: () => (/* binding */ EditMode),\n/* harmony export */   EmbedContentResponse: () => (/* binding */ EmbedContentResponse),\n/* harmony export */   EndSensitivity: () => (/* binding */ EndSensitivity),\n/* harmony export */   Environment: () => (/* binding */ Environment),\n/* harmony export */   FeatureSelectionPreference: () => (/* binding */ FeatureSelectionPreference),\n/* harmony export */   FileSource: () => (/* binding */ FileSource),\n/* harmony export */   FileState: () => (/* binding */ FileState),\n/* harmony export */   Files: () => (/* binding */ Files),\n/* harmony export */   FinishReason: () => (/* binding */ FinishReason),\n/* harmony export */   FunctionCallingConfigMode: () => (/* binding */ FunctionCallingConfigMode),\n/* harmony export */   FunctionResponse: () => (/* binding */ FunctionResponse),\n/* harmony export */   FunctionResponseBlob: () => (/* binding */ FunctionResponseBlob),\n/* harmony export */   FunctionResponseFileData: () => (/* binding */ FunctionResponseFileData),\n/* harmony export */   FunctionResponsePart: () => (/* binding */ FunctionResponsePart),\n/* harmony export */   FunctionResponseScheduling: () => (/* binding */ FunctionResponseScheduling),\n/* harmony export */   GenerateContentResponse: () => (/* binding */ GenerateContentResponse),\n/* harmony export */   GenerateContentResponsePromptFeedback: () => (/* binding */ GenerateContentResponsePromptFeedback),\n/* harmony export */   GenerateContentResponseUsageMetadata: () => (/* binding */ GenerateContentResponseUsageMetadata),\n/* harmony export */   GenerateImagesResponse: () => (/* binding */ GenerateImagesResponse),\n/* harmony export */   GenerateVideosOperation: () => (/* binding */ GenerateVideosOperation),\n/* harmony export */   GenerateVideosResponse: () => (/* binding */ GenerateVideosResponse),\n/* harmony export */   GoogleGenAI: () => (/* binding */ GoogleGenAI),\n/* harmony export */   HarmBlockMethod: () => (/* binding */ HarmBlockMethod),\n/* harmony export */   HarmBlockThreshold: () => (/* binding */ HarmBlockThreshold),\n/* harmony export */   HarmCategory: () => (/* binding */ HarmCategory),\n/* harmony export */   HarmProbability: () => (/* binding */ HarmProbability),\n/* harmony export */   HarmSeverity: () => (/* binding */ HarmSeverity),\n/* harmony export */   HttpElementLocation: () => (/* binding */ HttpElementLocation),\n/* harmony export */   HttpResponse: () => (/* binding */ HttpResponse),\n/* harmony export */   ImagePromptLanguage: () => (/* binding */ ImagePromptLanguage),\n/* harmony export */   ImportFileOperation: () => (/* binding */ ImportFileOperation),\n/* harmony export */   ImportFileResponse: () => (/* binding */ ImportFileResponse),\n/* harmony export */   InlinedEmbedContentResponse: () => (/* binding */ InlinedEmbedContentResponse),\n/* harmony export */   InlinedResponse: () => (/* binding */ InlinedResponse),\n/* harmony export */   JobState: () => (/* binding */ JobState),\n/* harmony export */   Language: () => (/* binding */ Language),\n/* harmony export */   ListBatchJobsResponse: () => (/* binding */ ListBatchJobsResponse),\n/* harmony export */   ListCachedContentsResponse: () => (/* binding */ ListCachedContentsResponse),\n/* harmony export */   ListDocumentsResponse: () => (/* binding */ ListDocumentsResponse),\n/* harmony export */   ListFileSearchStoresResponse: () => (/* binding */ ListFileSearchStoresResponse),\n/* harmony export */   ListFilesResponse: () => (/* binding */ ListFilesResponse),\n/* harmony export */   ListModelsResponse: () => (/* binding */ ListModelsResponse),\n/* harmony export */   ListTuningJobsResponse: () => (/* binding */ ListTuningJobsResponse),\n/* harmony export */   Live: () => (/* binding */ Live),\n/* harmony export */   LiveClientToolResponse: () => (/* binding */ LiveClientToolResponse),\n/* harmony export */   LiveMusicPlaybackControl: () => (/* binding */ LiveMusicPlaybackControl),\n/* harmony export */   LiveMusicServerMessage: () => (/* binding */ LiveMusicServerMessage),\n/* harmony export */   LiveSendToolResponseParameters: () => (/* binding */ LiveSendToolResponseParameters),\n/* harmony export */   LiveServerMessage: () => (/* binding */ LiveServerMessage),\n/* harmony export */   MaskReferenceImage: () => (/* binding */ MaskReferenceImage),\n/* harmony export */   MaskReferenceMode: () => (/* binding */ MaskReferenceMode),\n/* harmony export */   MediaModality: () => (/* binding */ MediaModality),\n/* harmony export */   MediaResolution: () => (/* binding */ MediaResolution),\n/* harmony export */   Modality: () => (/* binding */ Modality),\n/* harmony export */   Mode: () => (/* binding */ Mode),\n/* harmony export */   Models: () => (/* binding */ Models),\n/* harmony export */   MusicGenerationMode: () => (/* binding */ MusicGenerationMode),\n/* harmony export */   Operations: () => (/* binding */ Operations),\n/* harmony export */   Outcome: () => (/* binding */ Outcome),\n/* harmony export */   PagedItem: () => (/* binding */ PagedItem),\n/* harmony export */   Pager: () => (/* binding */ Pager),\n/* harmony export */   PartMediaResolutionLevel: () => (/* binding */ PartMediaResolutionLevel),\n/* harmony export */   PersonGeneration: () => (/* binding */ PersonGeneration),\n/* harmony export */   PhishBlockThreshold: () => (/* binding */ PhishBlockThreshold),\n/* harmony export */   RawReferenceImage: () => (/* binding */ RawReferenceImage),\n/* harmony export */   RecontextImageResponse: () => (/* binding */ RecontextImageResponse),\n/* harmony export */   ReplayResponse: () => (/* binding */ ReplayResponse),\n/* harmony export */   SafetyFilterLevel: () => (/* binding */ SafetyFilterLevel),\n/* harmony export */   Scale: () => (/* binding */ Scale),\n/* harmony export */   SegmentImageResponse: () => (/* binding */ SegmentImageResponse),\n/* harmony export */   SegmentMode: () => (/* binding */ SegmentMode),\n/* harmony export */   Session: () => (/* binding */ Session),\n/* harmony export */   SingleEmbedContentResponse: () => (/* binding */ SingleEmbedContentResponse),\n/* harmony export */   StartSensitivity: () => (/* binding */ StartSensitivity),\n/* harmony export */   StyleReferenceImage: () => (/* binding */ StyleReferenceImage),\n/* harmony export */   SubjectReferenceImage: () => (/* binding */ SubjectReferenceImage),\n/* harmony export */   SubjectReferenceType: () => (/* binding */ SubjectReferenceType),\n/* harmony export */   ThinkingLevel: () => (/* binding */ ThinkingLevel),\n/* harmony export */   Tokens: () => (/* binding */ Tokens),\n/* harmony export */   TrafficType: () => (/* binding */ TrafficType),\n/* harmony export */   TuningMethod: () => (/* binding */ TuningMethod),\n/* harmony export */   TuningMode: () => (/* binding */ TuningMode),\n/* harmony export */   TuningTask: () => (/* binding */ TuningTask),\n/* harmony export */   TurnCompleteReason: () => (/* binding */ TurnCompleteReason),\n/* harmony export */   TurnCoverage: () => (/* binding */ TurnCoverage),\n/* harmony export */   Type: () => (/* binding */ Type),\n/* harmony export */   UploadToFileSearchStoreOperation: () => (/* binding */ UploadToFileSearchStoreOperation),\n/* harmony export */   UploadToFileSearchStoreResponse: () => (/* binding */ UploadToFileSearchStoreResponse),\n/* harmony export */   UploadToFileSearchStoreResumableResponse: () => (/* binding */ UploadToFileSearchStoreResumableResponse),\n/* harmony export */   UpscaleImageResponse: () => (/* binding */ UpscaleImageResponse),\n/* harmony export */   UrlRetrievalStatus: () => (/* binding */ UrlRetrievalStatus),\n/* harmony export */   VideoCompressionQuality: () => (/* binding */ VideoCompressionQuality),\n/* harmony export */   VideoGenerationMaskMode: () => (/* binding */ VideoGenerationMaskMode),\n/* harmony export */   VideoGenerationReferenceType: () => (/* binding */ VideoGenerationReferenceType),\n/* harmony export */   createFunctionResponsePartFromBase64: () => (/* binding */ createFunctionResponsePartFromBase64),\n/* harmony export */   createFunctionResponsePartFromUri: () => (/* binding */ createFunctionResponsePartFromUri),\n/* harmony export */   createModelContent: () => (/* binding */ createModelContent),\n/* harmony export */   createPartFromBase64: () => (/* binding */ createPartFromBase64),\n/* harmony export */   createPartFromCodeExecutionResult: () => (/* binding */ createPartFromCodeExecutionResult),\n/* harmony export */   createPartFromExecutableCode: () => (/* binding */ createPartFromExecutableCode),\n/* harmony export */   createPartFromFunctionCall: () => (/* binding */ createPartFromFunctionCall),\n/* harmony export */   createPartFromFunctionResponse: () => (/* binding */ createPartFromFunctionResponse),\n/* harmony export */   createPartFromText: () => (/* binding */ createPartFromText),\n/* harmony export */   createPartFromUri: () => (/* binding */ createPartFromUri),\n/* harmony export */   createUserContent: () => (/* binding */ createUserContent),\n/* harmony export */   mcpToTool: () => (/* binding */ mcpToTool),\n/* harmony export */   setDefaultBaseUrls: () => (/* binding */ setDefaultBaseUrls)\n/* harmony export */ });\n/* harmony import */ var google_auth_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! google-auth-library */ \"(ssr)/./node_modules/google-auth-library/build/src/index.js\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fs/promises */ \"fs/promises\");\n/* harmony import */ var node_stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! node:stream */ \"node:stream\");\n/* harmony import */ var node_stream_promises__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! node:stream/promises */ \"node:stream/promises\");\n/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ws */ \"(ssr)/./node_modules/ws/wrapper.mjs\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! path */ \"path\");\n\n\n\n\n\n\n\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ let _defaultBaseGeminiUrl = undefined;\nlet _defaultBaseVertexUrl = undefined;\n/**\n * Overrides the base URLs for the Gemini API and Vertex AI API.\n *\n * @remarks This function should be called before initializing the SDK. If the\n * base URLs are set after initializing the SDK, the base URLs will not be\n * updated. Base URLs provided in the HttpOptions will also take precedence over\n * URLs set here.\n *\n * @example\n * ```ts\n * import {GoogleGenAI, setDefaultBaseUrls} from '@google/genai';\n * // Override the base URL for the Gemini API.\n * setDefaultBaseUrls({geminiUrl:'https://gemini.google.com'});\n *\n * // Override the base URL for the Vertex AI API.\n * setDefaultBaseUrls({vertexUrl: 'https://vertexai.googleapis.com'});\n *\n * const ai = new GoogleGenAI({apiKey: 'GEMINI_API_KEY'});\n * ```\n */ function setDefaultBaseUrls(baseUrlParams) {\n    _defaultBaseGeminiUrl = baseUrlParams.geminiUrl;\n    _defaultBaseVertexUrl = baseUrlParams.vertexUrl;\n}\n/**\n * Returns the default base URLs for the Gemini API and Vertex AI API.\n */ function getDefaultBaseUrls() {\n    return {\n        geminiUrl: _defaultBaseGeminiUrl,\n        vertexUrl: _defaultBaseVertexUrl\n    };\n}\n/**\n * Returns the default base URL based on the following priority:\n *   1. Base URLs set via HttpOptions.\n *   2. Base URLs set via the latest call to setDefaultBaseUrls.\n *   3. Base URLs set via environment variables.\n */ function getBaseUrl(httpOptions, vertexai, vertexBaseUrlFromEnv, geminiBaseUrlFromEnv) {\n    var _a, _b;\n    if (!(httpOptions === null || httpOptions === void 0 ? void 0 : httpOptions.baseUrl)) {\n        const defaultBaseUrls = getDefaultBaseUrls();\n        if (vertexai) {\n            return (_a = defaultBaseUrls.vertexUrl) !== null && _a !== void 0 ? _a : vertexBaseUrlFromEnv;\n        } else {\n            return (_b = defaultBaseUrls.geminiUrl) !== null && _b !== void 0 ? _b : geminiBaseUrlFromEnv;\n        }\n    }\n    return httpOptions.baseUrl;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class BaseModule {\n}\nfunction formatMap(templateString, valueMap) {\n    // Use a regular expression to find all placeholders in the template string\n    const regex = /\\{([^}]+)\\}/g;\n    // Replace each placeholder with its corresponding value from the valueMap\n    return templateString.replace(regex, (match, key)=>{\n        if (Object.prototype.hasOwnProperty.call(valueMap, key)) {\n            const value = valueMap[key];\n            // Convert the value to a string if it's not a string already\n            return value !== undefined && value !== null ? String(value) : \"\";\n        } else {\n            // Handle missing keys\n            throw new Error(`Key '${key}' not found in valueMap.`);\n        }\n    });\n}\nfunction setValueByPath(data, keys, value) {\n    for(let i = 0; i < keys.length - 1; i++){\n        const key = keys[i];\n        if (key.endsWith(\"[]\")) {\n            const keyName = key.slice(0, -2);\n            if (!(keyName in data)) {\n                if (Array.isArray(value)) {\n                    data[keyName] = Array.from({\n                        length: value.length\n                    }, ()=>({}));\n                } else {\n                    throw new Error(`Value must be a list given an array path ${key}`);\n                }\n            }\n            if (Array.isArray(data[keyName])) {\n                const arrayData = data[keyName];\n                if (Array.isArray(value)) {\n                    for(let j = 0; j < arrayData.length; j++){\n                        const entry = arrayData[j];\n                        setValueByPath(entry, keys.slice(i + 1), value[j]);\n                    }\n                } else {\n                    for (const d of arrayData){\n                        setValueByPath(d, keys.slice(i + 1), value);\n                    }\n                }\n            }\n            return;\n        } else if (key.endsWith(\"[0]\")) {\n            const keyName = key.slice(0, -3);\n            if (!(keyName in data)) {\n                data[keyName] = [\n                    {}\n                ];\n            }\n            const arrayData = data[keyName];\n            setValueByPath(arrayData[0], keys.slice(i + 1), value);\n            return;\n        }\n        if (!data[key] || typeof data[key] !== \"object\") {\n            data[key] = {};\n        }\n        data = data[key];\n    }\n    const keyToSet = keys[keys.length - 1];\n    const existingData = data[keyToSet];\n    if (existingData !== undefined) {\n        if (!value || typeof value === \"object\" && Object.keys(value).length === 0) {\n            return;\n        }\n        if (value === existingData) {\n            return;\n        }\n        if (typeof existingData === \"object\" && typeof value === \"object\" && existingData !== null && value !== null) {\n            Object.assign(existingData, value);\n        } else {\n            throw new Error(`Cannot set value for an existing key. Key: ${keyToSet}`);\n        }\n    } else {\n        if (keyToSet === \"_self\" && typeof value === \"object\" && value !== null && !Array.isArray(value)) {\n            const valueAsRecord = value;\n            Object.assign(data, valueAsRecord);\n        } else {\n            data[keyToSet] = value;\n        }\n    }\n}\nfunction getValueByPath(data, keys, defaultValue = undefined) {\n    try {\n        if (keys.length === 1 && keys[0] === \"_self\") {\n            return data;\n        }\n        for(let i = 0; i < keys.length; i++){\n            if (typeof data !== \"object\" || data === null) {\n                return defaultValue;\n            }\n            const key = keys[i];\n            if (key.endsWith(\"[]\")) {\n                const keyName = key.slice(0, -2);\n                if (keyName in data) {\n                    const arrayData = data[keyName];\n                    if (!Array.isArray(arrayData)) {\n                        return defaultValue;\n                    }\n                    return arrayData.map((d)=>getValueByPath(d, keys.slice(i + 1), defaultValue));\n                } else {\n                    return defaultValue;\n                }\n            } else {\n                data = data[key];\n            }\n        }\n        return data;\n    } catch (error) {\n        if (error instanceof TypeError) {\n            return defaultValue;\n        }\n        throw error;\n    }\n}\n/**\n * Moves values from source paths to destination paths.\n *\n * Examples:\n *   moveValueByPath(\n *     {'requests': [{'content': v1}, {'content': v2}]},\n *     {'requests[].*': 'requests[].request.*'}\n *   )\n *     -> {'requests': [{'request': {'content': v1}}, {'request': {'content': v2}}]}\n */ function moveValueByPath(data, paths) {\n    for (const [sourcePath, destPath] of Object.entries(paths)){\n        const sourceKeys = sourcePath.split(\".\");\n        const destKeys = destPath.split(\".\");\n        // Determine keys to exclude from wildcard to avoid cyclic references\n        const excludeKeys = new Set();\n        let wildcardIdx = -1;\n        for(let i = 0; i < sourceKeys.length; i++){\n            if (sourceKeys[i] === \"*\") {\n                wildcardIdx = i;\n                break;\n            }\n        }\n        if (wildcardIdx !== -1 && destKeys.length > wildcardIdx) {\n            // Extract the intermediate key between source and dest paths\n            // Example: source=['requests[]', '*'], dest=['requests[]', 'request', '*']\n            // We want to exclude 'request'\n            for(let i = wildcardIdx; i < destKeys.length; i++){\n                const key = destKeys[i];\n                if (key !== \"*\" && !key.endsWith(\"[]\") && !key.endsWith(\"[0]\")) {\n                    excludeKeys.add(key);\n                }\n            }\n        }\n        _moveValueRecursive(data, sourceKeys, destKeys, 0, excludeKeys);\n    }\n}\n/**\n * Recursively moves values from source path to destination path.\n */ function _moveValueRecursive(data, sourceKeys, destKeys, keyIdx, excludeKeys) {\n    if (keyIdx >= sourceKeys.length) {\n        return;\n    }\n    if (typeof data !== \"object\" || data === null) {\n        return;\n    }\n    const key = sourceKeys[keyIdx];\n    if (key.endsWith(\"[]\")) {\n        const keyName = key.slice(0, -2);\n        const dataRecord = data;\n        if (keyName in dataRecord && Array.isArray(dataRecord[keyName])) {\n            for (const item of dataRecord[keyName]){\n                _moveValueRecursive(item, sourceKeys, destKeys, keyIdx + 1, excludeKeys);\n            }\n        }\n    } else if (key === \"*\") {\n        // wildcard - move all fields\n        if (typeof data === \"object\" && data !== null && !Array.isArray(data)) {\n            const dataRecord = data;\n            const keysToMove = Object.keys(dataRecord).filter((k)=>!k.startsWith(\"_\") && !excludeKeys.has(k));\n            const valuesToMove = {};\n            for (const k of keysToMove){\n                valuesToMove[k] = dataRecord[k];\n            }\n            // Set values at destination\n            for (const [k, v] of Object.entries(valuesToMove)){\n                const newDestKeys = [];\n                for (const dk of destKeys.slice(keyIdx)){\n                    if (dk === \"*\") {\n                        newDestKeys.push(k);\n                    } else {\n                        newDestKeys.push(dk);\n                    }\n                }\n                setValueByPath(dataRecord, newDestKeys, v);\n            }\n            for (const k of keysToMove){\n                delete dataRecord[k];\n            }\n        }\n    } else {\n        // Navigate to next level\n        const dataRecord = data;\n        if (key in dataRecord) {\n            _moveValueRecursive(dataRecord[key], sourceKeys, destKeys, keyIdx + 1, excludeKeys);\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function tBytes$1(fromBytes) {\n    if (typeof fromBytes !== \"string\") {\n        throw new Error(\"fromImageBytes must be a string\");\n    }\n    // TODO(b/389133914): Remove dummy bytes converter.\n    return fromBytes;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ // Code generated by the Google Gen AI SDK generator DO NOT EDIT.\nfunction fetchPredictOperationParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromOperationName = getValueByPath(fromObject, [\n        \"operationName\"\n    ]);\n    if (fromOperationName != null) {\n        setValueByPath(toObject, [\n            \"operationName\"\n        ], fromOperationName);\n    }\n    const fromResourceName = getValueByPath(fromObject, [\n        \"resourceName\"\n    ]);\n    if (fromResourceName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"resourceName\"\n        ], fromResourceName);\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\",\n        \"generateVideoResponse\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], generateVideosResponseFromMldev$1(fromResponse));\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], generateVideosResponseFromVertex$1(fromResponse));\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, [\n        \"generatedSamples\"\n    ]);\n    if (fromGeneratedVideos != null) {\n        let transformedList = fromGeneratedVideos;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedVideoFromMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedVideos\"\n        ], transformedList);\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        \"raiMediaFilteredCount\"\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredCount\"\n        ], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        \"raiMediaFilteredReasons\"\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredReasons\"\n        ], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, [\n        \"videos\"\n    ]);\n    if (fromGeneratedVideos != null) {\n        let transformedList = fromGeneratedVideos;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedVideoFromVertex$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedVideos\"\n        ], transformedList);\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        \"raiMediaFilteredCount\"\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredCount\"\n        ], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        \"raiMediaFilteredReasons\"\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredReasons\"\n        ], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generatedVideoFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, [\n        \"video\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"video\"\n        ], videoFromMldev$1(fromVideo));\n    }\n    return toObject;\n}\nfunction generatedVideoFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"video\"\n        ], videoFromVertex$1(fromVideo));\n    }\n    return toObject;\n}\nfunction getOperationParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromOperationName = getValueByPath(fromObject, [\n        \"operationName\"\n    ]);\n    if (fromOperationName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"operationName\"\n        ], fromOperationName);\n    }\n    return toObject;\n}\nfunction getOperationParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromOperationName = getValueByPath(fromObject, [\n        \"operationName\"\n    ]);\n    if (fromOperationName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"operationName\"\n        ], fromOperationName);\n    }\n    return toObject;\n}\nfunction importFileOperationFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], importFileResponseFromMldev$1(fromResponse));\n    }\n    return toObject;\n}\nfunction importFileResponseFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromParent = getValueByPath(fromObject, [\n        \"parent\"\n    ]);\n    if (fromParent != null) {\n        setValueByPath(toObject, [\n            \"parent\"\n        ], fromParent);\n    }\n    const fromDocumentName = getValueByPath(fromObject, [\n        \"documentName\"\n    ]);\n    if (fromDocumentName != null) {\n        setValueByPath(toObject, [\n            \"documentName\"\n        ], fromDocumentName);\n    }\n    return toObject;\n}\nfunction uploadToFileSearchStoreOperationFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], uploadToFileSearchStoreResponseFromMldev(fromResponse));\n    }\n    return toObject;\n}\nfunction uploadToFileSearchStoreResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromParent = getValueByPath(fromObject, [\n        \"parent\"\n    ]);\n    if (fromParent != null) {\n        setValueByPath(toObject, [\n            \"parent\"\n        ], fromParent);\n    }\n    const fromDocumentName = getValueByPath(fromObject, [\n        \"documentName\"\n    ]);\n    if (fromDocumentName != null) {\n        setValueByPath(toObject, [\n            \"documentName\"\n        ], fromDocumentName);\n    }\n    return toObject;\n}\nfunction videoFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, [\n        \"uri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"uri\"\n        ], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        \"encodedVideo\"\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, [\n            \"videoBytes\"\n        ], tBytes$1(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"encoding\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction videoFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"uri\"\n        ], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        \"bytesBase64Encoded\"\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, [\n            \"videoBytes\"\n        ], tBytes$1(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ /** Outcome of the code execution. */ var Outcome;\n(function(Outcome) {\n    /**\n     * Unspecified status. This value should not be used.\n     */ Outcome[\"OUTCOME_UNSPECIFIED\"] = \"OUTCOME_UNSPECIFIED\";\n    /**\n     * Code execution completed successfully.\n     */ Outcome[\"OUTCOME_OK\"] = \"OUTCOME_OK\";\n    /**\n     * Code execution finished but with a failure. `stderr` should contain the reason.\n     */ Outcome[\"OUTCOME_FAILED\"] = \"OUTCOME_FAILED\";\n    /**\n     * Code execution ran for too long, and was cancelled. There may or may not be a partial output present.\n     */ Outcome[\"OUTCOME_DEADLINE_EXCEEDED\"] = \"OUTCOME_DEADLINE_EXCEEDED\";\n})(Outcome || (Outcome = {}));\n/** Programming language of the `code`. */ var Language;\n(function(Language) {\n    /**\n     * Unspecified language. This value should not be used.\n     */ Language[\"LANGUAGE_UNSPECIFIED\"] = \"LANGUAGE_UNSPECIFIED\";\n    /**\n     * Python >= 3.10, with numpy and simpy available.\n     */ Language[\"PYTHON\"] = \"PYTHON\";\n})(Language || (Language = {}));\n/** Specifies how the response should be scheduled in the conversation. */ var FunctionResponseScheduling;\n(function(FunctionResponseScheduling) {\n    /**\n     * This value is unused.\n     */ FunctionResponseScheduling[\"SCHEDULING_UNSPECIFIED\"] = \"SCHEDULING_UNSPECIFIED\";\n    /**\n     * Only add the result to the conversation context, do not interrupt or trigger generation.\n     */ FunctionResponseScheduling[\"SILENT\"] = \"SILENT\";\n    /**\n     * Add the result to the conversation context, and prompt to generate output without interrupting ongoing generation.\n     */ FunctionResponseScheduling[\"WHEN_IDLE\"] = \"WHEN_IDLE\";\n    /**\n     * Add the result to the conversation context, interrupt ongoing generation and prompt to generate output.\n     */ FunctionResponseScheduling[\"INTERRUPT\"] = \"INTERRUPT\";\n})(FunctionResponseScheduling || (FunctionResponseScheduling = {}));\n/** The type of the data. */ var Type;\n(function(Type) {\n    /**\n     * Not specified, should not be used.\n     */ Type[\"TYPE_UNSPECIFIED\"] = \"TYPE_UNSPECIFIED\";\n    /**\n     * OpenAPI string type\n     */ Type[\"STRING\"] = \"STRING\";\n    /**\n     * OpenAPI number type\n     */ Type[\"NUMBER\"] = \"NUMBER\";\n    /**\n     * OpenAPI integer type\n     */ Type[\"INTEGER\"] = \"INTEGER\";\n    /**\n     * OpenAPI boolean type\n     */ Type[\"BOOLEAN\"] = \"BOOLEAN\";\n    /**\n     * OpenAPI array type\n     */ Type[\"ARRAY\"] = \"ARRAY\";\n    /**\n     * OpenAPI object type\n     */ Type[\"OBJECT\"] = \"OBJECT\";\n    /**\n     * Null type\n     */ Type[\"NULL\"] = \"NULL\";\n})(Type || (Type = {}));\n/** The mode of the predictor to be used in dynamic retrieval. */ var Mode;\n(function(Mode) {\n    /**\n     * Always trigger retrieval.\n     */ Mode[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n    /**\n     * Run retrieval only when system decides it is necessary.\n     */ Mode[\"MODE_DYNAMIC\"] = \"MODE_DYNAMIC\";\n})(Mode || (Mode = {}));\n/** The API spec that the external API implements. This enum is not supported in Gemini API. */ var ApiSpec;\n(function(ApiSpec) {\n    /**\n     * Unspecified API spec. This value should not be used.\n     */ ApiSpec[\"API_SPEC_UNSPECIFIED\"] = \"API_SPEC_UNSPECIFIED\";\n    /**\n     * Simple search API spec.\n     */ ApiSpec[\"SIMPLE_SEARCH\"] = \"SIMPLE_SEARCH\";\n    /**\n     * Elastic search API spec.\n     */ ApiSpec[\"ELASTIC_SEARCH\"] = \"ELASTIC_SEARCH\";\n})(ApiSpec || (ApiSpec = {}));\n/** Type of auth scheme. This enum is not supported in Gemini API. */ var AuthType;\n(function(AuthType) {\n    AuthType[\"AUTH_TYPE_UNSPECIFIED\"] = \"AUTH_TYPE_UNSPECIFIED\";\n    /**\n     * No Auth.\n     */ AuthType[\"NO_AUTH\"] = \"NO_AUTH\";\n    /**\n     * API Key Auth.\n     */ AuthType[\"API_KEY_AUTH\"] = \"API_KEY_AUTH\";\n    /**\n     * HTTP Basic Auth.\n     */ AuthType[\"HTTP_BASIC_AUTH\"] = \"HTTP_BASIC_AUTH\";\n    /**\n     * Google Service Account Auth.\n     */ AuthType[\"GOOGLE_SERVICE_ACCOUNT_AUTH\"] = \"GOOGLE_SERVICE_ACCOUNT_AUTH\";\n    /**\n     * OAuth auth.\n     */ AuthType[\"OAUTH\"] = \"OAUTH\";\n    /**\n     * OpenID Connect (OIDC) Auth.\n     */ AuthType[\"OIDC_AUTH\"] = \"OIDC_AUTH\";\n})(AuthType || (AuthType = {}));\n/** The location of the API key. This enum is not supported in Gemini API. */ var HttpElementLocation;\n(function(HttpElementLocation) {\n    HttpElementLocation[\"HTTP_IN_UNSPECIFIED\"] = \"HTTP_IN_UNSPECIFIED\";\n    /**\n     * Element is in the HTTP request query.\n     */ HttpElementLocation[\"HTTP_IN_QUERY\"] = \"HTTP_IN_QUERY\";\n    /**\n     * Element is in the HTTP request header.\n     */ HttpElementLocation[\"HTTP_IN_HEADER\"] = \"HTTP_IN_HEADER\";\n    /**\n     * Element is in the HTTP request path.\n     */ HttpElementLocation[\"HTTP_IN_PATH\"] = \"HTTP_IN_PATH\";\n    /**\n     * Element is in the HTTP request body.\n     */ HttpElementLocation[\"HTTP_IN_BODY\"] = \"HTTP_IN_BODY\";\n    /**\n     * Element is in the HTTP request cookie.\n     */ HttpElementLocation[\"HTTP_IN_COOKIE\"] = \"HTTP_IN_COOKIE\";\n})(HttpElementLocation || (HttpElementLocation = {}));\n/** Sites with confidence level chosen & above this value will be blocked from the search results. This enum is not supported in Gemini API. */ var PhishBlockThreshold;\n(function(PhishBlockThreshold) {\n    /**\n     * Defaults to unspecified.\n     */ PhishBlockThreshold[\"PHISH_BLOCK_THRESHOLD_UNSPECIFIED\"] = \"PHISH_BLOCK_THRESHOLD_UNSPECIFIED\";\n    /**\n     * Blocks Low and above confidence URL that is risky.\n     */ PhishBlockThreshold[\"BLOCK_LOW_AND_ABOVE\"] = \"BLOCK_LOW_AND_ABOVE\";\n    /**\n     * Blocks Medium and above confidence URL that is risky.\n     */ PhishBlockThreshold[\"BLOCK_MEDIUM_AND_ABOVE\"] = \"BLOCK_MEDIUM_AND_ABOVE\";\n    /**\n     * Blocks High and above confidence URL that is risky.\n     */ PhishBlockThreshold[\"BLOCK_HIGH_AND_ABOVE\"] = \"BLOCK_HIGH_AND_ABOVE\";\n    /**\n     * Blocks Higher and above confidence URL that is risky.\n     */ PhishBlockThreshold[\"BLOCK_HIGHER_AND_ABOVE\"] = \"BLOCK_HIGHER_AND_ABOVE\";\n    /**\n     * Blocks Very high and above confidence URL that is risky.\n     */ PhishBlockThreshold[\"BLOCK_VERY_HIGH_AND_ABOVE\"] = \"BLOCK_VERY_HIGH_AND_ABOVE\";\n    /**\n     * Blocks Extremely high confidence URL that is risky.\n     */ PhishBlockThreshold[\"BLOCK_ONLY_EXTREMELY_HIGH\"] = \"BLOCK_ONLY_EXTREMELY_HIGH\";\n})(PhishBlockThreshold || (PhishBlockThreshold = {}));\n/** The level of thoughts tokens that the model should generate. */ var ThinkingLevel;\n(function(ThinkingLevel) {\n    /**\n     * Default value.\n     */ ThinkingLevel[\"THINKING_LEVEL_UNSPECIFIED\"] = \"THINKING_LEVEL_UNSPECIFIED\";\n    /**\n     * Low thinking level.\n     */ ThinkingLevel[\"LOW\"] = \"LOW\";\n    /**\n     * High thinking level.\n     */ ThinkingLevel[\"HIGH\"] = \"HIGH\";\n})(ThinkingLevel || (ThinkingLevel = {}));\n/** Harm category. */ var HarmCategory;\n(function(HarmCategory) {\n    /**\n     * The harm category is unspecified.\n     */ HarmCategory[\"HARM_CATEGORY_UNSPECIFIED\"] = \"HARM_CATEGORY_UNSPECIFIED\";\n    /**\n     * The harm category is harassment.\n     */ HarmCategory[\"HARM_CATEGORY_HARASSMENT\"] = \"HARM_CATEGORY_HARASSMENT\";\n    /**\n     * The harm category is hate speech.\n     */ HarmCategory[\"HARM_CATEGORY_HATE_SPEECH\"] = \"HARM_CATEGORY_HATE_SPEECH\";\n    /**\n     * The harm category is sexually explicit content.\n     */ HarmCategory[\"HARM_CATEGORY_SEXUALLY_EXPLICIT\"] = \"HARM_CATEGORY_SEXUALLY_EXPLICIT\";\n    /**\n     * The harm category is dangerous content.\n     */ HarmCategory[\"HARM_CATEGORY_DANGEROUS_CONTENT\"] = \"HARM_CATEGORY_DANGEROUS_CONTENT\";\n    /**\n     * Deprecated: Election filter is not longer supported. The harm category is civic integrity.\n     */ HarmCategory[\"HARM_CATEGORY_CIVIC_INTEGRITY\"] = \"HARM_CATEGORY_CIVIC_INTEGRITY\";\n    /**\n     * The harm category is image hate. This enum value is not supported in Gemini API.\n     */ HarmCategory[\"HARM_CATEGORY_IMAGE_HATE\"] = \"HARM_CATEGORY_IMAGE_HATE\";\n    /**\n     * The harm category is image dangerous content. This enum value is not supported in Gemini API.\n     */ HarmCategory[\"HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT\"] = \"HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT\";\n    /**\n     * The harm category is image harassment. This enum value is not supported in Gemini API.\n     */ HarmCategory[\"HARM_CATEGORY_IMAGE_HARASSMENT\"] = \"HARM_CATEGORY_IMAGE_HARASSMENT\";\n    /**\n     * The harm category is image sexually explicit content. This enum value is not supported in Gemini API.\n     */ HarmCategory[\"HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT\"] = \"HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT\";\n    /**\n     * The harm category is for jailbreak prompts. This enum value is not supported in Gemini API.\n     */ HarmCategory[\"HARM_CATEGORY_JAILBREAK\"] = \"HARM_CATEGORY_JAILBREAK\";\n})(HarmCategory || (HarmCategory = {}));\n/** Specify if the threshold is used for probability or severity score. If not specified, the threshold is used for probability score. This enum is not supported in Gemini API. */ var HarmBlockMethod;\n(function(HarmBlockMethod) {\n    /**\n     * The harm block method is unspecified.\n     */ HarmBlockMethod[\"HARM_BLOCK_METHOD_UNSPECIFIED\"] = \"HARM_BLOCK_METHOD_UNSPECIFIED\";\n    /**\n     * The harm block method uses both probability and severity scores.\n     */ HarmBlockMethod[\"SEVERITY\"] = \"SEVERITY\";\n    /**\n     * The harm block method uses the probability score.\n     */ HarmBlockMethod[\"PROBABILITY\"] = \"PROBABILITY\";\n})(HarmBlockMethod || (HarmBlockMethod = {}));\n/** The harm block threshold. */ var HarmBlockThreshold;\n(function(HarmBlockThreshold) {\n    /**\n     * Unspecified harm block threshold.\n     */ HarmBlockThreshold[\"HARM_BLOCK_THRESHOLD_UNSPECIFIED\"] = \"HARM_BLOCK_THRESHOLD_UNSPECIFIED\";\n    /**\n     * Block low threshold and above (i.e. block more).\n     */ HarmBlockThreshold[\"BLOCK_LOW_AND_ABOVE\"] = \"BLOCK_LOW_AND_ABOVE\";\n    /**\n     * Block medium threshold and above.\n     */ HarmBlockThreshold[\"BLOCK_MEDIUM_AND_ABOVE\"] = \"BLOCK_MEDIUM_AND_ABOVE\";\n    /**\n     * Block only high threshold (i.e. block less).\n     */ HarmBlockThreshold[\"BLOCK_ONLY_HIGH\"] = \"BLOCK_ONLY_HIGH\";\n    /**\n     * Block none.\n     */ HarmBlockThreshold[\"BLOCK_NONE\"] = \"BLOCK_NONE\";\n    /**\n     * Turn off the safety filter.\n     */ HarmBlockThreshold[\"OFF\"] = \"OFF\";\n})(HarmBlockThreshold || (HarmBlockThreshold = {}));\n/** Output only. The reason why the model stopped generating tokens.\n\nIf empty, the model has not stopped generating the tokens. */ var FinishReason;\n(function(FinishReason) {\n    /**\n     * The finish reason is unspecified.\n     */ FinishReason[\"FINISH_REASON_UNSPECIFIED\"] = \"FINISH_REASON_UNSPECIFIED\";\n    /**\n     * Token generation reached a natural stopping point or a configured stop sequence.\n     */ FinishReason[\"STOP\"] = \"STOP\";\n    /**\n     * Token generation reached the configured maximum output tokens.\n     */ FinishReason[\"MAX_TOKENS\"] = \"MAX_TOKENS\";\n    /**\n     * Token generation stopped because the content potentially contains safety violations. NOTE: When streaming, [content][] is empty if content filters blocks the output.\n     */ FinishReason[\"SAFETY\"] = \"SAFETY\";\n    /**\n     * The token generation stopped because of potential recitation.\n     */ FinishReason[\"RECITATION\"] = \"RECITATION\";\n    /**\n     * The token generation stopped because of using an unsupported language.\n     */ FinishReason[\"LANGUAGE\"] = \"LANGUAGE\";\n    /**\n     * All other reasons that stopped the token generation.\n     */ FinishReason[\"OTHER\"] = \"OTHER\";\n    /**\n     * Token generation stopped because the content contains forbidden terms.\n     */ FinishReason[\"BLOCKLIST\"] = \"BLOCKLIST\";\n    /**\n     * Token generation stopped for potentially containing prohibited content.\n     */ FinishReason[\"PROHIBITED_CONTENT\"] = \"PROHIBITED_CONTENT\";\n    /**\n     * Token generation stopped because the content potentially contains Sensitive Personally Identifiable Information (SPII).\n     */ FinishReason[\"SPII\"] = \"SPII\";\n    /**\n     * The function call generated by the model is invalid.\n     */ FinishReason[\"MALFORMED_FUNCTION_CALL\"] = \"MALFORMED_FUNCTION_CALL\";\n    /**\n     * Token generation stopped because generated images have safety violations.\n     */ FinishReason[\"IMAGE_SAFETY\"] = \"IMAGE_SAFETY\";\n    /**\n     * The tool call generated by the model is invalid.\n     */ FinishReason[\"UNEXPECTED_TOOL_CALL\"] = \"UNEXPECTED_TOOL_CALL\";\n    /**\n     * Image generation stopped because the generated images have prohibited content.\n     */ FinishReason[\"IMAGE_PROHIBITED_CONTENT\"] = \"IMAGE_PROHIBITED_CONTENT\";\n    /**\n     * The model was expected to generate an image, but none was generated.\n     */ FinishReason[\"NO_IMAGE\"] = \"NO_IMAGE\";\n})(FinishReason || (FinishReason = {}));\n/** Output only. Harm probability levels in the content. */ var HarmProbability;\n(function(HarmProbability) {\n    /**\n     * Harm probability unspecified.\n     */ HarmProbability[\"HARM_PROBABILITY_UNSPECIFIED\"] = \"HARM_PROBABILITY_UNSPECIFIED\";\n    /**\n     * Negligible level of harm.\n     */ HarmProbability[\"NEGLIGIBLE\"] = \"NEGLIGIBLE\";\n    /**\n     * Low level of harm.\n     */ HarmProbability[\"LOW\"] = \"LOW\";\n    /**\n     * Medium level of harm.\n     */ HarmProbability[\"MEDIUM\"] = \"MEDIUM\";\n    /**\n     * High level of harm.\n     */ HarmProbability[\"HIGH\"] = \"HIGH\";\n})(HarmProbability || (HarmProbability = {}));\n/** Output only. Harm severity levels in the content. This enum is not supported in Gemini API. */ var HarmSeverity;\n(function(HarmSeverity) {\n    /**\n     * Harm severity unspecified.\n     */ HarmSeverity[\"HARM_SEVERITY_UNSPECIFIED\"] = \"HARM_SEVERITY_UNSPECIFIED\";\n    /**\n     * Negligible level of harm severity.\n     */ HarmSeverity[\"HARM_SEVERITY_NEGLIGIBLE\"] = \"HARM_SEVERITY_NEGLIGIBLE\";\n    /**\n     * Low level of harm severity.\n     */ HarmSeverity[\"HARM_SEVERITY_LOW\"] = \"HARM_SEVERITY_LOW\";\n    /**\n     * Medium level of harm severity.\n     */ HarmSeverity[\"HARM_SEVERITY_MEDIUM\"] = \"HARM_SEVERITY_MEDIUM\";\n    /**\n     * High level of harm severity.\n     */ HarmSeverity[\"HARM_SEVERITY_HIGH\"] = \"HARM_SEVERITY_HIGH\";\n})(HarmSeverity || (HarmSeverity = {}));\n/** Status of the url retrieval. */ var UrlRetrievalStatus;\n(function(UrlRetrievalStatus) {\n    /**\n     * Default value. This value is unused.\n     */ UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_UNSPECIFIED\"] = \"URL_RETRIEVAL_STATUS_UNSPECIFIED\";\n    /**\n     * Url retrieval is successful.\n     */ UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_SUCCESS\"] = \"URL_RETRIEVAL_STATUS_SUCCESS\";\n    /**\n     * Url retrieval is failed due to error.\n     */ UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_ERROR\"] = \"URL_RETRIEVAL_STATUS_ERROR\";\n    /**\n     * Url retrieval is failed because the content is behind paywall. This enum value is not supported in Vertex AI.\n     */ UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_PAYWALL\"] = \"URL_RETRIEVAL_STATUS_PAYWALL\";\n    /**\n     * Url retrieval is failed because the content is unsafe. This enum value is not supported in Vertex AI.\n     */ UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_UNSAFE\"] = \"URL_RETRIEVAL_STATUS_UNSAFE\";\n})(UrlRetrievalStatus || (UrlRetrievalStatus = {}));\n/** Output only. The reason why the prompt was blocked. */ var BlockedReason;\n(function(BlockedReason) {\n    /**\n     * The blocked reason is unspecified.\n     */ BlockedReason[\"BLOCKED_REASON_UNSPECIFIED\"] = \"BLOCKED_REASON_UNSPECIFIED\";\n    /**\n     * The prompt was blocked for safety reasons.\n     */ BlockedReason[\"SAFETY\"] = \"SAFETY\";\n    /**\n     * The prompt was blocked for other reasons. For example, it may be due to the prompt's language, or because it contains other harmful content.\n     */ BlockedReason[\"OTHER\"] = \"OTHER\";\n    /**\n     * The prompt was blocked because it contains a term from the terminology blocklist.\n     */ BlockedReason[\"BLOCKLIST\"] = \"BLOCKLIST\";\n    /**\n     * The prompt was blocked because it contains prohibited content.\n     */ BlockedReason[\"PROHIBITED_CONTENT\"] = \"PROHIBITED_CONTENT\";\n    /**\n     * The prompt was blocked because it contains content that is unsafe for image generation.\n     */ BlockedReason[\"IMAGE_SAFETY\"] = \"IMAGE_SAFETY\";\n    /**\n     * The prompt was blocked by Model Armor. This enum value is not supported in Gemini API.\n     */ BlockedReason[\"MODEL_ARMOR\"] = \"MODEL_ARMOR\";\n    /**\n     * The prompt was blocked as a jailbreak attempt. This enum value is not supported in Gemini API.\n     */ BlockedReason[\"JAILBREAK\"] = \"JAILBREAK\";\n})(BlockedReason || (BlockedReason = {}));\n/** Output only. The traffic type for this request. This enum is not supported in Gemini API. */ var TrafficType;\n(function(TrafficType) {\n    /**\n     * Unspecified request traffic type.\n     */ TrafficType[\"TRAFFIC_TYPE_UNSPECIFIED\"] = \"TRAFFIC_TYPE_UNSPECIFIED\";\n    /**\n     * The request was processed using Pay-As-You-Go quota.\n     */ TrafficType[\"ON_DEMAND\"] = \"ON_DEMAND\";\n    /**\n     * Type for Provisioned Throughput traffic.\n     */ TrafficType[\"PROVISIONED_THROUGHPUT\"] = \"PROVISIONED_THROUGHPUT\";\n})(TrafficType || (TrafficType = {}));\n/** Server content modalities. */ var Modality;\n(function(Modality) {\n    /**\n     * The modality is unspecified.\n     */ Modality[\"MODALITY_UNSPECIFIED\"] = \"MODALITY_UNSPECIFIED\";\n    /**\n     * Indicates the model should return text\n     */ Modality[\"TEXT\"] = \"TEXT\";\n    /**\n     * Indicates the model should return images.\n     */ Modality[\"IMAGE\"] = \"IMAGE\";\n    /**\n     * Indicates the model should return audio.\n     */ Modality[\"AUDIO\"] = \"AUDIO\";\n})(Modality || (Modality = {}));\n/** The media resolution to use. */ var MediaResolution;\n(function(MediaResolution) {\n    /**\n     * Media resolution has not been set\n     */ MediaResolution[\"MEDIA_RESOLUTION_UNSPECIFIED\"] = \"MEDIA_RESOLUTION_UNSPECIFIED\";\n    /**\n     * Media resolution set to low (64 tokens).\n     */ MediaResolution[\"MEDIA_RESOLUTION_LOW\"] = \"MEDIA_RESOLUTION_LOW\";\n    /**\n     * Media resolution set to medium (256 tokens).\n     */ MediaResolution[\"MEDIA_RESOLUTION_MEDIUM\"] = \"MEDIA_RESOLUTION_MEDIUM\";\n    /**\n     * Media resolution set to high (zoomed reframing with 256 tokens).\n     */ MediaResolution[\"MEDIA_RESOLUTION_HIGH\"] = \"MEDIA_RESOLUTION_HIGH\";\n})(MediaResolution || (MediaResolution = {}));\n/** Tuning mode. This enum is not supported in Gemini API. */ var TuningMode;\n(function(TuningMode) {\n    /**\n     * Tuning mode is unspecified.\n     */ TuningMode[\"TUNING_MODE_UNSPECIFIED\"] = \"TUNING_MODE_UNSPECIFIED\";\n    /**\n     * Full fine-tuning mode.\n     */ TuningMode[\"TUNING_MODE_FULL\"] = \"TUNING_MODE_FULL\";\n    /**\n     * PEFT adapter tuning mode.\n     */ TuningMode[\"TUNING_MODE_PEFT_ADAPTER\"] = \"TUNING_MODE_PEFT_ADAPTER\";\n})(TuningMode || (TuningMode = {}));\n/** Adapter size for tuning. This enum is not supported in Gemini API. */ var AdapterSize;\n(function(AdapterSize) {\n    /**\n     * Adapter size is unspecified.\n     */ AdapterSize[\"ADAPTER_SIZE_UNSPECIFIED\"] = \"ADAPTER_SIZE_UNSPECIFIED\";\n    /**\n     * Adapter size 1.\n     */ AdapterSize[\"ADAPTER_SIZE_ONE\"] = \"ADAPTER_SIZE_ONE\";\n    /**\n     * Adapter size 2.\n     */ AdapterSize[\"ADAPTER_SIZE_TWO\"] = \"ADAPTER_SIZE_TWO\";\n    /**\n     * Adapter size 4.\n     */ AdapterSize[\"ADAPTER_SIZE_FOUR\"] = \"ADAPTER_SIZE_FOUR\";\n    /**\n     * Adapter size 8.\n     */ AdapterSize[\"ADAPTER_SIZE_EIGHT\"] = \"ADAPTER_SIZE_EIGHT\";\n    /**\n     * Adapter size 16.\n     */ AdapterSize[\"ADAPTER_SIZE_SIXTEEN\"] = \"ADAPTER_SIZE_SIXTEEN\";\n    /**\n     * Adapter size 32.\n     */ AdapterSize[\"ADAPTER_SIZE_THIRTY_TWO\"] = \"ADAPTER_SIZE_THIRTY_TWO\";\n})(AdapterSize || (AdapterSize = {}));\n/** Job state. */ var JobState;\n(function(JobState) {\n    /**\n     * The job state is unspecified.\n     */ JobState[\"JOB_STATE_UNSPECIFIED\"] = \"JOB_STATE_UNSPECIFIED\";\n    /**\n     * The job has been just created or resumed and processing has not yet begun.\n     */ JobState[\"JOB_STATE_QUEUED\"] = \"JOB_STATE_QUEUED\";\n    /**\n     * The service is preparing to run the job.\n     */ JobState[\"JOB_STATE_PENDING\"] = \"JOB_STATE_PENDING\";\n    /**\n     * The job is in progress.\n     */ JobState[\"JOB_STATE_RUNNING\"] = \"JOB_STATE_RUNNING\";\n    /**\n     * The job completed successfully.\n     */ JobState[\"JOB_STATE_SUCCEEDED\"] = \"JOB_STATE_SUCCEEDED\";\n    /**\n     * The job failed.\n     */ JobState[\"JOB_STATE_FAILED\"] = \"JOB_STATE_FAILED\";\n    /**\n     * The job is being cancelled. From this state the job may only go to either `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED` or `JOB_STATE_CANCELLED`.\n     */ JobState[\"JOB_STATE_CANCELLING\"] = \"JOB_STATE_CANCELLING\";\n    /**\n     * The job has been cancelled.\n     */ JobState[\"JOB_STATE_CANCELLED\"] = \"JOB_STATE_CANCELLED\";\n    /**\n     * The job has been stopped, and can be resumed.\n     */ JobState[\"JOB_STATE_PAUSED\"] = \"JOB_STATE_PAUSED\";\n    /**\n     * The job has expired.\n     */ JobState[\"JOB_STATE_EXPIRED\"] = \"JOB_STATE_EXPIRED\";\n    /**\n     * The job is being updated. Only jobs in the `JOB_STATE_RUNNING` state can be updated. After updating, the job goes back to the `JOB_STATE_RUNNING` state.\n     */ JobState[\"JOB_STATE_UPDATING\"] = \"JOB_STATE_UPDATING\";\n    /**\n     * The job is partially succeeded, some results may be missing due to errors.\n     */ JobState[\"JOB_STATE_PARTIALLY_SUCCEEDED\"] = \"JOB_STATE_PARTIALLY_SUCCEEDED\";\n})(JobState || (JobState = {}));\n/** The tuning task. Either I2V or T2V. This enum is not supported in Gemini API. */ var TuningTask;\n(function(TuningTask) {\n    /**\n     * Default value. This value is unused.\n     */ TuningTask[\"TUNING_TASK_UNSPECIFIED\"] = \"TUNING_TASK_UNSPECIFIED\";\n    /**\n     * Tuning task for image to video.\n     */ TuningTask[\"TUNING_TASK_I2V\"] = \"TUNING_TASK_I2V\";\n    /**\n     * Tuning task for text to video.\n     */ TuningTask[\"TUNING_TASK_T2V\"] = \"TUNING_TASK_T2V\";\n    /**\n     * Tuning task for reference to video.\n     */ TuningTask[\"TUNING_TASK_R2V\"] = \"TUNING_TASK_R2V\";\n})(TuningTask || (TuningTask = {}));\n/** The tokenization quality used for given media. */ var PartMediaResolutionLevel;\n(function(PartMediaResolutionLevel) {\n    /**\n     * Media resolution has not been set.\n     */ PartMediaResolutionLevel[\"MEDIA_RESOLUTION_UNSPECIFIED\"] = \"MEDIA_RESOLUTION_UNSPECIFIED\";\n    /**\n     * Media resolution set to low.\n     */ PartMediaResolutionLevel[\"MEDIA_RESOLUTION_LOW\"] = \"MEDIA_RESOLUTION_LOW\";\n    /**\n     * Media resolution set to medium.\n     */ PartMediaResolutionLevel[\"MEDIA_RESOLUTION_MEDIUM\"] = \"MEDIA_RESOLUTION_MEDIUM\";\n    /**\n     * Media resolution set to high.\n     */ PartMediaResolutionLevel[\"MEDIA_RESOLUTION_HIGH\"] = \"MEDIA_RESOLUTION_HIGH\";\n})(PartMediaResolutionLevel || (PartMediaResolutionLevel = {}));\n/** Options for feature selection preference. */ var FeatureSelectionPreference;\n(function(FeatureSelectionPreference) {\n    FeatureSelectionPreference[\"FEATURE_SELECTION_PREFERENCE_UNSPECIFIED\"] = \"FEATURE_SELECTION_PREFERENCE_UNSPECIFIED\";\n    FeatureSelectionPreference[\"PRIORITIZE_QUALITY\"] = \"PRIORITIZE_QUALITY\";\n    FeatureSelectionPreference[\"BALANCED\"] = \"BALANCED\";\n    FeatureSelectionPreference[\"PRIORITIZE_COST\"] = \"PRIORITIZE_COST\";\n})(FeatureSelectionPreference || (FeatureSelectionPreference = {}));\n/** Defines the function behavior. Defaults to `BLOCKING`. */ var Behavior;\n(function(Behavior) {\n    /**\n     * This value is unused.\n     */ Behavior[\"UNSPECIFIED\"] = \"UNSPECIFIED\";\n    /**\n     * If set, the system will wait to receive the function response before continuing the conversation.\n     */ Behavior[\"BLOCKING\"] = \"BLOCKING\";\n    /**\n     * If set, the system will not wait to receive the function response. Instead, it will attempt to handle function responses as they become available while maintaining the conversation between the user and the model.\n     */ Behavior[\"NON_BLOCKING\"] = \"NON_BLOCKING\";\n})(Behavior || (Behavior = {}));\n/** Config for the dynamic retrieval config mode. */ var DynamicRetrievalConfigMode;\n(function(DynamicRetrievalConfigMode) {\n    /**\n     * Always trigger retrieval.\n     */ DynamicRetrievalConfigMode[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n    /**\n     * Run retrieval only when system decides it is necessary.\n     */ DynamicRetrievalConfigMode[\"MODE_DYNAMIC\"] = \"MODE_DYNAMIC\";\n})(DynamicRetrievalConfigMode || (DynamicRetrievalConfigMode = {}));\n/** The environment being operated. */ var Environment;\n(function(Environment) {\n    /**\n     * Defaults to browser.\n     */ Environment[\"ENVIRONMENT_UNSPECIFIED\"] = \"ENVIRONMENT_UNSPECIFIED\";\n    /**\n     * Operates in a web browser.\n     */ Environment[\"ENVIRONMENT_BROWSER\"] = \"ENVIRONMENT_BROWSER\";\n})(Environment || (Environment = {}));\n/** Config for the function calling config mode. */ var FunctionCallingConfigMode;\n(function(FunctionCallingConfigMode) {\n    /**\n     * The function calling config mode is unspecified. Should not be used.\n     */ FunctionCallingConfigMode[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n    /**\n     * Default model behavior, model decides to predict either function calls or natural language response.\n     */ FunctionCallingConfigMode[\"AUTO\"] = \"AUTO\";\n    /**\n     * Model is constrained to always predicting function calls only. If \"allowed_function_names\" are set, the predicted function calls will be limited to any one of \"allowed_function_names\", else the predicted function calls will be any one of the provided \"function_declarations\".\n     */ FunctionCallingConfigMode[\"ANY\"] = \"ANY\";\n    /**\n     * Model will not predict any function calls. Model behavior is same as when not passing any function declarations.\n     */ FunctionCallingConfigMode[\"NONE\"] = \"NONE\";\n    /**\n     * Model decides to predict either a function call or a natural language response, but will validate function calls with constrained decoding. If \"allowed_function_names\" are set, the predicted function call will be limited to any one of \"allowed_function_names\", else the predicted function call will be any one of the provided \"function_declarations\".\n     */ FunctionCallingConfigMode[\"VALIDATED\"] = \"VALIDATED\";\n})(FunctionCallingConfigMode || (FunctionCallingConfigMode = {}));\n/** Enum that controls the safety filter level for objectionable content. */ var SafetyFilterLevel;\n(function(SafetyFilterLevel) {\n    SafetyFilterLevel[\"BLOCK_LOW_AND_ABOVE\"] = \"BLOCK_LOW_AND_ABOVE\";\n    SafetyFilterLevel[\"BLOCK_MEDIUM_AND_ABOVE\"] = \"BLOCK_MEDIUM_AND_ABOVE\";\n    SafetyFilterLevel[\"BLOCK_ONLY_HIGH\"] = \"BLOCK_ONLY_HIGH\";\n    SafetyFilterLevel[\"BLOCK_NONE\"] = \"BLOCK_NONE\";\n})(SafetyFilterLevel || (SafetyFilterLevel = {}));\n/** Enum that controls the generation of people. */ var PersonGeneration;\n(function(PersonGeneration) {\n    /**\n     * Block generation of images of people.\n     */ PersonGeneration[\"DONT_ALLOW\"] = \"DONT_ALLOW\";\n    /**\n     * Generate images of adults, but not children.\n     */ PersonGeneration[\"ALLOW_ADULT\"] = \"ALLOW_ADULT\";\n    /**\n     * Generate images that include adults and children.\n     */ PersonGeneration[\"ALLOW_ALL\"] = \"ALLOW_ALL\";\n})(PersonGeneration || (PersonGeneration = {}));\n/** Enum that specifies the language of the text in the prompt. */ var ImagePromptLanguage;\n(function(ImagePromptLanguage) {\n    /**\n     * Auto-detect the language.\n     */ ImagePromptLanguage[\"auto\"] = \"auto\";\n    /**\n     * English\n     */ ImagePromptLanguage[\"en\"] = \"en\";\n    /**\n     * Japanese\n     */ ImagePromptLanguage[\"ja\"] = \"ja\";\n    /**\n     * Korean\n     */ ImagePromptLanguage[\"ko\"] = \"ko\";\n    /**\n     * Hindi\n     */ ImagePromptLanguage[\"hi\"] = \"hi\";\n    /**\n     * Chinese\n     */ ImagePromptLanguage[\"zh\"] = \"zh\";\n    /**\n     * Portuguese\n     */ ImagePromptLanguage[\"pt\"] = \"pt\";\n    /**\n     * Spanish\n     */ ImagePromptLanguage[\"es\"] = \"es\";\n})(ImagePromptLanguage || (ImagePromptLanguage = {}));\n/** Enum representing the mask mode of a mask reference image. */ var MaskReferenceMode;\n(function(MaskReferenceMode) {\n    MaskReferenceMode[\"MASK_MODE_DEFAULT\"] = \"MASK_MODE_DEFAULT\";\n    MaskReferenceMode[\"MASK_MODE_USER_PROVIDED\"] = \"MASK_MODE_USER_PROVIDED\";\n    MaskReferenceMode[\"MASK_MODE_BACKGROUND\"] = \"MASK_MODE_BACKGROUND\";\n    MaskReferenceMode[\"MASK_MODE_FOREGROUND\"] = \"MASK_MODE_FOREGROUND\";\n    MaskReferenceMode[\"MASK_MODE_SEMANTIC\"] = \"MASK_MODE_SEMANTIC\";\n})(MaskReferenceMode || (MaskReferenceMode = {}));\n/** Enum representing the control type of a control reference image. */ var ControlReferenceType;\n(function(ControlReferenceType) {\n    ControlReferenceType[\"CONTROL_TYPE_DEFAULT\"] = \"CONTROL_TYPE_DEFAULT\";\n    ControlReferenceType[\"CONTROL_TYPE_CANNY\"] = \"CONTROL_TYPE_CANNY\";\n    ControlReferenceType[\"CONTROL_TYPE_SCRIBBLE\"] = \"CONTROL_TYPE_SCRIBBLE\";\n    ControlReferenceType[\"CONTROL_TYPE_FACE_MESH\"] = \"CONTROL_TYPE_FACE_MESH\";\n})(ControlReferenceType || (ControlReferenceType = {}));\n/** Enum representing the subject type of a subject reference image. */ var SubjectReferenceType;\n(function(SubjectReferenceType) {\n    SubjectReferenceType[\"SUBJECT_TYPE_DEFAULT\"] = \"SUBJECT_TYPE_DEFAULT\";\n    SubjectReferenceType[\"SUBJECT_TYPE_PERSON\"] = \"SUBJECT_TYPE_PERSON\";\n    SubjectReferenceType[\"SUBJECT_TYPE_ANIMAL\"] = \"SUBJECT_TYPE_ANIMAL\";\n    SubjectReferenceType[\"SUBJECT_TYPE_PRODUCT\"] = \"SUBJECT_TYPE_PRODUCT\";\n})(SubjectReferenceType || (SubjectReferenceType = {}));\n/** Enum representing the editing mode. */ var EditMode;\n(function(EditMode) {\n    EditMode[\"EDIT_MODE_DEFAULT\"] = \"EDIT_MODE_DEFAULT\";\n    EditMode[\"EDIT_MODE_INPAINT_REMOVAL\"] = \"EDIT_MODE_INPAINT_REMOVAL\";\n    EditMode[\"EDIT_MODE_INPAINT_INSERTION\"] = \"EDIT_MODE_INPAINT_INSERTION\";\n    EditMode[\"EDIT_MODE_OUTPAINT\"] = \"EDIT_MODE_OUTPAINT\";\n    EditMode[\"EDIT_MODE_CONTROLLED_EDITING\"] = \"EDIT_MODE_CONTROLLED_EDITING\";\n    EditMode[\"EDIT_MODE_STYLE\"] = \"EDIT_MODE_STYLE\";\n    EditMode[\"EDIT_MODE_BGSWAP\"] = \"EDIT_MODE_BGSWAP\";\n    EditMode[\"EDIT_MODE_PRODUCT_IMAGE\"] = \"EDIT_MODE_PRODUCT_IMAGE\";\n})(EditMode || (EditMode = {}));\n/** Enum that represents the segmentation mode. */ var SegmentMode;\n(function(SegmentMode) {\n    SegmentMode[\"FOREGROUND\"] = \"FOREGROUND\";\n    SegmentMode[\"BACKGROUND\"] = \"BACKGROUND\";\n    SegmentMode[\"PROMPT\"] = \"PROMPT\";\n    SegmentMode[\"SEMANTIC\"] = \"SEMANTIC\";\n    SegmentMode[\"INTERACTIVE\"] = \"INTERACTIVE\";\n})(SegmentMode || (SegmentMode = {}));\n/** Enum for the reference type of a video generation reference image. */ var VideoGenerationReferenceType;\n(function(VideoGenerationReferenceType) {\n    /**\n     * A reference image that provides assets to the generated video,\n        such as the scene, an object, a character, etc.\n     */ VideoGenerationReferenceType[\"ASSET\"] = \"ASSET\";\n    /**\n     * A reference image that provides aesthetics including colors,\n        lighting, texture, etc., to be used as the style of the generated video,\n        such as 'anime', 'photography', 'origami', etc.\n     */ VideoGenerationReferenceType[\"STYLE\"] = \"STYLE\";\n})(VideoGenerationReferenceType || (VideoGenerationReferenceType = {}));\n/** Enum for the mask mode of a video generation mask. */ var VideoGenerationMaskMode;\n(function(VideoGenerationMaskMode) {\n    /**\n     * The image mask contains a masked rectangular region which is\n        applied on the first frame of the input video. The object described in\n        the prompt is inserted into this region and will appear in subsequent\n        frames.\n     */ VideoGenerationMaskMode[\"INSERT\"] = \"INSERT\";\n    /**\n     * The image mask is used to determine an object in the\n        first video frame to track. This object is removed from the video.\n     */ VideoGenerationMaskMode[\"REMOVE\"] = \"REMOVE\";\n    /**\n     * The image mask is used to determine a region in the\n        video. Objects in this region will be removed.\n     */ VideoGenerationMaskMode[\"REMOVE_STATIC\"] = \"REMOVE_STATIC\";\n    /**\n     * The image mask contains a masked rectangular region where\n        the input video will go. The remaining area will be generated. Video\n        masks are not supported.\n     */ VideoGenerationMaskMode[\"OUTPAINT\"] = \"OUTPAINT\";\n})(VideoGenerationMaskMode || (VideoGenerationMaskMode = {}));\n/** Enum that controls the compression quality of the generated videos. */ var VideoCompressionQuality;\n(function(VideoCompressionQuality) {\n    /**\n     * Optimized video compression quality. This will produce videos\n        with a compressed, smaller file size.\n     */ VideoCompressionQuality[\"OPTIMIZED\"] = \"OPTIMIZED\";\n    /**\n     * Lossless video compression quality. This will produce videos\n        with a larger file size.\n     */ VideoCompressionQuality[\"LOSSLESS\"] = \"LOSSLESS\";\n})(VideoCompressionQuality || (VideoCompressionQuality = {}));\n/** Enum representing the tuning method. */ var TuningMethod;\n(function(TuningMethod) {\n    /**\n     * Supervised fine tuning.\n     */ TuningMethod[\"SUPERVISED_FINE_TUNING\"] = \"SUPERVISED_FINE_TUNING\";\n    /**\n     * Preference optimization tuning.\n     */ TuningMethod[\"PREFERENCE_TUNING\"] = \"PREFERENCE_TUNING\";\n})(TuningMethod || (TuningMethod = {}));\n/** State for the lifecycle of a Document. */ var DocumentState;\n(function(DocumentState) {\n    DocumentState[\"STATE_UNSPECIFIED\"] = \"STATE_UNSPECIFIED\";\n    DocumentState[\"STATE_PENDING\"] = \"STATE_PENDING\";\n    DocumentState[\"STATE_ACTIVE\"] = \"STATE_ACTIVE\";\n    DocumentState[\"STATE_FAILED\"] = \"STATE_FAILED\";\n})(DocumentState || (DocumentState = {}));\n/** State for the lifecycle of a File. */ var FileState;\n(function(FileState) {\n    FileState[\"STATE_UNSPECIFIED\"] = \"STATE_UNSPECIFIED\";\n    FileState[\"PROCESSING\"] = \"PROCESSING\";\n    FileState[\"ACTIVE\"] = \"ACTIVE\";\n    FileState[\"FAILED\"] = \"FAILED\";\n})(FileState || (FileState = {}));\n/** Source of the File. */ var FileSource;\n(function(FileSource) {\n    FileSource[\"SOURCE_UNSPECIFIED\"] = \"SOURCE_UNSPECIFIED\";\n    FileSource[\"UPLOADED\"] = \"UPLOADED\";\n    FileSource[\"GENERATED\"] = \"GENERATED\";\n})(FileSource || (FileSource = {}));\n/** The reason why the turn is complete. */ var TurnCompleteReason;\n(function(TurnCompleteReason) {\n    /**\n     * Default value. Reason is unspecified.\n     */ TurnCompleteReason[\"TURN_COMPLETE_REASON_UNSPECIFIED\"] = \"TURN_COMPLETE_REASON_UNSPECIFIED\";\n    /**\n     * The function call generated by the model is invalid.\n     */ TurnCompleteReason[\"MALFORMED_FUNCTION_CALL\"] = \"MALFORMED_FUNCTION_CALL\";\n    /**\n     * The response is rejected by the model.\n     */ TurnCompleteReason[\"RESPONSE_REJECTED\"] = \"RESPONSE_REJECTED\";\n    /**\n     * Needs more input from the user.\n     */ TurnCompleteReason[\"NEED_MORE_INPUT\"] = \"NEED_MORE_INPUT\";\n})(TurnCompleteReason || (TurnCompleteReason = {}));\n/** Server content modalities. */ var MediaModality;\n(function(MediaModality) {\n    /**\n     * The modality is unspecified.\n     */ MediaModality[\"MODALITY_UNSPECIFIED\"] = \"MODALITY_UNSPECIFIED\";\n    /**\n     * Plain text.\n     */ MediaModality[\"TEXT\"] = \"TEXT\";\n    /**\n     * Images.\n     */ MediaModality[\"IMAGE\"] = \"IMAGE\";\n    /**\n     * Video.\n     */ MediaModality[\"VIDEO\"] = \"VIDEO\";\n    /**\n     * Audio.\n     */ MediaModality[\"AUDIO\"] = \"AUDIO\";\n    /**\n     * Document, e.g. PDF.\n     */ MediaModality[\"DOCUMENT\"] = \"DOCUMENT\";\n})(MediaModality || (MediaModality = {}));\n/** Start of speech sensitivity. */ var StartSensitivity;\n(function(StartSensitivity) {\n    /**\n     * The default is START_SENSITIVITY_LOW.\n     */ StartSensitivity[\"START_SENSITIVITY_UNSPECIFIED\"] = \"START_SENSITIVITY_UNSPECIFIED\";\n    /**\n     * Automatic detection will detect the start of speech more often.\n     */ StartSensitivity[\"START_SENSITIVITY_HIGH\"] = \"START_SENSITIVITY_HIGH\";\n    /**\n     * Automatic detection will detect the start of speech less often.\n     */ StartSensitivity[\"START_SENSITIVITY_LOW\"] = \"START_SENSITIVITY_LOW\";\n})(StartSensitivity || (StartSensitivity = {}));\n/** End of speech sensitivity. */ var EndSensitivity;\n(function(EndSensitivity) {\n    /**\n     * The default is END_SENSITIVITY_LOW.\n     */ EndSensitivity[\"END_SENSITIVITY_UNSPECIFIED\"] = \"END_SENSITIVITY_UNSPECIFIED\";\n    /**\n     * Automatic detection ends speech more often.\n     */ EndSensitivity[\"END_SENSITIVITY_HIGH\"] = \"END_SENSITIVITY_HIGH\";\n    /**\n     * Automatic detection ends speech less often.\n     */ EndSensitivity[\"END_SENSITIVITY_LOW\"] = \"END_SENSITIVITY_LOW\";\n})(EndSensitivity || (EndSensitivity = {}));\n/** The different ways of handling user activity. */ var ActivityHandling;\n(function(ActivityHandling) {\n    /**\n     * If unspecified, the default behavior is `START_OF_ACTIVITY_INTERRUPTS`.\n     */ ActivityHandling[\"ACTIVITY_HANDLING_UNSPECIFIED\"] = \"ACTIVITY_HANDLING_UNSPECIFIED\";\n    /**\n     * If true, start of activity will interrupt the model's response (also called \"barge in\"). The model's current response will be cut-off in the moment of the interruption. This is the default behavior.\n     */ ActivityHandling[\"START_OF_ACTIVITY_INTERRUPTS\"] = \"START_OF_ACTIVITY_INTERRUPTS\";\n    /**\n     * The model's response will not be interrupted.\n     */ ActivityHandling[\"NO_INTERRUPTION\"] = \"NO_INTERRUPTION\";\n})(ActivityHandling || (ActivityHandling = {}));\n/** Options about which input is included in the user's turn. */ var TurnCoverage;\n(function(TurnCoverage) {\n    /**\n     * If unspecified, the default behavior is `TURN_INCLUDES_ONLY_ACTIVITY`.\n     */ TurnCoverage[\"TURN_COVERAGE_UNSPECIFIED\"] = \"TURN_COVERAGE_UNSPECIFIED\";\n    /**\n     * The users turn only includes activity since the last turn, excluding inactivity (e.g. silence on the audio stream). This is the default behavior.\n     */ TurnCoverage[\"TURN_INCLUDES_ONLY_ACTIVITY\"] = \"TURN_INCLUDES_ONLY_ACTIVITY\";\n    /**\n     * The users turn includes all realtime input since the last turn, including inactivity (e.g. silence on the audio stream).\n     */ TurnCoverage[\"TURN_INCLUDES_ALL_INPUT\"] = \"TURN_INCLUDES_ALL_INPUT\";\n})(TurnCoverage || (TurnCoverage = {}));\n/** Scale of the generated music. */ var Scale;\n(function(Scale) {\n    /**\n     * Default value. This value is unused.\n     */ Scale[\"SCALE_UNSPECIFIED\"] = \"SCALE_UNSPECIFIED\";\n    /**\n     * C major or A minor.\n     */ Scale[\"C_MAJOR_A_MINOR\"] = \"C_MAJOR_A_MINOR\";\n    /**\n     * Db major or Bb minor.\n     */ Scale[\"D_FLAT_MAJOR_B_FLAT_MINOR\"] = \"D_FLAT_MAJOR_B_FLAT_MINOR\";\n    /**\n     * D major or B minor.\n     */ Scale[\"D_MAJOR_B_MINOR\"] = \"D_MAJOR_B_MINOR\";\n    /**\n     * Eb major or C minor\n     */ Scale[\"E_FLAT_MAJOR_C_MINOR\"] = \"E_FLAT_MAJOR_C_MINOR\";\n    /**\n     * E major or Db minor.\n     */ Scale[\"E_MAJOR_D_FLAT_MINOR\"] = \"E_MAJOR_D_FLAT_MINOR\";\n    /**\n     * F major or D minor.\n     */ Scale[\"F_MAJOR_D_MINOR\"] = \"F_MAJOR_D_MINOR\";\n    /**\n     * Gb major or Eb minor.\n     */ Scale[\"G_FLAT_MAJOR_E_FLAT_MINOR\"] = \"G_FLAT_MAJOR_E_FLAT_MINOR\";\n    /**\n     * G major or E minor.\n     */ Scale[\"G_MAJOR_E_MINOR\"] = \"G_MAJOR_E_MINOR\";\n    /**\n     * Ab major or F minor.\n     */ Scale[\"A_FLAT_MAJOR_F_MINOR\"] = \"A_FLAT_MAJOR_F_MINOR\";\n    /**\n     * A major or Gb minor.\n     */ Scale[\"A_MAJOR_G_FLAT_MINOR\"] = \"A_MAJOR_G_FLAT_MINOR\";\n    /**\n     * Bb major or G minor.\n     */ Scale[\"B_FLAT_MAJOR_G_MINOR\"] = \"B_FLAT_MAJOR_G_MINOR\";\n    /**\n     * B major or Ab minor.\n     */ Scale[\"B_MAJOR_A_FLAT_MINOR\"] = \"B_MAJOR_A_FLAT_MINOR\";\n})(Scale || (Scale = {}));\n/** The mode of music generation. */ var MusicGenerationMode;\n(function(MusicGenerationMode) {\n    /**\n     * Rely on the server default generation mode.\n     */ MusicGenerationMode[\"MUSIC_GENERATION_MODE_UNSPECIFIED\"] = \"MUSIC_GENERATION_MODE_UNSPECIFIED\";\n    /**\n     * Steer text prompts to regions of latent space with higher quality\n        music.\n     */ MusicGenerationMode[\"QUALITY\"] = \"QUALITY\";\n    /**\n     * Steer text prompts to regions of latent space with a larger\n        diversity of music.\n     */ MusicGenerationMode[\"DIVERSITY\"] = \"DIVERSITY\";\n    /**\n     * Steer text prompts to regions of latent space more likely to\n        generate music with vocals.\n     */ MusicGenerationMode[\"VOCALIZATION\"] = \"VOCALIZATION\";\n})(MusicGenerationMode || (MusicGenerationMode = {}));\n/** The playback control signal to apply to the music generation. */ var LiveMusicPlaybackControl;\n(function(LiveMusicPlaybackControl) {\n    /**\n     * This value is unused.\n     */ LiveMusicPlaybackControl[\"PLAYBACK_CONTROL_UNSPECIFIED\"] = \"PLAYBACK_CONTROL_UNSPECIFIED\";\n    /**\n     * Start generating the music.\n     */ LiveMusicPlaybackControl[\"PLAY\"] = \"PLAY\";\n    /**\n     * Hold the music generation. Use PLAY to resume from the current position.\n     */ LiveMusicPlaybackControl[\"PAUSE\"] = \"PAUSE\";\n    /**\n     * Stop the music generation and reset the context (prompts retained).\n        Use PLAY to restart the music generation.\n     */ LiveMusicPlaybackControl[\"STOP\"] = \"STOP\";\n    /**\n     * Reset the context of the music generation without stopping it.\n        Retains the current prompts and config.\n     */ LiveMusicPlaybackControl[\"RESET_CONTEXT\"] = \"RESET_CONTEXT\";\n})(LiveMusicPlaybackControl || (LiveMusicPlaybackControl = {}));\n/** Raw media bytes for function response.\n\nText should not be sent as raw bytes, use the FunctionResponse.response\nfield. */ class FunctionResponseBlob {\n}\n/** URI based data for function response. */ class FunctionResponseFileData {\n}\n/** A datatype containing media that is part of a `FunctionResponse` message.\n\nA `FunctionResponsePart` consists of data which has an associated datatype. A\n`FunctionResponsePart` can only contain one of the accepted types in\n`FunctionResponsePart.data`.\n\nA `FunctionResponsePart` must have a fixed IANA MIME type identifying the\ntype and subtype of the media if the `inline_data` field is filled with raw\nbytes. */ class FunctionResponsePart {\n}\n/**\n * Creates a `FunctionResponsePart` object from a `base64` encoded `string`.\n */ function createFunctionResponsePartFromBase64(data, mimeType) {\n    return {\n        inlineData: {\n            data: data,\n            mimeType: mimeType\n        }\n    };\n}\n/**\n * Creates a `FunctionResponsePart` object from a `URI` string.\n */ function createFunctionResponsePartFromUri(uri, mimeType) {\n    return {\n        fileData: {\n            fileUri: uri,\n            mimeType: mimeType\n        }\n    };\n}\n/** A function response. */ class FunctionResponse {\n}\n/**\n * Creates a `Part` object from a `URI` string.\n */ function createPartFromUri(uri, mimeType, mediaResolution) {\n    return Object.assign({\n        fileData: {\n            fileUri: uri,\n            mimeType: mimeType\n        }\n    }, mediaResolution && {\n        mediaResolution: {\n            level: mediaResolution\n        }\n    });\n}\n/**\n * Creates a `Part` object from a `text` string.\n */ function createPartFromText(text) {\n    return {\n        text: text\n    };\n}\n/**\n * Creates a `Part` object from a `FunctionCall` object.\n */ function createPartFromFunctionCall(name, args) {\n    return {\n        functionCall: {\n            name: name,\n            args: args\n        }\n    };\n}\n/**\n * Creates a `Part` object from a `FunctionResponse` object.\n */ function createPartFromFunctionResponse(id, name, response, parts = []) {\n    return {\n        functionResponse: Object.assign({\n            id: id,\n            name: name,\n            response: response\n        }, parts.length > 0 && {\n            parts\n        })\n    };\n}\n/**\n * Creates a `Part` object from a `base64` encoded `string`.\n */ function createPartFromBase64(data, mimeType, mediaResolution) {\n    return Object.assign({\n        inlineData: {\n            data: data,\n            mimeType: mimeType\n        }\n    }, mediaResolution && {\n        mediaResolution: {\n            level: mediaResolution\n        }\n    });\n}\n/**\n * Creates a `Part` object from the `outcome` and `output` of a `CodeExecutionResult` object.\n */ function createPartFromCodeExecutionResult(outcome, output) {\n    return {\n        codeExecutionResult: {\n            outcome: outcome,\n            output: output\n        }\n    };\n}\n/**\n * Creates a `Part` object from the `code` and `language` of an `ExecutableCode` object.\n */ function createPartFromExecutableCode(code, language) {\n    return {\n        executableCode: {\n            code: code,\n            language: language\n        }\n    };\n}\nfunction _isPart(obj) {\n    if (typeof obj === \"object\" && obj !== null) {\n        return \"fileData\" in obj || \"text\" in obj || \"functionCall\" in obj || \"functionResponse\" in obj || \"inlineData\" in obj || \"videoMetadata\" in obj || \"codeExecutionResult\" in obj || \"executableCode\" in obj;\n    }\n    return false;\n}\nfunction _toParts(partOrString) {\n    const parts = [];\n    if (typeof partOrString === \"string\") {\n        parts.push(createPartFromText(partOrString));\n    } else if (_isPart(partOrString)) {\n        parts.push(partOrString);\n    } else if (Array.isArray(partOrString)) {\n        if (partOrString.length === 0) {\n            throw new Error(\"partOrString cannot be an empty array\");\n        }\n        for (const part of partOrString){\n            if (typeof part === \"string\") {\n                parts.push(createPartFromText(part));\n            } else if (_isPart(part)) {\n                parts.push(part);\n            } else {\n                throw new Error(\"element in PartUnion must be a Part object or string\");\n            }\n        }\n    } else {\n        throw new Error(\"partOrString must be a Part object, string, or array\");\n    }\n    return parts;\n}\n/**\n * Creates a `Content` object with a user role from a `PartListUnion` object or `string`.\n */ function createUserContent(partOrString) {\n    return {\n        role: \"user\",\n        parts: _toParts(partOrString)\n    };\n}\n/**\n * Creates a `Content` object with a model role from a `PartListUnion` object or `string`.\n */ function createModelContent(partOrString) {\n    return {\n        role: \"model\",\n        parts: _toParts(partOrString)\n    };\n}\n/** A wrapper class for the http response. */ class HttpResponse {\n    constructor(response){\n        // Process the headers.\n        const headers = {};\n        for (const pair of response.headers.entries()){\n            headers[pair[0]] = pair[1];\n        }\n        this.headers = headers;\n        // Keep the original response.\n        this.responseInternal = response;\n    }\n    json() {\n        return this.responseInternal.json();\n    }\n}\n/** Content filter results for a prompt sent in the request. Note: This is sent only in the first stream chunk and only if no candidates were generated due to content violations. */ class GenerateContentResponsePromptFeedback {\n}\n/** Usage metadata about the content generation request and response. This message provides a detailed breakdown of token usage and other relevant metrics. This data type is not supported in Gemini API. */ class GenerateContentResponseUsageMetadata {\n}\n/** Response message for PredictionService.GenerateContent. */ class GenerateContentResponse {\n    /**\n     * Returns the concatenation of all text parts from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the text from the first\n     * one will be returned.\n     * If there are non-text parts in the response, the concatenation of all text\n     * parts will be returned, and a warning will be logged.\n     * If there are thought parts in the response, the concatenation of all text\n     * parts excluding the thought parts will be returned.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.generateContent({\n     *   model: 'gemini-2.0-flash',\n     *   contents:\n     *     'Why is the sky blue?',\n     * });\n     *\n     * console.debug(response.text);\n     * ```\n     */ get text() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn(\"there are multiple candidates in the response, returning text from the first one.\");\n        }\n        let text = \"\";\n        let anyTextPartText = false;\n        const nonTextParts = [];\n        for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []){\n            for (const [fieldName, fieldValue] of Object.entries(part)){\n                if (fieldName !== \"text\" && fieldName !== \"thought\" && fieldName !== \"thoughtSignature\" && (fieldValue !== null || fieldValue !== undefined)) {\n                    nonTextParts.push(fieldName);\n                }\n            }\n            if (typeof part.text === \"string\") {\n                if (typeof part.thought === \"boolean\" && part.thought) {\n                    continue;\n                }\n                anyTextPartText = true;\n                text += part.text;\n            }\n        }\n        if (nonTextParts.length > 0) {\n            console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);\n        }\n        // part.text === '' is different from part.text is null\n        return anyTextPartText ? text : undefined;\n    }\n    /**\n     * Returns the concatenation of all inline data parts from the first candidate\n     * in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the inline data from the\n     * first one will be returned. If there are non-inline data parts in the\n     * response, the concatenation of all inline data parts will be returned, and\n     * a warning will be logged.\n     */ get data() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn(\"there are multiple candidates in the response, returning data from the first one.\");\n        }\n        let data = \"\";\n        const nonDataParts = [];\n        for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []){\n            for (const [fieldName, fieldValue] of Object.entries(part)){\n                if (fieldName !== \"inlineData\" && (fieldValue !== null || fieldValue !== undefined)) {\n                    nonDataParts.push(fieldName);\n                }\n            }\n            if (part.inlineData && typeof part.inlineData.data === \"string\") {\n                data += atob(part.inlineData.data);\n            }\n        }\n        if (nonDataParts.length > 0) {\n            console.warn(`there are non-data parts ${nonDataParts} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`);\n        }\n        return data.length > 0 ? btoa(data) : undefined;\n    }\n    /**\n     * Returns the function calls from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the function calls from\n     * the first one will be returned.\n     * If there are no function calls in the response, undefined will be returned.\n     *\n     * @example\n     * ```ts\n     * const controlLightFunctionDeclaration: FunctionDeclaration = {\n     *   name: 'controlLight',\n     *   parameters: {\n     *   type: Type.OBJECT,\n     *   description: 'Set the brightness and color temperature of a room light.',\n     *   properties: {\n     *     brightness: {\n     *       type: Type.NUMBER,\n     *       description:\n     *         'Light level from 0 to 100. Zero is off and 100 is full brightness.',\n     *     },\n     *     colorTemperature: {\n     *       type: Type.STRING,\n     *       description:\n     *         'Color temperature of the light fixture which can be `daylight`, `cool` or `warm`.',\n     *     },\n     *   },\n     *   required: ['brightness', 'colorTemperature'],\n     *  };\n     *  const response = await ai.models.generateContent({\n     *     model: 'gemini-2.0-flash',\n     *     contents: 'Dim the lights so the room feels cozy and warm.',\n     *     config: {\n     *       tools: [{functionDeclarations: [controlLightFunctionDeclaration]}],\n     *       toolConfig: {\n     *         functionCallingConfig: {\n     *           mode: FunctionCallingConfigMode.ANY,\n     *           allowedFunctionNames: ['controlLight'],\n     *         },\n     *       },\n     *     },\n     *   });\n     *  console.debug(JSON.stringify(response.functionCalls));\n     * ```\n     */ get functionCalls() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn(\"there are multiple candidates in the response, returning function calls from the first one.\");\n        }\n        const functionCalls = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part)=>part.functionCall).map((part)=>part.functionCall).filter((functionCall)=>functionCall !== undefined);\n        if ((functionCalls === null || functionCalls === void 0 ? void 0 : functionCalls.length) === 0) {\n            return undefined;\n        }\n        return functionCalls;\n    }\n    /**\n     * Returns the first executable code from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the executable code from\n     * the first one will be returned.\n     * If there are no executable code in the response, undefined will be\n     * returned.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.generateContent({\n     *   model: 'gemini-2.0-flash',\n     *   contents:\n     *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'\n     *   config: {\n     *     tools: [{codeExecution: {}}],\n     *   },\n     * });\n     *\n     * console.debug(response.executableCode);\n     * ```\n     */ get executableCode() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn(\"there are multiple candidates in the response, returning executable code from the first one.\");\n        }\n        const executableCode = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part)=>part.executableCode).map((part)=>part.executableCode).filter((executableCode)=>executableCode !== undefined);\n        if ((executableCode === null || executableCode === void 0 ? void 0 : executableCode.length) === 0) {\n            return undefined;\n        }\n        return (_j = executableCode === null || executableCode === void 0 ? void 0 : executableCode[0]) === null || _j === void 0 ? void 0 : _j.code;\n    }\n    /**\n     * Returns the first code execution result from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the code execution result from\n     * the first one will be returned.\n     * If there are no code execution result in the response, undefined will be returned.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.generateContent({\n     *   model: 'gemini-2.0-flash',\n     *   contents:\n     *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'\n     *   config: {\n     *     tools: [{codeExecution: {}}],\n     *   },\n     * });\n     *\n     * console.debug(response.codeExecutionResult);\n     * ```\n     */ get codeExecutionResult() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn(\"there are multiple candidates in the response, returning code execution result from the first one.\");\n        }\n        const codeExecutionResult = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part)=>part.codeExecutionResult).map((part)=>part.codeExecutionResult).filter((codeExecutionResult)=>codeExecutionResult !== undefined);\n        if ((codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult.length) === 0) {\n            return undefined;\n        }\n        return (_j = codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult[0]) === null || _j === void 0 ? void 0 : _j.output;\n    }\n}\n/** Response for the embed_content method. */ class EmbedContentResponse {\n}\n/** The output images response. */ class GenerateImagesResponse {\n}\n/** Response for the request to edit an image. */ class EditImageResponse {\n}\nclass UpscaleImageResponse {\n}\n/** The output images response. */ class RecontextImageResponse {\n}\n/** The output images response. */ class SegmentImageResponse {\n}\nclass ListModelsResponse {\n}\nclass DeleteModelResponse {\n}\n/** Response for counting tokens. */ class CountTokensResponse {\n}\n/** Response for computing tokens. */ class ComputeTokensResponse {\n}\n/** Response with generated videos. */ class GenerateVideosResponse {\n}\n/** A video generation operation. */ class GenerateVideosOperation {\n    /**\n     * Instantiates an Operation of the same type as the one being called with the fields set from the API response.\n     * @internal\n     */ _fromAPIResponse({ apiResponse, _isVertexAI }) {\n        const operation = new GenerateVideosOperation();\n        let response;\n        const op = apiResponse;\n        if (_isVertexAI) {\n            response = generateVideosOperationFromVertex$1(op);\n        } else {\n            response = generateVideosOperationFromMldev$1(op);\n        }\n        Object.assign(operation, response);\n        return operation;\n    }\n}\n/** Response for the list tuning jobs method. */ class ListTuningJobsResponse {\n}\n/** Empty response for tunings.cancel method. */ class CancelTuningJobResponse {\n}\n/** Empty response for caches.delete method. */ class DeleteCachedContentResponse {\n}\nclass ListCachedContentsResponse {\n}\n/** Config for documents.list return value. */ class ListDocumentsResponse {\n}\n/** Config for file_search_stores.list return value. */ class ListFileSearchStoresResponse {\n}\n/** Response for the resumable upload method. */ class UploadToFileSearchStoreResumableResponse {\n}\n/** Response for ImportFile to import a File API file with a file search store. */ class ImportFileResponse {\n}\n/** Long-running operation for importing a file to a FileSearchStore. */ class ImportFileOperation {\n    /**\n     * Instantiates an Operation of the same type as the one being called with the fields set from the API response.\n     * @internal\n     */ _fromAPIResponse({ apiResponse, _isVertexAI }) {\n        const operation = new ImportFileOperation();\n        const op = apiResponse;\n        const response = importFileOperationFromMldev$1(op);\n        Object.assign(operation, response);\n        return operation;\n    }\n}\n/** Response for the list files method. */ class ListFilesResponse {\n}\n/** Response for the create file method. */ class CreateFileResponse {\n}\n/** Response for the delete file method. */ class DeleteFileResponse {\n}\n/** Config for `inlined_responses` parameter. */ class InlinedResponse {\n}\n/** Config for `response` parameter. */ class SingleEmbedContentResponse {\n}\n/** Config for `inlined_embedding_responses` parameter. */ class InlinedEmbedContentResponse {\n}\n/** Config for batches.list return value. */ class ListBatchJobsResponse {\n}\n/** Represents a single response in a replay. */ class ReplayResponse {\n}\n/** A raw reference image.\n\nA raw reference image represents the base image to edit, provided by the user.\nIt can optionally be provided in addition to a mask reference image or\na style reference image. */ class RawReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */ toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: \"REFERENCE_TYPE_RAW\",\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId\n        };\n        return referenceImageAPI;\n    }\n}\n/** A mask reference image.\n\nThis encapsulates either a mask image provided by the user and configs for\nthe user provided mask, or only config parameters for the model to generate\na mask.\n\nA mask image is an image whose non-zero values indicate where to edit the base\nimage. If the user provides a mask image, the mask must be in the same\ndimensions as the raw image. */ class MaskReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */ toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: \"REFERENCE_TYPE_MASK\",\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n            maskImageConfig: this.config\n        };\n        return referenceImageAPI;\n    }\n}\n/** A control reference image.\n\nThe image of the control reference image is either a control image provided\nby the user, or a regular image which the backend will use to generate a\ncontrol image of. In the case of the latter, the\nenable_control_image_computation field in the config should be set to True.\n\nA control image is an image that represents a sketch image of areas for the\nmodel to fill in based on the prompt. */ class ControlReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */ toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: \"REFERENCE_TYPE_CONTROL\",\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n            controlImageConfig: this.config\n        };\n        return referenceImageAPI;\n    }\n}\n/** A style reference image.\n\nThis encapsulates a style reference image provided by the user, and\nadditionally optional config parameters for the style reference image.\n\nA raw reference image can also be provided as a destination for the style to\nbe applied to. */ class StyleReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */ toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: \"REFERENCE_TYPE_STYLE\",\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n            styleImageConfig: this.config\n        };\n        return referenceImageAPI;\n    }\n}\n/** A subject reference image.\n\nThis encapsulates a subject reference image provided by the user, and\nadditionally optional config parameters for the subject reference image.\n\nA raw reference image can also be provided as a destination for the subject to\nbe applied to. */ class SubjectReferenceImage {\n    /* Internal method to convert to ReferenceImageAPIInternal. */ toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: \"REFERENCE_TYPE_SUBJECT\",\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n            subjectImageConfig: this.config\n        };\n        return referenceImageAPI;\n    }\n}\n/** A content reference image.\n\nA content reference image represents a subject to reference (ex. person,\nproduct, animal) provided by the user. It can optionally be provided in\naddition to a style reference image (ex. background, style reference). */ class ContentReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */ toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: \"REFERENCE_TYPE_CONTENT\",\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId\n        };\n        return referenceImageAPI;\n    }\n}\n/** Response message for API call. */ class LiveServerMessage {\n    /**\n     * Returns the concatenation of all text parts from the server content if present.\n     *\n     * @remarks\n     * If there are non-text parts in the response, the concatenation of all text\n     * parts will be returned, and a warning will be logged.\n     */ get text() {\n        var _a, _b, _c;\n        let text = \"\";\n        let anyTextPartFound = false;\n        const nonTextParts = [];\n        for (const part of (_c = (_b = (_a = this.serverContent) === null || _a === void 0 ? void 0 : _a.modelTurn) === null || _b === void 0 ? void 0 : _b.parts) !== null && _c !== void 0 ? _c : []){\n            for (const [fieldName, fieldValue] of Object.entries(part)){\n                if (fieldName !== \"text\" && fieldName !== \"thought\" && fieldValue !== null) {\n                    nonTextParts.push(fieldName);\n                }\n            }\n            if (typeof part.text === \"string\") {\n                if (typeof part.thought === \"boolean\" && part.thought) {\n                    continue;\n                }\n                anyTextPartFound = true;\n                text += part.text;\n            }\n        }\n        if (nonTextParts.length > 0) {\n            console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);\n        }\n        // part.text === '' is different from part.text is null\n        return anyTextPartFound ? text : undefined;\n    }\n    /**\n     * Returns the concatenation of all inline data parts from the server content if present.\n     *\n     * @remarks\n     * If there are non-inline data parts in the\n     * response, the concatenation of all inline data parts will be returned, and\n     * a warning will be logged.\n     */ get data() {\n        var _a, _b, _c;\n        let data = \"\";\n        const nonDataParts = [];\n        for (const part of (_c = (_b = (_a = this.serverContent) === null || _a === void 0 ? void 0 : _a.modelTurn) === null || _b === void 0 ? void 0 : _b.parts) !== null && _c !== void 0 ? _c : []){\n            for (const [fieldName, fieldValue] of Object.entries(part)){\n                if (fieldName !== \"inlineData\" && fieldValue !== null) {\n                    nonDataParts.push(fieldName);\n                }\n            }\n            if (part.inlineData && typeof part.inlineData.data === \"string\") {\n                data += atob(part.inlineData.data);\n            }\n        }\n        if (nonDataParts.length > 0) {\n            console.warn(`there are non-data parts ${nonDataParts} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`);\n        }\n        return data.length > 0 ? btoa(data) : undefined;\n    }\n}\n/** Client generated response to a `ToolCall` received from the server.\n\nIndividual `FunctionResponse` objects are matched to the respective\n`FunctionCall` objects by the `id` field.\n\nNote that in the unary and server-streaming GenerateContent APIs function\ncalling happens by exchanging the `Content` parts, while in the bidi\nGenerateContent APIs function calling happens over this dedicated set of\nmessages. */ class LiveClientToolResponse {\n}\n/** Parameters for sending tool responses to the live API. */ class LiveSendToolResponseParameters {\n    constructor(){\n        /** Tool responses to send to the session. */ this.functionResponses = [];\n    }\n}\n/** Response message for the LiveMusicClientMessage call. */ class LiveMusicServerMessage {\n    /**\n     * Returns the first audio chunk from the server content, if present.\n     *\n     * @remarks\n     * If there are no audio chunks in the response, undefined will be returned.\n     */ get audioChunk() {\n        if (this.serverContent && this.serverContent.audioChunks && this.serverContent.audioChunks.length > 0) {\n            return this.serverContent.audioChunks[0];\n        }\n        return undefined;\n    }\n}\n/** The response when long-running operation for uploading a file to a FileSearchStore complete. */ class UploadToFileSearchStoreResponse {\n}\n/** Long-running operation for uploading a file to a FileSearchStore. */ class UploadToFileSearchStoreOperation {\n    /**\n     * Instantiates an Operation of the same type as the one being called with the fields set from the API response.\n     * @internal\n     */ _fromAPIResponse({ apiResponse, _isVertexAI }) {\n        const operation = new UploadToFileSearchStoreOperation();\n        const op = apiResponse;\n        const response = uploadToFileSearchStoreOperationFromMldev(op);\n        Object.assign(operation, response);\n        return operation;\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function tModel(apiClient, model) {\n    if (!model || typeof model !== \"string\") {\n        throw new Error(\"model is required and must be a string\");\n    }\n    if (model.includes(\"..\") || model.includes(\"?\") || model.includes(\"&\")) {\n        throw new Error(\"invalid model parameter\");\n    }\n    if (apiClient.isVertexAI()) {\n        if (model.startsWith(\"publishers/\") || model.startsWith(\"projects/\") || model.startsWith(\"models/\")) {\n            return model;\n        } else if (model.indexOf(\"/\") >= 0) {\n            const parts = model.split(\"/\", 2);\n            return `publishers/${parts[0]}/models/${parts[1]}`;\n        } else {\n            return `publishers/google/models/${model}`;\n        }\n    } else {\n        if (model.startsWith(\"models/\") || model.startsWith(\"tunedModels/\")) {\n            return model;\n        } else {\n            return `models/${model}`;\n        }\n    }\n}\nfunction tCachesModel(apiClient, model) {\n    const transformedModel = tModel(apiClient, model);\n    if (!transformedModel) {\n        return \"\";\n    }\n    if (transformedModel.startsWith(\"publishers/\") && apiClient.isVertexAI()) {\n        // vertex caches only support model name start with projects.\n        return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/${transformedModel}`;\n    } else if (transformedModel.startsWith(\"models/\") && apiClient.isVertexAI()) {\n        return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/publishers/google/${transformedModel}`;\n    } else {\n        return transformedModel;\n    }\n}\nfunction tBlobs(blobs) {\n    if (Array.isArray(blobs)) {\n        return blobs.map((blob)=>tBlob(blob));\n    } else {\n        return [\n            tBlob(blobs)\n        ];\n    }\n}\nfunction tBlob(blob) {\n    if (typeof blob === \"object\" && blob !== null) {\n        return blob;\n    }\n    throw new Error(`Could not parse input as Blob. Unsupported blob type: ${typeof blob}`);\n}\nfunction tImageBlob(blob) {\n    const transformedBlob = tBlob(blob);\n    if (transformedBlob.mimeType && transformedBlob.mimeType.startsWith(\"image/\")) {\n        return transformedBlob;\n    }\n    throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);\n}\nfunction tAudioBlob(blob) {\n    const transformedBlob = tBlob(blob);\n    if (transformedBlob.mimeType && transformedBlob.mimeType.startsWith(\"audio/\")) {\n        return transformedBlob;\n    }\n    throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);\n}\nfunction tPart(origin) {\n    if (origin === null || origin === undefined) {\n        throw new Error(\"PartUnion is required\");\n    }\n    if (typeof origin === \"object\") {\n        return origin;\n    }\n    if (typeof origin === \"string\") {\n        return {\n            text: origin\n        };\n    }\n    throw new Error(`Unsupported part type: ${typeof origin}`);\n}\nfunction tParts(origin) {\n    if (origin === null || origin === undefined || Array.isArray(origin) && origin.length === 0) {\n        throw new Error(\"PartListUnion is required\");\n    }\n    if (Array.isArray(origin)) {\n        return origin.map((item)=>tPart(item));\n    }\n    return [\n        tPart(origin)\n    ];\n}\nfunction _isContent(origin) {\n    return origin !== null && origin !== undefined && typeof origin === \"object\" && \"parts\" in origin && Array.isArray(origin.parts);\n}\nfunction _isFunctionCallPart(origin) {\n    return origin !== null && origin !== undefined && typeof origin === \"object\" && \"functionCall\" in origin;\n}\nfunction _isFunctionResponsePart(origin) {\n    return origin !== null && origin !== undefined && typeof origin === \"object\" && \"functionResponse\" in origin;\n}\nfunction tContent(origin) {\n    if (origin === null || origin === undefined) {\n        throw new Error(\"ContentUnion is required\");\n    }\n    if (_isContent(origin)) {\n        // _isContent is a utility function that checks if the\n        // origin is a Content.\n        return origin;\n    }\n    return {\n        role: \"user\",\n        parts: tParts(origin)\n    };\n}\nfunction tContentsForEmbed(apiClient, origin) {\n    if (!origin) {\n        return [];\n    }\n    if (apiClient.isVertexAI() && Array.isArray(origin)) {\n        return origin.flatMap((item)=>{\n            const content = tContent(item);\n            if (content.parts && content.parts.length > 0 && content.parts[0].text !== undefined) {\n                return [\n                    content.parts[0].text\n                ];\n            }\n            return [];\n        });\n    } else if (apiClient.isVertexAI()) {\n        const content = tContent(origin);\n        if (content.parts && content.parts.length > 0 && content.parts[0].text !== undefined) {\n            return [\n                content.parts[0].text\n            ];\n        }\n        return [];\n    }\n    if (Array.isArray(origin)) {\n        return origin.map((item)=>tContent(item));\n    }\n    return [\n        tContent(origin)\n    ];\n}\nfunction tContents(origin) {\n    if (origin === null || origin === undefined || Array.isArray(origin) && origin.length === 0) {\n        throw new Error(\"contents are required\");\n    }\n    if (!Array.isArray(origin)) {\n        // If it's not an array, it's a single content or a single PartUnion.\n        if (_isFunctionCallPart(origin) || _isFunctionResponsePart(origin)) {\n            throw new Error(\"To specify functionCall or functionResponse parts, please wrap them in a Content object, specifying the role for them\");\n        }\n        return [\n            tContent(origin)\n        ];\n    }\n    const result = [];\n    const accumulatedParts = [];\n    const isContentArray = _isContent(origin[0]);\n    for (const item of origin){\n        const isContent = _isContent(item);\n        if (isContent != isContentArray) {\n            throw new Error(\"Mixing Content and Parts is not supported, please group the parts into a the appropriate Content objects and specify the roles for them\");\n        }\n        if (isContent) {\n            // `isContent` contains the result of _isContent, which is a utility\n            // function that checks if the item is a Content.\n            result.push(item);\n        } else if (_isFunctionCallPart(item) || _isFunctionResponsePart(item)) {\n            throw new Error(\"To specify functionCall or functionResponse parts, please wrap them, and any other parts, in Content objects as appropriate, specifying the role for them\");\n        } else {\n            accumulatedParts.push(item);\n        }\n    }\n    if (!isContentArray) {\n        result.push({\n            role: \"user\",\n            parts: tParts(accumulatedParts)\n        });\n    }\n    return result;\n}\n/*\nTransform the type field from an array of types to an array of anyOf fields.\nExample:\n  {type: ['STRING', 'NUMBER']}\nwill be transformed to\n  {anyOf: [{type: 'STRING'}, {type: 'NUMBER'}]}\n*/ function flattenTypeArrayToAnyOf(typeList, resultingSchema) {\n    if (typeList.includes(\"null\")) {\n        resultingSchema[\"nullable\"] = true;\n    }\n    const listWithoutNull = typeList.filter((type)=>type !== \"null\");\n    if (listWithoutNull.length === 1) {\n        resultingSchema[\"type\"] = Object.values(Type).includes(listWithoutNull[0].toUpperCase()) ? listWithoutNull[0].toUpperCase() : Type.TYPE_UNSPECIFIED;\n    } else {\n        resultingSchema[\"anyOf\"] = [];\n        for (const i of listWithoutNull){\n            resultingSchema[\"anyOf\"].push({\n                \"type\": Object.values(Type).includes(i.toUpperCase()) ? i.toUpperCase() : Type.TYPE_UNSPECIFIED\n            });\n        }\n    }\n}\nfunction processJsonSchema(_jsonSchema) {\n    const genAISchema = {};\n    const schemaFieldNames = [\n        \"items\"\n    ];\n    const listSchemaFieldNames = [\n        \"anyOf\"\n    ];\n    const dictSchemaFieldNames = [\n        \"properties\"\n    ];\n    if (_jsonSchema[\"type\"] && _jsonSchema[\"anyOf\"]) {\n        throw new Error(\"type and anyOf cannot be both populated.\");\n    }\n    /*\n    This is to handle the nullable array or object. The _jsonSchema will\n    be in the format of {anyOf: [{type: 'null'}, {type: 'object'}]}. The\n    logic is to check if anyOf has 2 elements and one of the element is null,\n    if so, the anyOf field is unnecessary, so we need to get rid of the anyOf\n    field and make the schema nullable. Then use the other element as the new\n    _jsonSchema for processing. This is because the backend doesn't have a null\n    type.\n    This has to be checked before we process any other fields.\n    For example:\n      const objectNullable = z.object({\n        nullableArray: z.array(z.string()).nullable(),\n      });\n    Will have the raw _jsonSchema as:\n    {\n      type: 'OBJECT',\n      properties: {\n          nullableArray: {\n             anyOf: [\n                {type: 'null'},\n                {\n                  type: 'array',\n                  items: {type: 'string'},\n                },\n              ],\n          }\n      },\n      required: [ 'nullableArray' ],\n    }\n    Will result in following schema compatible with Gemini API:\n      {\n        type: 'OBJECT',\n        properties: {\n           nullableArray: {\n              nullable: true,\n              type: 'ARRAY',\n              items: {type: 'string'},\n           }\n        },\n        required: [ 'nullableArray' ],\n      }\n    */ const incomingAnyOf = _jsonSchema[\"anyOf\"];\n    if (incomingAnyOf != null && incomingAnyOf.length == 2) {\n        if (incomingAnyOf[0][\"type\"] === \"null\") {\n            genAISchema[\"nullable\"] = true;\n            _jsonSchema = incomingAnyOf[1];\n        } else if (incomingAnyOf[1][\"type\"] === \"null\") {\n            genAISchema[\"nullable\"] = true;\n            _jsonSchema = incomingAnyOf[0];\n        }\n    }\n    if (_jsonSchema[\"type\"] instanceof Array) {\n        flattenTypeArrayToAnyOf(_jsonSchema[\"type\"], genAISchema);\n    }\n    for (const [fieldName, fieldValue] of Object.entries(_jsonSchema)){\n        // Skip if the fieldvalue is undefined or null.\n        if (fieldValue == null) {\n            continue;\n        }\n        if (fieldName == \"type\") {\n            if (fieldValue === \"null\") {\n                throw new Error(\"type: null can not be the only possible type for the field.\");\n            }\n            if (fieldValue instanceof Array) {\n                continue;\n            }\n            genAISchema[\"type\"] = Object.values(Type).includes(fieldValue.toUpperCase()) ? fieldValue.toUpperCase() : Type.TYPE_UNSPECIFIED;\n        } else if (schemaFieldNames.includes(fieldName)) {\n            genAISchema[fieldName] = processJsonSchema(fieldValue);\n        } else if (listSchemaFieldNames.includes(fieldName)) {\n            const listSchemaFieldValue = [];\n            for (const item of fieldValue){\n                if (item[\"type\"] == \"null\") {\n                    genAISchema[\"nullable\"] = true;\n                    continue;\n                }\n                listSchemaFieldValue.push(processJsonSchema(item));\n            }\n            genAISchema[fieldName] = listSchemaFieldValue;\n        } else if (dictSchemaFieldNames.includes(fieldName)) {\n            const dictSchemaFieldValue = {};\n            for (const [key, value] of Object.entries(fieldValue)){\n                dictSchemaFieldValue[key] = processJsonSchema(value);\n            }\n            genAISchema[fieldName] = dictSchemaFieldValue;\n        } else {\n            // additionalProperties is not included in JSONSchema, skipping it.\n            if (fieldName === \"additionalProperties\") {\n                continue;\n            }\n            genAISchema[fieldName] = fieldValue;\n        }\n    }\n    return genAISchema;\n}\n// we take the unknown in the schema field because we want enable user to pass\n// the output of major schema declaration tools without casting. Tools such as\n// zodToJsonSchema, typebox, zodToJsonSchema function can return JsonSchema7Type\n// or object, see details in\n// https://github.com/StefanTerdell/zod-to-json-schema/blob/70525efe555cd226691e093d171370a3b10921d1/src/zodToJsonSchema.ts#L7\n// typebox can return unknown, see details in\n// https://github.com/sinclairzx81/typebox/blob/5a5431439f7d5ca6b494d0d18fbfd7b1a356d67c/src/type/create/type.ts#L35\n// Note: proper json schemas with the $schema field set never arrive to this\n// transformer. Schemas with $schema are routed to the equivalent API json\n// schema field.\nfunction tSchema(schema) {\n    return processJsonSchema(schema);\n}\nfunction tSpeechConfig(speechConfig) {\n    if (typeof speechConfig === \"object\") {\n        return speechConfig;\n    } else if (typeof speechConfig === \"string\") {\n        return {\n            voiceConfig: {\n                prebuiltVoiceConfig: {\n                    voiceName: speechConfig\n                }\n            }\n        };\n    } else {\n        throw new Error(`Unsupported speechConfig type: ${typeof speechConfig}`);\n    }\n}\nfunction tLiveSpeechConfig(speechConfig) {\n    if (\"multiSpeakerVoiceConfig\" in speechConfig) {\n        throw new Error(\"multiSpeakerVoiceConfig is not supported in the live API.\");\n    }\n    return speechConfig;\n}\nfunction tTool(tool) {\n    if (tool.functionDeclarations) {\n        for (const functionDeclaration of tool.functionDeclarations){\n            if (functionDeclaration.parameters) {\n                if (!Object.keys(functionDeclaration.parameters).includes(\"$schema\")) {\n                    functionDeclaration.parameters = processJsonSchema(functionDeclaration.parameters);\n                } else {\n                    if (!functionDeclaration.parametersJsonSchema) {\n                        functionDeclaration.parametersJsonSchema = functionDeclaration.parameters;\n                        delete functionDeclaration.parameters;\n                    }\n                }\n            }\n            if (functionDeclaration.response) {\n                if (!Object.keys(functionDeclaration.response).includes(\"$schema\")) {\n                    functionDeclaration.response = processJsonSchema(functionDeclaration.response);\n                } else {\n                    if (!functionDeclaration.responseJsonSchema) {\n                        functionDeclaration.responseJsonSchema = functionDeclaration.response;\n                        delete functionDeclaration.response;\n                    }\n                }\n            }\n        }\n    }\n    return tool;\n}\nfunction tTools(tools) {\n    // Check if the incoming type is defined.\n    if (tools === undefined || tools === null) {\n        throw new Error(\"tools is required\");\n    }\n    if (!Array.isArray(tools)) {\n        throw new Error(\"tools is required and must be an array of Tools\");\n    }\n    const result = [];\n    for (const tool of tools){\n        result.push(tool);\n    }\n    return result;\n}\n/**\n * Prepends resource name with project, location, resource_prefix if needed.\n *\n * @param client The API client.\n * @param resourceName The resource name.\n * @param resourcePrefix The resource prefix.\n * @param splitsAfterPrefix The number of splits after the prefix.\n * @returns The completed resource name.\n *\n * Examples:\n *\n * ```\n * resource_name = '123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = True\n * client.project = 'bar'\n * client.location = 'us-west1'\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * returns: 'projects/bar/locations/us-west1/cachedContents/123'\n * ```\n *\n * ```\n * resource_name = 'projects/foo/locations/us-central1/cachedContents/123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = True\n * client.project = 'bar'\n * client.location = 'us-west1'\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * returns: 'projects/foo/locations/us-central1/cachedContents/123'\n * ```\n *\n * ```\n * resource_name = '123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = False\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * returns 'cachedContents/123'\n * ```\n *\n * ```\n * resource_name = 'some/wrong/cachedContents/resource/name/123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = False\n * # client.vertexai = True\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * -> 'some/wrong/resource/name/123'\n * ```\n */ function resourceName(client, resourceName, resourcePrefix, splitsAfterPrefix = 1) {\n    const shouldAppendPrefix = !resourceName.startsWith(`${resourcePrefix}/`) && resourceName.split(\"/\").length === splitsAfterPrefix;\n    if (client.isVertexAI()) {\n        if (resourceName.startsWith(\"projects/\")) {\n            return resourceName;\n        } else if (resourceName.startsWith(\"locations/\")) {\n            return `projects/${client.getProject()}/${resourceName}`;\n        } else if (resourceName.startsWith(`${resourcePrefix}/`)) {\n            return `projects/${client.getProject()}/locations/${client.getLocation()}/${resourceName}`;\n        } else if (shouldAppendPrefix) {\n            return `projects/${client.getProject()}/locations/${client.getLocation()}/${resourcePrefix}/${resourceName}`;\n        } else {\n            return resourceName;\n        }\n    }\n    if (shouldAppendPrefix) {\n        return `${resourcePrefix}/${resourceName}`;\n    }\n    return resourceName;\n}\nfunction tCachedContentName(apiClient, name) {\n    if (typeof name !== \"string\") {\n        throw new Error(\"name must be a string\");\n    }\n    return resourceName(apiClient, name, \"cachedContents\");\n}\nfunction tTuningJobStatus(status) {\n    switch(status){\n        case \"STATE_UNSPECIFIED\":\n            return \"JOB_STATE_UNSPECIFIED\";\n        case \"CREATING\":\n            return \"JOB_STATE_RUNNING\";\n        case \"ACTIVE\":\n            return \"JOB_STATE_SUCCEEDED\";\n        case \"FAILED\":\n            return \"JOB_STATE_FAILED\";\n        default:\n            return status;\n    }\n}\nfunction tBytes(fromImageBytes) {\n    return tBytes$1(fromImageBytes);\n}\nfunction _isFile(origin) {\n    return origin !== null && origin !== undefined && typeof origin === \"object\" && \"name\" in origin;\n}\nfunction isGeneratedVideo(origin) {\n    return origin !== null && origin !== undefined && typeof origin === \"object\" && \"video\" in origin;\n}\nfunction isVideo(origin) {\n    return origin !== null && origin !== undefined && typeof origin === \"object\" && \"uri\" in origin;\n}\nfunction tFileName(fromName) {\n    var _a;\n    let name;\n    if (_isFile(fromName)) {\n        name = fromName.name;\n    }\n    if (isVideo(fromName)) {\n        name = fromName.uri;\n        if (name === undefined) {\n            return undefined;\n        }\n    }\n    if (isGeneratedVideo(fromName)) {\n        name = (_a = fromName.video) === null || _a === void 0 ? void 0 : _a.uri;\n        if (name === undefined) {\n            return undefined;\n        }\n    }\n    if (typeof fromName === \"string\") {\n        name = fromName;\n    }\n    if (name === undefined) {\n        throw new Error(\"Could not extract file name from the provided input.\");\n    }\n    if (name.startsWith(\"https://\")) {\n        const suffix = name.split(\"files/\")[1];\n        const match = suffix.match(/[a-z0-9]+/);\n        if (match === null) {\n            throw new Error(`Could not extract file name from URI ${name}`);\n        }\n        name = match[0];\n    } else if (name.startsWith(\"files/\")) {\n        name = name.split(\"files/\")[1];\n    }\n    return name;\n}\nfunction tModelsUrl(apiClient, baseModels) {\n    let res;\n    if (apiClient.isVertexAI()) {\n        res = baseModels ? \"publishers/google/models\" : \"models\";\n    } else {\n        res = baseModels ? \"models\" : \"tunedModels\";\n    }\n    return res;\n}\nfunction tExtractModels(response) {\n    for (const key of [\n        \"models\",\n        \"tunedModels\",\n        \"publisherModels\"\n    ]){\n        if (hasField(response, key)) {\n            return response[key];\n        }\n    }\n    return [];\n}\nfunction hasField(data, fieldName) {\n    return data !== null && typeof data === \"object\" && fieldName in data;\n}\nfunction mcpToGeminiTool(mcpTool, config = {}) {\n    const mcpToolSchema = mcpTool;\n    const functionDeclaration = {\n        name: mcpToolSchema[\"name\"],\n        description: mcpToolSchema[\"description\"],\n        parametersJsonSchema: mcpToolSchema[\"inputSchema\"]\n    };\n    if (mcpToolSchema[\"outputSchema\"]) {\n        functionDeclaration[\"responseJsonSchema\"] = mcpToolSchema[\"outputSchema\"];\n    }\n    if (config.behavior) {\n        functionDeclaration[\"behavior\"] = config.behavior;\n    }\n    const geminiTool = {\n        functionDeclarations: [\n            functionDeclaration\n        ]\n    };\n    return geminiTool;\n}\n/**\n * Converts a list of MCP tools to a single Gemini tool with a list of function\n * declarations.\n */ function mcpToolsToGeminiTool(mcpTools, config = {}) {\n    const functionDeclarations = [];\n    const toolNames = new Set();\n    for (const mcpTool of mcpTools){\n        const mcpToolName = mcpTool.name;\n        if (toolNames.has(mcpToolName)) {\n            throw new Error(`Duplicate function name ${mcpToolName} found in MCP tools. Please ensure function names are unique.`);\n        }\n        toolNames.add(mcpToolName);\n        const geminiTool = mcpToGeminiTool(mcpTool, config);\n        if (geminiTool.functionDeclarations) {\n            functionDeclarations.push(...geminiTool.functionDeclarations);\n        }\n    }\n    return {\n        functionDeclarations: functionDeclarations\n    };\n}\n// Transforms a source input into a BatchJobSource object with validation.\nfunction tBatchJobSource(client, src) {\n    let sourceObj;\n    if (typeof src === \"string\") {\n        if (client.isVertexAI()) {\n            if (src.startsWith(\"gs://\")) {\n                sourceObj = {\n                    format: \"jsonl\",\n                    gcsUri: [\n                        src\n                    ]\n                };\n            } else if (src.startsWith(\"bq://\")) {\n                sourceObj = {\n                    format: \"bigquery\",\n                    bigqueryUri: src\n                };\n            } else {\n                throw new Error(`Unsupported string source for Vertex AI: ${src}`);\n            }\n        } else {\n            // MLDEV\n            if (src.startsWith(\"files/\")) {\n                sourceObj = {\n                    fileName: src\n                }; // Default to fileName for string input\n            } else {\n                throw new Error(`Unsupported string source for Gemini API: ${src}`);\n            }\n        }\n    } else if (Array.isArray(src)) {\n        if (client.isVertexAI()) {\n            throw new Error(\"InlinedRequest[] is not supported in Vertex AI.\");\n        }\n        sourceObj = {\n            inlinedRequests: src\n        };\n    } else {\n        // It's already a BatchJobSource object\n        sourceObj = src;\n    }\n    // Validation logic\n    const vertexSourcesCount = [\n        sourceObj.gcsUri,\n        sourceObj.bigqueryUri\n    ].filter(Boolean).length;\n    const mldevSourcesCount = [\n        sourceObj.inlinedRequests,\n        sourceObj.fileName\n    ].filter(Boolean).length;\n    if (client.isVertexAI()) {\n        if (mldevSourcesCount > 0 || vertexSourcesCount !== 1) {\n            throw new Error(\"Exactly one of `gcsUri` or `bigqueryUri` must be set for Vertex AI.\");\n        }\n    } else {\n        // MLDEV\n        if (vertexSourcesCount > 0 || mldevSourcesCount !== 1) {\n            throw new Error(\"Exactly one of `inlinedRequests`, `fileName`, \" + \"must be set for Gemini API.\");\n        }\n    }\n    return sourceObj;\n}\nfunction tBatchJobDestination(dest) {\n    if (typeof dest !== \"string\") {\n        return dest;\n    }\n    const destString = dest;\n    if (destString.startsWith(\"gs://\")) {\n        return {\n            format: \"jsonl\",\n            gcsUri: destString\n        };\n    } else if (destString.startsWith(\"bq://\")) {\n        return {\n            format: \"bigquery\",\n            bigqueryUri: destString\n        };\n    } else {\n        throw new Error(`Unsupported destination: ${destString}`);\n    }\n}\nfunction tRecvBatchJobDestination(dest) {\n    // Ensure dest is a non-null object before proceeding.\n    if (typeof dest !== \"object\" || dest === null) {\n        // If the input is not an object, it cannot be a valid BatchJobDestination\n        // based on the operations performed. Return it cast, or handle as an error.\n        // Casting an empty object might be a safe default.\n        return {};\n    }\n    // Cast to Record<string, unknown> to allow string property access.\n    const obj = dest;\n    // Safely access nested properties.\n    const inlineResponsesVal = obj[\"inlinedResponses\"];\n    if (typeof inlineResponsesVal !== \"object\" || inlineResponsesVal === null) {\n        return dest;\n    }\n    const inlineResponsesObj = inlineResponsesVal;\n    const responsesArray = inlineResponsesObj[\"inlinedResponses\"];\n    if (!Array.isArray(responsesArray) || responsesArray.length === 0) {\n        return dest;\n    }\n    // Check if any response has the 'embedding' property.\n    let hasEmbedding = false;\n    for (const responseItem of responsesArray){\n        if (typeof responseItem !== \"object\" || responseItem === null) {\n            continue;\n        }\n        const responseItemObj = responseItem;\n        const responseVal = responseItemObj[\"response\"];\n        if (typeof responseVal !== \"object\" || responseVal === null) {\n            continue;\n        }\n        const responseObj = responseVal;\n        // Check for the existence of the 'embedding' key.\n        if (responseObj[\"embedding\"] !== undefined) {\n            hasEmbedding = true;\n            break;\n        }\n    }\n    // Perform the transformation if an embedding was found.\n    if (hasEmbedding) {\n        obj[\"inlinedEmbedContentResponses\"] = obj[\"inlinedResponses\"];\n        delete obj[\"inlinedResponses\"];\n    }\n    // Cast the (potentially) modified object to the target type.\n    return dest;\n}\nfunction tBatchJobName(apiClient, name) {\n    const nameString = name;\n    if (!apiClient.isVertexAI()) {\n        const mldevPattern = /batches\\/[^/]+$/;\n        if (mldevPattern.test(nameString)) {\n            return nameString.split(\"/\").pop();\n        } else {\n            throw new Error(`Invalid batch job name: ${nameString}.`);\n        }\n    }\n    const vertexPattern = /^projects\\/[^/]+\\/locations\\/[^/]+\\/batchPredictionJobs\\/[^/]+$/;\n    if (vertexPattern.test(nameString)) {\n        return nameString.split(\"/\").pop();\n    } else if (/^\\d+$/.test(nameString)) {\n        return nameString;\n    } else {\n        throw new Error(`Invalid batch job name: ${nameString}.`);\n    }\n}\nfunction tJobState(state) {\n    const stateString = state;\n    if (stateString === \"BATCH_STATE_UNSPECIFIED\") {\n        return \"JOB_STATE_UNSPECIFIED\";\n    } else if (stateString === \"BATCH_STATE_PENDING\") {\n        return \"JOB_STATE_PENDING\";\n    } else if (stateString === \"BATCH_STATE_RUNNING\") {\n        return \"JOB_STATE_RUNNING\";\n    } else if (stateString === \"BATCH_STATE_SUCCEEDED\") {\n        return \"JOB_STATE_SUCCEEDED\";\n    } else if (stateString === \"BATCH_STATE_FAILED\") {\n        return \"JOB_STATE_FAILED\";\n    } else if (stateString === \"BATCH_STATE_CANCELLED\") {\n        return \"JOB_STATE_CANCELLED\";\n    } else if (stateString === \"BATCH_STATE_EXPIRED\") {\n        return \"JOB_STATE_EXPIRED\";\n    } else {\n        return stateString;\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function batchJobDestinationFromMldev(fromObject) {\n    const toObject = {};\n    const fromFileName = getValueByPath(fromObject, [\n        \"responsesFile\"\n    ]);\n    if (fromFileName != null) {\n        setValueByPath(toObject, [\n            \"fileName\"\n        ], fromFileName);\n    }\n    const fromInlinedResponses = getValueByPath(fromObject, [\n        \"inlinedResponses\",\n        \"inlinedResponses\"\n    ]);\n    if (fromInlinedResponses != null) {\n        let transformedList = fromInlinedResponses;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return inlinedResponseFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"inlinedResponses\"\n        ], transformedList);\n    }\n    const fromInlinedEmbedContentResponses = getValueByPath(fromObject, [\n        \"inlinedEmbedContentResponses\",\n        \"inlinedResponses\"\n    ]);\n    if (fromInlinedEmbedContentResponses != null) {\n        let transformedList = fromInlinedEmbedContentResponses;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"inlinedEmbedContentResponses\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction batchJobDestinationFromVertex(fromObject) {\n    const toObject = {};\n    const fromFormat = getValueByPath(fromObject, [\n        \"predictionsFormat\"\n    ]);\n    if (fromFormat != null) {\n        setValueByPath(toObject, [\n            \"format\"\n        ], fromFormat);\n    }\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsDestination\",\n        \"outputUriPrefix\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"gcsUri\"\n        ], fromGcsUri);\n    }\n    const fromBigqueryUri = getValueByPath(fromObject, [\n        \"bigqueryDestination\",\n        \"outputUri\"\n    ]);\n    if (fromBigqueryUri != null) {\n        setValueByPath(toObject, [\n            \"bigqueryUri\"\n        ], fromBigqueryUri);\n    }\n    return toObject;\n}\nfunction batchJobDestinationToVertex(fromObject) {\n    const toObject = {};\n    const fromFormat = getValueByPath(fromObject, [\n        \"format\"\n    ]);\n    if (fromFormat != null) {\n        setValueByPath(toObject, [\n            \"predictionsFormat\"\n        ], fromFormat);\n    }\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"gcsDestination\",\n            \"outputUriPrefix\"\n        ], fromGcsUri);\n    }\n    const fromBigqueryUri = getValueByPath(fromObject, [\n        \"bigqueryUri\"\n    ]);\n    if (fromBigqueryUri != null) {\n        setValueByPath(toObject, [\n            \"bigqueryDestination\",\n            \"outputUri\"\n        ], fromBigqueryUri);\n    }\n    if (getValueByPath(fromObject, [\n        \"fileName\"\n    ]) !== undefined) {\n        throw new Error(\"fileName parameter is not supported in Vertex AI.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"inlinedResponses\"\n    ]) !== undefined) {\n        throw new Error(\"inlinedResponses parameter is not supported in Vertex AI.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"inlinedEmbedContentResponses\"\n    ]) !== undefined) {\n        throw new Error(\"inlinedEmbedContentResponses parameter is not supported in Vertex AI.\");\n    }\n    return toObject;\n}\nfunction batchJobFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"metadata\",\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromState = getValueByPath(fromObject, [\n        \"metadata\",\n        \"state\"\n    ]);\n    if (fromState != null) {\n        setValueByPath(toObject, [\n            \"state\"\n        ], tJobState(fromState));\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"metadata\",\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"metadata\",\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"metadata\",\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    const fromModel = getValueByPath(fromObject, [\n        \"metadata\",\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], fromModel);\n    }\n    const fromDest = getValueByPath(fromObject, [\n        \"metadata\",\n        \"output\"\n    ]);\n    if (fromDest != null) {\n        setValueByPath(toObject, [\n            \"dest\"\n        ], batchJobDestinationFromMldev(tRecvBatchJobDestination(fromDest)));\n    }\n    return toObject;\n}\nfunction batchJobFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromState = getValueByPath(fromObject, [\n        \"state\"\n    ]);\n    if (fromState != null) {\n        setValueByPath(toObject, [\n            \"state\"\n        ], tJobState(fromState));\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromStartTime = getValueByPath(fromObject, [\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], fromModel);\n    }\n    const fromSrc = getValueByPath(fromObject, [\n        \"inputConfig\"\n    ]);\n    if (fromSrc != null) {\n        setValueByPath(toObject, [\n            \"src\"\n        ], batchJobSourceFromVertex(fromSrc));\n    }\n    const fromDest = getValueByPath(fromObject, [\n        \"outputConfig\"\n    ]);\n    if (fromDest != null) {\n        setValueByPath(toObject, [\n            \"dest\"\n        ], batchJobDestinationFromVertex(tRecvBatchJobDestination(fromDest)));\n    }\n    const fromCompletionStats = getValueByPath(fromObject, [\n        \"completionStats\"\n    ]);\n    if (fromCompletionStats != null) {\n        setValueByPath(toObject, [\n            \"completionStats\"\n        ], fromCompletionStats);\n    }\n    return toObject;\n}\nfunction batchJobSourceFromVertex(fromObject) {\n    const toObject = {};\n    const fromFormat = getValueByPath(fromObject, [\n        \"instancesFormat\"\n    ]);\n    if (fromFormat != null) {\n        setValueByPath(toObject, [\n            \"format\"\n        ], fromFormat);\n    }\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsSource\",\n        \"uris\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"gcsUri\"\n        ], fromGcsUri);\n    }\n    const fromBigqueryUri = getValueByPath(fromObject, [\n        \"bigquerySource\",\n        \"inputUri\"\n    ]);\n    if (fromBigqueryUri != null) {\n        setValueByPath(toObject, [\n            \"bigqueryUri\"\n        ], fromBigqueryUri);\n    }\n    return toObject;\n}\nfunction batchJobSourceToMldev(apiClient, fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"format\"\n    ]) !== undefined) {\n        throw new Error(\"format parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]) !== undefined) {\n        throw new Error(\"gcsUri parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"bigqueryUri\"\n    ]) !== undefined) {\n        throw new Error(\"bigqueryUri parameter is not supported in Gemini API.\");\n    }\n    const fromFileName = getValueByPath(fromObject, [\n        \"fileName\"\n    ]);\n    if (fromFileName != null) {\n        setValueByPath(toObject, [\n            \"fileName\"\n        ], fromFileName);\n    }\n    const fromInlinedRequests = getValueByPath(fromObject, [\n        \"inlinedRequests\"\n    ]);\n    if (fromInlinedRequests != null) {\n        let transformedList = fromInlinedRequests;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return inlinedRequestToMldev(apiClient, item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"requests\",\n            \"requests\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction batchJobSourceToVertex(fromObject) {\n    const toObject = {};\n    const fromFormat = getValueByPath(fromObject, [\n        \"format\"\n    ]);\n    if (fromFormat != null) {\n        setValueByPath(toObject, [\n            \"instancesFormat\"\n        ], fromFormat);\n    }\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"gcsSource\",\n            \"uris\"\n        ], fromGcsUri);\n    }\n    const fromBigqueryUri = getValueByPath(fromObject, [\n        \"bigqueryUri\"\n    ]);\n    if (fromBigqueryUri != null) {\n        setValueByPath(toObject, [\n            \"bigquerySource\",\n            \"inputUri\"\n        ], fromBigqueryUri);\n    }\n    if (getValueByPath(fromObject, [\n        \"fileName\"\n    ]) !== undefined) {\n        throw new Error(\"fileName parameter is not supported in Vertex AI.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"inlinedRequests\"\n    ]) !== undefined) {\n        throw new Error(\"inlinedRequests parameter is not supported in Vertex AI.\");\n    }\n    return toObject;\n}\nfunction blobToMldev$4(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction cancelBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction cancelBatchJobParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction candidateFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromContent = getValueByPath(fromObject, [\n        \"content\"\n    ]);\n    if (fromContent != null) {\n        setValueByPath(toObject, [\n            \"content\"\n        ], fromContent);\n    }\n    const fromCitationMetadata = getValueByPath(fromObject, [\n        \"citationMetadata\"\n    ]);\n    if (fromCitationMetadata != null) {\n        setValueByPath(toObject, [\n            \"citationMetadata\"\n        ], citationMetadataFromMldev$1(fromCitationMetadata));\n    }\n    const fromTokenCount = getValueByPath(fromObject, [\n        \"tokenCount\"\n    ]);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, [\n            \"tokenCount\"\n        ], fromTokenCount);\n    }\n    const fromFinishReason = getValueByPath(fromObject, [\n        \"finishReason\"\n    ]);\n    if (fromFinishReason != null) {\n        setValueByPath(toObject, [\n            \"finishReason\"\n        ], fromFinishReason);\n    }\n    const fromAvgLogprobs = getValueByPath(fromObject, [\n        \"avgLogprobs\"\n    ]);\n    if (fromAvgLogprobs != null) {\n        setValueByPath(toObject, [\n            \"avgLogprobs\"\n        ], fromAvgLogprobs);\n    }\n    const fromGroundingMetadata = getValueByPath(fromObject, [\n        \"groundingMetadata\"\n    ]);\n    if (fromGroundingMetadata != null) {\n        setValueByPath(toObject, [\n            \"groundingMetadata\"\n        ], fromGroundingMetadata);\n    }\n    const fromIndex = getValueByPath(fromObject, [\n        \"index\"\n    ]);\n    if (fromIndex != null) {\n        setValueByPath(toObject, [\n            \"index\"\n        ], fromIndex);\n    }\n    const fromLogprobsResult = getValueByPath(fromObject, [\n        \"logprobsResult\"\n    ]);\n    if (fromLogprobsResult != null) {\n        setValueByPath(toObject, [\n            \"logprobsResult\"\n        ], fromLogprobsResult);\n    }\n    const fromSafetyRatings = getValueByPath(fromObject, [\n        \"safetyRatings\"\n    ]);\n    if (fromSafetyRatings != null) {\n        let transformedList = fromSafetyRatings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"safetyRatings\"\n        ], transformedList);\n    }\n    const fromUrlContextMetadata = getValueByPath(fromObject, [\n        \"urlContextMetadata\"\n    ]);\n    if (fromUrlContextMetadata != null) {\n        setValueByPath(toObject, [\n            \"urlContextMetadata\"\n        ], fromUrlContextMetadata);\n    }\n    return toObject;\n}\nfunction citationMetadataFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromCitations = getValueByPath(fromObject, [\n        \"citationSources\"\n    ]);\n    if (fromCitations != null) {\n        let transformedList = fromCitations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"citations\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction contentToMldev$4(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partToMldev$4(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction createBatchJobConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"batch\",\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    if (getValueByPath(fromObject, [\n        \"dest\"\n    ]) !== undefined) {\n        throw new Error(\"dest parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction createBatchJobConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromDest = getValueByPath(fromObject, [\n        \"dest\"\n    ]);\n    if (parentObject !== undefined && fromDest != null) {\n        setValueByPath(parentObject, [\n            \"outputConfig\"\n        ], batchJobDestinationToVertex(tBatchJobDestination(fromDest)));\n    }\n    return toObject;\n}\nfunction createBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromSrc = getValueByPath(fromObject, [\n        \"src\"\n    ]);\n    if (fromSrc != null) {\n        setValueByPath(toObject, [\n            \"batch\",\n            \"inputConfig\"\n        ], batchJobSourceToMldev(apiClient, tBatchJobSource(apiClient, fromSrc)));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        createBatchJobConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction createBatchJobParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromSrc = getValueByPath(fromObject, [\n        \"src\"\n    ]);\n    if (fromSrc != null) {\n        setValueByPath(toObject, [\n            \"inputConfig\"\n        ], batchJobSourceToVertex(tBatchJobSource(apiClient, fromSrc)));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        createBatchJobConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction createEmbeddingsBatchJobConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"batch\",\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    return toObject;\n}\nfunction createEmbeddingsBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromSrc = getValueByPath(fromObject, [\n        \"src\"\n    ]);\n    if (fromSrc != null) {\n        setValueByPath(toObject, [\n            \"batch\",\n            \"inputConfig\"\n        ], embeddingsBatchJobSourceToMldev(apiClient, fromSrc));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        createEmbeddingsBatchJobConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction deleteBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction deleteBatchJobParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction deleteResourceJobFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    return toObject;\n}\nfunction deleteResourceJobFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    return toObject;\n}\nfunction embedContentBatchToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContentsForEmbed(apiClient, fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"requests[]\",\n            \"request\",\n            \"content\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"_self\"\n        ], embedContentConfigToMldev$1(fromConfig, toObject));\n        moveValueByPath(toObject, {\n            \"requests[].*\": \"requests[].request.*\"\n        });\n    }\n    return toObject;\n}\nfunction embedContentConfigToMldev$1(fromObject, parentObject) {\n    const toObject = {};\n    const fromTaskType = getValueByPath(fromObject, [\n        \"taskType\"\n    ]);\n    if (parentObject !== undefined && fromTaskType != null) {\n        setValueByPath(parentObject, [\n            \"requests[]\",\n            \"taskType\"\n        ], fromTaskType);\n    }\n    const fromTitle = getValueByPath(fromObject, [\n        \"title\"\n    ]);\n    if (parentObject !== undefined && fromTitle != null) {\n        setValueByPath(parentObject, [\n            \"requests[]\",\n            \"title\"\n        ], fromTitle);\n    }\n    const fromOutputDimensionality = getValueByPath(fromObject, [\n        \"outputDimensionality\"\n    ]);\n    if (parentObject !== undefined && fromOutputDimensionality != null) {\n        setValueByPath(parentObject, [\n            \"requests[]\",\n            \"outputDimensionality\"\n        ], fromOutputDimensionality);\n    }\n    if (getValueByPath(fromObject, [\n        \"mimeType\"\n    ]) !== undefined) {\n        throw new Error(\"mimeType parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"autoTruncate\"\n    ]) !== undefined) {\n        throw new Error(\"autoTruncate parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction embeddingsBatchJobSourceToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromFileName = getValueByPath(fromObject, [\n        \"fileName\"\n    ]);\n    if (fromFileName != null) {\n        setValueByPath(toObject, [\n            \"file_name\"\n        ], fromFileName);\n    }\n    const fromInlinedRequests = getValueByPath(fromObject, [\n        \"inlinedRequests\"\n    ]);\n    if (fromInlinedRequests != null) {\n        setValueByPath(toObject, [\n            \"requests\"\n        ], embedContentBatchToMldev(apiClient, fromInlinedRequests));\n    }\n    return toObject;\n}\nfunction fileDataToMldev$4(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction functionCallToMldev$4(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, [\n        \"id\"\n    ]);\n    if (fromId != null) {\n        setValueByPath(toObject, [\n            \"id\"\n        ], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, [\n        \"args\"\n    ]);\n    if (fromArgs != null) {\n        setValueByPath(toObject, [\n            \"args\"\n        ], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    if (getValueByPath(fromObject, [\n        \"partialArgs\"\n    ]) !== undefined) {\n        throw new Error(\"partialArgs parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"willContinue\"\n    ]) !== undefined) {\n        throw new Error(\"willContinue parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction functionCallingConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromAllowedFunctionNames = getValueByPath(fromObject, [\n        \"allowedFunctionNames\"\n    ]);\n    if (fromAllowedFunctionNames != null) {\n        setValueByPath(toObject, [\n            \"allowedFunctionNames\"\n        ], fromAllowedFunctionNames);\n    }\n    if (getValueByPath(fromObject, [\n        \"streamFunctionCallArguments\"\n    ]) !== undefined) {\n        throw new Error(\"streamFunctionCallArguments parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction generateContentConfigToMldev$1(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"systemInstruction\"\n        ], contentToMldev$4(tContent(fromSystemInstruction)));\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, [\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (fromTopP != null) {\n        setValueByPath(toObject, [\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (fromTopK != null) {\n        setValueByPath(toObject, [\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        \"candidateCount\"\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, [\n            \"candidateCount\"\n        ], fromCandidateCount);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, [\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        \"stopSequences\"\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, [\n            \"stopSequences\"\n        ], fromStopSequences);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        \"responseLogprobs\"\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, [\n            \"responseLogprobs\"\n        ], fromResponseLogprobs);\n    }\n    const fromLogprobs = getValueByPath(fromObject, [\n        \"logprobs\"\n    ]);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, [\n            \"logprobs\"\n        ], fromLogprobs);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        \"presencePenalty\"\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, [\n            \"presencePenalty\"\n        ], fromPresencePenalty);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        \"frequencyPenalty\"\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, [\n            \"frequencyPenalty\"\n        ], fromFrequencyPenalty);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (fromSeed != null) {\n        setValueByPath(toObject, [\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        \"responseMimeType\"\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, [\n            \"responseMimeType\"\n        ], fromResponseMimeType);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        \"responseSchema\"\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, [\n            \"responseSchema\"\n        ], tSchema(fromResponseSchema));\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    if (getValueByPath(fromObject, [\n        \"routingConfig\"\n    ]) !== undefined) {\n        throw new Error(\"routingConfig parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"modelSelectionConfig\"\n    ]) !== undefined) {\n        throw new Error(\"modelSelectionConfig parameter is not supported in Gemini API.\");\n    }\n    const fromSafetySettings = getValueByPath(fromObject, [\n        \"safetySettings\"\n    ]);\n    if (parentObject !== undefined && fromSafetySettings != null) {\n        let transformedList = fromSafetySettings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return safetySettingToMldev$1(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"safetySettings\"\n        ], transformedList);\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToMldev$4(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, [\n            \"tools\"\n        ], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, [\n        \"toolConfig\"\n    ]);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, [\n            \"toolConfig\"\n        ], toolConfigToMldev$2(fromToolConfig));\n    }\n    if (getValueByPath(fromObject, [\n        \"labels\"\n    ]) !== undefined) {\n        throw new Error(\"labels parameter is not supported in Gemini API.\");\n    }\n    const fromCachedContent = getValueByPath(fromObject, [\n        \"cachedContent\"\n    ]);\n    if (parentObject !== undefined && fromCachedContent != null) {\n        setValueByPath(parentObject, [\n            \"cachedContent\"\n        ], tCachedContentName(apiClient, fromCachedContent));\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, [\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, [\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, [\n            \"speechConfig\"\n        ], tSpeechConfig(fromSpeechConfig));\n    }\n    if (getValueByPath(fromObject, [\n        \"audioTimestamp\"\n    ]) !== undefined) {\n        throw new Error(\"audioTimestamp parameter is not supported in Gemini API.\");\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        \"thinkingConfig\"\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, [\n            \"thinkingConfig\"\n        ], fromThinkingConfig);\n    }\n    const fromImageConfig = getValueByPath(fromObject, [\n        \"imageConfig\"\n    ]);\n    if (fromImageConfig != null) {\n        setValueByPath(toObject, [\n            \"imageConfig\"\n        ], imageConfigToMldev$1(fromImageConfig));\n    }\n    return toObject;\n}\nfunction generateContentResponseFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromCandidates = getValueByPath(fromObject, [\n        \"candidates\"\n    ]);\n    if (fromCandidates != null) {\n        let transformedList = fromCandidates;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return candidateFromMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"candidates\"\n        ], transformedList);\n    }\n    const fromModelVersion = getValueByPath(fromObject, [\n        \"modelVersion\"\n    ]);\n    if (fromModelVersion != null) {\n        setValueByPath(toObject, [\n            \"modelVersion\"\n        ], fromModelVersion);\n    }\n    const fromPromptFeedback = getValueByPath(fromObject, [\n        \"promptFeedback\"\n    ]);\n    if (fromPromptFeedback != null) {\n        setValueByPath(toObject, [\n            \"promptFeedback\"\n        ], fromPromptFeedback);\n    }\n    const fromResponseId = getValueByPath(fromObject, [\n        \"responseId\"\n    ]);\n    if (fromResponseId != null) {\n        setValueByPath(toObject, [\n            \"responseId\"\n        ], fromResponseId);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        \"usageMetadata\"\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, [\n            \"usageMetadata\"\n        ], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction getBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction getBatchJobParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction googleMapsToMldev$4(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"authConfig\"\n    ]) !== undefined) {\n        throw new Error(\"authConfig parameter is not supported in Gemini API.\");\n    }\n    const fromEnableWidget = getValueByPath(fromObject, [\n        \"enableWidget\"\n    ]);\n    if (fromEnableWidget != null) {\n        setValueByPath(toObject, [\n            \"enableWidget\"\n        ], fromEnableWidget);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$4(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"excludeDomains\"\n    ]) !== undefined) {\n        throw new Error(\"excludeDomains parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"blockingConfidence\"\n    ]) !== undefined) {\n        throw new Error(\"blockingConfidence parameter is not supported in Gemini API.\");\n    }\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        \"timeRangeFilter\"\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, [\n            \"timeRangeFilter\"\n        ], fromTimeRangeFilter);\n    }\n    return toObject;\n}\nfunction imageConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (fromAspectRatio != null) {\n        setValueByPath(toObject, [\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    const fromImageSize = getValueByPath(fromObject, [\n        \"imageSize\"\n    ]);\n    if (fromImageSize != null) {\n        setValueByPath(toObject, [\n            \"imageSize\"\n        ], fromImageSize);\n    }\n    if (getValueByPath(fromObject, [\n        \"outputMimeType\"\n    ]) !== undefined) {\n        throw new Error(\"outputMimeType parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"outputCompressionQuality\"\n    ]) !== undefined) {\n        throw new Error(\"outputCompressionQuality parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction inlinedRequestToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"request\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentToMldev$4(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"request\",\n            \"contents\"\n        ], transformedList);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"request\",\n            \"generationConfig\"\n        ], generateContentConfigToMldev$1(apiClient, fromConfig, getValueByPath(toObject, [\n            \"request\"\n        ], {})));\n    }\n    return toObject;\n}\nfunction inlinedResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], generateContentResponseFromMldev$1(fromResponse));\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    return toObject;\n}\nfunction listBatchJobsConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    if (getValueByPath(fromObject, [\n        \"filter\"\n    ]) !== undefined) {\n        throw new Error(\"filter parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction listBatchJobsConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, [\n        \"filter\"\n    ]);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"filter\"\n        ], fromFilter);\n    }\n    return toObject;\n}\nfunction listBatchJobsParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listBatchJobsConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listBatchJobsParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listBatchJobsConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listBatchJobsResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromBatchJobs = getValueByPath(fromObject, [\n        \"operations\"\n    ]);\n    if (fromBatchJobs != null) {\n        let transformedList = fromBatchJobs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return batchJobFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"batchJobs\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction listBatchJobsResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromBatchJobs = getValueByPath(fromObject, [\n        \"batchPredictionJobs\"\n    ]);\n    if (fromBatchJobs != null) {\n        let transformedList = fromBatchJobs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return batchJobFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"batchJobs\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction partToMldev$4(fromObject) {\n    const toObject = {};\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, [\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataToMldev$4(fromFileData));\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], functionCallToMldev$4(fromFunctionCall));\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobToMldev$4(fromInlineData));\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], fromVideoMetadata);\n    }\n    return toObject;\n}\nfunction safetySettingToMldev$1(fromObject) {\n    const toObject = {};\n    const fromCategory = getValueByPath(fromObject, [\n        \"category\"\n    ]);\n    if (fromCategory != null) {\n        setValueByPath(toObject, [\n            \"category\"\n        ], fromCategory);\n    }\n    if (getValueByPath(fromObject, [\n        \"method\"\n    ]) !== undefined) {\n        throw new Error(\"method parameter is not supported in Gemini API.\");\n    }\n    const fromThreshold = getValueByPath(fromObject, [\n        \"threshold\"\n    ]);\n    if (fromThreshold != null) {\n        setValueByPath(toObject, [\n            \"threshold\"\n        ], fromThreshold);\n    }\n    return toObject;\n}\nfunction toolConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromFunctionCallingConfig = getValueByPath(fromObject, [\n        \"functionCallingConfig\"\n    ]);\n    if (fromFunctionCallingConfig != null) {\n        setValueByPath(toObject, [\n            \"functionCallingConfig\"\n        ], functionCallingConfigToMldev$2(fromFunctionCallingConfig));\n    }\n    const fromRetrievalConfig = getValueByPath(fromObject, [\n        \"retrievalConfig\"\n    ]);\n    if (fromRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"retrievalConfig\"\n        ], fromRetrievalConfig);\n    }\n    return toObject;\n}\nfunction toolToMldev$4(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    if (getValueByPath(fromObject, [\n        \"retrieval\"\n    ]) !== undefined) {\n        throw new Error(\"retrieval parameter is not supported in Gemini API.\");\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], fromGoogleSearchRetrieval);\n    }\n    const fromComputerUse = getValueByPath(fromObject, [\n        \"computerUse\"\n    ]);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, [\n            \"computerUse\"\n        ], fromComputerUse);\n    }\n    const fromFileSearch = getValueByPath(fromObject, [\n        \"fileSearch\"\n    ]);\n    if (fromFileSearch != null) {\n        setValueByPath(toObject, [\n            \"fileSearch\"\n        ], fromFileSearch);\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    if (getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]) !== undefined) {\n        throw new Error(\"enterpriseWebSearch parameter is not supported in Gemini API.\");\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, [\n            \"googleMaps\"\n        ], googleMapsToMldev$4(fromGoogleMaps));\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToMldev$4(fromGoogleSearch));\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], fromUrlContext);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ var PagedItem;\n(function(PagedItem) {\n    PagedItem[\"PAGED_ITEM_BATCH_JOBS\"] = \"batchJobs\";\n    PagedItem[\"PAGED_ITEM_MODELS\"] = \"models\";\n    PagedItem[\"PAGED_ITEM_TUNING_JOBS\"] = \"tuningJobs\";\n    PagedItem[\"PAGED_ITEM_FILES\"] = \"files\";\n    PagedItem[\"PAGED_ITEM_CACHED_CONTENTS\"] = \"cachedContents\";\n    PagedItem[\"PAGED_ITEM_FILE_SEARCH_STORES\"] = \"fileSearchStores\";\n    PagedItem[\"PAGED_ITEM_DOCUMENTS\"] = \"documents\";\n})(PagedItem || (PagedItem = {}));\n/**\n * Pager class for iterating through paginated results.\n */ class Pager {\n    constructor(name, request, response, params){\n        this.pageInternal = [];\n        this.paramsInternal = {};\n        this.requestInternal = request;\n        this.init(name, response, params);\n    }\n    init(name, response, params) {\n        var _a, _b;\n        this.nameInternal = name;\n        this.pageInternal = response[this.nameInternal] || [];\n        this.sdkHttpResponseInternal = response === null || response === void 0 ? void 0 : response.sdkHttpResponse;\n        this.idxInternal = 0;\n        let requestParams = {\n            config: {}\n        };\n        if (!params || Object.keys(params).length === 0) {\n            requestParams = {\n                config: {}\n            };\n        } else if (typeof params === \"object\") {\n            requestParams = Object.assign({}, params);\n        } else {\n            requestParams = params;\n        }\n        if (requestParams[\"config\"]) {\n            requestParams[\"config\"][\"pageToken\"] = response[\"nextPageToken\"];\n        }\n        this.paramsInternal = requestParams;\n        this.pageInternalSize = (_b = (_a = requestParams[\"config\"]) === null || _a === void 0 ? void 0 : _a[\"pageSize\"]) !== null && _b !== void 0 ? _b : this.pageInternal.length;\n    }\n    initNextPage(response) {\n        this.init(this.nameInternal, response, this.paramsInternal);\n    }\n    /**\n     * Returns the current page, which is a list of items.\n     *\n     * @remarks\n     * The first page is retrieved when the pager is created. The returned list of\n     * items could be a subset of the entire list.\n     */ get page() {\n        return this.pageInternal;\n    }\n    /**\n     * Returns the type of paged item (for example, ``batch_jobs``).\n     */ get name() {\n        return this.nameInternal;\n    }\n    /**\n     * Returns the length of the page fetched each time by this pager.\n     *\n     * @remarks\n     * The number of items in the page is less than or equal to the page length.\n     */ get pageSize() {\n        return this.pageInternalSize;\n    }\n    /**\n     * Returns the headers of the API response.\n     */ get sdkHttpResponse() {\n        return this.sdkHttpResponseInternal;\n    }\n    /**\n     * Returns the parameters when making the API request for the next page.\n     *\n     * @remarks\n     * Parameters contain a set of optional configs that can be\n     * used to customize the API request. For example, the `pageToken` parameter\n     * contains the token to request the next page.\n     */ get params() {\n        return this.paramsInternal;\n    }\n    /**\n     * Returns the total number of items in the current page.\n     */ get pageLength() {\n        return this.pageInternal.length;\n    }\n    /**\n     * Returns the item at the given index.\n     */ getItem(index) {\n        return this.pageInternal[index];\n    }\n    /**\n     * Returns an async iterator that support iterating through all items\n     * retrieved from the API.\n     *\n     * @remarks\n     * The iterator will automatically fetch the next page if there are more items\n     * to fetch from the API.\n     *\n     * @example\n     *\n     * ```ts\n     * const pager = await ai.files.list({config: {pageSize: 10}});\n     * for await (const file of pager) {\n     *   console.log(file.name);\n     * }\n     * ```\n     */ [Symbol.asyncIterator]() {\n        return {\n            next: async ()=>{\n                if (this.idxInternal >= this.pageLength) {\n                    if (this.hasNextPage()) {\n                        await this.nextPage();\n                    } else {\n                        return {\n                            value: undefined,\n                            done: true\n                        };\n                    }\n                }\n                const item = this.getItem(this.idxInternal);\n                this.idxInternal += 1;\n                return {\n                    value: item,\n                    done: false\n                };\n            },\n            return: async ()=>{\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n        };\n    }\n    /**\n     * Fetches the next page of items. This makes a new API request.\n     *\n     * @throws {Error} If there are no more pages to fetch.\n     *\n     * @example\n     *\n     * ```ts\n     * const pager = await ai.files.list({config: {pageSize: 10}});\n     * let page = pager.page;\n     * while (true) {\n     *   for (const file of page) {\n     *     console.log(file.name);\n     *   }\n     *   if (!pager.hasNextPage()) {\n     *     break;\n     *   }\n     *   page = await pager.nextPage();\n     * }\n     * ```\n     */ async nextPage() {\n        if (!this.hasNextPage()) {\n            throw new Error(\"No more pages to fetch.\");\n        }\n        const response = await this.requestInternal(this.params);\n        this.initNextPage(response);\n        return this.page;\n    }\n    /**\n     * Returns true if there are more pages to fetch from the API.\n     */ hasNextPage() {\n        var _a;\n        if (((_a = this.params[\"config\"]) === null || _a === void 0 ? void 0 : _a[\"pageToken\"]) !== undefined) {\n            return true;\n        }\n        return false;\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Batches extends BaseModule {\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Lists batch jobs.\n         *\n         * @param params - The parameters for the list request.\n         * @return - A pager of batch jobs.\n         *\n         * @example\n         * ```ts\n         * const batchJobs = await ai.batches.list({config: {'pageSize': 2}});\n         * for await (const batchJob of batchJobs) {\n         *   console.log(batchJob);\n         * }\n         * ```\n         */ this.list = async (params = {})=>{\n            return new Pager(PagedItem.PAGED_ITEM_BATCH_JOBS, (x)=>this.listInternal(x), await this.listInternal(params), params);\n        };\n        /**\n         * Create batch job.\n         *\n         * @param params - The parameters for create batch job request.\n         * @return The created batch job.\n         *\n         * @example\n         * ```ts\n         * const response = await ai.batches.create({\n         *   model: 'gemini-2.0-flash',\n         *   src: {gcsUri: 'gs://bucket/path/to/file.jsonl', format: 'jsonl'},\n         *   config: {\n         *     dest: {gcsUri: 'gs://bucket/path/output/directory', format: 'jsonl'},\n         *   }\n         * });\n         * console.log(response);\n         * ```\n         */ this.create = async (params)=>{\n            if (this.apiClient.isVertexAI()) {\n                // Format destination if not provided\n                // Cast params.src as Vertex AI path does not handle InlinedRequest[]\n                params.config = this.formatDestination(params.src, params.config);\n            }\n            return this.createInternal(params);\n        };\n        /**\n         * **Experimental** Creates an embedding batch job.\n         *\n         * @param params - The parameters for create embedding batch job request.\n         * @return The created batch job.\n         *\n         * @example\n         * ```ts\n         * const response = await ai.batches.createEmbeddings({\n         *   model: 'text-embedding-004',\n         *   src: {fileName: 'files/my_embedding_input'},\n         * });\n         * console.log(response);\n         * ```\n         */ this.createEmbeddings = async (params)=>{\n            console.warn(\"batches.createEmbeddings() is experimental and may change without notice.\");\n            if (this.apiClient.isVertexAI()) {\n                throw new Error(\"Vertex AI does not support batches.createEmbeddings.\");\n            }\n            return this.createEmbeddingsInternal(params);\n        };\n    }\n    // Helper function to handle inlined generate content requests\n    createInlinedGenerateContentRequest(params) {\n        const body = createBatchJobParametersToMldev(this.apiClient, params);\n        const urlParams = body[\"_url\"];\n        const path = formatMap(\"{model}:batchGenerateContent\", urlParams);\n        const batch = body[\"batch\"];\n        const inputConfig = batch[\"inputConfig\"];\n        const requestsWrapper = inputConfig[\"requests\"];\n        const requests = requestsWrapper[\"requests\"];\n        const newRequests = [];\n        for (const request of requests){\n            const requestDict = Object.assign({}, request); // Clone\n            if (requestDict[\"systemInstruction\"]) {\n                const systemInstructionValue = requestDict[\"systemInstruction\"];\n                delete requestDict[\"systemInstruction\"];\n                const requestContent = requestDict[\"request\"];\n                requestContent[\"systemInstruction\"] = systemInstructionValue;\n                requestDict[\"request\"] = requestContent;\n            }\n            newRequests.push(requestDict);\n        }\n        requestsWrapper[\"requests\"] = newRequests;\n        delete body[\"config\"];\n        delete body[\"_url\"];\n        delete body[\"_query\"];\n        return {\n            path,\n            body\n        };\n    }\n    // Helper function to get the first GCS URI\n    getGcsUri(src) {\n        if (typeof src === \"string\") {\n            return src.startsWith(\"gs://\") ? src : undefined;\n        }\n        if (!Array.isArray(src) && src.gcsUri && src.gcsUri.length > 0) {\n            return src.gcsUri[0];\n        }\n        return undefined;\n    }\n    // Helper function to get the BigQuery URI\n    getBigqueryUri(src) {\n        if (typeof src === \"string\") {\n            return src.startsWith(\"bq://\") ? src : undefined;\n        }\n        if (!Array.isArray(src)) {\n            return src.bigqueryUri;\n        }\n        return undefined;\n    }\n    // Function to format the destination configuration for Vertex AI\n    formatDestination(src, config) {\n        const newConfig = config ? Object.assign({}, config) : {};\n        const timestampStr = Date.now().toString();\n        if (!newConfig.displayName) {\n            newConfig.displayName = `genaiBatchJob_${timestampStr}`;\n        }\n        if (newConfig.dest === undefined) {\n            const gcsUri = this.getGcsUri(src);\n            const bigqueryUri = this.getBigqueryUri(src);\n            if (gcsUri) {\n                if (gcsUri.endsWith(\".jsonl\")) {\n                    // For .jsonl files, remove suffix and add /dest\n                    newConfig.dest = `${gcsUri.slice(0, -6)}/dest`;\n                } else {\n                    // Fallback for other GCS URIs\n                    newConfig.dest = `${gcsUri}_dest_${timestampStr}`;\n                }\n            } else if (bigqueryUri) {\n                newConfig.dest = `${bigqueryUri}_dest_${timestampStr}`;\n            } else {\n                throw new Error(\"Unsupported source for Vertex AI: No GCS or BigQuery URI found.\");\n            }\n        }\n        return newConfig;\n    }\n    /**\n     * Internal method to create batch job.\n     *\n     * @param params - The parameters for create batch job request.\n     * @return The created batch job.\n     *\n     */ async createInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = createBatchJobParametersToVertex(this.apiClient, params);\n            path = formatMap(\"batchPredictionJobs\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = batchJobFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = createBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:batchGenerateContent\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = batchJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Internal method to create batch job.\n     *\n     * @param params - The parameters for create batch job request.\n     * @return The created batch job.\n     *\n     */ async createEmbeddingsInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = createEmbeddingsBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:asyncBatchEmbedContent\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = batchJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Gets batch job configurations.\n     *\n     * @param params - The parameters for the get request.\n     * @return The batch job.\n     *\n     * @example\n     * ```ts\n     * await ai.batches.get({name: '...'}); // The server-generated resource name.\n     * ```\n     */ async get(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getBatchJobParametersToVertex(this.apiClient, params);\n            path = formatMap(\"batchPredictionJobs/{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = batchJobFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = getBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap(\"batches/{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = batchJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Cancels a batch job.\n     *\n     * @param params - The parameters for the cancel request.\n     * @return The empty response returned by the API.\n     *\n     * @example\n     * ```ts\n     * await ai.batches.cancel({name: '...'}); // The server-generated resource name.\n     * ```\n     */ async cancel(params) {\n        var _a, _b, _c, _d;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = cancelBatchJobParametersToVertex(this.apiClient, params);\n            path = formatMap(\"batchPredictionJobs/{name}:cancel\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            await this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            });\n        } else {\n            const body = cancelBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap(\"batches/{name}:cancel\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            await this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = listBatchJobsParametersToVertex(params);\n            path = formatMap(\"batchPredictionJobs\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listBatchJobsResponseFromVertex(apiResponse);\n                const typedResp = new ListBatchJobsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = listBatchJobsParametersToMldev(params);\n            path = formatMap(\"batches\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listBatchJobsResponseFromMldev(apiResponse);\n                const typedResp = new ListBatchJobsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Deletes a batch job.\n     *\n     * @param params - The parameters for the delete request.\n     * @return The empty response returned by the API.\n     *\n     * @example\n     * ```ts\n     * await ai.batches.delete({name: '...'}); // The server-generated resource name.\n     * ```\n     */ async delete(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = deleteBatchJobParametersToVertex(this.apiClient, params);\n            path = formatMap(\"batchPredictionJobs/{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = deleteResourceJobFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = deleteBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap(\"batches/{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = deleteResourceJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function blobToMldev$3(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction contentToMldev$3(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partToMldev$3(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction createCachedContentConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, [\n        \"ttl\"\n    ]);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, [\n            \"ttl\"\n        ], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (parentObject !== undefined && fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentToMldev$3(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"systemInstruction\"\n        ], contentToMldev$3(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = fromTools;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToMldev$3(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"tools\"\n        ], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, [\n        \"toolConfig\"\n    ]);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, [\n            \"toolConfig\"\n        ], toolConfigToMldev$1(fromToolConfig));\n    }\n    if (getValueByPath(fromObject, [\n        \"kmsKeyName\"\n    ]) !== undefined) {\n        throw new Error(\"kmsKeyName parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction createCachedContentConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, [\n        \"ttl\"\n    ]);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, [\n            \"ttl\"\n        ], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (parentObject !== undefined && fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(parentObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"systemInstruction\"\n        ], tContent(fromSystemInstruction));\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = fromTools;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToVertex$2(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"tools\"\n        ], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, [\n        \"toolConfig\"\n    ]);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, [\n            \"toolConfig\"\n        ], fromToolConfig);\n    }\n    const fromKmsKeyName = getValueByPath(fromObject, [\n        \"kmsKeyName\"\n    ]);\n    if (parentObject !== undefined && fromKmsKeyName != null) {\n        setValueByPath(parentObject, [\n            \"encryption_spec\",\n            \"kmsKeyName\"\n        ], fromKmsKeyName);\n    }\n    return toObject;\n}\nfunction createCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], tCachesModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        createCachedContentConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction createCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], tCachesModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        createCachedContentConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction deleteCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction deleteCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction deleteCachedContentResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction deleteCachedContentResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction fileDataToMldev$3(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction functionCallToMldev$3(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, [\n        \"id\"\n    ]);\n    if (fromId != null) {\n        setValueByPath(toObject, [\n            \"id\"\n        ], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, [\n        \"args\"\n    ]);\n    if (fromArgs != null) {\n        setValueByPath(toObject, [\n            \"args\"\n        ], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    if (getValueByPath(fromObject, [\n        \"partialArgs\"\n    ]) !== undefined) {\n        throw new Error(\"partialArgs parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"willContinue\"\n    ]) !== undefined) {\n        throw new Error(\"willContinue parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction functionCallingConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromAllowedFunctionNames = getValueByPath(fromObject, [\n        \"allowedFunctionNames\"\n    ]);\n    if (fromAllowedFunctionNames != null) {\n        setValueByPath(toObject, [\n            \"allowedFunctionNames\"\n        ], fromAllowedFunctionNames);\n    }\n    if (getValueByPath(fromObject, [\n        \"streamFunctionCallArguments\"\n    ]) !== undefined) {\n        throw new Error(\"streamFunctionCallArguments parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction functionDeclarationToVertex$2(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"behavior\"\n    ]) !== undefined) {\n        throw new Error(\"behavior parameter is not supported in Vertex AI.\");\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, [\n        \"parameters\"\n    ]);\n    if (fromParameters != null) {\n        setValueByPath(toObject, [\n            \"parameters\"\n        ], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        \"parametersJsonSchema\"\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"parametersJsonSchema\"\n        ], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction getCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction getCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction googleMapsToMldev$3(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"authConfig\"\n    ]) !== undefined) {\n        throw new Error(\"authConfig parameter is not supported in Gemini API.\");\n    }\n    const fromEnableWidget = getValueByPath(fromObject, [\n        \"enableWidget\"\n    ]);\n    if (fromEnableWidget != null) {\n        setValueByPath(toObject, [\n            \"enableWidget\"\n        ], fromEnableWidget);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$3(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"excludeDomains\"\n    ]) !== undefined) {\n        throw new Error(\"excludeDomains parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"blockingConfidence\"\n    ]) !== undefined) {\n        throw new Error(\"blockingConfidence parameter is not supported in Gemini API.\");\n    }\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        \"timeRangeFilter\"\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, [\n            \"timeRangeFilter\"\n        ], fromTimeRangeFilter);\n    }\n    return toObject;\n}\nfunction listCachedContentsConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    return toObject;\n}\nfunction listCachedContentsConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    return toObject;\n}\nfunction listCachedContentsParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listCachedContentsConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listCachedContentsParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listCachedContentsConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listCachedContentsResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromCachedContents = getValueByPath(fromObject, [\n        \"cachedContents\"\n    ]);\n    if (fromCachedContents != null) {\n        let transformedList = fromCachedContents;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"cachedContents\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction listCachedContentsResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromCachedContents = getValueByPath(fromObject, [\n        \"cachedContents\"\n    ]);\n    if (fromCachedContents != null) {\n        let transformedList = fromCachedContents;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"cachedContents\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction partToMldev$3(fromObject) {\n    const toObject = {};\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, [\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataToMldev$3(fromFileData));\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], functionCallToMldev$3(fromFunctionCall));\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobToMldev$3(fromInlineData));\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], fromVideoMetadata);\n    }\n    return toObject;\n}\nfunction toolConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromFunctionCallingConfig = getValueByPath(fromObject, [\n        \"functionCallingConfig\"\n    ]);\n    if (fromFunctionCallingConfig != null) {\n        setValueByPath(toObject, [\n            \"functionCallingConfig\"\n        ], functionCallingConfigToMldev$1(fromFunctionCallingConfig));\n    }\n    const fromRetrievalConfig = getValueByPath(fromObject, [\n        \"retrievalConfig\"\n    ]);\n    if (fromRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"retrievalConfig\"\n        ], fromRetrievalConfig);\n    }\n    return toObject;\n}\nfunction toolToMldev$3(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    if (getValueByPath(fromObject, [\n        \"retrieval\"\n    ]) !== undefined) {\n        throw new Error(\"retrieval parameter is not supported in Gemini API.\");\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], fromGoogleSearchRetrieval);\n    }\n    const fromComputerUse = getValueByPath(fromObject, [\n        \"computerUse\"\n    ]);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, [\n            \"computerUse\"\n        ], fromComputerUse);\n    }\n    const fromFileSearch = getValueByPath(fromObject, [\n        \"fileSearch\"\n    ]);\n    if (fromFileSearch != null) {\n        setValueByPath(toObject, [\n            \"fileSearch\"\n        ], fromFileSearch);\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    if (getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]) !== undefined) {\n        throw new Error(\"enterpriseWebSearch parameter is not supported in Gemini API.\");\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, [\n            \"googleMaps\"\n        ], googleMapsToMldev$3(fromGoogleMaps));\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToMldev$3(fromGoogleSearch));\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], fromUrlContext);\n    }\n    return toObject;\n}\nfunction toolToVertex$2(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return functionDeclarationToVertex$2(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    const fromRetrieval = getValueByPath(fromObject, [\n        \"retrieval\"\n    ]);\n    if (fromRetrieval != null) {\n        setValueByPath(toObject, [\n            \"retrieval\"\n        ], fromRetrieval);\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], fromGoogleSearchRetrieval);\n    }\n    const fromComputerUse = getValueByPath(fromObject, [\n        \"computerUse\"\n    ]);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, [\n            \"computerUse\"\n        ], fromComputerUse);\n    }\n    if (getValueByPath(fromObject, [\n        \"fileSearch\"\n    ]) !== undefined) {\n        throw new Error(\"fileSearch parameter is not supported in Vertex AI.\");\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    const fromEnterpriseWebSearch = getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]);\n    if (fromEnterpriseWebSearch != null) {\n        setValueByPath(toObject, [\n            \"enterpriseWebSearch\"\n        ], fromEnterpriseWebSearch);\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, [\n            \"googleMaps\"\n        ], fromGoogleMaps);\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], fromGoogleSearch);\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], fromUrlContext);\n    }\n    return toObject;\n}\nfunction updateCachedContentConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, [\n        \"ttl\"\n    ]);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, [\n            \"ttl\"\n        ], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    return toObject;\n}\nfunction updateCachedContentConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, [\n        \"ttl\"\n    ]);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, [\n            \"ttl\"\n        ], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    return toObject;\n}\nfunction updateCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        updateCachedContentConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction updateCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        updateCachedContentConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Caches extends BaseModule {\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Lists cached contents.\n         *\n         * @param params - The parameters for the list request.\n         * @return - A pager of cached contents.\n         *\n         * @example\n         * ```ts\n         * const cachedContents = await ai.caches.list({config: {'pageSize': 2}});\n         * for await (const cachedContent of cachedContents) {\n         *   console.log(cachedContent);\n         * }\n         * ```\n         */ this.list = async (params = {})=>{\n            return new Pager(PagedItem.PAGED_ITEM_CACHED_CONTENTS, (x)=>this.listInternal(x), await this.listInternal(params), params);\n        };\n    }\n    /**\n     * Creates a cached contents resource.\n     *\n     * @remarks\n     * Context caching is only supported for specific models. See [Gemini\n     * Developer API reference](https://ai.google.dev/gemini-api/docs/caching?lang=node/context-cac)\n     * and [Vertex AI reference](https://cloud.google.com/vertex-ai/generative-ai/docs/context-cache/context-cache-overview#supported_models)\n     * for more information.\n     *\n     * @param params - The parameters for the create request.\n     * @return The created cached content.\n     *\n     * @example\n     * ```ts\n     * const contents = ...; // Initialize the content to cache.\n     * const response = await ai.caches.create({\n     *   model: 'gemini-2.0-flash-001',\n     *   config: {\n     *    'contents': contents,\n     *    'displayName': 'test cache',\n     *    'systemInstruction': 'What is the sum of the two pdfs?',\n     *    'ttl': '86400s',\n     *  }\n     * });\n     * ```\n     */ async create(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = createCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"cachedContents\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((resp)=>{\n                return resp;\n            });\n        } else {\n            const body = createCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"cachedContents\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((resp)=>{\n                return resp;\n            });\n        }\n    }\n    /**\n     * Gets cached content configurations.\n     *\n     * @param params - The parameters for the get request.\n     * @return The cached content.\n     *\n     * @example\n     * ```ts\n     * await ai.caches.get({name: '...'}); // The server-generated resource name.\n     * ```\n     */ async get(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((resp)=>{\n                return resp;\n            });\n        } else {\n            const body = getCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((resp)=>{\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes cached content.\n     *\n     * @param params - The parameters for the delete request.\n     * @return The empty response returned by the API.\n     *\n     * @example\n     * ```ts\n     * await ai.caches.delete({name: '...'}); // The server-generated resource name.\n     * ```\n     */ async delete(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = deleteCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = deleteCachedContentResponseFromVertex(apiResponse);\n                const typedResp = new DeleteCachedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = deleteCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = deleteCachedContentResponseFromMldev(apiResponse);\n                const typedResp = new DeleteCachedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Updates cached content configurations.\n     *\n     * @param params - The parameters for the update request.\n     * @return The updated cached content.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.caches.update({\n     *   name: '...',  // The server-generated resource name.\n     *   config: {'ttl': '7600s'}\n     * });\n     * ```\n     */ async update(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = updateCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"PATCH\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((resp)=>{\n                return resp;\n            });\n        } else {\n            const body = updateCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"PATCH\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((resp)=>{\n                return resp;\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = listCachedContentsParametersToVertex(params);\n            path = formatMap(\"cachedContents\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listCachedContentsResponseFromVertex(apiResponse);\n                const typedResp = new ListCachedContentsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = listCachedContentsParametersToMldev(params);\n            path = formatMap(\"cachedContents\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listCachedContentsResponseFromMldev(apiResponse);\n                const typedResp = new ListCachedContentsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n}\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol, Iterator */ function __values(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function() {\n            if (o && i >= o.length) o = void 0;\n            return {\n                value: o && o[i++],\n                done: !o\n            };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __await(v) {\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i;\n    function awaitReturn(f) {\n        return function(v) {\n            return Promise.resolve(v).then(f, reject);\n        };\n    }\n    function verb(n, f) {\n        if (g[n]) {\n            i[n] = function(v) {\n                return new Promise(function(a, b) {\n                    q.push([\n                        n,\n                        v,\n                        a,\n                        b\n                    ]) > 1 || resume(n, v);\n                });\n            };\n            if (f) i[n] = f(i[n]);\n        }\n    }\n    function resume(n, v) {\n        try {\n            step(g[n](v));\n        } catch (e) {\n            settle(q[0][3], e);\n        }\n    }\n    function step(r) {\n        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n    }\n    function fulfill(value) {\n        resume(\"next\", value);\n    }\n    function reject(value) {\n        resume(\"throw\", value);\n    }\n    function settle(f, v) {\n        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n    }\n}\nfunction __asyncValues(o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i);\n    function verb(n) {\n        i[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n                v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n        };\n    }\n    function settle(resolve, reject, d, v) {\n        Promise.resolve(v).then(function(v) {\n            resolve({\n                value: v,\n                done: d\n            });\n        }, reject);\n    }\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ /**\n * Returns true if the response is valid, false otherwise.\n */ function isValidResponse(response) {\n    var _a;\n    if (response.candidates == undefined || response.candidates.length === 0) {\n        return false;\n    }\n    const content = (_a = response.candidates[0]) === null || _a === void 0 ? void 0 : _a.content;\n    if (content === undefined) {\n        return false;\n    }\n    return isValidContent(content);\n}\nfunction isValidContent(content) {\n    if (content.parts === undefined || content.parts.length === 0) {\n        return false;\n    }\n    for (const part of content.parts){\n        if (part === undefined || Object.keys(part).length === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Validates the history contains the correct roles.\n *\n * @throws Error if the history does not start with a user turn.\n * @throws Error if the history contains an invalid role.\n */ function validateHistory(history) {\n    // Empty history is valid.\n    if (history.length === 0) {\n        return;\n    }\n    for (const content of history){\n        if (content.role !== \"user\" && content.role !== \"model\") {\n            throw new Error(`Role must be user or model, but got ${content.role}.`);\n        }\n    }\n}\n/**\n * Extracts the curated (valid) history from a comprehensive history.\n *\n * @remarks\n * The model may sometimes generate invalid or empty contents(e.g., due to safty\n * filters or recitation). Extracting valid turns from the history\n * ensures that subsequent requests could be accpeted by the model.\n */ function extractCuratedHistory(comprehensiveHistory) {\n    if (comprehensiveHistory === undefined || comprehensiveHistory.length === 0) {\n        return [];\n    }\n    const curatedHistory = [];\n    const length = comprehensiveHistory.length;\n    let i = 0;\n    while(i < length){\n        if (comprehensiveHistory[i].role === \"user\") {\n            curatedHistory.push(comprehensiveHistory[i]);\n            i++;\n        } else {\n            const modelOutput = [];\n            let isValid = true;\n            while(i < length && comprehensiveHistory[i].role === \"model\"){\n                modelOutput.push(comprehensiveHistory[i]);\n                if (isValid && !isValidContent(comprehensiveHistory[i])) {\n                    isValid = false;\n                }\n                i++;\n            }\n            if (isValid) {\n                curatedHistory.push(...modelOutput);\n            } else {\n                // Remove the last user input when model content is invalid.\n                curatedHistory.pop();\n            }\n        }\n    }\n    return curatedHistory;\n}\n/**\n * A utility class to create a chat session.\n */ class Chats {\n    constructor(modelsModule, apiClient){\n        this.modelsModule = modelsModule;\n        this.apiClient = apiClient;\n    }\n    /**\n     * Creates a new chat session.\n     *\n     * @remarks\n     * The config in the params will be used for all requests within the chat\n     * session unless overridden by a per-request `config` in\n     * @see {@link types.SendMessageParameters#config}.\n     *\n     * @param params - Parameters for creating a chat session.\n     * @returns A new chat session.\n     *\n     * @example\n     * ```ts\n     * const chat = ai.chats.create({\n     *   model: 'gemini-2.0-flash'\n     *   config: {\n     *     temperature: 0.5,\n     *     maxOutputTokens: 1024,\n     *   }\n     * });\n     * ```\n     */ create(params) {\n        return new Chat(this.apiClient, this.modelsModule, params.model, params.config, // Deep copy the history to avoid mutating the history outside of the\n        // chat session.\n        structuredClone(params.history));\n    }\n}\n/**\n * Chat session that enables sending messages to the model with previous\n * conversation context.\n *\n * @remarks\n * The session maintains all the turns between user and model.\n */ class Chat {\n    constructor(apiClient, modelsModule, model, config = {}, history = []){\n        this.apiClient = apiClient;\n        this.modelsModule = modelsModule;\n        this.model = model;\n        this.config = config;\n        this.history = history;\n        // A promise to represent the current state of the message being sent to the\n        // model.\n        this.sendPromise = Promise.resolve();\n        validateHistory(history);\n    }\n    /**\n     * Sends a message to the model and returns the response.\n     *\n     * @remarks\n     * This method will wait for the previous message to be processed before\n     * sending the next message.\n     *\n     * @see {@link Chat#sendMessageStream} for streaming method.\n     * @param params - parameters for sending messages within a chat session.\n     * @returns The model's response.\n     *\n     * @example\n     * ```ts\n     * const chat = ai.chats.create({model: 'gemini-2.0-flash'});\n     * const response = await chat.sendMessage({\n     *   message: 'Why is the sky blue?'\n     * });\n     * console.log(response.text);\n     * ```\n     */ async sendMessage(params) {\n        var _a;\n        await this.sendPromise;\n        const inputContent = tContent(params.message);\n        const responsePromise = this.modelsModule.generateContent({\n            model: this.model,\n            contents: this.getHistory(true).concat(inputContent),\n            config: (_a = params.config) !== null && _a !== void 0 ? _a : this.config\n        });\n        this.sendPromise = (async ()=>{\n            var _a, _b, _c;\n            const response = await responsePromise;\n            const outputContent = (_b = (_a = response.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content;\n            // Because the AFC input contains the entire curated chat history in\n            // addition to the new user input, we need to truncate the AFC history\n            // to deduplicate the existing chat history.\n            const fullAutomaticFunctionCallingHistory = response.automaticFunctionCallingHistory;\n            const index = this.getHistory(true).length;\n            let automaticFunctionCallingHistory = [];\n            if (fullAutomaticFunctionCallingHistory != null) {\n                automaticFunctionCallingHistory = (_c = fullAutomaticFunctionCallingHistory.slice(index)) !== null && _c !== void 0 ? _c : [];\n            }\n            const modelOutput = outputContent ? [\n                outputContent\n            ] : [];\n            this.recordHistory(inputContent, modelOutput, automaticFunctionCallingHistory);\n            return;\n        })();\n        await this.sendPromise.catch(()=>{\n            // Resets sendPromise to avoid subsequent calls failing\n            this.sendPromise = Promise.resolve();\n        });\n        return responsePromise;\n    }\n    /**\n     * Sends a message to the model and returns the response in chunks.\n     *\n     * @remarks\n     * This method will wait for the previous message to be processed before\n     * sending the next message.\n     *\n     * @see {@link Chat#sendMessage} for non-streaming method.\n     * @param params - parameters for sending the message.\n     * @return The model's response.\n     *\n     * @example\n     * ```ts\n     * const chat = ai.chats.create({model: 'gemini-2.0-flash'});\n     * const response = await chat.sendMessageStream({\n     *   message: 'Why is the sky blue?'\n     * });\n     * for await (const chunk of response) {\n     *   console.log(chunk.text);\n     * }\n     * ```\n     */ async sendMessageStream(params) {\n        var _a;\n        await this.sendPromise;\n        const inputContent = tContent(params.message);\n        const streamResponse = this.modelsModule.generateContentStream({\n            model: this.model,\n            contents: this.getHistory(true).concat(inputContent),\n            config: (_a = params.config) !== null && _a !== void 0 ? _a : this.config\n        });\n        // Resolve the internal tracking of send completion promise - `sendPromise`\n        // for both success and failure response. The actual failure is still\n        // propagated by the `await streamResponse`.\n        this.sendPromise = streamResponse.then(()=>undefined).catch(()=>undefined);\n        const response = await streamResponse;\n        const result = this.processStreamResponse(response, inputContent);\n        return result;\n    }\n    /**\n     * Returns the chat history.\n     *\n     * @remarks\n     * The history is a list of contents alternating between user and model.\n     *\n     * There are two types of history:\n     * - The `curated history` contains only the valid turns between user and\n     * model, which will be included in the subsequent requests sent to the model.\n     * - The `comprehensive history` contains all turns, including invalid or\n     *   empty model outputs, providing a complete record of the history.\n     *\n     * The history is updated after receiving the response from the model,\n     * for streaming response, it means receiving the last chunk of the response.\n     *\n     * The `comprehensive history` is returned by default. To get the `curated\n     * history`, set the `curated` parameter to `true`.\n     *\n     * @param curated - whether to return the curated history or the comprehensive\n     *     history.\n     * @return History contents alternating between user and model for the entire\n     *     chat session.\n     */ getHistory(curated = false) {\n        const history = curated ? extractCuratedHistory(this.history) : this.history;\n        // Deep copy the history to avoid mutating the history outside of the\n        // chat session.\n        return structuredClone(history);\n    }\n    processStreamResponse(streamResponse, inputContent) {\n        var _a, _b;\n        return __asyncGenerator(this, arguments, function* processStreamResponse_1() {\n            var _c, e_1, _d, _e;\n            const outputContent = [];\n            try {\n                for(var _f = true, streamResponse_1 = __asyncValues(streamResponse), streamResponse_1_1; streamResponse_1_1 = yield __await(streamResponse_1.next()), _c = streamResponse_1_1.done, !_c; _f = true){\n                    _e = streamResponse_1_1.value;\n                    _f = false;\n                    const chunk = _e;\n                    if (isValidResponse(chunk)) {\n                        const content = (_b = (_a = chunk.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content;\n                        if (content !== undefined) {\n                            outputContent.push(content);\n                        }\n                    }\n                    yield yield __await(chunk);\n                }\n            } catch (e_1_1) {\n                e_1 = {\n                    error: e_1_1\n                };\n            } finally{\n                try {\n                    if (!_f && !_c && (_d = streamResponse_1.return)) yield __await(_d.call(streamResponse_1));\n                } finally{\n                    if (e_1) throw e_1.error;\n                }\n            }\n            this.recordHistory(inputContent, outputContent);\n        });\n    }\n    recordHistory(userInput, modelOutput, automaticFunctionCallingHistory) {\n        let outputContents = [];\n        if (modelOutput.length > 0 && modelOutput.every((content)=>content.role !== undefined)) {\n            outputContents = modelOutput;\n        } else {\n            // Appends an empty content when model returns empty response, so that the\n            // history is always alternating between user and model.\n            outputContents.push({\n                role: \"model\",\n                parts: []\n            });\n        }\n        if (automaticFunctionCallingHistory && automaticFunctionCallingHistory.length > 0) {\n            this.history.push(...extractCuratedHistory(automaticFunctionCallingHistory));\n        } else {\n            this.history.push(userInput);\n        }\n        this.history.push(...outputContents);\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ /**\n * API errors raised by the GenAI API.\n */ class ApiError extends Error {\n    constructor(options){\n        super(options.message);\n        this.name = \"ApiError\";\n        this.status = options.status;\n        Object.setPrototypeOf(this, ApiError.prototype);\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ // Code generated by the Google Gen AI SDK generator DO NOT EDIT.\nfunction createFileParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromFile = getValueByPath(fromObject, [\n        \"file\"\n    ]);\n    if (fromFile != null) {\n        setValueByPath(toObject, [\n            \"file\"\n        ], fromFile);\n    }\n    return toObject;\n}\nfunction createFileResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction deleteFileParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"file\"\n        ], tFileName(fromName));\n    }\n    return toObject;\n}\nfunction deleteFileResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction getFileParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"file\"\n        ], tFileName(fromName));\n    }\n    return toObject;\n}\nfunction listFilesConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    return toObject;\n}\nfunction listFilesParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listFilesConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listFilesResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromFiles = getValueByPath(fromObject, [\n        \"files\"\n    ]);\n    if (fromFiles != null) {\n        let transformedList = fromFiles;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"files\"\n        ], transformedList);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Files extends BaseModule {\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Lists files.\n         *\n         * @param params - The parameters for the list request.\n         * @return - A pager of files.\n         *\n         * @example\n         * ```ts\n         * const files = await ai.files.list({config: {'pageSize': 2}});\n         * for await (const file of files) {\n         *   console.log(file);\n         * }\n         * ```\n         */ this.list = async (params = {})=>{\n            return new Pager(PagedItem.PAGED_ITEM_FILES, (x)=>this.listInternal(x), await this.listInternal(params), params);\n        };\n    }\n    /**\n     * Uploads a file asynchronously to the Gemini API.\n     * This method is not available in Vertex AI.\n     * Supported upload sources:\n     * - Node.js: File path (string) or Blob object.\n     * - Browser: Blob object (e.g., File).\n     *\n     * @remarks\n     * The `mimeType` can be specified in the `config` parameter. If omitted:\n     *  - For file path (string) inputs, the `mimeType` will be inferred from the\n     *     file extension.\n     *  - For Blob object inputs, the `mimeType` will be set to the Blob's `type`\n     *     property.\n     * Somex eamples for file extension to mimeType mapping:\n     * .txt -> text/plain\n     * .json -> application/json\n     * .jpg  -> image/jpeg\n     * .png -> image/png\n     * .mp3 -> audio/mpeg\n     * .mp4 -> video/mp4\n     *\n     * This section can contain multiple paragraphs and code examples.\n     *\n     * @param params - Optional parameters specified in the\n     *        `types.UploadFileParameters` interface.\n     *         @see {@link types.UploadFileParameters#config} for the optional\n     *         config in the parameters.\n     * @return A promise that resolves to a `types.File` object.\n     * @throws An error if called on a Vertex AI client.\n     * @throws An error if the `mimeType` is not provided and can not be inferred,\n     * the `mimeType` can be provided in the `params.config` parameter.\n     * @throws An error occurs if a suitable upload location cannot be established.\n     *\n     * @example\n     * The following code uploads a file to Gemini API.\n     *\n     * ```ts\n     * const file = await ai.files.upload({file: 'file.txt', config: {\n     *   mimeType: 'text/plain',\n     * }});\n     * console.log(file.name);\n     * ```\n     */ async upload(params) {\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"Vertex AI does not support uploading files. You can share files through a GCS bucket.\");\n        }\n        return this.apiClient.uploadFile(params.file, params.config).then((resp)=>{\n            return resp;\n        });\n    }\n    /**\n     * Downloads a remotely stored file asynchronously to a location specified in\n     * the `params` object. This method only works on Node environment, to\n     * download files in the browser, use a browser compliant method like an <a>\n     * tag.\n     *\n     * @param params - The parameters for the download request.\n     *\n     * @example\n     * The following code downloads an example file named \"files/mehozpxf877d\" as\n     * \"file.txt\".\n     *\n     * ```ts\n     * await ai.files.download({file: file.name, downloadPath: 'file.txt'});\n     * ```\n     */ async download(params) {\n        await this.apiClient.downloadFile(params);\n    }\n    async listInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = listFilesParametersToMldev(params);\n            path = formatMap(\"files\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listFilesResponseFromMldev(apiResponse);\n                const typedResp = new ListFilesResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    async createInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = createFileParametersToMldev(params);\n            path = formatMap(\"upload/v1beta/files\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = createFileResponseFromMldev(apiResponse);\n                const typedResp = new CreateFileResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Retrieves the file information from the service.\n     *\n     * @param params - The parameters for the get request\n     * @return The Promise that resolves to the types.File object requested.\n     *\n     * @example\n     * ```ts\n     * const config: GetFileParameters = {\n     *   name: fileName,\n     * };\n     * file = await ai.files.get(config);\n     * console.log(file.name);\n     * ```\n     */ async get(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = getFileParametersToMldev(params);\n            path = formatMap(\"files/{file}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((resp)=>{\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes a remotely stored file.\n     *\n     * @param params - The parameters for the delete request.\n     * @return The DeleteFileResponse, the response for the delete method.\n     *\n     * @example\n     * The following code deletes an example file named \"files/mehozpxf877d\".\n     *\n     * ```ts\n     * await ai.files.delete({name: file.name});\n     * ```\n     */ async delete(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = deleteFileParametersToMldev(params);\n            path = formatMap(\"files/{file}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = deleteFileResponseFromMldev(apiResponse);\n                const typedResp = new DeleteFileResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function blobToMldev$2(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction contentToMldev$2(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partToMldev$2(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction fileDataToMldev$2(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction functionCallToMldev$2(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, [\n        \"id\"\n    ]);\n    if (fromId != null) {\n        setValueByPath(toObject, [\n            \"id\"\n        ], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, [\n        \"args\"\n    ]);\n    if (fromArgs != null) {\n        setValueByPath(toObject, [\n            \"args\"\n        ], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    if (getValueByPath(fromObject, [\n        \"partialArgs\"\n    ]) !== undefined) {\n        throw new Error(\"partialArgs parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"willContinue\"\n    ]) !== undefined) {\n        throw new Error(\"willContinue parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction functionDeclarationToVertex$1(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"behavior\"\n    ]) !== undefined) {\n        throw new Error(\"behavior parameter is not supported in Vertex AI.\");\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, [\n        \"parameters\"\n    ]);\n    if (fromParameters != null) {\n        setValueByPath(toObject, [\n            \"parameters\"\n        ], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        \"parametersJsonSchema\"\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"parametersJsonSchema\"\n        ], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction generationConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromModelSelectionConfig = getValueByPath(fromObject, [\n        \"modelSelectionConfig\"\n    ]);\n    if (fromModelSelectionConfig != null) {\n        setValueByPath(toObject, [\n            \"modelConfig\"\n        ], fromModelSelectionConfig);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    const fromAudioTimestamp = getValueByPath(fromObject, [\n        \"audioTimestamp\"\n    ]);\n    if (fromAudioTimestamp != null) {\n        setValueByPath(toObject, [\n            \"audioTimestamp\"\n        ], fromAudioTimestamp);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        \"candidateCount\"\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, [\n            \"candidateCount\"\n        ], fromCandidateCount);\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        \"enableAffectiveDialog\"\n    ]);\n    if (fromEnableAffectiveDialog != null) {\n        setValueByPath(toObject, [\n            \"enableAffectiveDialog\"\n        ], fromEnableAffectiveDialog);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        \"frequencyPenalty\"\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, [\n            \"frequencyPenalty\"\n        ], fromFrequencyPenalty);\n    }\n    const fromLogprobs = getValueByPath(fromObject, [\n        \"logprobs\"\n    ]);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, [\n            \"logprobs\"\n        ], fromLogprobs);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, [\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, [\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        \"presencePenalty\"\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, [\n            \"presencePenalty\"\n        ], fromPresencePenalty);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        \"responseLogprobs\"\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, [\n            \"responseLogprobs\"\n        ], fromResponseLogprobs);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        \"responseMimeType\"\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, [\n            \"responseMimeType\"\n        ], fromResponseMimeType);\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, [\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        \"responseSchema\"\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, [\n            \"responseSchema\"\n        ], fromResponseSchema);\n    }\n    const fromRoutingConfig = getValueByPath(fromObject, [\n        \"routingConfig\"\n    ]);\n    if (fromRoutingConfig != null) {\n        setValueByPath(toObject, [\n            \"routingConfig\"\n        ], fromRoutingConfig);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (fromSeed != null) {\n        setValueByPath(toObject, [\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, [\n            \"speechConfig\"\n        ], speechConfigToVertex$1(fromSpeechConfig));\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        \"stopSequences\"\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, [\n            \"stopSequences\"\n        ], fromStopSequences);\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, [\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        \"thinkingConfig\"\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, [\n            \"thinkingConfig\"\n        ], fromThinkingConfig);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (fromTopK != null) {\n        setValueByPath(toObject, [\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (fromTopP != null) {\n        setValueByPath(toObject, [\n            \"topP\"\n        ], fromTopP);\n    }\n    if (getValueByPath(fromObject, [\n        \"enableEnhancedCivicAnswers\"\n    ]) !== undefined) {\n        throw new Error(\"enableEnhancedCivicAnswers parameter is not supported in Vertex AI.\");\n    }\n    return toObject;\n}\nfunction googleMapsToMldev$2(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"authConfig\"\n    ]) !== undefined) {\n        throw new Error(\"authConfig parameter is not supported in Gemini API.\");\n    }\n    const fromEnableWidget = getValueByPath(fromObject, [\n        \"enableWidget\"\n    ]);\n    if (fromEnableWidget != null) {\n        setValueByPath(toObject, [\n            \"enableWidget\"\n        ], fromEnableWidget);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$2(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"excludeDomains\"\n    ]) !== undefined) {\n        throw new Error(\"excludeDomains parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"blockingConfidence\"\n    ]) !== undefined) {\n        throw new Error(\"blockingConfidence parameter is not supported in Gemini API.\");\n    }\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        \"timeRangeFilter\"\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, [\n            \"timeRangeFilter\"\n        ], fromTimeRangeFilter);\n    }\n    return toObject;\n}\nfunction liveConnectConfigToMldev$1(fromObject, parentObject) {\n    const toObject = {};\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        \"generationConfig\"\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\"\n        ], fromGenerationConfig);\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (parentObject !== undefined && fromResponseModalities != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (parentObject !== undefined && fromTemperature != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (parentObject !== undefined && fromTopP != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (parentObject !== undefined && fromTopK != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (parentObject !== undefined && fromMaxOutputTokens != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (parentObject !== undefined && fromMediaResolution != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (parentObject !== undefined && fromSpeechConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"speechConfig\"\n        ], tLiveSpeechConfig(fromSpeechConfig));\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        \"thinkingConfig\"\n    ]);\n    if (parentObject !== undefined && fromThinkingConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"thinkingConfig\"\n        ], fromThinkingConfig);\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        \"enableAffectiveDialog\"\n    ]);\n    if (parentObject !== undefined && fromEnableAffectiveDialog != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"enableAffectiveDialog\"\n        ], fromEnableAffectiveDialog);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"systemInstruction\"\n        ], contentToMldev$2(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToMldev$2(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"tools\"\n        ], transformedList);\n    }\n    const fromSessionResumption = getValueByPath(fromObject, [\n        \"sessionResumption\"\n    ]);\n    if (parentObject !== undefined && fromSessionResumption != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"sessionResumption\"\n        ], sessionResumptionConfigToMldev$1(fromSessionResumption));\n    }\n    const fromInputAudioTranscription = getValueByPath(fromObject, [\n        \"inputAudioTranscription\"\n    ]);\n    if (parentObject !== undefined && fromInputAudioTranscription != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"inputAudioTranscription\"\n        ], fromInputAudioTranscription);\n    }\n    const fromOutputAudioTranscription = getValueByPath(fromObject, [\n        \"outputAudioTranscription\"\n    ]);\n    if (parentObject !== undefined && fromOutputAudioTranscription != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"outputAudioTranscription\"\n        ], fromOutputAudioTranscription);\n    }\n    const fromRealtimeInputConfig = getValueByPath(fromObject, [\n        \"realtimeInputConfig\"\n    ]);\n    if (parentObject !== undefined && fromRealtimeInputConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"realtimeInputConfig\"\n        ], fromRealtimeInputConfig);\n    }\n    const fromContextWindowCompression = getValueByPath(fromObject, [\n        \"contextWindowCompression\"\n    ]);\n    if (parentObject !== undefined && fromContextWindowCompression != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"contextWindowCompression\"\n        ], fromContextWindowCompression);\n    }\n    const fromProactivity = getValueByPath(fromObject, [\n        \"proactivity\"\n    ]);\n    if (parentObject !== undefined && fromProactivity != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"proactivity\"\n        ], fromProactivity);\n    }\n    return toObject;\n}\nfunction liveConnectConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        \"generationConfig\"\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\"\n        ], generationConfigToVertex$1(fromGenerationConfig));\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (parentObject !== undefined && fromResponseModalities != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (parentObject !== undefined && fromTemperature != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (parentObject !== undefined && fromTopP != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (parentObject !== undefined && fromTopK != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (parentObject !== undefined && fromMaxOutputTokens != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (parentObject !== undefined && fromMediaResolution != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (parentObject !== undefined && fromSpeechConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"speechConfig\"\n        ], speechConfigToVertex$1(tLiveSpeechConfig(fromSpeechConfig)));\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        \"thinkingConfig\"\n    ]);\n    if (parentObject !== undefined && fromThinkingConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"thinkingConfig\"\n        ], fromThinkingConfig);\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        \"enableAffectiveDialog\"\n    ]);\n    if (parentObject !== undefined && fromEnableAffectiveDialog != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"enableAffectiveDialog\"\n        ], fromEnableAffectiveDialog);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"systemInstruction\"\n        ], tContent(fromSystemInstruction));\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToVertex$1(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"tools\"\n        ], transformedList);\n    }\n    const fromSessionResumption = getValueByPath(fromObject, [\n        \"sessionResumption\"\n    ]);\n    if (parentObject !== undefined && fromSessionResumption != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"sessionResumption\"\n        ], fromSessionResumption);\n    }\n    const fromInputAudioTranscription = getValueByPath(fromObject, [\n        \"inputAudioTranscription\"\n    ]);\n    if (parentObject !== undefined && fromInputAudioTranscription != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"inputAudioTranscription\"\n        ], fromInputAudioTranscription);\n    }\n    const fromOutputAudioTranscription = getValueByPath(fromObject, [\n        \"outputAudioTranscription\"\n    ]);\n    if (parentObject !== undefined && fromOutputAudioTranscription != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"outputAudioTranscription\"\n        ], fromOutputAudioTranscription);\n    }\n    const fromRealtimeInputConfig = getValueByPath(fromObject, [\n        \"realtimeInputConfig\"\n    ]);\n    if (parentObject !== undefined && fromRealtimeInputConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"realtimeInputConfig\"\n        ], fromRealtimeInputConfig);\n    }\n    const fromContextWindowCompression = getValueByPath(fromObject, [\n        \"contextWindowCompression\"\n    ]);\n    if (parentObject !== undefined && fromContextWindowCompression != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"contextWindowCompression\"\n        ], fromContextWindowCompression);\n    }\n    const fromProactivity = getValueByPath(fromObject, [\n        \"proactivity\"\n    ]);\n    if (parentObject !== undefined && fromProactivity != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"proactivity\"\n        ], fromProactivity);\n    }\n    return toObject;\n}\nfunction liveConnectParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"setup\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], liveConnectConfigToMldev$1(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction liveConnectParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"setup\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], liveConnectConfigToVertex(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction liveMusicSetConfigParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromMusicGenerationConfig = getValueByPath(fromObject, [\n        \"musicGenerationConfig\"\n    ]);\n    if (fromMusicGenerationConfig != null) {\n        setValueByPath(toObject, [\n            \"musicGenerationConfig\"\n        ], fromMusicGenerationConfig);\n    }\n    return toObject;\n}\nfunction liveMusicSetWeightedPromptsParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromWeightedPrompts = getValueByPath(fromObject, [\n        \"weightedPrompts\"\n    ]);\n    if (fromWeightedPrompts != null) {\n        let transformedList = fromWeightedPrompts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"weightedPrompts\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction liveSendRealtimeInputParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromMedia = getValueByPath(fromObject, [\n        \"media\"\n    ]);\n    if (fromMedia != null) {\n        let transformedList = tBlobs(fromMedia);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return blobToMldev$2(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"mediaChunks\"\n        ], transformedList);\n    }\n    const fromAudio = getValueByPath(fromObject, [\n        \"audio\"\n    ]);\n    if (fromAudio != null) {\n        setValueByPath(toObject, [\n            \"audio\"\n        ], blobToMldev$2(tAudioBlob(fromAudio)));\n    }\n    const fromAudioStreamEnd = getValueByPath(fromObject, [\n        \"audioStreamEnd\"\n    ]);\n    if (fromAudioStreamEnd != null) {\n        setValueByPath(toObject, [\n            \"audioStreamEnd\"\n        ], fromAudioStreamEnd);\n    }\n    const fromVideo = getValueByPath(fromObject, [\n        \"video\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"video\"\n        ], blobToMldev$2(tImageBlob(fromVideo)));\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromActivityStart = getValueByPath(fromObject, [\n        \"activityStart\"\n    ]);\n    if (fromActivityStart != null) {\n        setValueByPath(toObject, [\n            \"activityStart\"\n        ], fromActivityStart);\n    }\n    const fromActivityEnd = getValueByPath(fromObject, [\n        \"activityEnd\"\n    ]);\n    if (fromActivityEnd != null) {\n        setValueByPath(toObject, [\n            \"activityEnd\"\n        ], fromActivityEnd);\n    }\n    return toObject;\n}\nfunction liveSendRealtimeInputParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromMedia = getValueByPath(fromObject, [\n        \"media\"\n    ]);\n    if (fromMedia != null) {\n        let transformedList = tBlobs(fromMedia);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"mediaChunks\"\n        ], transformedList);\n    }\n    const fromAudio = getValueByPath(fromObject, [\n        \"audio\"\n    ]);\n    if (fromAudio != null) {\n        setValueByPath(toObject, [\n            \"audio\"\n        ], tAudioBlob(fromAudio));\n    }\n    const fromAudioStreamEnd = getValueByPath(fromObject, [\n        \"audioStreamEnd\"\n    ]);\n    if (fromAudioStreamEnd != null) {\n        setValueByPath(toObject, [\n            \"audioStreamEnd\"\n        ], fromAudioStreamEnd);\n    }\n    const fromVideo = getValueByPath(fromObject, [\n        \"video\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"video\"\n        ], tImageBlob(fromVideo));\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromActivityStart = getValueByPath(fromObject, [\n        \"activityStart\"\n    ]);\n    if (fromActivityStart != null) {\n        setValueByPath(toObject, [\n            \"activityStart\"\n        ], fromActivityStart);\n    }\n    const fromActivityEnd = getValueByPath(fromObject, [\n        \"activityEnd\"\n    ]);\n    if (fromActivityEnd != null) {\n        setValueByPath(toObject, [\n            \"activityEnd\"\n        ], fromActivityEnd);\n    }\n    return toObject;\n}\nfunction liveServerMessageFromVertex(fromObject) {\n    const toObject = {};\n    const fromSetupComplete = getValueByPath(fromObject, [\n        \"setupComplete\"\n    ]);\n    if (fromSetupComplete != null) {\n        setValueByPath(toObject, [\n            \"setupComplete\"\n        ], fromSetupComplete);\n    }\n    const fromServerContent = getValueByPath(fromObject, [\n        \"serverContent\"\n    ]);\n    if (fromServerContent != null) {\n        setValueByPath(toObject, [\n            \"serverContent\"\n        ], fromServerContent);\n    }\n    const fromToolCall = getValueByPath(fromObject, [\n        \"toolCall\"\n    ]);\n    if (fromToolCall != null) {\n        setValueByPath(toObject, [\n            \"toolCall\"\n        ], fromToolCall);\n    }\n    const fromToolCallCancellation = getValueByPath(fromObject, [\n        \"toolCallCancellation\"\n    ]);\n    if (fromToolCallCancellation != null) {\n        setValueByPath(toObject, [\n            \"toolCallCancellation\"\n        ], fromToolCallCancellation);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        \"usageMetadata\"\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, [\n            \"usageMetadata\"\n        ], usageMetadataFromVertex(fromUsageMetadata));\n    }\n    const fromGoAway = getValueByPath(fromObject, [\n        \"goAway\"\n    ]);\n    if (fromGoAway != null) {\n        setValueByPath(toObject, [\n            \"goAway\"\n        ], fromGoAway);\n    }\n    const fromSessionResumptionUpdate = getValueByPath(fromObject, [\n        \"sessionResumptionUpdate\"\n    ]);\n    if (fromSessionResumptionUpdate != null) {\n        setValueByPath(toObject, [\n            \"sessionResumptionUpdate\"\n        ], fromSessionResumptionUpdate);\n    }\n    return toObject;\n}\nfunction partToMldev$2(fromObject) {\n    const toObject = {};\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, [\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataToMldev$2(fromFileData));\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], functionCallToMldev$2(fromFunctionCall));\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobToMldev$2(fromInlineData));\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], fromVideoMetadata);\n    }\n    return toObject;\n}\nfunction sessionResumptionConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromHandle = getValueByPath(fromObject, [\n        \"handle\"\n    ]);\n    if (fromHandle != null) {\n        setValueByPath(toObject, [\n            \"handle\"\n        ], fromHandle);\n    }\n    if (getValueByPath(fromObject, [\n        \"transparent\"\n    ]) !== undefined) {\n        throw new Error(\"transparent parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction speechConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromLanguageCode = getValueByPath(fromObject, [\n        \"languageCode\"\n    ]);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, [\n            \"languageCode\"\n        ], fromLanguageCode);\n    }\n    const fromVoiceConfig = getValueByPath(fromObject, [\n        \"voiceConfig\"\n    ]);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"voiceConfig\"\n        ], fromVoiceConfig);\n    }\n    if (getValueByPath(fromObject, [\n        \"multiSpeakerVoiceConfig\"\n    ]) !== undefined) {\n        throw new Error(\"multiSpeakerVoiceConfig parameter is not supported in Vertex AI.\");\n    }\n    return toObject;\n}\nfunction toolToMldev$2(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    if (getValueByPath(fromObject, [\n        \"retrieval\"\n    ]) !== undefined) {\n        throw new Error(\"retrieval parameter is not supported in Gemini API.\");\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], fromGoogleSearchRetrieval);\n    }\n    const fromComputerUse = getValueByPath(fromObject, [\n        \"computerUse\"\n    ]);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, [\n            \"computerUse\"\n        ], fromComputerUse);\n    }\n    const fromFileSearch = getValueByPath(fromObject, [\n        \"fileSearch\"\n    ]);\n    if (fromFileSearch != null) {\n        setValueByPath(toObject, [\n            \"fileSearch\"\n        ], fromFileSearch);\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    if (getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]) !== undefined) {\n        throw new Error(\"enterpriseWebSearch parameter is not supported in Gemini API.\");\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, [\n            \"googleMaps\"\n        ], googleMapsToMldev$2(fromGoogleMaps));\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToMldev$2(fromGoogleSearch));\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], fromUrlContext);\n    }\n    return toObject;\n}\nfunction toolToVertex$1(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return functionDeclarationToVertex$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    const fromRetrieval = getValueByPath(fromObject, [\n        \"retrieval\"\n    ]);\n    if (fromRetrieval != null) {\n        setValueByPath(toObject, [\n            \"retrieval\"\n        ], fromRetrieval);\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], fromGoogleSearchRetrieval);\n    }\n    const fromComputerUse = getValueByPath(fromObject, [\n        \"computerUse\"\n    ]);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, [\n            \"computerUse\"\n        ], fromComputerUse);\n    }\n    if (getValueByPath(fromObject, [\n        \"fileSearch\"\n    ]) !== undefined) {\n        throw new Error(\"fileSearch parameter is not supported in Vertex AI.\");\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    const fromEnterpriseWebSearch = getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]);\n    if (fromEnterpriseWebSearch != null) {\n        setValueByPath(toObject, [\n            \"enterpriseWebSearch\"\n        ], fromEnterpriseWebSearch);\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, [\n            \"googleMaps\"\n        ], fromGoogleMaps);\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], fromGoogleSearch);\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], fromUrlContext);\n    }\n    return toObject;\n}\nfunction usageMetadataFromVertex(fromObject) {\n    const toObject = {};\n    const fromPromptTokenCount = getValueByPath(fromObject, [\n        \"promptTokenCount\"\n    ]);\n    if (fromPromptTokenCount != null) {\n        setValueByPath(toObject, [\n            \"promptTokenCount\"\n        ], fromPromptTokenCount);\n    }\n    const fromCachedContentTokenCount = getValueByPath(fromObject, [\n        \"cachedContentTokenCount\"\n    ]);\n    if (fromCachedContentTokenCount != null) {\n        setValueByPath(toObject, [\n            \"cachedContentTokenCount\"\n        ], fromCachedContentTokenCount);\n    }\n    const fromResponseTokenCount = getValueByPath(fromObject, [\n        \"candidatesTokenCount\"\n    ]);\n    if (fromResponseTokenCount != null) {\n        setValueByPath(toObject, [\n            \"responseTokenCount\"\n        ], fromResponseTokenCount);\n    }\n    const fromToolUsePromptTokenCount = getValueByPath(fromObject, [\n        \"toolUsePromptTokenCount\"\n    ]);\n    if (fromToolUsePromptTokenCount != null) {\n        setValueByPath(toObject, [\n            \"toolUsePromptTokenCount\"\n        ], fromToolUsePromptTokenCount);\n    }\n    const fromThoughtsTokenCount = getValueByPath(fromObject, [\n        \"thoughtsTokenCount\"\n    ]);\n    if (fromThoughtsTokenCount != null) {\n        setValueByPath(toObject, [\n            \"thoughtsTokenCount\"\n        ], fromThoughtsTokenCount);\n    }\n    const fromTotalTokenCount = getValueByPath(fromObject, [\n        \"totalTokenCount\"\n    ]);\n    if (fromTotalTokenCount != null) {\n        setValueByPath(toObject, [\n            \"totalTokenCount\"\n        ], fromTotalTokenCount);\n    }\n    const fromPromptTokensDetails = getValueByPath(fromObject, [\n        \"promptTokensDetails\"\n    ]);\n    if (fromPromptTokensDetails != null) {\n        let transformedList = fromPromptTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"promptTokensDetails\"\n        ], transformedList);\n    }\n    const fromCacheTokensDetails = getValueByPath(fromObject, [\n        \"cacheTokensDetails\"\n    ]);\n    if (fromCacheTokensDetails != null) {\n        let transformedList = fromCacheTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"cacheTokensDetails\"\n        ], transformedList);\n    }\n    const fromResponseTokensDetails = getValueByPath(fromObject, [\n        \"candidatesTokensDetails\"\n    ]);\n    if (fromResponseTokensDetails != null) {\n        let transformedList = fromResponseTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"responseTokensDetails\"\n        ], transformedList);\n    }\n    const fromToolUsePromptTokensDetails = getValueByPath(fromObject, [\n        \"toolUsePromptTokensDetails\"\n    ]);\n    if (fromToolUsePromptTokensDetails != null) {\n        let transformedList = fromToolUsePromptTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"toolUsePromptTokensDetails\"\n        ], transformedList);\n    }\n    const fromTrafficType = getValueByPath(fromObject, [\n        \"trafficType\"\n    ]);\n    if (fromTrafficType != null) {\n        setValueByPath(toObject, [\n            \"trafficType\"\n        ], fromTrafficType);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function blobToMldev$1(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction candidateFromMldev(fromObject) {\n    const toObject = {};\n    const fromContent = getValueByPath(fromObject, [\n        \"content\"\n    ]);\n    if (fromContent != null) {\n        setValueByPath(toObject, [\n            \"content\"\n        ], fromContent);\n    }\n    const fromCitationMetadata = getValueByPath(fromObject, [\n        \"citationMetadata\"\n    ]);\n    if (fromCitationMetadata != null) {\n        setValueByPath(toObject, [\n            \"citationMetadata\"\n        ], citationMetadataFromMldev(fromCitationMetadata));\n    }\n    const fromTokenCount = getValueByPath(fromObject, [\n        \"tokenCount\"\n    ]);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, [\n            \"tokenCount\"\n        ], fromTokenCount);\n    }\n    const fromFinishReason = getValueByPath(fromObject, [\n        \"finishReason\"\n    ]);\n    if (fromFinishReason != null) {\n        setValueByPath(toObject, [\n            \"finishReason\"\n        ], fromFinishReason);\n    }\n    const fromAvgLogprobs = getValueByPath(fromObject, [\n        \"avgLogprobs\"\n    ]);\n    if (fromAvgLogprobs != null) {\n        setValueByPath(toObject, [\n            \"avgLogprobs\"\n        ], fromAvgLogprobs);\n    }\n    const fromGroundingMetadata = getValueByPath(fromObject, [\n        \"groundingMetadata\"\n    ]);\n    if (fromGroundingMetadata != null) {\n        setValueByPath(toObject, [\n            \"groundingMetadata\"\n        ], fromGroundingMetadata);\n    }\n    const fromIndex = getValueByPath(fromObject, [\n        \"index\"\n    ]);\n    if (fromIndex != null) {\n        setValueByPath(toObject, [\n            \"index\"\n        ], fromIndex);\n    }\n    const fromLogprobsResult = getValueByPath(fromObject, [\n        \"logprobsResult\"\n    ]);\n    if (fromLogprobsResult != null) {\n        setValueByPath(toObject, [\n            \"logprobsResult\"\n        ], fromLogprobsResult);\n    }\n    const fromSafetyRatings = getValueByPath(fromObject, [\n        \"safetyRatings\"\n    ]);\n    if (fromSafetyRatings != null) {\n        let transformedList = fromSafetyRatings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"safetyRatings\"\n        ], transformedList);\n    }\n    const fromUrlContextMetadata = getValueByPath(fromObject, [\n        \"urlContextMetadata\"\n    ]);\n    if (fromUrlContextMetadata != null) {\n        setValueByPath(toObject, [\n            \"urlContextMetadata\"\n        ], fromUrlContextMetadata);\n    }\n    return toObject;\n}\nfunction citationMetadataFromMldev(fromObject) {\n    const toObject = {};\n    const fromCitations = getValueByPath(fromObject, [\n        \"citationSources\"\n    ]);\n    if (fromCitations != null) {\n        let transformedList = fromCitations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"citations\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction computeTokensParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction computeTokensResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromTokensInfo = getValueByPath(fromObject, [\n        \"tokensInfo\"\n    ]);\n    if (fromTokensInfo != null) {\n        let transformedList = fromTokensInfo;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"tokensInfo\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction contentEmbeddingFromVertex(fromObject) {\n    const toObject = {};\n    const fromValues = getValueByPath(fromObject, [\n        \"values\"\n    ]);\n    if (fromValues != null) {\n        setValueByPath(toObject, [\n            \"values\"\n        ], fromValues);\n    }\n    const fromStatistics = getValueByPath(fromObject, [\n        \"statistics\"\n    ]);\n    if (fromStatistics != null) {\n        setValueByPath(toObject, [\n            \"statistics\"\n        ], contentEmbeddingStatisticsFromVertex(fromStatistics));\n    }\n    return toObject;\n}\nfunction contentEmbeddingStatisticsFromVertex(fromObject) {\n    const toObject = {};\n    const fromTruncated = getValueByPath(fromObject, [\n        \"truncated\"\n    ]);\n    if (fromTruncated != null) {\n        setValueByPath(toObject, [\n            \"truncated\"\n        ], fromTruncated);\n    }\n    const fromTokenCount = getValueByPath(fromObject, [\n        \"token_count\"\n    ]);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, [\n            \"tokenCount\"\n        ], fromTokenCount);\n    }\n    return toObject;\n}\nfunction contentToMldev$1(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partToMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction controlReferenceConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromControlType = getValueByPath(fromObject, [\n        \"controlType\"\n    ]);\n    if (fromControlType != null) {\n        setValueByPath(toObject, [\n            \"controlType\"\n        ], fromControlType);\n    }\n    const fromEnableControlImageComputation = getValueByPath(fromObject, [\n        \"enableControlImageComputation\"\n    ]);\n    if (fromEnableControlImageComputation != null) {\n        setValueByPath(toObject, [\n            \"computeControl\"\n        ], fromEnableControlImageComputation);\n    }\n    return toObject;\n}\nfunction countTokensConfigToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]) !== undefined) {\n        throw new Error(\"systemInstruction parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"tools\"\n    ]) !== undefined) {\n        throw new Error(\"tools parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"generationConfig\"\n    ]) !== undefined) {\n        throw new Error(\"generationConfig parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction countTokensConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"systemInstruction\"\n        ], tContent(fromSystemInstruction));\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = fromTools;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToVertex(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"tools\"\n        ], transformedList);\n    }\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        \"generationConfig\"\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, [\n            \"generationConfig\"\n        ], generationConfigToVertex(fromGenerationConfig));\n    }\n    return toObject;\n}\nfunction countTokensParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentToMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        countTokensConfigToMldev(fromConfig);\n    }\n    return toObject;\n}\nfunction countTokensParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        countTokensConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction countTokensResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromTotalTokens = getValueByPath(fromObject, [\n        \"totalTokens\"\n    ]);\n    if (fromTotalTokens != null) {\n        setValueByPath(toObject, [\n            \"totalTokens\"\n        ], fromTotalTokens);\n    }\n    const fromCachedContentTokenCount = getValueByPath(fromObject, [\n        \"cachedContentTokenCount\"\n    ]);\n    if (fromCachedContentTokenCount != null) {\n        setValueByPath(toObject, [\n            \"cachedContentTokenCount\"\n        ], fromCachedContentTokenCount);\n    }\n    return toObject;\n}\nfunction countTokensResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromTotalTokens = getValueByPath(fromObject, [\n        \"totalTokens\"\n    ]);\n    if (fromTotalTokens != null) {\n        setValueByPath(toObject, [\n            \"totalTokens\"\n        ], fromTotalTokens);\n    }\n    return toObject;\n}\nfunction deleteModelParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tModel(apiClient, fromModel));\n    }\n    return toObject;\n}\nfunction deleteModelParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tModel(apiClient, fromModel));\n    }\n    return toObject;\n}\nfunction deleteModelResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction deleteModelResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction editImageConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromOutputGcsUri = getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"storageUri\"\n        ], fromOutputGcsUri);\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        \"negativePrompt\"\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"negativePrompt\"\n        ], fromNegativePrompt);\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        \"numberOfImages\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfImages);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    const fromGuidanceScale = getValueByPath(fromObject, [\n        \"guidanceScale\"\n    ]);\n    if (parentObject !== undefined && fromGuidanceScale != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"guidanceScale\"\n        ], fromGuidanceScale);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        \"safetyFilterLevel\"\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"safetySetting\"\n        ], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [\n        \"includeSafetyAttributes\"\n    ]);\n    if (parentObject !== undefined && fromIncludeSafetyAttributes != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeSafetyAttributes\"\n        ], fromIncludeSafetyAttributes);\n    }\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        \"includeRaiReason\"\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeRaiReason\"\n        ], fromIncludeRaiReason);\n    }\n    const fromLanguage = getValueByPath(fromObject, [\n        \"language\"\n    ]);\n    if (parentObject !== undefined && fromLanguage != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"language\"\n        ], fromLanguage);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        \"outputMimeType\"\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"mimeType\"\n        ], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        \"outputCompressionQuality\"\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"compressionQuality\"\n        ], fromOutputCompressionQuality);\n    }\n    const fromAddWatermark = getValueByPath(fromObject, [\n        \"addWatermark\"\n    ]);\n    if (parentObject !== undefined && fromAddWatermark != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"addWatermark\"\n        ], fromAddWatermark);\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    const fromEditMode = getValueByPath(fromObject, [\n        \"editMode\"\n    ]);\n    if (parentObject !== undefined && fromEditMode != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"editMode\"\n        ], fromEditMode);\n    }\n    const fromBaseSteps = getValueByPath(fromObject, [\n        \"baseSteps\"\n    ]);\n    if (parentObject !== undefined && fromBaseSteps != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"editConfig\",\n            \"baseSteps\"\n        ], fromBaseSteps);\n    }\n    return toObject;\n}\nfunction editImageParametersInternalToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromReferenceImages = getValueByPath(fromObject, [\n        \"referenceImages\"\n    ]);\n    if (fromReferenceImages != null) {\n        let transformedList = fromReferenceImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return referenceImageAPIInternalToVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"referenceImages\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        editImageConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction editImageResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        \"predictions\"\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedImageFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedImages\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction embedContentConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromTaskType = getValueByPath(fromObject, [\n        \"taskType\"\n    ]);\n    if (parentObject !== undefined && fromTaskType != null) {\n        setValueByPath(parentObject, [\n            \"requests[]\",\n            \"taskType\"\n        ], fromTaskType);\n    }\n    const fromTitle = getValueByPath(fromObject, [\n        \"title\"\n    ]);\n    if (parentObject !== undefined && fromTitle != null) {\n        setValueByPath(parentObject, [\n            \"requests[]\",\n            \"title\"\n        ], fromTitle);\n    }\n    const fromOutputDimensionality = getValueByPath(fromObject, [\n        \"outputDimensionality\"\n    ]);\n    if (parentObject !== undefined && fromOutputDimensionality != null) {\n        setValueByPath(parentObject, [\n            \"requests[]\",\n            \"outputDimensionality\"\n        ], fromOutputDimensionality);\n    }\n    if (getValueByPath(fromObject, [\n        \"mimeType\"\n    ]) !== undefined) {\n        throw new Error(\"mimeType parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"autoTruncate\"\n    ]) !== undefined) {\n        throw new Error(\"autoTruncate parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction embedContentConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromTaskType = getValueByPath(fromObject, [\n        \"taskType\"\n    ]);\n    if (parentObject !== undefined && fromTaskType != null) {\n        setValueByPath(parentObject, [\n            \"instances[]\",\n            \"task_type\"\n        ], fromTaskType);\n    }\n    const fromTitle = getValueByPath(fromObject, [\n        \"title\"\n    ]);\n    if (parentObject !== undefined && fromTitle != null) {\n        setValueByPath(parentObject, [\n            \"instances[]\",\n            \"title\"\n        ], fromTitle);\n    }\n    const fromOutputDimensionality = getValueByPath(fromObject, [\n        \"outputDimensionality\"\n    ]);\n    if (parentObject !== undefined && fromOutputDimensionality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputDimensionality\"\n        ], fromOutputDimensionality);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (parentObject !== undefined && fromMimeType != null) {\n        setValueByPath(parentObject, [\n            \"instances[]\",\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    const fromAutoTruncate = getValueByPath(fromObject, [\n        \"autoTruncate\"\n    ]);\n    if (parentObject !== undefined && fromAutoTruncate != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"autoTruncate\"\n        ], fromAutoTruncate);\n    }\n    return toObject;\n}\nfunction embedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContentsForEmbed(apiClient, fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"requests[]\",\n            \"content\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        embedContentConfigToMldev(fromConfig, toObject);\n    }\n    const fromModelForEmbedContent = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModelForEmbedContent !== undefined) {\n        setValueByPath(toObject, [\n            \"requests[]\",\n            \"model\"\n        ], tModel(apiClient, fromModelForEmbedContent));\n    }\n    return toObject;\n}\nfunction embedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContentsForEmbed(apiClient, fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"instances[]\",\n            \"content\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        embedContentConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction embedContentResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromEmbeddings = getValueByPath(fromObject, [\n        \"embeddings\"\n    ]);\n    if (fromEmbeddings != null) {\n        let transformedList = fromEmbeddings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"embeddings\"\n        ], transformedList);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    return toObject;\n}\nfunction embedContentResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromEmbeddings = getValueByPath(fromObject, [\n        \"predictions[]\",\n        \"embeddings\"\n    ]);\n    if (fromEmbeddings != null) {\n        let transformedList = fromEmbeddings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentEmbeddingFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"embeddings\"\n        ], transformedList);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    return toObject;\n}\nfunction endpointFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"endpoint\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDeployedModelId = getValueByPath(fromObject, [\n        \"deployedModelId\"\n    ]);\n    if (fromDeployedModelId != null) {\n        setValueByPath(toObject, [\n            \"deployedModelId\"\n        ], fromDeployedModelId);\n    }\n    return toObject;\n}\nfunction fileDataToMldev$1(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction functionCallToMldev$1(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, [\n        \"id\"\n    ]);\n    if (fromId != null) {\n        setValueByPath(toObject, [\n            \"id\"\n        ], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, [\n        \"args\"\n    ]);\n    if (fromArgs != null) {\n        setValueByPath(toObject, [\n            \"args\"\n        ], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    if (getValueByPath(fromObject, [\n        \"partialArgs\"\n    ]) !== undefined) {\n        throw new Error(\"partialArgs parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"willContinue\"\n    ]) !== undefined) {\n        throw new Error(\"willContinue parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction functionCallingConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromAllowedFunctionNames = getValueByPath(fromObject, [\n        \"allowedFunctionNames\"\n    ]);\n    if (fromAllowedFunctionNames != null) {\n        setValueByPath(toObject, [\n            \"allowedFunctionNames\"\n        ], fromAllowedFunctionNames);\n    }\n    if (getValueByPath(fromObject, [\n        \"streamFunctionCallArguments\"\n    ]) !== undefined) {\n        throw new Error(\"streamFunctionCallArguments parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction functionDeclarationToVertex(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"behavior\"\n    ]) !== undefined) {\n        throw new Error(\"behavior parameter is not supported in Vertex AI.\");\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, [\n        \"parameters\"\n    ]);\n    if (fromParameters != null) {\n        setValueByPath(toObject, [\n            \"parameters\"\n        ], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        \"parametersJsonSchema\"\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"parametersJsonSchema\"\n        ], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction generateContentConfigToMldev(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"systemInstruction\"\n        ], contentToMldev$1(tContent(fromSystemInstruction)));\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, [\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (fromTopP != null) {\n        setValueByPath(toObject, [\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (fromTopK != null) {\n        setValueByPath(toObject, [\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        \"candidateCount\"\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, [\n            \"candidateCount\"\n        ], fromCandidateCount);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, [\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        \"stopSequences\"\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, [\n            \"stopSequences\"\n        ], fromStopSequences);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        \"responseLogprobs\"\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, [\n            \"responseLogprobs\"\n        ], fromResponseLogprobs);\n    }\n    const fromLogprobs = getValueByPath(fromObject, [\n        \"logprobs\"\n    ]);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, [\n            \"logprobs\"\n        ], fromLogprobs);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        \"presencePenalty\"\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, [\n            \"presencePenalty\"\n        ], fromPresencePenalty);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        \"frequencyPenalty\"\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, [\n            \"frequencyPenalty\"\n        ], fromFrequencyPenalty);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (fromSeed != null) {\n        setValueByPath(toObject, [\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        \"responseMimeType\"\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, [\n            \"responseMimeType\"\n        ], fromResponseMimeType);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        \"responseSchema\"\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, [\n            \"responseSchema\"\n        ], tSchema(fromResponseSchema));\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    if (getValueByPath(fromObject, [\n        \"routingConfig\"\n    ]) !== undefined) {\n        throw new Error(\"routingConfig parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"modelSelectionConfig\"\n    ]) !== undefined) {\n        throw new Error(\"modelSelectionConfig parameter is not supported in Gemini API.\");\n    }\n    const fromSafetySettings = getValueByPath(fromObject, [\n        \"safetySettings\"\n    ]);\n    if (parentObject !== undefined && fromSafetySettings != null) {\n        let transformedList = fromSafetySettings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return safetySettingToMldev(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"safetySettings\"\n        ], transformedList);\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToMldev$1(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, [\n            \"tools\"\n        ], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, [\n        \"toolConfig\"\n    ]);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, [\n            \"toolConfig\"\n        ], toolConfigToMldev(fromToolConfig));\n    }\n    if (getValueByPath(fromObject, [\n        \"labels\"\n    ]) !== undefined) {\n        throw new Error(\"labels parameter is not supported in Gemini API.\");\n    }\n    const fromCachedContent = getValueByPath(fromObject, [\n        \"cachedContent\"\n    ]);\n    if (parentObject !== undefined && fromCachedContent != null) {\n        setValueByPath(parentObject, [\n            \"cachedContent\"\n        ], tCachedContentName(apiClient, fromCachedContent));\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, [\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, [\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, [\n            \"speechConfig\"\n        ], tSpeechConfig(fromSpeechConfig));\n    }\n    if (getValueByPath(fromObject, [\n        \"audioTimestamp\"\n    ]) !== undefined) {\n        throw new Error(\"audioTimestamp parameter is not supported in Gemini API.\");\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        \"thinkingConfig\"\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, [\n            \"thinkingConfig\"\n        ], fromThinkingConfig);\n    }\n    const fromImageConfig = getValueByPath(fromObject, [\n        \"imageConfig\"\n    ]);\n    if (fromImageConfig != null) {\n        setValueByPath(toObject, [\n            \"imageConfig\"\n        ], imageConfigToMldev(fromImageConfig));\n    }\n    return toObject;\n}\nfunction generateContentConfigToVertex(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"systemInstruction\"\n        ], tContent(fromSystemInstruction));\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, [\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (fromTopP != null) {\n        setValueByPath(toObject, [\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (fromTopK != null) {\n        setValueByPath(toObject, [\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        \"candidateCount\"\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, [\n            \"candidateCount\"\n        ], fromCandidateCount);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, [\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        \"stopSequences\"\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, [\n            \"stopSequences\"\n        ], fromStopSequences);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        \"responseLogprobs\"\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, [\n            \"responseLogprobs\"\n        ], fromResponseLogprobs);\n    }\n    const fromLogprobs = getValueByPath(fromObject, [\n        \"logprobs\"\n    ]);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, [\n            \"logprobs\"\n        ], fromLogprobs);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        \"presencePenalty\"\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, [\n            \"presencePenalty\"\n        ], fromPresencePenalty);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        \"frequencyPenalty\"\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, [\n            \"frequencyPenalty\"\n        ], fromFrequencyPenalty);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (fromSeed != null) {\n        setValueByPath(toObject, [\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        \"responseMimeType\"\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, [\n            \"responseMimeType\"\n        ], fromResponseMimeType);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        \"responseSchema\"\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, [\n            \"responseSchema\"\n        ], tSchema(fromResponseSchema));\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    const fromRoutingConfig = getValueByPath(fromObject, [\n        \"routingConfig\"\n    ]);\n    if (fromRoutingConfig != null) {\n        setValueByPath(toObject, [\n            \"routingConfig\"\n        ], fromRoutingConfig);\n    }\n    const fromModelSelectionConfig = getValueByPath(fromObject, [\n        \"modelSelectionConfig\"\n    ]);\n    if (fromModelSelectionConfig != null) {\n        setValueByPath(toObject, [\n            \"modelConfig\"\n        ], fromModelSelectionConfig);\n    }\n    const fromSafetySettings = getValueByPath(fromObject, [\n        \"safetySettings\"\n    ]);\n    if (parentObject !== undefined && fromSafetySettings != null) {\n        let transformedList = fromSafetySettings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(parentObject, [\n            \"safetySettings\"\n        ], transformedList);\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToVertex(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, [\n            \"tools\"\n        ], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, [\n        \"toolConfig\"\n    ]);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, [\n            \"toolConfig\"\n        ], fromToolConfig);\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    const fromCachedContent = getValueByPath(fromObject, [\n        \"cachedContent\"\n    ]);\n    if (parentObject !== undefined && fromCachedContent != null) {\n        setValueByPath(parentObject, [\n            \"cachedContent\"\n        ], tCachedContentName(apiClient, fromCachedContent));\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, [\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, [\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, [\n            \"speechConfig\"\n        ], speechConfigToVertex(tSpeechConfig(fromSpeechConfig)));\n    }\n    const fromAudioTimestamp = getValueByPath(fromObject, [\n        \"audioTimestamp\"\n    ]);\n    if (fromAudioTimestamp != null) {\n        setValueByPath(toObject, [\n            \"audioTimestamp\"\n        ], fromAudioTimestamp);\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        \"thinkingConfig\"\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, [\n            \"thinkingConfig\"\n        ], fromThinkingConfig);\n    }\n    const fromImageConfig = getValueByPath(fromObject, [\n        \"imageConfig\"\n    ]);\n    if (fromImageConfig != null) {\n        setValueByPath(toObject, [\n            \"imageConfig\"\n        ], imageConfigToVertex(fromImageConfig));\n    }\n    return toObject;\n}\nfunction generateContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentToMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"generationConfig\"\n        ], generateContentConfigToMldev(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction generateContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"generationConfig\"\n        ], generateContentConfigToVertex(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction generateContentResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromCandidates = getValueByPath(fromObject, [\n        \"candidates\"\n    ]);\n    if (fromCandidates != null) {\n        let transformedList = fromCandidates;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return candidateFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"candidates\"\n        ], transformedList);\n    }\n    const fromModelVersion = getValueByPath(fromObject, [\n        \"modelVersion\"\n    ]);\n    if (fromModelVersion != null) {\n        setValueByPath(toObject, [\n            \"modelVersion\"\n        ], fromModelVersion);\n    }\n    const fromPromptFeedback = getValueByPath(fromObject, [\n        \"promptFeedback\"\n    ]);\n    if (fromPromptFeedback != null) {\n        setValueByPath(toObject, [\n            \"promptFeedback\"\n        ], fromPromptFeedback);\n    }\n    const fromResponseId = getValueByPath(fromObject, [\n        \"responseId\"\n    ]);\n    if (fromResponseId != null) {\n        setValueByPath(toObject, [\n            \"responseId\"\n        ], fromResponseId);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        \"usageMetadata\"\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, [\n            \"usageMetadata\"\n        ], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction generateContentResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromCandidates = getValueByPath(fromObject, [\n        \"candidates\"\n    ]);\n    if (fromCandidates != null) {\n        let transformedList = fromCandidates;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"candidates\"\n        ], transformedList);\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromModelVersion = getValueByPath(fromObject, [\n        \"modelVersion\"\n    ]);\n    if (fromModelVersion != null) {\n        setValueByPath(toObject, [\n            \"modelVersion\"\n        ], fromModelVersion);\n    }\n    const fromPromptFeedback = getValueByPath(fromObject, [\n        \"promptFeedback\"\n    ]);\n    if (fromPromptFeedback != null) {\n        setValueByPath(toObject, [\n            \"promptFeedback\"\n        ], fromPromptFeedback);\n    }\n    const fromResponseId = getValueByPath(fromObject, [\n        \"responseId\"\n    ]);\n    if (fromResponseId != null) {\n        setValueByPath(toObject, [\n            \"responseId\"\n        ], fromResponseId);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        \"usageMetadata\"\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, [\n            \"usageMetadata\"\n        ], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction generateImagesConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]) !== undefined) {\n        throw new Error(\"outputGcsUri parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"negativePrompt\"\n    ]) !== undefined) {\n        throw new Error(\"negativePrompt parameter is not supported in Gemini API.\");\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        \"numberOfImages\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfImages);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    const fromGuidanceScale = getValueByPath(fromObject, [\n        \"guidanceScale\"\n    ]);\n    if (parentObject !== undefined && fromGuidanceScale != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"guidanceScale\"\n        ], fromGuidanceScale);\n    }\n    if (getValueByPath(fromObject, [\n        \"seed\"\n    ]) !== undefined) {\n        throw new Error(\"seed parameter is not supported in Gemini API.\");\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        \"safetyFilterLevel\"\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"safetySetting\"\n        ], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [\n        \"includeSafetyAttributes\"\n    ]);\n    if (parentObject !== undefined && fromIncludeSafetyAttributes != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeSafetyAttributes\"\n        ], fromIncludeSafetyAttributes);\n    }\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        \"includeRaiReason\"\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeRaiReason\"\n        ], fromIncludeRaiReason);\n    }\n    const fromLanguage = getValueByPath(fromObject, [\n        \"language\"\n    ]);\n    if (parentObject !== undefined && fromLanguage != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"language\"\n        ], fromLanguage);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        \"outputMimeType\"\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"mimeType\"\n        ], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        \"outputCompressionQuality\"\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"compressionQuality\"\n        ], fromOutputCompressionQuality);\n    }\n    if (getValueByPath(fromObject, [\n        \"addWatermark\"\n    ]) !== undefined) {\n        throw new Error(\"addWatermark parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"labels\"\n    ]) !== undefined) {\n        throw new Error(\"labels parameter is not supported in Gemini API.\");\n    }\n    const fromImageSize = getValueByPath(fromObject, [\n        \"imageSize\"\n    ]);\n    if (parentObject !== undefined && fromImageSize != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleImageSize\"\n        ], fromImageSize);\n    }\n    if (getValueByPath(fromObject, [\n        \"enhancePrompt\"\n    ]) !== undefined) {\n        throw new Error(\"enhancePrompt parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction generateImagesConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromOutputGcsUri = getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"storageUri\"\n        ], fromOutputGcsUri);\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        \"negativePrompt\"\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"negativePrompt\"\n        ], fromNegativePrompt);\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        \"numberOfImages\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfImages);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    const fromGuidanceScale = getValueByPath(fromObject, [\n        \"guidanceScale\"\n    ]);\n    if (parentObject !== undefined && fromGuidanceScale != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"guidanceScale\"\n        ], fromGuidanceScale);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        \"safetyFilterLevel\"\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"safetySetting\"\n        ], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [\n        \"includeSafetyAttributes\"\n    ]);\n    if (parentObject !== undefined && fromIncludeSafetyAttributes != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeSafetyAttributes\"\n        ], fromIncludeSafetyAttributes);\n    }\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        \"includeRaiReason\"\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeRaiReason\"\n        ], fromIncludeRaiReason);\n    }\n    const fromLanguage = getValueByPath(fromObject, [\n        \"language\"\n    ]);\n    if (parentObject !== undefined && fromLanguage != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"language\"\n        ], fromLanguage);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        \"outputMimeType\"\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"mimeType\"\n        ], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        \"outputCompressionQuality\"\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"compressionQuality\"\n        ], fromOutputCompressionQuality);\n    }\n    const fromAddWatermark = getValueByPath(fromObject, [\n        \"addWatermark\"\n    ]);\n    if (parentObject !== undefined && fromAddWatermark != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"addWatermark\"\n        ], fromAddWatermark);\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    const fromImageSize = getValueByPath(fromObject, [\n        \"imageSize\"\n    ]);\n    if (parentObject !== undefined && fromImageSize != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleImageSize\"\n        ], fromImageSize);\n    }\n    const fromEnhancePrompt = getValueByPath(fromObject, [\n        \"enhancePrompt\"\n    ]);\n    if (parentObject !== undefined && fromEnhancePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"enhancePrompt\"\n        ], fromEnhancePrompt);\n    }\n    return toObject;\n}\nfunction generateImagesParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        generateImagesConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction generateImagesParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        generateImagesConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction generateImagesResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        \"predictions\"\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedImageFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedImages\"\n        ], transformedList);\n    }\n    const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [\n        \"positivePromptSafetyAttributes\"\n    ]);\n    if (fromPositivePromptSafetyAttributes != null) {\n        setValueByPath(toObject, [\n            \"positivePromptSafetyAttributes\"\n        ], safetyAttributesFromMldev(fromPositivePromptSafetyAttributes));\n    }\n    return toObject;\n}\nfunction generateImagesResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        \"predictions\"\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedImageFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedImages\"\n        ], transformedList);\n    }\n    const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [\n        \"positivePromptSafetyAttributes\"\n    ]);\n    if (fromPositivePromptSafetyAttributes != null) {\n        setValueByPath(toObject, [\n            \"positivePromptSafetyAttributes\"\n        ], safetyAttributesFromVertex(fromPositivePromptSafetyAttributes));\n    }\n    return toObject;\n}\nfunction generateVideosConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromNumberOfVideos = getValueByPath(fromObject, [\n        \"numberOfVideos\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfVideos != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfVideos);\n    }\n    if (getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]) !== undefined) {\n        throw new Error(\"outputGcsUri parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"fps\"\n    ]) !== undefined) {\n        throw new Error(\"fps parameter is not supported in Gemini API.\");\n    }\n    const fromDurationSeconds = getValueByPath(fromObject, [\n        \"durationSeconds\"\n    ]);\n    if (parentObject !== undefined && fromDurationSeconds != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"durationSeconds\"\n        ], fromDurationSeconds);\n    }\n    if (getValueByPath(fromObject, [\n        \"seed\"\n    ]) !== undefined) {\n        throw new Error(\"seed parameter is not supported in Gemini API.\");\n    }\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    const fromResolution = getValueByPath(fromObject, [\n        \"resolution\"\n    ]);\n    if (parentObject !== undefined && fromResolution != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"resolution\"\n        ], fromResolution);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    if (getValueByPath(fromObject, [\n        \"pubsubTopic\"\n    ]) !== undefined) {\n        throw new Error(\"pubsubTopic parameter is not supported in Gemini API.\");\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        \"negativePrompt\"\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"negativePrompt\"\n        ], fromNegativePrompt);\n    }\n    const fromEnhancePrompt = getValueByPath(fromObject, [\n        \"enhancePrompt\"\n    ]);\n    if (parentObject !== undefined && fromEnhancePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"enhancePrompt\"\n        ], fromEnhancePrompt);\n    }\n    if (getValueByPath(fromObject, [\n        \"generateAudio\"\n    ]) !== undefined) {\n        throw new Error(\"generateAudio parameter is not supported in Gemini API.\");\n    }\n    const fromLastFrame = getValueByPath(fromObject, [\n        \"lastFrame\"\n    ]);\n    if (parentObject !== undefined && fromLastFrame != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"lastFrame\"\n        ], imageToMldev(fromLastFrame));\n    }\n    const fromReferenceImages = getValueByPath(fromObject, [\n        \"referenceImages\"\n    ]);\n    if (parentObject !== undefined && fromReferenceImages != null) {\n        let transformedList = fromReferenceImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return videoGenerationReferenceImageToMldev(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"referenceImages\"\n        ], transformedList);\n    }\n    if (getValueByPath(fromObject, [\n        \"mask\"\n    ]) !== undefined) {\n        throw new Error(\"mask parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"compressionQuality\"\n    ]) !== undefined) {\n        throw new Error(\"compressionQuality parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction generateVideosConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromNumberOfVideos = getValueByPath(fromObject, [\n        \"numberOfVideos\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfVideos != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfVideos);\n    }\n    const fromOutputGcsUri = getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"storageUri\"\n        ], fromOutputGcsUri);\n    }\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (parentObject !== undefined && fromFps != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"fps\"\n        ], fromFps);\n    }\n    const fromDurationSeconds = getValueByPath(fromObject, [\n        \"durationSeconds\"\n    ]);\n    if (parentObject !== undefined && fromDurationSeconds != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"durationSeconds\"\n        ], fromDurationSeconds);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    const fromResolution = getValueByPath(fromObject, [\n        \"resolution\"\n    ]);\n    if (parentObject !== undefined && fromResolution != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"resolution\"\n        ], fromResolution);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    const fromPubsubTopic = getValueByPath(fromObject, [\n        \"pubsubTopic\"\n    ]);\n    if (parentObject !== undefined && fromPubsubTopic != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"pubsubTopic\"\n        ], fromPubsubTopic);\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        \"negativePrompt\"\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"negativePrompt\"\n        ], fromNegativePrompt);\n    }\n    const fromEnhancePrompt = getValueByPath(fromObject, [\n        \"enhancePrompt\"\n    ]);\n    if (parentObject !== undefined && fromEnhancePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"enhancePrompt\"\n        ], fromEnhancePrompt);\n    }\n    const fromGenerateAudio = getValueByPath(fromObject, [\n        \"generateAudio\"\n    ]);\n    if (parentObject !== undefined && fromGenerateAudio != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"generateAudio\"\n        ], fromGenerateAudio);\n    }\n    const fromLastFrame = getValueByPath(fromObject, [\n        \"lastFrame\"\n    ]);\n    if (parentObject !== undefined && fromLastFrame != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"lastFrame\"\n        ], imageToVertex(fromLastFrame));\n    }\n    const fromReferenceImages = getValueByPath(fromObject, [\n        \"referenceImages\"\n    ]);\n    if (parentObject !== undefined && fromReferenceImages != null) {\n        let transformedList = fromReferenceImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return videoGenerationReferenceImageToVertex(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"referenceImages\"\n        ], transformedList);\n    }\n    const fromMask = getValueByPath(fromObject, [\n        \"mask\"\n    ]);\n    if (parentObject !== undefined && fromMask != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"mask\"\n        ], videoGenerationMaskToVertex(fromMask));\n    }\n    const fromCompressionQuality = getValueByPath(fromObject, [\n        \"compressionQuality\"\n    ]);\n    if (parentObject !== undefined && fromCompressionQuality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"compressionQuality\"\n        ], fromCompressionQuality);\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\",\n        \"generateVideoResponse\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], generateVideosResponseFromMldev(fromResponse));\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], generateVideosResponseFromVertex(fromResponse));\n    }\n    return toObject;\n}\nfunction generateVideosParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"image\"\n        ], imageToMldev(fromImage));\n    }\n    const fromVideo = getValueByPath(fromObject, [\n        \"video\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"video\"\n        ], videoToMldev(fromVideo));\n    }\n    const fromSource = getValueByPath(fromObject, [\n        \"source\"\n    ]);\n    if (fromSource != null) {\n        generateVideosSourceToMldev(fromSource, toObject);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        generateVideosConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction generateVideosParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"image\"\n        ], imageToVertex(fromImage));\n    }\n    const fromVideo = getValueByPath(fromObject, [\n        \"video\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"video\"\n        ], videoToVertex(fromVideo));\n    }\n    const fromSource = getValueByPath(fromObject, [\n        \"source\"\n    ]);\n    if (fromSource != null) {\n        generateVideosSourceToVertex(fromSource, toObject);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        generateVideosConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, [\n        \"generatedSamples\"\n    ]);\n    if (fromGeneratedVideos != null) {\n        let transformedList = fromGeneratedVideos;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedVideoFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedVideos\"\n        ], transformedList);\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        \"raiMediaFilteredCount\"\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredCount\"\n        ], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        \"raiMediaFilteredReasons\"\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredReasons\"\n        ], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, [\n        \"videos\"\n    ]);\n    if (fromGeneratedVideos != null) {\n        let transformedList = fromGeneratedVideos;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedVideoFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedVideos\"\n        ], transformedList);\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        \"raiMediaFilteredCount\"\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredCount\"\n        ], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        \"raiMediaFilteredReasons\"\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredReasons\"\n        ], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generateVideosSourceToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (parentObject !== undefined && fromPrompt != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (parentObject !== undefined && fromImage != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"image\"\n        ], imageToMldev(fromImage));\n    }\n    const fromVideo = getValueByPath(fromObject, [\n        \"video\"\n    ]);\n    if (parentObject !== undefined && fromVideo != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"video\"\n        ], videoToMldev(fromVideo));\n    }\n    return toObject;\n}\nfunction generateVideosSourceToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (parentObject !== undefined && fromPrompt != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (parentObject !== undefined && fromImage != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"image\"\n        ], imageToVertex(fromImage));\n    }\n    const fromVideo = getValueByPath(fromObject, [\n        \"video\"\n    ]);\n    if (parentObject !== undefined && fromVideo != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"video\"\n        ], videoToVertex(fromVideo));\n    }\n    return toObject;\n}\nfunction generatedImageFromMldev(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"image\"\n        ], imageFromMldev(fromImage));\n    }\n    const fromRaiFilteredReason = getValueByPath(fromObject, [\n        \"raiFilteredReason\"\n    ]);\n    if (fromRaiFilteredReason != null) {\n        setValueByPath(toObject, [\n            \"raiFilteredReason\"\n        ], fromRaiFilteredReason);\n    }\n    const fromSafetyAttributes = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromSafetyAttributes != null) {\n        setValueByPath(toObject, [\n            \"safetyAttributes\"\n        ], safetyAttributesFromMldev(fromSafetyAttributes));\n    }\n    return toObject;\n}\nfunction generatedImageFromVertex(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"image\"\n        ], imageFromVertex(fromImage));\n    }\n    const fromRaiFilteredReason = getValueByPath(fromObject, [\n        \"raiFilteredReason\"\n    ]);\n    if (fromRaiFilteredReason != null) {\n        setValueByPath(toObject, [\n            \"raiFilteredReason\"\n        ], fromRaiFilteredReason);\n    }\n    const fromSafetyAttributes = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromSafetyAttributes != null) {\n        setValueByPath(toObject, [\n            \"safetyAttributes\"\n        ], safetyAttributesFromVertex(fromSafetyAttributes));\n    }\n    const fromEnhancedPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (fromEnhancedPrompt != null) {\n        setValueByPath(toObject, [\n            \"enhancedPrompt\"\n        ], fromEnhancedPrompt);\n    }\n    return toObject;\n}\nfunction generatedImageMaskFromVertex(fromObject) {\n    const toObject = {};\n    const fromMask = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromMask != null) {\n        setValueByPath(toObject, [\n            \"mask\"\n        ], imageFromVertex(fromMask));\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (fromLabels != null) {\n        let transformedList = fromLabels;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"labels\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction generatedVideoFromMldev(fromObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, [\n        \"video\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"video\"\n        ], videoFromMldev(fromVideo));\n    }\n    return toObject;\n}\nfunction generatedVideoFromVertex(fromObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"video\"\n        ], videoFromVertex(fromVideo));\n    }\n    return toObject;\n}\nfunction generationConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromModelSelectionConfig = getValueByPath(fromObject, [\n        \"modelSelectionConfig\"\n    ]);\n    if (fromModelSelectionConfig != null) {\n        setValueByPath(toObject, [\n            \"modelConfig\"\n        ], fromModelSelectionConfig);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    const fromAudioTimestamp = getValueByPath(fromObject, [\n        \"audioTimestamp\"\n    ]);\n    if (fromAudioTimestamp != null) {\n        setValueByPath(toObject, [\n            \"audioTimestamp\"\n        ], fromAudioTimestamp);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        \"candidateCount\"\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, [\n            \"candidateCount\"\n        ], fromCandidateCount);\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        \"enableAffectiveDialog\"\n    ]);\n    if (fromEnableAffectiveDialog != null) {\n        setValueByPath(toObject, [\n            \"enableAffectiveDialog\"\n        ], fromEnableAffectiveDialog);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        \"frequencyPenalty\"\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, [\n            \"frequencyPenalty\"\n        ], fromFrequencyPenalty);\n    }\n    const fromLogprobs = getValueByPath(fromObject, [\n        \"logprobs\"\n    ]);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, [\n            \"logprobs\"\n        ], fromLogprobs);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, [\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, [\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        \"presencePenalty\"\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, [\n            \"presencePenalty\"\n        ], fromPresencePenalty);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        \"responseLogprobs\"\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, [\n            \"responseLogprobs\"\n        ], fromResponseLogprobs);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        \"responseMimeType\"\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, [\n            \"responseMimeType\"\n        ], fromResponseMimeType);\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, [\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        \"responseSchema\"\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, [\n            \"responseSchema\"\n        ], fromResponseSchema);\n    }\n    const fromRoutingConfig = getValueByPath(fromObject, [\n        \"routingConfig\"\n    ]);\n    if (fromRoutingConfig != null) {\n        setValueByPath(toObject, [\n            \"routingConfig\"\n        ], fromRoutingConfig);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (fromSeed != null) {\n        setValueByPath(toObject, [\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, [\n            \"speechConfig\"\n        ], speechConfigToVertex(fromSpeechConfig));\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        \"stopSequences\"\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, [\n            \"stopSequences\"\n        ], fromStopSequences);\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, [\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        \"thinkingConfig\"\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, [\n            \"thinkingConfig\"\n        ], fromThinkingConfig);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (fromTopK != null) {\n        setValueByPath(toObject, [\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (fromTopP != null) {\n        setValueByPath(toObject, [\n            \"topP\"\n        ], fromTopP);\n    }\n    if (getValueByPath(fromObject, [\n        \"enableEnhancedCivicAnswers\"\n    ]) !== undefined) {\n        throw new Error(\"enableEnhancedCivicAnswers parameter is not supported in Vertex AI.\");\n    }\n    return toObject;\n}\nfunction getModelParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tModel(apiClient, fromModel));\n    }\n    return toObject;\n}\nfunction getModelParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tModel(apiClient, fromModel));\n    }\n    return toObject;\n}\nfunction googleMapsToMldev$1(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"authConfig\"\n    ]) !== undefined) {\n        throw new Error(\"authConfig parameter is not supported in Gemini API.\");\n    }\n    const fromEnableWidget = getValueByPath(fromObject, [\n        \"enableWidget\"\n    ]);\n    if (fromEnableWidget != null) {\n        setValueByPath(toObject, [\n            \"enableWidget\"\n        ], fromEnableWidget);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$1(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"excludeDomains\"\n    ]) !== undefined) {\n        throw new Error(\"excludeDomains parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"blockingConfidence\"\n    ]) !== undefined) {\n        throw new Error(\"blockingConfidence parameter is not supported in Gemini API.\");\n    }\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        \"timeRangeFilter\"\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, [\n            \"timeRangeFilter\"\n        ], fromTimeRangeFilter);\n    }\n    return toObject;\n}\nfunction imageConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (fromAspectRatio != null) {\n        setValueByPath(toObject, [\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    const fromImageSize = getValueByPath(fromObject, [\n        \"imageSize\"\n    ]);\n    if (fromImageSize != null) {\n        setValueByPath(toObject, [\n            \"imageSize\"\n        ], fromImageSize);\n    }\n    if (getValueByPath(fromObject, [\n        \"outputMimeType\"\n    ]) !== undefined) {\n        throw new Error(\"outputMimeType parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"outputCompressionQuality\"\n    ]) !== undefined) {\n        throw new Error(\"outputCompressionQuality parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction imageConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (fromAspectRatio != null) {\n        setValueByPath(toObject, [\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    const fromImageSize = getValueByPath(fromObject, [\n        \"imageSize\"\n    ]);\n    if (fromImageSize != null) {\n        setValueByPath(toObject, [\n            \"imageSize\"\n        ], fromImageSize);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        \"outputMimeType\"\n    ]);\n    if (fromOutputMimeType != null) {\n        setValueByPath(toObject, [\n            \"imageOutputOptions\",\n            \"mimeType\"\n        ], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        \"outputCompressionQuality\"\n    ]);\n    if (fromOutputCompressionQuality != null) {\n        setValueByPath(toObject, [\n            \"imageOutputOptions\",\n            \"compressionQuality\"\n        ], fromOutputCompressionQuality);\n    }\n    return toObject;\n}\nfunction imageFromMldev(fromObject) {\n    const toObject = {};\n    const fromImageBytes = getValueByPath(fromObject, [\n        \"bytesBase64Encoded\"\n    ]);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, [\n            \"imageBytes\"\n        ], tBytes(fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction imageFromVertex(fromObject) {\n    const toObject = {};\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"gcsUri\"\n        ], fromGcsUri);\n    }\n    const fromImageBytes = getValueByPath(fromObject, [\n        \"bytesBase64Encoded\"\n    ]);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, [\n            \"imageBytes\"\n        ], tBytes(fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction imageToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]) !== undefined) {\n        throw new Error(\"gcsUri parameter is not supported in Gemini API.\");\n    }\n    const fromImageBytes = getValueByPath(fromObject, [\n        \"imageBytes\"\n    ]);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, [\n            \"bytesBase64Encoded\"\n        ], tBytes(fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction imageToVertex(fromObject) {\n    const toObject = {};\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"gcsUri\"\n        ], fromGcsUri);\n    }\n    const fromImageBytes = getValueByPath(fromObject, [\n        \"imageBytes\"\n    ]);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, [\n            \"bytesBase64Encoded\"\n        ], tBytes(fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction listModelsConfigToMldev(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, [\n        \"filter\"\n    ]);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"filter\"\n        ], fromFilter);\n    }\n    const fromQueryBase = getValueByPath(fromObject, [\n        \"queryBase\"\n    ]);\n    if (parentObject !== undefined && fromQueryBase != null) {\n        setValueByPath(parentObject, [\n            \"_url\",\n            \"models_url\"\n        ], tModelsUrl(apiClient, fromQueryBase));\n    }\n    return toObject;\n}\nfunction listModelsConfigToVertex(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, [\n        \"filter\"\n    ]);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"filter\"\n        ], fromFilter);\n    }\n    const fromQueryBase = getValueByPath(fromObject, [\n        \"queryBase\"\n    ]);\n    if (parentObject !== undefined && fromQueryBase != null) {\n        setValueByPath(parentObject, [\n            \"_url\",\n            \"models_url\"\n        ], tModelsUrl(apiClient, fromQueryBase));\n    }\n    return toObject;\n}\nfunction listModelsParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listModelsConfigToMldev(apiClient, fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listModelsParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listModelsConfigToVertex(apiClient, fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listModelsResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromModels = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromModels != null) {\n        let transformedList = tExtractModels(fromModels);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return modelFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"models\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction listModelsResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromModels = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromModels != null) {\n        let transformedList = tExtractModels(fromModels);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return modelFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"models\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction maskReferenceConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromMaskMode = getValueByPath(fromObject, [\n        \"maskMode\"\n    ]);\n    if (fromMaskMode != null) {\n        setValueByPath(toObject, [\n            \"maskMode\"\n        ], fromMaskMode);\n    }\n    const fromSegmentationClasses = getValueByPath(fromObject, [\n        \"segmentationClasses\"\n    ]);\n    if (fromSegmentationClasses != null) {\n        setValueByPath(toObject, [\n            \"maskClasses\"\n        ], fromSegmentationClasses);\n    }\n    const fromMaskDilation = getValueByPath(fromObject, [\n        \"maskDilation\"\n    ]);\n    if (fromMaskDilation != null) {\n        setValueByPath(toObject, [\n            \"dilation\"\n        ], fromMaskDilation);\n    }\n    return toObject;\n}\nfunction modelFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromVersion = getValueByPath(fromObject, [\n        \"version\"\n    ]);\n    if (fromVersion != null) {\n        setValueByPath(toObject, [\n            \"version\"\n        ], fromVersion);\n    }\n    const fromTunedModelInfo = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromTunedModelInfo != null) {\n        setValueByPath(toObject, [\n            \"tunedModelInfo\"\n        ], tunedModelInfoFromMldev(fromTunedModelInfo));\n    }\n    const fromInputTokenLimit = getValueByPath(fromObject, [\n        \"inputTokenLimit\"\n    ]);\n    if (fromInputTokenLimit != null) {\n        setValueByPath(toObject, [\n            \"inputTokenLimit\"\n        ], fromInputTokenLimit);\n    }\n    const fromOutputTokenLimit = getValueByPath(fromObject, [\n        \"outputTokenLimit\"\n    ]);\n    if (fromOutputTokenLimit != null) {\n        setValueByPath(toObject, [\n            \"outputTokenLimit\"\n        ], fromOutputTokenLimit);\n    }\n    const fromSupportedActions = getValueByPath(fromObject, [\n        \"supportedGenerationMethods\"\n    ]);\n    if (fromSupportedActions != null) {\n        setValueByPath(toObject, [\n            \"supportedActions\"\n        ], fromSupportedActions);\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, [\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromMaxTemperature = getValueByPath(fromObject, [\n        \"maxTemperature\"\n    ]);\n    if (fromMaxTemperature != null) {\n        setValueByPath(toObject, [\n            \"maxTemperature\"\n        ], fromMaxTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (fromTopP != null) {\n        setValueByPath(toObject, [\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (fromTopK != null) {\n        setValueByPath(toObject, [\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromThinking = getValueByPath(fromObject, [\n        \"thinking\"\n    ]);\n    if (fromThinking != null) {\n        setValueByPath(toObject, [\n            \"thinking\"\n        ], fromThinking);\n    }\n    return toObject;\n}\nfunction modelFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromVersion = getValueByPath(fromObject, [\n        \"versionId\"\n    ]);\n    if (fromVersion != null) {\n        setValueByPath(toObject, [\n            \"version\"\n        ], fromVersion);\n    }\n    const fromEndpoints = getValueByPath(fromObject, [\n        \"deployedModels\"\n    ]);\n    if (fromEndpoints != null) {\n        let transformedList = fromEndpoints;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return endpointFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"endpoints\"\n        ], transformedList);\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (fromLabels != null) {\n        setValueByPath(toObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    const fromTunedModelInfo = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromTunedModelInfo != null) {\n        setValueByPath(toObject, [\n            \"tunedModelInfo\"\n        ], tunedModelInfoFromVertex(fromTunedModelInfo));\n    }\n    const fromDefaultCheckpointId = getValueByPath(fromObject, [\n        \"defaultCheckpointId\"\n    ]);\n    if (fromDefaultCheckpointId != null) {\n        setValueByPath(toObject, [\n            \"defaultCheckpointId\"\n        ], fromDefaultCheckpointId);\n    }\n    const fromCheckpoints = getValueByPath(fromObject, [\n        \"checkpoints\"\n    ]);\n    if (fromCheckpoints != null) {\n        let transformedList = fromCheckpoints;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"checkpoints\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction partToMldev$1(fromObject) {\n    const toObject = {};\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, [\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataToMldev$1(fromFileData));\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], functionCallToMldev$1(fromFunctionCall));\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobToMldev$1(fromInlineData));\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], fromVideoMetadata);\n    }\n    return toObject;\n}\nfunction productImageToVertex(fromObject) {\n    const toObject = {};\n    const fromProductImage = getValueByPath(fromObject, [\n        \"productImage\"\n    ]);\n    if (fromProductImage != null) {\n        setValueByPath(toObject, [\n            \"image\"\n        ], imageToVertex(fromProductImage));\n    }\n    return toObject;\n}\nfunction recontextImageConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        \"numberOfImages\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfImages);\n    }\n    const fromBaseSteps = getValueByPath(fromObject, [\n        \"baseSteps\"\n    ]);\n    if (parentObject !== undefined && fromBaseSteps != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"baseSteps\"\n        ], fromBaseSteps);\n    }\n    const fromOutputGcsUri = getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"storageUri\"\n        ], fromOutputGcsUri);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        \"safetyFilterLevel\"\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"safetySetting\"\n        ], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    const fromAddWatermark = getValueByPath(fromObject, [\n        \"addWatermark\"\n    ]);\n    if (parentObject !== undefined && fromAddWatermark != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"addWatermark\"\n        ], fromAddWatermark);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        \"outputMimeType\"\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"mimeType\"\n        ], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        \"outputCompressionQuality\"\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"compressionQuality\"\n        ], fromOutputCompressionQuality);\n    }\n    const fromEnhancePrompt = getValueByPath(fromObject, [\n        \"enhancePrompt\"\n    ]);\n    if (parentObject !== undefined && fromEnhancePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"enhancePrompt\"\n        ], fromEnhancePrompt);\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    return toObject;\n}\nfunction recontextImageParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromSource = getValueByPath(fromObject, [\n        \"source\"\n    ]);\n    if (fromSource != null) {\n        recontextImageSourceToVertex(fromSource, toObject);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        recontextImageConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction recontextImageResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        \"predictions\"\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedImageFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedImages\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction recontextImageSourceToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (parentObject !== undefined && fromPrompt != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromPersonImage = getValueByPath(fromObject, [\n        \"personImage\"\n    ]);\n    if (parentObject !== undefined && fromPersonImage != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"personImage\",\n            \"image\"\n        ], imageToVertex(fromPersonImage));\n    }\n    const fromProductImages = getValueByPath(fromObject, [\n        \"productImages\"\n    ]);\n    if (parentObject !== undefined && fromProductImages != null) {\n        let transformedList = fromProductImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return productImageToVertex(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"productImages\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction referenceImageAPIInternalToVertex(fromObject) {\n    const toObject = {};\n    const fromReferenceImage = getValueByPath(fromObject, [\n        \"referenceImage\"\n    ]);\n    if (fromReferenceImage != null) {\n        setValueByPath(toObject, [\n            \"referenceImage\"\n        ], imageToVertex(fromReferenceImage));\n    }\n    const fromReferenceId = getValueByPath(fromObject, [\n        \"referenceId\"\n    ]);\n    if (fromReferenceId != null) {\n        setValueByPath(toObject, [\n            \"referenceId\"\n        ], fromReferenceId);\n    }\n    const fromReferenceType = getValueByPath(fromObject, [\n        \"referenceType\"\n    ]);\n    if (fromReferenceType != null) {\n        setValueByPath(toObject, [\n            \"referenceType\"\n        ], fromReferenceType);\n    }\n    const fromMaskImageConfig = getValueByPath(fromObject, [\n        \"maskImageConfig\"\n    ]);\n    if (fromMaskImageConfig != null) {\n        setValueByPath(toObject, [\n            \"maskImageConfig\"\n        ], maskReferenceConfigToVertex(fromMaskImageConfig));\n    }\n    const fromControlImageConfig = getValueByPath(fromObject, [\n        \"controlImageConfig\"\n    ]);\n    if (fromControlImageConfig != null) {\n        setValueByPath(toObject, [\n            \"controlImageConfig\"\n        ], controlReferenceConfigToVertex(fromControlImageConfig));\n    }\n    const fromStyleImageConfig = getValueByPath(fromObject, [\n        \"styleImageConfig\"\n    ]);\n    if (fromStyleImageConfig != null) {\n        setValueByPath(toObject, [\n            \"styleImageConfig\"\n        ], fromStyleImageConfig);\n    }\n    const fromSubjectImageConfig = getValueByPath(fromObject, [\n        \"subjectImageConfig\"\n    ]);\n    if (fromSubjectImageConfig != null) {\n        setValueByPath(toObject, [\n            \"subjectImageConfig\"\n        ], fromSubjectImageConfig);\n    }\n    return toObject;\n}\nfunction safetyAttributesFromMldev(fromObject) {\n    const toObject = {};\n    const fromCategories = getValueByPath(fromObject, [\n        \"safetyAttributes\",\n        \"categories\"\n    ]);\n    if (fromCategories != null) {\n        setValueByPath(toObject, [\n            \"categories\"\n        ], fromCategories);\n    }\n    const fromScores = getValueByPath(fromObject, [\n        \"safetyAttributes\",\n        \"scores\"\n    ]);\n    if (fromScores != null) {\n        setValueByPath(toObject, [\n            \"scores\"\n        ], fromScores);\n    }\n    const fromContentType = getValueByPath(fromObject, [\n        \"contentType\"\n    ]);\n    if (fromContentType != null) {\n        setValueByPath(toObject, [\n            \"contentType\"\n        ], fromContentType);\n    }\n    return toObject;\n}\nfunction safetyAttributesFromVertex(fromObject) {\n    const toObject = {};\n    const fromCategories = getValueByPath(fromObject, [\n        \"safetyAttributes\",\n        \"categories\"\n    ]);\n    if (fromCategories != null) {\n        setValueByPath(toObject, [\n            \"categories\"\n        ], fromCategories);\n    }\n    const fromScores = getValueByPath(fromObject, [\n        \"safetyAttributes\",\n        \"scores\"\n    ]);\n    if (fromScores != null) {\n        setValueByPath(toObject, [\n            \"scores\"\n        ], fromScores);\n    }\n    const fromContentType = getValueByPath(fromObject, [\n        \"contentType\"\n    ]);\n    if (fromContentType != null) {\n        setValueByPath(toObject, [\n            \"contentType\"\n        ], fromContentType);\n    }\n    return toObject;\n}\nfunction safetySettingToMldev(fromObject) {\n    const toObject = {};\n    const fromCategory = getValueByPath(fromObject, [\n        \"category\"\n    ]);\n    if (fromCategory != null) {\n        setValueByPath(toObject, [\n            \"category\"\n        ], fromCategory);\n    }\n    if (getValueByPath(fromObject, [\n        \"method\"\n    ]) !== undefined) {\n        throw new Error(\"method parameter is not supported in Gemini API.\");\n    }\n    const fromThreshold = getValueByPath(fromObject, [\n        \"threshold\"\n    ]);\n    if (fromThreshold != null) {\n        setValueByPath(toObject, [\n            \"threshold\"\n        ], fromThreshold);\n    }\n    return toObject;\n}\nfunction scribbleImageToVertex(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"image\"\n        ], imageToVertex(fromImage));\n    }\n    return toObject;\n}\nfunction segmentImageConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (parentObject !== undefined && fromMode != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"mode\"\n        ], fromMode);\n    }\n    const fromMaxPredictions = getValueByPath(fromObject, [\n        \"maxPredictions\"\n    ]);\n    if (parentObject !== undefined && fromMaxPredictions != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"maxPredictions\"\n        ], fromMaxPredictions);\n    }\n    const fromConfidenceThreshold = getValueByPath(fromObject, [\n        \"confidenceThreshold\"\n    ]);\n    if (parentObject !== undefined && fromConfidenceThreshold != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"confidenceThreshold\"\n        ], fromConfidenceThreshold);\n    }\n    const fromMaskDilation = getValueByPath(fromObject, [\n        \"maskDilation\"\n    ]);\n    if (parentObject !== undefined && fromMaskDilation != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"maskDilation\"\n        ], fromMaskDilation);\n    }\n    const fromBinaryColorThreshold = getValueByPath(fromObject, [\n        \"binaryColorThreshold\"\n    ]);\n    if (parentObject !== undefined && fromBinaryColorThreshold != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"binaryColorThreshold\"\n        ], fromBinaryColorThreshold);\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    return toObject;\n}\nfunction segmentImageParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromSource = getValueByPath(fromObject, [\n        \"source\"\n    ]);\n    if (fromSource != null) {\n        segmentImageSourceToVertex(fromSource, toObject);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        segmentImageConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction segmentImageResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromGeneratedMasks = getValueByPath(fromObject, [\n        \"predictions\"\n    ]);\n    if (fromGeneratedMasks != null) {\n        let transformedList = fromGeneratedMasks;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedImageMaskFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedMasks\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction segmentImageSourceToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (parentObject !== undefined && fromPrompt != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (parentObject !== undefined && fromImage != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"image\"\n        ], imageToVertex(fromImage));\n    }\n    const fromScribbleImage = getValueByPath(fromObject, [\n        \"scribbleImage\"\n    ]);\n    if (parentObject !== undefined && fromScribbleImage != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"scribble\"\n        ], scribbleImageToVertex(fromScribbleImage));\n    }\n    return toObject;\n}\nfunction speechConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromLanguageCode = getValueByPath(fromObject, [\n        \"languageCode\"\n    ]);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, [\n            \"languageCode\"\n        ], fromLanguageCode);\n    }\n    const fromVoiceConfig = getValueByPath(fromObject, [\n        \"voiceConfig\"\n    ]);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"voiceConfig\"\n        ], fromVoiceConfig);\n    }\n    if (getValueByPath(fromObject, [\n        \"multiSpeakerVoiceConfig\"\n    ]) !== undefined) {\n        throw new Error(\"multiSpeakerVoiceConfig parameter is not supported in Vertex AI.\");\n    }\n    return toObject;\n}\nfunction toolConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromFunctionCallingConfig = getValueByPath(fromObject, [\n        \"functionCallingConfig\"\n    ]);\n    if (fromFunctionCallingConfig != null) {\n        setValueByPath(toObject, [\n            \"functionCallingConfig\"\n        ], functionCallingConfigToMldev(fromFunctionCallingConfig));\n    }\n    const fromRetrievalConfig = getValueByPath(fromObject, [\n        \"retrievalConfig\"\n    ]);\n    if (fromRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"retrievalConfig\"\n        ], fromRetrievalConfig);\n    }\n    return toObject;\n}\nfunction toolToMldev$1(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    if (getValueByPath(fromObject, [\n        \"retrieval\"\n    ]) !== undefined) {\n        throw new Error(\"retrieval parameter is not supported in Gemini API.\");\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], fromGoogleSearchRetrieval);\n    }\n    const fromComputerUse = getValueByPath(fromObject, [\n        \"computerUse\"\n    ]);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, [\n            \"computerUse\"\n        ], fromComputerUse);\n    }\n    const fromFileSearch = getValueByPath(fromObject, [\n        \"fileSearch\"\n    ]);\n    if (fromFileSearch != null) {\n        setValueByPath(toObject, [\n            \"fileSearch\"\n        ], fromFileSearch);\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    if (getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]) !== undefined) {\n        throw new Error(\"enterpriseWebSearch parameter is not supported in Gemini API.\");\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, [\n            \"googleMaps\"\n        ], googleMapsToMldev$1(fromGoogleMaps));\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToMldev$1(fromGoogleSearch));\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], fromUrlContext);\n    }\n    return toObject;\n}\nfunction toolToVertex(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return functionDeclarationToVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    const fromRetrieval = getValueByPath(fromObject, [\n        \"retrieval\"\n    ]);\n    if (fromRetrieval != null) {\n        setValueByPath(toObject, [\n            \"retrieval\"\n        ], fromRetrieval);\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], fromGoogleSearchRetrieval);\n    }\n    const fromComputerUse = getValueByPath(fromObject, [\n        \"computerUse\"\n    ]);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, [\n            \"computerUse\"\n        ], fromComputerUse);\n    }\n    if (getValueByPath(fromObject, [\n        \"fileSearch\"\n    ]) !== undefined) {\n        throw new Error(\"fileSearch parameter is not supported in Vertex AI.\");\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    const fromEnterpriseWebSearch = getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]);\n    if (fromEnterpriseWebSearch != null) {\n        setValueByPath(toObject, [\n            \"enterpriseWebSearch\"\n        ], fromEnterpriseWebSearch);\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, [\n            \"googleMaps\"\n        ], fromGoogleMaps);\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], fromGoogleSearch);\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], fromUrlContext);\n    }\n    return toObject;\n}\nfunction tunedModelInfoFromMldev(fromObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, [\n        \"baseModel\"\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, [\n            \"baseModel\"\n        ], fromBaseModel);\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    return toObject;\n}\nfunction tunedModelInfoFromVertex(fromObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, [\n        \"labels\",\n        \"google-vertex-llm-tuning-base-model-id\"\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, [\n            \"baseModel\"\n        ], fromBaseModel);\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    return toObject;\n}\nfunction updateModelConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (parentObject !== undefined && fromDescription != null) {\n        setValueByPath(parentObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromDefaultCheckpointId = getValueByPath(fromObject, [\n        \"defaultCheckpointId\"\n    ]);\n    if (parentObject !== undefined && fromDefaultCheckpointId != null) {\n        setValueByPath(parentObject, [\n            \"defaultCheckpointId\"\n        ], fromDefaultCheckpointId);\n    }\n    return toObject;\n}\nfunction updateModelConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (parentObject !== undefined && fromDescription != null) {\n        setValueByPath(parentObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromDefaultCheckpointId = getValueByPath(fromObject, [\n        \"defaultCheckpointId\"\n    ]);\n    if (parentObject !== undefined && fromDefaultCheckpointId != null) {\n        setValueByPath(parentObject, [\n            \"defaultCheckpointId\"\n        ], fromDefaultCheckpointId);\n    }\n    return toObject;\n}\nfunction updateModelParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        updateModelConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction updateModelParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        updateModelConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction upscaleImageAPIConfigInternalToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromOutputGcsUri = getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"storageUri\"\n        ], fromOutputGcsUri);\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        \"safetyFilterLevel\"\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"safetySetting\"\n        ], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        \"includeRaiReason\"\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeRaiReason\"\n        ], fromIncludeRaiReason);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        \"outputMimeType\"\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"mimeType\"\n        ], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        \"outputCompressionQuality\"\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"compressionQuality\"\n        ], fromOutputCompressionQuality);\n    }\n    const fromEnhanceInputImage = getValueByPath(fromObject, [\n        \"enhanceInputImage\"\n    ]);\n    if (parentObject !== undefined && fromEnhanceInputImage != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"upscaleConfig\",\n            \"enhanceInputImage\"\n        ], fromEnhanceInputImage);\n    }\n    const fromImagePreservationFactor = getValueByPath(fromObject, [\n        \"imagePreservationFactor\"\n    ]);\n    if (parentObject !== undefined && fromImagePreservationFactor != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"upscaleConfig\",\n            \"imagePreservationFactor\"\n        ], fromImagePreservationFactor);\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        \"numberOfImages\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfImages);\n    }\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (parentObject !== undefined && fromMode != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"mode\"\n        ], fromMode);\n    }\n    return toObject;\n}\nfunction upscaleImageAPIParametersInternalToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"image\"\n        ], imageToVertex(fromImage));\n    }\n    const fromUpscaleFactor = getValueByPath(fromObject, [\n        \"upscaleFactor\"\n    ]);\n    if (fromUpscaleFactor != null) {\n        setValueByPath(toObject, [\n            \"parameters\",\n            \"upscaleConfig\",\n            \"upscaleFactor\"\n        ], fromUpscaleFactor);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        upscaleImageAPIConfigInternalToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction upscaleImageResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        \"predictions\"\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedImageFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedImages\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction videoFromMldev(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, [\n        \"uri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"uri\"\n        ], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        \"encodedVideo\"\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, [\n            \"videoBytes\"\n        ], tBytes(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"encoding\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction videoFromVertex(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"uri\"\n        ], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        \"bytesBase64Encoded\"\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, [\n            \"videoBytes\"\n        ], tBytes(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction videoGenerationMaskToVertex(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"_self\"\n        ], imageToVertex(fromImage));\n    }\n    const fromMaskMode = getValueByPath(fromObject, [\n        \"maskMode\"\n    ]);\n    if (fromMaskMode != null) {\n        setValueByPath(toObject, [\n            \"maskMode\"\n        ], fromMaskMode);\n    }\n    return toObject;\n}\nfunction videoGenerationReferenceImageToMldev(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"image\"\n        ], imageToMldev(fromImage));\n    }\n    const fromReferenceType = getValueByPath(fromObject, [\n        \"referenceType\"\n    ]);\n    if (fromReferenceType != null) {\n        setValueByPath(toObject, [\n            \"referenceType\"\n        ], fromReferenceType);\n    }\n    return toObject;\n}\nfunction videoGenerationReferenceImageToVertex(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"image\"\n        ], imageToVertex(fromImage));\n    }\n    const fromReferenceType = getValueByPath(fromObject, [\n        \"referenceType\"\n    ]);\n    if (fromReferenceType != null) {\n        setValueByPath(toObject, [\n            \"referenceType\"\n        ], fromReferenceType);\n    }\n    return toObject;\n}\nfunction videoToMldev(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, [\n        \"uri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"uri\"\n        ], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        \"videoBytes\"\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, [\n            \"encodedVideo\"\n        ], tBytes(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"encoding\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction videoToVertex(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, [\n        \"uri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"gcsUri\"\n        ], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        \"videoBytes\"\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, [\n            \"bytesBase64Encoded\"\n        ], tBytes(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ // Code generated by the Google Gen AI SDK generator DO NOT EDIT.\nfunction createFileSearchStoreConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    return toObject;\n}\nfunction createFileSearchStoreParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        createFileSearchStoreConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction deleteFileSearchStoreConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromForce = getValueByPath(fromObject, [\n        \"force\"\n    ]);\n    if (parentObject !== undefined && fromForce != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"force\"\n        ], fromForce);\n    }\n    return toObject;\n}\nfunction deleteFileSearchStoreParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], fromName);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        deleteFileSearchStoreConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction getFileSearchStoreParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction importFileConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromCustomMetadata = getValueByPath(fromObject, [\n        \"customMetadata\"\n    ]);\n    if (parentObject !== undefined && fromCustomMetadata != null) {\n        let transformedList = fromCustomMetadata;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(parentObject, [\n            \"customMetadata\"\n        ], transformedList);\n    }\n    const fromChunkingConfig = getValueByPath(fromObject, [\n        \"chunkingConfig\"\n    ]);\n    if (parentObject !== undefined && fromChunkingConfig != null) {\n        setValueByPath(parentObject, [\n            \"chunkingConfig\"\n        ], fromChunkingConfig);\n    }\n    return toObject;\n}\nfunction importFileOperationFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], importFileResponseFromMldev(fromResponse));\n    }\n    return toObject;\n}\nfunction importFileParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromFileSearchStoreName = getValueByPath(fromObject, [\n        \"fileSearchStoreName\"\n    ]);\n    if (fromFileSearchStoreName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"file_search_store_name\"\n        ], fromFileSearchStoreName);\n    }\n    const fromFileName = getValueByPath(fromObject, [\n        \"fileName\"\n    ]);\n    if (fromFileName != null) {\n        setValueByPath(toObject, [\n            \"fileName\"\n        ], fromFileName);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        importFileConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction importFileResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromParent = getValueByPath(fromObject, [\n        \"parent\"\n    ]);\n    if (fromParent != null) {\n        setValueByPath(toObject, [\n            \"parent\"\n        ], fromParent);\n    }\n    const fromDocumentName = getValueByPath(fromObject, [\n        \"documentName\"\n    ]);\n    if (fromDocumentName != null) {\n        setValueByPath(toObject, [\n            \"documentName\"\n        ], fromDocumentName);\n    }\n    return toObject;\n}\nfunction listFileSearchStoresConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    return toObject;\n}\nfunction listFileSearchStoresParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listFileSearchStoresConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listFileSearchStoresResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromFileSearchStores = getValueByPath(fromObject, [\n        \"fileSearchStores\"\n    ]);\n    if (fromFileSearchStores != null) {\n        let transformedList = fromFileSearchStores;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"fileSearchStores\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction uploadToFileSearchStoreConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (parentObject !== undefined && fromMimeType != null) {\n        setValueByPath(parentObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromCustomMetadata = getValueByPath(fromObject, [\n        \"customMetadata\"\n    ]);\n    if (parentObject !== undefined && fromCustomMetadata != null) {\n        let transformedList = fromCustomMetadata;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(parentObject, [\n            \"customMetadata\"\n        ], transformedList);\n    }\n    const fromChunkingConfig = getValueByPath(fromObject, [\n        \"chunkingConfig\"\n    ]);\n    if (parentObject !== undefined && fromChunkingConfig != null) {\n        setValueByPath(parentObject, [\n            \"chunkingConfig\"\n        ], fromChunkingConfig);\n    }\n    return toObject;\n}\nfunction uploadToFileSearchStoreParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromFileSearchStoreName = getValueByPath(fromObject, [\n        \"fileSearchStoreName\"\n    ]);\n    if (fromFileSearchStoreName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"file_search_store_name\"\n        ], fromFileSearchStoreName);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        uploadToFileSearchStoreConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction uploadToFileSearchStoreResumableResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ const CONTENT_TYPE_HEADER = \"Content-Type\";\nconst SERVER_TIMEOUT_HEADER = \"X-Server-Timeout\";\nconst USER_AGENT_HEADER = \"User-Agent\";\nconst GOOGLE_API_CLIENT_HEADER = \"x-goog-api-client\";\nconst SDK_VERSION = \"1.31.0\"; // x-release-please-version\nconst LIBRARY_LABEL = `google-genai-sdk/${SDK_VERSION}`;\nconst VERTEX_AI_API_DEFAULT_VERSION = \"v1beta1\";\nconst GOOGLE_AI_API_DEFAULT_VERSION = \"v1beta\";\nconst responseLineRE = /^\\s*data: (.*)(?:\\n\\n|\\r\\r|\\r\\n\\r\\n)/;\n/**\n * The ApiClient class is used to send requests to the Gemini API or Vertex AI\n * endpoints.\n */ class ApiClient {\n    constructor(opts){\n        var _a, _b;\n        this.clientOptions = Object.assign(Object.assign({}, opts), {\n            project: opts.project,\n            location: opts.location,\n            apiKey: opts.apiKey,\n            vertexai: opts.vertexai\n        });\n        const initHttpOptions = {};\n        if (this.clientOptions.vertexai) {\n            initHttpOptions.apiVersion = (_a = this.clientOptions.apiVersion) !== null && _a !== void 0 ? _a : VERTEX_AI_API_DEFAULT_VERSION;\n            initHttpOptions.baseUrl = this.baseUrlFromProjectLocation();\n            this.normalizeAuthParameters();\n        } else {\n            // Gemini API\n            initHttpOptions.apiVersion = (_b = this.clientOptions.apiVersion) !== null && _b !== void 0 ? _b : GOOGLE_AI_API_DEFAULT_VERSION;\n            initHttpOptions.baseUrl = `https://generativelanguage.googleapis.com/`;\n        }\n        initHttpOptions.headers = this.getDefaultHeaders();\n        this.clientOptions.httpOptions = initHttpOptions;\n        if (opts.httpOptions) {\n            this.clientOptions.httpOptions = this.patchHttpOptions(initHttpOptions, opts.httpOptions);\n        }\n    }\n    /**\n     * Determines the base URL for Vertex AI based on project and location.\n     * Uses the global endpoint if location is 'global' or if project/location\n     * are not specified (implying API key usage).\n     * @private\n     */ baseUrlFromProjectLocation() {\n        if (this.clientOptions.project && this.clientOptions.location && this.clientOptions.location !== \"global\") {\n            // Regional endpoint\n            return `https://${this.clientOptions.location}-aiplatform.googleapis.com/`;\n        }\n        // Global endpoint (covers 'global' location and API key usage)\n        return `https://aiplatform.googleapis.com/`;\n    }\n    /**\n     * Normalizes authentication parameters for Vertex AI.\n     * If project and location are provided, API key is cleared.\n     * If project and location are not provided (implying API key usage),\n     * project and location are cleared.\n     * @private\n     */ normalizeAuthParameters() {\n        if (this.clientOptions.project && this.clientOptions.location) {\n            // Using project/location for auth, clear potential API key\n            this.clientOptions.apiKey = undefined;\n            return;\n        }\n        // Using API key for auth (or no auth provided yet), clear project/location\n        this.clientOptions.project = undefined;\n        this.clientOptions.location = undefined;\n    }\n    isVertexAI() {\n        var _a;\n        return (_a = this.clientOptions.vertexai) !== null && _a !== void 0 ? _a : false;\n    }\n    getProject() {\n        return this.clientOptions.project;\n    }\n    getLocation() {\n        return this.clientOptions.location;\n    }\n    getApiVersion() {\n        if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.apiVersion !== undefined) {\n            return this.clientOptions.httpOptions.apiVersion;\n        }\n        throw new Error(\"API version is not set.\");\n    }\n    getBaseUrl() {\n        if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.baseUrl !== undefined) {\n            return this.clientOptions.httpOptions.baseUrl;\n        }\n        throw new Error(\"Base URL is not set.\");\n    }\n    getRequestUrl() {\n        return this.getRequestUrlInternal(this.clientOptions.httpOptions);\n    }\n    getHeaders() {\n        if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.headers !== undefined) {\n            return this.clientOptions.httpOptions.headers;\n        } else {\n            throw new Error(\"Headers are not set.\");\n        }\n    }\n    getRequestUrlInternal(httpOptions) {\n        if (!httpOptions || httpOptions.baseUrl === undefined || httpOptions.apiVersion === undefined) {\n            throw new Error(\"HTTP options are not correctly set.\");\n        }\n        const baseUrl = httpOptions.baseUrl.endsWith(\"/\") ? httpOptions.baseUrl.slice(0, -1) : httpOptions.baseUrl;\n        const urlElement = [\n            baseUrl\n        ];\n        if (httpOptions.apiVersion && httpOptions.apiVersion !== \"\") {\n            urlElement.push(httpOptions.apiVersion);\n        }\n        return urlElement.join(\"/\");\n    }\n    getBaseResourcePath() {\n        return `projects/${this.clientOptions.project}/locations/${this.clientOptions.location}`;\n    }\n    getApiKey() {\n        return this.clientOptions.apiKey;\n    }\n    getWebsocketBaseUrl() {\n        const baseUrl = this.getBaseUrl();\n        const urlParts = new URL(baseUrl);\n        urlParts.protocol = urlParts.protocol == \"http:\" ? \"ws\" : \"wss\";\n        return urlParts.toString();\n    }\n    setBaseUrl(url) {\n        if (this.clientOptions.httpOptions) {\n            this.clientOptions.httpOptions.baseUrl = url;\n        } else {\n            throw new Error(\"HTTP options are not correctly set.\");\n        }\n    }\n    constructUrl(path, httpOptions, prependProjectLocation) {\n        const urlElement = [\n            this.getRequestUrlInternal(httpOptions)\n        ];\n        if (prependProjectLocation) {\n            urlElement.push(this.getBaseResourcePath());\n        }\n        if (path !== \"\") {\n            urlElement.push(path);\n        }\n        const url = new URL(`${urlElement.join(\"/\")}`);\n        return url;\n    }\n    shouldPrependVertexProjectPath(request) {\n        if (this.clientOptions.apiKey) {\n            return false;\n        }\n        if (!this.clientOptions.vertexai) {\n            return false;\n        }\n        if (request.path.startsWith(\"projects/\")) {\n            // Assume the path already starts with\n            // `projects/<project>/location/<location>`.\n            return false;\n        }\n        if (request.httpMethod === \"GET\" && request.path.startsWith(\"publishers/google/models\")) {\n            // These paths are used by Vertex's models.get and models.list\n            // calls. For base models Vertex does not accept a project/location\n            // prefix (for tuned model the prefix is required).\n            return false;\n        }\n        return true;\n    }\n    async request(request) {\n        let patchedHttpOptions = this.clientOptions.httpOptions;\n        if (request.httpOptions) {\n            patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);\n        }\n        const prependProjectLocation = this.shouldPrependVertexProjectPath(request);\n        const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);\n        if (request.queryParams) {\n            for (const [key, value] of Object.entries(request.queryParams)){\n                url.searchParams.append(key, String(value));\n            }\n        }\n        let requestInit = {};\n        if (request.httpMethod === \"GET\") {\n            if (request.body && request.body !== \"{}\") {\n                throw new Error(\"Request body should be empty for GET request, but got non empty request body\");\n            }\n        } else {\n            requestInit.body = request.body;\n        }\n        requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, url.toString(), request.abortSignal);\n        return this.unaryApiCall(url, requestInit, request.httpMethod);\n    }\n    patchHttpOptions(baseHttpOptions, requestHttpOptions) {\n        const patchedHttpOptions = JSON.parse(JSON.stringify(baseHttpOptions));\n        for (const [key, value] of Object.entries(requestHttpOptions)){\n            // Records compile to objects.\n            if (typeof value === \"object\") {\n                // @ts-expect-error TS2345TS7053: Element implicitly has an 'any' type\n                // because expression of type 'string' can't be used to index type\n                // 'HttpOptions'.\n                patchedHttpOptions[key] = Object.assign(Object.assign({}, patchedHttpOptions[key]), value);\n            } else if (value !== undefined) {\n                // @ts-expect-error TS2345TS7053: Element implicitly has an 'any' type\n                // because expression of type 'string' can't be used to index type\n                // 'HttpOptions'.\n                patchedHttpOptions[key] = value;\n            }\n        }\n        return patchedHttpOptions;\n    }\n    async requestStream(request) {\n        let patchedHttpOptions = this.clientOptions.httpOptions;\n        if (request.httpOptions) {\n            patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);\n        }\n        const prependProjectLocation = this.shouldPrependVertexProjectPath(request);\n        const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);\n        if (!url.searchParams.has(\"alt\") || url.searchParams.get(\"alt\") !== \"sse\") {\n            url.searchParams.set(\"alt\", \"sse\");\n        }\n        let requestInit = {};\n        requestInit.body = request.body;\n        requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, url.toString(), request.abortSignal);\n        return this.streamApiCall(url, requestInit, request.httpMethod);\n    }\n    async includeExtraHttpOptionsToRequestInit(requestInit, httpOptions, url, abortSignal) {\n        if (httpOptions && httpOptions.timeout || abortSignal) {\n            const abortController = new AbortController();\n            const signal = abortController.signal;\n            if (httpOptions.timeout && (httpOptions === null || httpOptions === void 0 ? void 0 : httpOptions.timeout) > 0) {\n                const timeoutHandle = setTimeout(()=>abortController.abort(), httpOptions.timeout);\n                if (timeoutHandle && typeof timeoutHandle.unref === \"function\") {\n                    // call unref to prevent nodejs process from hanging, see\n                    // https://nodejs.org/api/timers.html#timeoutunref\n                    timeoutHandle.unref();\n                }\n            }\n            if (abortSignal) {\n                abortSignal.addEventListener(\"abort\", ()=>{\n                    abortController.abort();\n                });\n            }\n            requestInit.signal = signal;\n        }\n        if (httpOptions && httpOptions.extraBody !== null) {\n            includeExtraBodyToRequestInit(requestInit, httpOptions.extraBody);\n        }\n        requestInit.headers = await this.getHeadersInternal(httpOptions, url);\n        return requestInit;\n    }\n    async unaryApiCall(url, requestInit, httpMethod) {\n        return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), {\n            method: httpMethod\n        })).then(async (response)=>{\n            await throwErrorIfNotOK(response);\n            return new HttpResponse(response);\n        }).catch((e)=>{\n            if (e instanceof Error) {\n                throw e;\n            } else {\n                throw new Error(JSON.stringify(e));\n            }\n        });\n    }\n    async streamApiCall(url, requestInit, httpMethod) {\n        return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), {\n            method: httpMethod\n        })).then(async (response)=>{\n            await throwErrorIfNotOK(response);\n            return this.processStreamResponse(response);\n        }).catch((e)=>{\n            if (e instanceof Error) {\n                throw e;\n            } else {\n                throw new Error(JSON.stringify(e));\n            }\n        });\n    }\n    processStreamResponse(response) {\n        var _a;\n        return __asyncGenerator(this, arguments, function* processStreamResponse_1() {\n            const reader = (_a = response === null || response === void 0 ? void 0 : response.body) === null || _a === void 0 ? void 0 : _a.getReader();\n            const decoder = new TextDecoder(\"utf-8\");\n            if (!reader) {\n                throw new Error(\"Response body is empty\");\n            }\n            try {\n                let buffer = \"\";\n                while(true){\n                    const { done, value } = yield __await(reader.read());\n                    if (done) {\n                        if (buffer.trim().length > 0) {\n                            throw new Error(\"Incomplete JSON segment at the end\");\n                        }\n                        break;\n                    }\n                    const chunkString = decoder.decode(value, {\n                        stream: true\n                    });\n                    // Parse and throw an error if the chunk contains an error.\n                    try {\n                        const chunkJson = JSON.parse(chunkString);\n                        if (\"error\" in chunkJson) {\n                            const errorJson = JSON.parse(JSON.stringify(chunkJson[\"error\"]));\n                            const status = errorJson[\"status\"];\n                            const code = errorJson[\"code\"];\n                            const errorMessage = `got status: ${status}. ${JSON.stringify(chunkJson)}`;\n                            if (code >= 400 && code < 600) {\n                                const apiError = new ApiError({\n                                    message: errorMessage,\n                                    status: code\n                                });\n                                throw apiError;\n                            }\n                        }\n                    } catch (e) {\n                        const error = e;\n                        if (error.name === \"ApiError\") {\n                            throw e;\n                        }\n                    }\n                    buffer += chunkString;\n                    let match = buffer.match(responseLineRE);\n                    while(match){\n                        const processedChunkString = match[1];\n                        try {\n                            const partialResponse = new Response(processedChunkString, {\n                                headers: response === null || response === void 0 ? void 0 : response.headers,\n                                status: response === null || response === void 0 ? void 0 : response.status,\n                                statusText: response === null || response === void 0 ? void 0 : response.statusText\n                            });\n                            yield yield __await(new HttpResponse(partialResponse));\n                            buffer = buffer.slice(match[0].length);\n                            match = buffer.match(responseLineRE);\n                        } catch (e) {\n                            throw new Error(`exception parsing stream chunk ${processedChunkString}. ${e}`);\n                        }\n                    }\n                }\n            } finally{\n                reader.releaseLock();\n            }\n        });\n    }\n    async apiCall(url, requestInit) {\n        return fetch(url, requestInit).catch((e)=>{\n            throw new Error(`exception ${e} sending request`);\n        });\n    }\n    getDefaultHeaders() {\n        const headers = {};\n        const versionHeaderValue = LIBRARY_LABEL + \" \" + this.clientOptions.userAgentExtra;\n        headers[USER_AGENT_HEADER] = versionHeaderValue;\n        headers[GOOGLE_API_CLIENT_HEADER] = versionHeaderValue;\n        headers[CONTENT_TYPE_HEADER] = \"application/json\";\n        return headers;\n    }\n    async getHeadersInternal(httpOptions, url) {\n        const headers = new Headers();\n        if (httpOptions && httpOptions.headers) {\n            for (const [key, value] of Object.entries(httpOptions.headers)){\n                headers.append(key, value);\n            }\n            // Append a timeout header if it is set, note that the timeout option is\n            // in milliseconds but the header is in seconds.\n            if (httpOptions.timeout && httpOptions.timeout > 0) {\n                headers.append(SERVER_TIMEOUT_HEADER, String(Math.ceil(httpOptions.timeout / 1000)));\n            }\n        }\n        await this.clientOptions.auth.addAuthHeaders(headers, url);\n        return headers;\n    }\n    getFileName(file) {\n        var _a;\n        let fileName = \"\";\n        if (typeof file === \"string\") {\n            fileName = file.replace(/[/\\\\]+$/, \"\");\n            fileName = (_a = fileName.split(/[/\\\\]/).pop()) !== null && _a !== void 0 ? _a : \"\";\n        }\n        return fileName;\n    }\n    /**\n     * Uploads a file asynchronously using Gemini API only, this is not supported\n     * in Vertex AI.\n     *\n     * @param file The string path to the file to be uploaded or a Blob object.\n     * @param config Optional parameters specified in the `UploadFileConfig`\n     *     interface. @see {@link types.UploadFileConfig}\n     * @return A promise that resolves to a `File` object.\n     * @throws An error if called on a Vertex AI client.\n     * @throws An error if the `mimeType` is not provided and can not be inferred,\n     */ async uploadFile(file, config) {\n        var _a;\n        const fileToUpload = {};\n        if (config != null) {\n            fileToUpload.mimeType = config.mimeType;\n            fileToUpload.name = config.name;\n            fileToUpload.displayName = config.displayName;\n        }\n        if (fileToUpload.name && !fileToUpload.name.startsWith(\"files/\")) {\n            fileToUpload.name = `files/${fileToUpload.name}`;\n        }\n        const uploader = this.clientOptions.uploader;\n        const fileStat = await uploader.stat(file);\n        fileToUpload.sizeBytes = String(fileStat.size);\n        const mimeType = (_a = config === null || config === void 0 ? void 0 : config.mimeType) !== null && _a !== void 0 ? _a : fileStat.type;\n        if (mimeType === undefined || mimeType === \"\") {\n            throw new Error(\"Can not determine mimeType. Please provide mimeType in the config.\");\n        }\n        fileToUpload.mimeType = mimeType;\n        const body = {\n            file: fileToUpload\n        };\n        const fileName = this.getFileName(file);\n        const path = formatMap(\"upload/v1beta/files\", body[\"_url\"]);\n        const uploadUrl = await this.fetchUploadUrl(path, fileToUpload.sizeBytes, fileToUpload.mimeType, fileName, body, config === null || config === void 0 ? void 0 : config.httpOptions);\n        return uploader.upload(file, uploadUrl, this);\n    }\n    /**\n     * Uploads a file to a given file search store asynchronously using Gemini API only, this is not supported\n     * in Vertex AI.\n     *\n     * @param fileSearchStoreName The name of the file search store to upload the file to.\n     * @param file The string path to the file to be uploaded or a Blob object.\n     * @param config Optional parameters specified in the `UploadFileConfig`\n     *     interface. @see {@link UploadFileConfig}\n     * @return A promise that resolves to a `File` object.\n     * @throws An error if called on a Vertex AI client.\n     * @throws An error if the `mimeType` is not provided and can not be inferred,\n     */ async uploadFileToFileSearchStore(fileSearchStoreName, file, config) {\n        var _a;\n        const uploader = this.clientOptions.uploader;\n        const fileStat = await uploader.stat(file);\n        const sizeBytes = String(fileStat.size);\n        const mimeType = (_a = config === null || config === void 0 ? void 0 : config.mimeType) !== null && _a !== void 0 ? _a : fileStat.type;\n        if (mimeType === undefined || mimeType === \"\") {\n            throw new Error(\"Can not determine mimeType. Please provide mimeType in the config.\");\n        }\n        const path = `upload/v1beta/${fileSearchStoreName}:uploadToFileSearchStore`;\n        const fileName = this.getFileName(file);\n        const body = {};\n        if (config != null) {\n            uploadToFileSearchStoreConfigToMldev(config, body);\n        }\n        const uploadUrl = await this.fetchUploadUrl(path, sizeBytes, mimeType, fileName, body, config === null || config === void 0 ? void 0 : config.httpOptions);\n        return uploader.uploadToFileSearchStore(file, uploadUrl, this);\n    }\n    /**\n     * Downloads a file asynchronously to the specified path.\n     *\n     * @params params - The parameters for the download request, see {@link\n     * types.DownloadFileParameters}\n     */ async downloadFile(params) {\n        const downloader = this.clientOptions.downloader;\n        await downloader.download(params, this);\n    }\n    async fetchUploadUrl(path, sizeBytes, mimeType, fileName, body, configHttpOptions) {\n        var _a;\n        let httpOptions = {};\n        if (configHttpOptions) {\n            httpOptions = configHttpOptions;\n        } else {\n            httpOptions = {\n                apiVersion: \"\",\n                headers: Object.assign({\n                    \"Content-Type\": \"application/json\",\n                    \"X-Goog-Upload-Protocol\": \"resumable\",\n                    \"X-Goog-Upload-Command\": \"start\",\n                    \"X-Goog-Upload-Header-Content-Length\": `${sizeBytes}`,\n                    \"X-Goog-Upload-Header-Content-Type\": `${mimeType}`\n                }, fileName ? {\n                    \"X-Goog-Upload-File-Name\": fileName\n                } : {})\n            };\n        }\n        const httpResponse = await this.request({\n            path,\n            body: JSON.stringify(body),\n            httpMethod: \"POST\",\n            httpOptions\n        });\n        if (!httpResponse || !(httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers)) {\n            throw new Error(\"Server did not return an HttpResponse or the returned HttpResponse did not have headers.\");\n        }\n        const uploadUrl = (_a = httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers) === null || _a === void 0 ? void 0 : _a[\"x-goog-upload-url\"];\n        if (uploadUrl === undefined) {\n            throw new Error(\"Failed to get upload url. Server did not return the x-google-upload-url in the headers\");\n        }\n        return uploadUrl;\n    }\n}\nasync function throwErrorIfNotOK(response) {\n    var _a;\n    if (response === undefined) {\n        throw new Error(\"response is undefined\");\n    }\n    if (!response.ok) {\n        const status = response.status;\n        let errorBody;\n        if ((_a = response.headers.get(\"content-type\")) === null || _a === void 0 ? void 0 : _a.includes(\"application/json\")) {\n            errorBody = await response.json();\n        } else {\n            errorBody = {\n                error: {\n                    message: await response.text(),\n                    code: response.status,\n                    status: response.statusText\n                }\n            };\n        }\n        const errorMessage = JSON.stringify(errorBody);\n        if (status >= 400 && status < 600) {\n            const apiError = new ApiError({\n                message: errorMessage,\n                status: status\n            });\n            throw apiError;\n        }\n        throw new Error(errorMessage);\n    }\n}\n/**\n * Recursively updates the `requestInit.body` with values from an `extraBody` object.\n *\n * If `requestInit.body` is a string, it's assumed to be JSON and will be parsed.\n * The `extraBody` is then deeply merged into this parsed object.\n * If `requestInit.body` is a Blob, `extraBody` will be ignored, and a warning logged,\n * as merging structured data into an opaque Blob is not supported.\n *\n * The function does not enforce that updated values from `extraBody` have the\n * same type as existing values in `requestInit.body`. Type mismatches during\n * the merge will result in a warning, but the value from `extraBody` will overwrite\n * the original. `extraBody` users are responsible for ensuring `extraBody` has the correct structure.\n *\n * @param requestInit The RequestInit object whose body will be updated.\n * @param extraBody The object containing updates to be merged into `requestInit.body`.\n */ function includeExtraBodyToRequestInit(requestInit, extraBody) {\n    if (!extraBody || Object.keys(extraBody).length === 0) {\n        return;\n    }\n    if (requestInit.body instanceof Blob) {\n        console.warn(\"includeExtraBodyToRequestInit: extraBody provided but current request body is a Blob. extraBody will be ignored as merging is not supported for Blob bodies.\");\n        return;\n    }\n    let currentBodyObject = {};\n    // If adding new type to HttpRequest.body, please check the code below to\n    // see if we need to update the logic.\n    if (typeof requestInit.body === \"string\" && requestInit.body.length > 0) {\n        try {\n            const parsedBody = JSON.parse(requestInit.body);\n            if (typeof parsedBody === \"object\" && parsedBody !== null && !Array.isArray(parsedBody)) {\n                currentBodyObject = parsedBody;\n            } else {\n                console.warn(\"includeExtraBodyToRequestInit: Original request body is valid JSON but not a non-array object. Skip applying extraBody to the request body.\");\n                return;\n            }\n        /*  eslint-disable-next-line @typescript-eslint/no-unused-vars */ } catch (e) {\n            console.warn(\"includeExtraBodyToRequestInit: Original request body is not valid JSON. Skip applying extraBody to the request body.\");\n            return;\n        }\n    }\n    function deepMerge(target, source) {\n        const output = Object.assign({}, target);\n        for(const key in source){\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n                const sourceValue = source[key];\n                const targetValue = output[key];\n                if (sourceValue && typeof sourceValue === \"object\" && !Array.isArray(sourceValue) && targetValue && typeof targetValue === \"object\" && !Array.isArray(targetValue)) {\n                    output[key] = deepMerge(targetValue, sourceValue);\n                } else {\n                    if (targetValue && sourceValue && typeof targetValue !== typeof sourceValue) {\n                        console.warn(`includeExtraBodyToRequestInit:deepMerge: Type mismatch for key \"${key}\". Original type: ${typeof targetValue}, New type: ${typeof sourceValue}. Overwriting.`);\n                    }\n                    output[key] = sourceValue;\n                }\n            }\n        }\n        return output;\n    }\n    const mergedBody = deepMerge(currentBodyObject, extraBody);\n    requestInit.body = JSON.stringify(mergedBody);\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ // TODO: b/416041229 - Determine how to retrieve the MCP package version.\nconst MCP_LABEL = \"mcp_used/unknown\";\n// Whether MCP tool usage is detected from mcpToTool. This is used for\n// telemetry.\nlet hasMcpToolUsageFromMcpToTool = false;\n// Checks whether the list of tools contains any MCP tools.\nfunction hasMcpToolUsage(tools) {\n    for (const tool of tools){\n        if (isMcpCallableTool(tool)) {\n            return true;\n        }\n        if (typeof tool === \"object\" && \"inputSchema\" in tool) {\n            return true;\n        }\n    }\n    return hasMcpToolUsageFromMcpToTool;\n}\n// Sets the MCP version label in the Google API client header.\nfunction setMcpUsageHeader(headers) {\n    var _a;\n    const existingHeader = (_a = headers[GOOGLE_API_CLIENT_HEADER]) !== null && _a !== void 0 ? _a : \"\";\n    headers[GOOGLE_API_CLIENT_HEADER] = (existingHeader + ` ${MCP_LABEL}`).trimStart();\n}\n// Returns true if the object is a MCP CallableTool, otherwise false.\nfunction isMcpCallableTool(object) {\n    return object !== null && typeof object === \"object\" && object instanceof McpCallableTool;\n}\n// List all tools from the MCP client.\nfunction listAllTools(mcpClient, maxTools = 100) {\n    return __asyncGenerator(this, arguments, function* listAllTools_1() {\n        let cursor = undefined;\n        let numTools = 0;\n        while(numTools < maxTools){\n            const t = yield __await(mcpClient.listTools({\n                cursor\n            }));\n            for (const tool of t.tools){\n                yield yield __await(tool);\n                numTools++;\n            }\n            if (!t.nextCursor) {\n                break;\n            }\n            cursor = t.nextCursor;\n        }\n    });\n}\n/**\n * McpCallableTool can be used for model inference and invoking MCP clients with\n * given function call arguments.\n *\n * @experimental Built-in MCP support is an experimental feature, may change in future\n * versions.\n */ class McpCallableTool {\n    constructor(mcpClients = [], config){\n        this.mcpTools = [];\n        this.functionNameToMcpClient = {};\n        this.mcpClients = mcpClients;\n        this.config = config;\n    }\n    /**\n     * Creates a McpCallableTool.\n     */ static create(mcpClients, config) {\n        return new McpCallableTool(mcpClients, config);\n    }\n    /**\n     * Validates the function names are not duplicate and initialize the function\n     * name to MCP client mapping.\n     *\n     * @throws {Error} if the MCP tools from the MCP clients have duplicate tool\n     *     names.\n     */ async initialize() {\n        var _a, e_1, _b, _c;\n        if (this.mcpTools.length > 0) {\n            return;\n        }\n        const functionMap = {};\n        const mcpTools = [];\n        for (const mcpClient of this.mcpClients){\n            try {\n                for(var _d = true, _e = (e_1 = void 0, __asyncValues(listAllTools(mcpClient))), _f; _f = await _e.next(), _a = _f.done, !_a; _d = true){\n                    _c = _f.value;\n                    _d = false;\n                    const mcpTool = _c;\n                    mcpTools.push(mcpTool);\n                    const mcpToolName = mcpTool.name;\n                    if (functionMap[mcpToolName]) {\n                        throw new Error(`Duplicate function name ${mcpToolName} found in MCP tools. Please ensure function names are unique.`);\n                    }\n                    functionMap[mcpToolName] = mcpClient;\n                }\n            } catch (e_1_1) {\n                e_1 = {\n                    error: e_1_1\n                };\n            } finally{\n                try {\n                    if (!_d && !_a && (_b = _e.return)) await _b.call(_e);\n                } finally{\n                    if (e_1) throw e_1.error;\n                }\n            }\n        }\n        this.mcpTools = mcpTools;\n        this.functionNameToMcpClient = functionMap;\n    }\n    async tool() {\n        await this.initialize();\n        return mcpToolsToGeminiTool(this.mcpTools, this.config);\n    }\n    async callTool(functionCalls) {\n        await this.initialize();\n        const functionCallResponseParts = [];\n        for (const functionCall of functionCalls){\n            if (functionCall.name in this.functionNameToMcpClient) {\n                const mcpClient = this.functionNameToMcpClient[functionCall.name];\n                let requestOptions = undefined;\n                // TODO: b/424238654 - Add support for finer grained timeout control.\n                if (this.config.timeout) {\n                    requestOptions = {\n                        timeout: this.config.timeout\n                    };\n                }\n                const callToolResponse = await mcpClient.callTool({\n                    name: functionCall.name,\n                    arguments: functionCall.args\n                }, // Set the result schema to undefined to allow MCP to rely on the\n                // default schema.\n                undefined, requestOptions);\n                functionCallResponseParts.push({\n                    functionResponse: {\n                        name: functionCall.name,\n                        response: callToolResponse.isError ? {\n                            error: callToolResponse\n                        } : callToolResponse\n                    }\n                });\n            }\n        }\n        return functionCallResponseParts;\n    }\n}\nfunction isMcpClient(client) {\n    return client !== null && typeof client === \"object\" && \"listTools\" in client && typeof client.listTools === \"function\";\n}\n/**\n * Creates a McpCallableTool from MCP clients and an optional config.\n *\n * The callable tool can invoke the MCP clients with given function call\n * arguments. (often for automatic function calling).\n * Use the config to modify tool parameters such as behavior.\n *\n * @experimental Built-in MCP support is an experimental feature, may change in future\n * versions.\n */ function mcpToTool(...args) {\n    // Set MCP usage for telemetry.\n    hasMcpToolUsageFromMcpToTool = true;\n    if (args.length === 0) {\n        throw new Error(\"No MCP clients provided\");\n    }\n    const maybeConfig = args[args.length - 1];\n    if (isMcpClient(maybeConfig)) {\n        return McpCallableTool.create(args, {});\n    }\n    return McpCallableTool.create(args.slice(0, args.length - 1), maybeConfig);\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ /**\n * Handles incoming messages from the WebSocket.\n *\n * @remarks\n * This function is responsible for parsing incoming messages, transforming them\n * into LiveMusicServerMessage, and then calling the onmessage callback.\n * Note that the first message which is received from the server is a\n * setupComplete message.\n *\n * @param apiClient The ApiClient instance.\n * @param onmessage The user-provided onmessage callback (if any).\n * @param event The MessageEvent from the WebSocket.\n */ async function handleWebSocketMessage$1(apiClient, onmessage, event) {\n    const serverMessage = new LiveMusicServerMessage();\n    let data;\n    if (event.data instanceof Blob) {\n        data = JSON.parse(await event.data.text());\n    } else {\n        data = JSON.parse(event.data);\n    }\n    Object.assign(serverMessage, data);\n    onmessage(serverMessage);\n}\n/**\n   LiveMusic class encapsulates the configuration for live music\n   generation via Lyria Live models.\n\n   @experimental\n  */ class LiveMusic {\n    constructor(apiClient, auth, webSocketFactory){\n        this.apiClient = apiClient;\n        this.auth = auth;\n        this.webSocketFactory = webSocketFactory;\n    }\n    /**\n       Establishes a connection to the specified model and returns a\n       LiveMusicSession object representing that connection.\n  \n       @experimental\n  \n       @remarks\n  \n       @param params - The parameters for establishing a connection to the model.\n       @return A live session.\n  \n       @example\n       ```ts\n       let model = 'models/lyria-realtime-exp';\n       const session = await ai.live.music.connect({\n         model: model,\n         callbacks: {\n           onmessage: (e: MessageEvent) => {\n             console.log('Received message from the server: %s\\n', debug(e.data));\n           },\n           onerror: (e: ErrorEvent) => {\n             console.log('Error occurred: %s\\n', debug(e.error));\n           },\n           onclose: (e: CloseEvent) => {\n             console.log('Connection closed.');\n           },\n         },\n       });\n       ```\n      */ async connect(params) {\n        var _a, _b;\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"Live music is not supported for Vertex AI.\");\n        }\n        console.warn(\"Live music generation is experimental and may change in future versions.\");\n        const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();\n        const apiVersion = this.apiClient.getApiVersion();\n        const headers = mapToHeaders$1(this.apiClient.getDefaultHeaders());\n        const apiKey = this.apiClient.getApiKey();\n        const url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.BidiGenerateMusic?key=${apiKey}`;\n        let onopenResolve = ()=>{};\n        const onopenPromise = new Promise((resolve)=>{\n            onopenResolve = resolve;\n        });\n        const callbacks = params.callbacks;\n        const onopenAwaitedCallback = function() {\n            onopenResolve({});\n        };\n        const apiClient = this.apiClient;\n        const websocketCallbacks = {\n            onopen: onopenAwaitedCallback,\n            onmessage: (event)=>{\n                void handleWebSocketMessage$1(apiClient, callbacks.onmessage, event);\n            },\n            onerror: (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a !== void 0 ? _a : function(e) {},\n            onclose: (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b !== void 0 ? _b : function(e) {}\n        };\n        const conn = this.webSocketFactory.create(url, headersToMap$1(headers), websocketCallbacks);\n        conn.connect();\n        // Wait for the websocket to open before sending requests.\n        await onopenPromise;\n        const model = tModel(this.apiClient, params.model);\n        const setup = {\n            model\n        };\n        const clientMessage = {\n            setup\n        };\n        conn.send(JSON.stringify(clientMessage));\n        return new LiveMusicSession(conn, this.apiClient);\n    }\n}\n/**\n   Represents a connection to the API.\n\n   @experimental\n  */ class LiveMusicSession {\n    constructor(conn, apiClient){\n        this.conn = conn;\n        this.apiClient = apiClient;\n    }\n    /**\n      Sets inputs to steer music generation. Updates the session's current\n      weighted prompts.\n  \n      @param params - Contains one property, `weightedPrompts`.\n  \n        - `weightedPrompts` to send to the model; weights are normalized to\n          sum to 1.0.\n  \n      @experimental\n     */ async setWeightedPrompts(params) {\n        if (!params.weightedPrompts || Object.keys(params.weightedPrompts).length === 0) {\n            throw new Error(\"Weighted prompts must be set and contain at least one entry.\");\n        }\n        const clientContent = liveMusicSetWeightedPromptsParametersToMldev(params);\n        this.conn.send(JSON.stringify({\n            clientContent\n        }));\n    }\n    /**\n      Sets a configuration to the model. Updates the session's current\n      music generation config.\n  \n      @param params - Contains one property, `musicGenerationConfig`.\n  \n        - `musicGenerationConfig` to set in the model. Passing an empty or\n      undefined config to the model will reset the config to defaults.\n  \n      @experimental\n     */ async setMusicGenerationConfig(params) {\n        if (!params.musicGenerationConfig) {\n            params.musicGenerationConfig = {};\n        }\n        const setConfigParameters = liveMusicSetConfigParametersToMldev(params);\n        this.conn.send(JSON.stringify(setConfigParameters));\n    }\n    sendPlaybackControl(playbackControl) {\n        const clientMessage = {\n            playbackControl\n        };\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n     * Start the music stream.\n     *\n     * @experimental\n     */ play() {\n        this.sendPlaybackControl(LiveMusicPlaybackControl.PLAY);\n    }\n    /**\n     * Temporarily halt the music stream. Use `play` to resume from the current\n     * position.\n     *\n     * @experimental\n     */ pause() {\n        this.sendPlaybackControl(LiveMusicPlaybackControl.PAUSE);\n    }\n    /**\n     * Stop the music stream and reset the state. Retains the current prompts\n     * and config.\n     *\n     * @experimental\n     */ stop() {\n        this.sendPlaybackControl(LiveMusicPlaybackControl.STOP);\n    }\n    /**\n     * Resets the context of the music generation without stopping it.\n     * Retains the current prompts and config.\n     *\n     * @experimental\n     */ resetContext() {\n        this.sendPlaybackControl(LiveMusicPlaybackControl.RESET_CONTEXT);\n    }\n    /**\n       Terminates the WebSocket connection.\n  \n       @experimental\n     */ close() {\n        this.conn.close();\n    }\n}\n// Converts an headers object to a \"map\" object as expected by the WebSocket\n// constructor. We use this as the Auth interface works with Headers objects\n// while the WebSocket constructor takes a map.\nfunction headersToMap$1(headers) {\n    const headerMap = {};\n    headers.forEach((value, key)=>{\n        headerMap[key] = value;\n    });\n    return headerMap;\n}\n// Converts a \"map\" object to a headers object. We use this as the Auth\n// interface works with Headers objects while the API client default headers\n// returns a map.\nfunction mapToHeaders$1(map) {\n    const headers = new Headers();\n    for (const [key, value] of Object.entries(map)){\n        headers.append(key, value);\n    }\n    return headers;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ const FUNCTION_RESPONSE_REQUIRES_ID = \"FunctionResponse request must have an `id` field from the response of a ToolCall.FunctionalCalls in Google AI.\";\n/**\n * Handles incoming messages from the WebSocket.\n *\n * @remarks\n * This function is responsible for parsing incoming messages, transforming them\n * into LiveServerMessages, and then calling the onmessage callback. Note that\n * the first message which is received from the server is a setupComplete\n * message.\n *\n * @param apiClient The ApiClient instance.\n * @param onmessage The user-provided onmessage callback (if any).\n * @param event The MessageEvent from the WebSocket.\n */ async function handleWebSocketMessage(apiClient, onmessage, event) {\n    const serverMessage = new LiveServerMessage();\n    let jsonData;\n    if (event.data instanceof Blob) {\n        jsonData = await event.data.text();\n    } else if (event.data instanceof ArrayBuffer) {\n        jsonData = new TextDecoder().decode(event.data);\n    } else {\n        jsonData = event.data;\n    }\n    const data = JSON.parse(jsonData);\n    if (apiClient.isVertexAI()) {\n        const resp = liveServerMessageFromVertex(data);\n        Object.assign(serverMessage, resp);\n    } else {\n        const resp = data;\n        Object.assign(serverMessage, resp);\n    }\n    onmessage(serverMessage);\n}\n/**\n   Live class encapsulates the configuration for live interaction with the\n   Generative Language API. It embeds ApiClient for general API settings.\n\n   @experimental\n  */ class Live {\n    constructor(apiClient, auth, webSocketFactory){\n        this.apiClient = apiClient;\n        this.auth = auth;\n        this.webSocketFactory = webSocketFactory;\n        this.music = new LiveMusic(this.apiClient, this.auth, this.webSocketFactory);\n    }\n    /**\n       Establishes a connection to the specified model with the given\n       configuration and returns a Session object representing that connection.\n  \n       @experimental Built-in MCP support is an experimental feature, may change in\n       future versions.\n  \n       @remarks\n  \n       @param params - The parameters for establishing a connection to the model.\n       @return A live session.\n  \n       @example\n       ```ts\n       let model: string;\n       if (GOOGLE_GENAI_USE_VERTEXAI) {\n         model = 'gemini-2.0-flash-live-preview-04-09';\n       } else {\n         model = 'gemini-live-2.5-flash-preview';\n       }\n       const session = await ai.live.connect({\n         model: model,\n         config: {\n           responseModalities: [Modality.AUDIO],\n         },\n         callbacks: {\n           onopen: () => {\n             console.log('Connected to the socket.');\n           },\n           onmessage: (e: MessageEvent) => {\n             console.log('Received message from the server: %s\\n', debug(e.data));\n           },\n           onerror: (e: ErrorEvent) => {\n             console.log('Error occurred: %s\\n', debug(e.error));\n           },\n           onclose: (e: CloseEvent) => {\n             console.log('Connection closed.');\n           },\n         },\n       });\n       ```\n      */ async connect(params) {\n        var _a, _b, _c, _d, _e, _f;\n        // TODO: b/404946746 - Support per request HTTP options.\n        if (params.config && params.config.httpOptions) {\n            throw new Error(\"The Live module does not support httpOptions at request-level in\" + \" LiveConnectConfig yet. Please use the client-level httpOptions\" + \" configuration instead.\");\n        }\n        const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();\n        const apiVersion = this.apiClient.getApiVersion();\n        let url;\n        const clientHeaders = this.apiClient.getHeaders();\n        if (params.config && params.config.tools && hasMcpToolUsage(params.config.tools)) {\n            setMcpUsageHeader(clientHeaders);\n        }\n        const headers = mapToHeaders(clientHeaders);\n        if (this.apiClient.isVertexAI()) {\n            url = `${websocketBaseUrl}/ws/google.cloud.aiplatform.${apiVersion}.LlmBidiService/BidiGenerateContent`;\n            await this.auth.addAuthHeaders(headers, url);\n        } else {\n            const apiKey = this.apiClient.getApiKey();\n            let method = \"BidiGenerateContent\";\n            let keyName = \"key\";\n            if (apiKey === null || apiKey === void 0 ? void 0 : apiKey.startsWith(\"auth_tokens/\")) {\n                console.warn(\"Warning: Ephemeral token support is experimental and may change in future versions.\");\n                if (apiVersion !== \"v1alpha\") {\n                    console.warn(\"Warning: The SDK's ephemeral token support is in v1alpha only. Please use const ai = new GoogleGenAI({apiKey: token.name, httpOptions: { apiVersion: 'v1alpha' }}); before session connection.\");\n                }\n                method = \"BidiGenerateContentConstrained\";\n                keyName = \"access_token\";\n            }\n            url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.${method}?${keyName}=${apiKey}`;\n        }\n        let onopenResolve = ()=>{};\n        const onopenPromise = new Promise((resolve)=>{\n            onopenResolve = resolve;\n        });\n        const callbacks = params.callbacks;\n        const onopenAwaitedCallback = function() {\n            var _a;\n            (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onopen) === null || _a === void 0 ? void 0 : _a.call(callbacks);\n            onopenResolve({});\n        };\n        const apiClient = this.apiClient;\n        const websocketCallbacks = {\n            onopen: onopenAwaitedCallback,\n            onmessage: (event)=>{\n                void handleWebSocketMessage(apiClient, callbacks.onmessage, event);\n            },\n            onerror: (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a !== void 0 ? _a : function(e) {},\n            onclose: (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b !== void 0 ? _b : function(e) {}\n        };\n        const conn = this.webSocketFactory.create(url, headersToMap(headers), websocketCallbacks);\n        conn.connect();\n        // Wait for the websocket to open before sending requests.\n        await onopenPromise;\n        let transformedModel = tModel(this.apiClient, params.model);\n        if (this.apiClient.isVertexAI() && transformedModel.startsWith(\"publishers/\")) {\n            const project = this.apiClient.getProject();\n            const location = this.apiClient.getLocation();\n            transformedModel = `projects/${project}/locations/${location}/` + transformedModel;\n        }\n        let clientMessage = {};\n        if (this.apiClient.isVertexAI() && ((_c = params.config) === null || _c === void 0 ? void 0 : _c.responseModalities) === undefined) {\n            // Set default to AUDIO to align with MLDev API.\n            if (params.config === undefined) {\n                params.config = {\n                    responseModalities: [\n                        Modality.AUDIO\n                    ]\n                };\n            } else {\n                params.config.responseModalities = [\n                    Modality.AUDIO\n                ];\n            }\n        }\n        if ((_d = params.config) === null || _d === void 0 ? void 0 : _d.generationConfig) {\n            // Raise deprecation warning for generationConfig.\n            console.warn(\"Setting `LiveConnectConfig.generation_config` is deprecated, please set the fields on `LiveConnectConfig` directly. This will become an error in a future version (not before Q3 2025).\");\n        }\n        const inputTools = (_f = (_e = params.config) === null || _e === void 0 ? void 0 : _e.tools) !== null && _f !== void 0 ? _f : [];\n        const convertedTools = [];\n        for (const tool of inputTools){\n            if (this.isCallableTool(tool)) {\n                const callableTool = tool;\n                convertedTools.push(await callableTool.tool());\n            } else {\n                convertedTools.push(tool);\n            }\n        }\n        if (convertedTools.length > 0) {\n            params.config.tools = convertedTools;\n        }\n        const liveConnectParameters = {\n            model: transformedModel,\n            config: params.config,\n            callbacks: params.callbacks\n        };\n        if (this.apiClient.isVertexAI()) {\n            clientMessage = liveConnectParametersToVertex(this.apiClient, liveConnectParameters);\n        } else {\n            clientMessage = liveConnectParametersToMldev(this.apiClient, liveConnectParameters);\n        }\n        delete clientMessage[\"config\"];\n        conn.send(JSON.stringify(clientMessage));\n        return new Session(conn, this.apiClient);\n    }\n    // TODO: b/416041229 - Abstract this method to a common place.\n    isCallableTool(tool) {\n        return \"callTool\" in tool && typeof tool.callTool === \"function\";\n    }\n}\nconst defaultLiveSendClientContentParamerters = {\n    turnComplete: true\n};\n/**\n   Represents a connection to the API.\n\n   @experimental\n  */ class Session {\n    constructor(conn, apiClient){\n        this.conn = conn;\n        this.apiClient = apiClient;\n    }\n    tLiveClientContent(apiClient, params) {\n        if (params.turns !== null && params.turns !== undefined) {\n            let contents = [];\n            try {\n                contents = tContents(params.turns);\n                if (!apiClient.isVertexAI()) {\n                    contents = contents.map((item)=>contentToMldev$1(item));\n                }\n            } catch (_a) {\n                throw new Error(`Failed to parse client content \"turns\", type: '${typeof params.turns}'`);\n            }\n            return {\n                clientContent: {\n                    turns: contents,\n                    turnComplete: params.turnComplete\n                }\n            };\n        }\n        return {\n            clientContent: {\n                turnComplete: params.turnComplete\n            }\n        };\n    }\n    tLiveClienttToolResponse(apiClient, params) {\n        let functionResponses = [];\n        if (params.functionResponses == null) {\n            throw new Error(\"functionResponses is required.\");\n        }\n        if (!Array.isArray(params.functionResponses)) {\n            functionResponses = [\n                params.functionResponses\n            ];\n        } else {\n            functionResponses = params.functionResponses;\n        }\n        if (functionResponses.length === 0) {\n            throw new Error(\"functionResponses is required.\");\n        }\n        for (const functionResponse of functionResponses){\n            if (typeof functionResponse !== \"object\" || functionResponse === null || !(\"name\" in functionResponse) || !(\"response\" in functionResponse)) {\n                throw new Error(`Could not parse function response, type '${typeof functionResponse}'.`);\n            }\n            if (!apiClient.isVertexAI() && !(\"id\" in functionResponse)) {\n                throw new Error(FUNCTION_RESPONSE_REQUIRES_ID);\n            }\n        }\n        const clientMessage = {\n            toolResponse: {\n                functionResponses: functionResponses\n            }\n        };\n        return clientMessage;\n    }\n    /**\n      Send a message over the established connection.\n  \n      @param params - Contains two **optional** properties, `turns` and\n          `turnComplete`.\n  \n        - `turns` will be converted to a `Content[]`\n        - `turnComplete: true` [default] indicates that you are done sending\n          content and expect a response. If `turnComplete: false`, the server\n          will wait for additional messages before starting generation.\n  \n      @experimental\n  \n      @remarks\n      There are two ways to send messages to the live API:\n      `sendClientContent` and `sendRealtimeInput`.\n  \n      `sendClientContent` messages are added to the model context **in order**.\n      Having a conversation using `sendClientContent` messages is roughly\n      equivalent to using the `Chat.sendMessageStream`, except that the state of\n      the `chat` history is stored on the API server instead of locally.\n  \n      Because of `sendClientContent`'s order guarantee, the model cannot respons\n      as quickly to `sendClientContent` messages as to `sendRealtimeInput`\n      messages. This makes the biggest difference when sending objects that have\n      significant preprocessing time (typically images).\n  \n      The `sendClientContent` message sends a `Content[]`\n      which has more options than the `Blob` sent by `sendRealtimeInput`.\n  \n      So the main use-cases for `sendClientContent` over `sendRealtimeInput` are:\n  \n      - Sending anything that can't be represented as a `Blob` (text,\n      `sendClientContent({turns=\"Hello?\"}`)).\n      - Managing turns when not using audio input and voice activity detection.\n        (`sendClientContent({turnComplete:true})` or the short form\n      `sendClientContent()`)\n      - Prefilling a conversation context\n        ```\n        sendClientContent({\n            turns: [\n              Content({role:user, parts:...}),\n              Content({role:user, parts:...}),\n              ...\n            ]\n        })\n        ```\n      @experimental\n     */ sendClientContent(params) {\n        params = Object.assign(Object.assign({}, defaultLiveSendClientContentParamerters), params);\n        const clientMessage = this.tLiveClientContent(this.apiClient, params);\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n      Send a realtime message over the established connection.\n  \n      @param params - Contains one property, `media`.\n  \n        - `media` will be converted to a `Blob`\n  \n      @experimental\n  \n      @remarks\n      Use `sendRealtimeInput` for realtime audio chunks and video frames (images).\n  \n      With `sendRealtimeInput` the api will respond to audio automatically\n      based on voice activity detection (VAD).\n  \n      `sendRealtimeInput` is optimized for responsivness at the expense of\n      deterministic ordering guarantees. Audio and video tokens are to the\n      context when they become available.\n  \n      Note: The Call signature expects a `Blob` object, but only a subset\n      of audio and image mimetypes are allowed.\n     */ sendRealtimeInput(params) {\n        let clientMessage = {};\n        if (this.apiClient.isVertexAI()) {\n            clientMessage = {\n                \"realtimeInput\": liveSendRealtimeInputParametersToVertex(params)\n            };\n        } else {\n            clientMessage = {\n                \"realtimeInput\": liveSendRealtimeInputParametersToMldev(params)\n            };\n        }\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n      Send a function response message over the established connection.\n  \n      @param params - Contains property `functionResponses`.\n  \n        - `functionResponses` will be converted to a `functionResponses[]`\n  \n      @remarks\n      Use `sendFunctionResponse` to reply to `LiveServerToolCall` from the server.\n  \n      Use {@link types.LiveConnectConfig#tools} to configure the callable functions.\n  \n      @experimental\n     */ sendToolResponse(params) {\n        if (params.functionResponses == null) {\n            throw new Error(\"Tool response parameters are required.\");\n        }\n        const clientMessage = this.tLiveClienttToolResponse(this.apiClient, params);\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n       Terminates the WebSocket connection.\n  \n       @experimental\n  \n       @example\n       ```ts\n       let model: string;\n       if (GOOGLE_GENAI_USE_VERTEXAI) {\n         model = 'gemini-2.0-flash-live-preview-04-09';\n       } else {\n         model = 'gemini-live-2.5-flash-preview';\n       }\n       const session = await ai.live.connect({\n         model: model,\n         config: {\n           responseModalities: [Modality.AUDIO],\n         }\n       });\n  \n       session.close();\n       ```\n     */ close() {\n        this.conn.close();\n    }\n}\n// Converts an headers object to a \"map\" object as expected by the WebSocket\n// constructor. We use this as the Auth interface works with Headers objects\n// while the WebSocket constructor takes a map.\nfunction headersToMap(headers) {\n    const headerMap = {};\n    headers.forEach((value, key)=>{\n        headerMap[key] = value;\n    });\n    return headerMap;\n}\n// Converts a \"map\" object to a headers object. We use this as the Auth\n// interface works with Headers objects while the API client default headers\n// returns a map.\nfunction mapToHeaders(map) {\n    const headers = new Headers();\n    for (const [key, value] of Object.entries(map)){\n        headers.append(key, value);\n    }\n    return headers;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ const DEFAULT_MAX_REMOTE_CALLS = 10;\n/** Returns whether automatic function calling is disabled. */ function shouldDisableAfc(config) {\n    var _a, _b, _c;\n    if ((_a = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _a === void 0 ? void 0 : _a.disable) {\n        return true;\n    }\n    let callableToolsPresent = false;\n    for (const tool of (_b = config === null || config === void 0 ? void 0 : config.tools) !== null && _b !== void 0 ? _b : []){\n        if (isCallableTool(tool)) {\n            callableToolsPresent = true;\n            break;\n        }\n    }\n    if (!callableToolsPresent) {\n        return true;\n    }\n    const maxCalls = (_c = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _c === void 0 ? void 0 : _c.maximumRemoteCalls;\n    if (maxCalls && (maxCalls < 0 || !Number.isInteger(maxCalls)) || maxCalls == 0) {\n        console.warn(\"Invalid maximumRemoteCalls value provided for automatic function calling. Disabled automatic function calling. Please provide a valid integer value greater than 0. maximumRemoteCalls provided:\", maxCalls);\n        return true;\n    }\n    return false;\n}\nfunction isCallableTool(tool) {\n    return \"callTool\" in tool && typeof tool.callTool === \"function\";\n}\n// Checks whether the list of tools contains any CallableTools. Will return true\n// if there is at least one CallableTool.\nfunction hasCallableTools(params) {\n    var _a, _b, _c;\n    return (_c = (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools) === null || _b === void 0 ? void 0 : _b.some((tool)=>isCallableTool(tool))) !== null && _c !== void 0 ? _c : false;\n}\n/**\n * Returns the indexes of the tools that are not compatible with AFC.\n */ function findAfcIncompatibleToolIndexes(params) {\n    var _a;\n    // Use number[] for an array of numbers in TypeScript\n    const afcIncompatibleToolIndexes = [];\n    if (!((_a = params === null || params === void 0 ? void 0 : params.config) === null || _a === void 0 ? void 0 : _a.tools)) {\n        return afcIncompatibleToolIndexes;\n    }\n    params.config.tools.forEach((tool, index)=>{\n        if (isCallableTool(tool)) {\n            return;\n        }\n        const geminiTool = tool;\n        if (geminiTool.functionDeclarations && geminiTool.functionDeclarations.length > 0) {\n            afcIncompatibleToolIndexes.push(index);\n        }\n    });\n    return afcIncompatibleToolIndexes;\n}\n/**\n * Returns whether to append automatic function calling history to the\n * response.\n */ function shouldAppendAfcHistory(config) {\n    var _a;\n    return !((_a = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _a === void 0 ? void 0 : _a.ignoreCallHistory);\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Models extends BaseModule {\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Makes an API request to generate content with a given model.\n         *\n         * For the `model` parameter, supported formats for Vertex AI API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The full resource name starts with 'projects/', for example:\n         *  'projects/my-project-id/locations/us-central1/publishers/google/models/gemini-2.0-flash'\n         * - The partial resource name with 'publishers/', for example:\n         *  'publishers/google/models/gemini-2.0-flash' or\n         *  'publishers/meta/models/llama-3.1-405b-instruct-maas'\n         * - `/` separated publisher and model name, for example:\n         * 'google/gemini-2.0-flash' or 'meta/llama-3.1-405b-instruct-maas'\n         *\n         * For the `model` parameter, supported formats for Gemini API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The model name starts with 'models/', for example:\n         *  'models/gemini-2.0-flash'\n         * - For tuned models, the model name starts with 'tunedModels/',\n         * for example:\n         * 'tunedModels/1234567890123456789'\n         *\n         * Some models support multimodal input and output.\n         *\n         * @param params - The parameters for generating content.\n         * @return The response from generating content.\n         *\n         * @example\n         * ```ts\n         * const response = await ai.models.generateContent({\n         *   model: 'gemini-2.0-flash',\n         *   contents: 'why is the sky blue?',\n         *   config: {\n         *     candidateCount: 2,\n         *   }\n         * });\n         * console.log(response);\n         * ```\n         */ this.generateContent = async (params)=>{\n            var _a, _b, _c, _d, _e;\n            const transformedParams = await this.processParamsMaybeAddMcpUsage(params);\n            this.maybeMoveToResponseJsonSchem(params);\n            if (!hasCallableTools(params) || shouldDisableAfc(params.config)) {\n                return await this.generateContentInternal(transformedParams);\n            }\n            const incompatibleToolIndexes = findAfcIncompatibleToolIndexes(params);\n            if (incompatibleToolIndexes.length > 0) {\n                const formattedIndexes = incompatibleToolIndexes.map((index)=>`tools[${index}]`).join(\", \");\n                throw new Error(`Automatic function calling with CallableTools (or MCP objects) and basic FunctionDeclarations is not yet supported. Incompatible tools found at ${formattedIndexes}.`);\n            }\n            let response;\n            let functionResponseContent;\n            const automaticFunctionCallingHistory = tContents(transformedParams.contents);\n            const maxRemoteCalls = (_c = (_b = (_a = transformedParams.config) === null || _a === void 0 ? void 0 : _a.automaticFunctionCalling) === null || _b === void 0 ? void 0 : _b.maximumRemoteCalls) !== null && _c !== void 0 ? _c : DEFAULT_MAX_REMOTE_CALLS;\n            let remoteCalls = 0;\n            while(remoteCalls < maxRemoteCalls){\n                response = await this.generateContentInternal(transformedParams);\n                if (!response.functionCalls || response.functionCalls.length === 0) {\n                    break;\n                }\n                const responseContent = response.candidates[0].content;\n                const functionResponseParts = [];\n                for (const tool of (_e = (_d = params.config) === null || _d === void 0 ? void 0 : _d.tools) !== null && _e !== void 0 ? _e : []){\n                    if (isCallableTool(tool)) {\n                        const callableTool = tool;\n                        const parts = await callableTool.callTool(response.functionCalls);\n                        functionResponseParts.push(...parts);\n                    }\n                }\n                remoteCalls++;\n                functionResponseContent = {\n                    role: \"user\",\n                    parts: functionResponseParts\n                };\n                transformedParams.contents = tContents(transformedParams.contents);\n                transformedParams.contents.push(responseContent);\n                transformedParams.contents.push(functionResponseContent);\n                if (shouldAppendAfcHistory(transformedParams.config)) {\n                    automaticFunctionCallingHistory.push(responseContent);\n                    automaticFunctionCallingHistory.push(functionResponseContent);\n                }\n            }\n            if (shouldAppendAfcHistory(transformedParams.config)) {\n                response.automaticFunctionCallingHistory = automaticFunctionCallingHistory;\n            }\n            return response;\n        };\n        /**\n         * Makes an API request to generate content with a given model and yields the\n         * response in chunks.\n         *\n         * For the `model` parameter, supported formats for Vertex AI API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The full resource name starts with 'projects/', for example:\n         *  'projects/my-project-id/locations/us-central1/publishers/google/models/gemini-2.0-flash'\n         * - The partial resource name with 'publishers/', for example:\n         *  'publishers/google/models/gemini-2.0-flash' or\n         *  'publishers/meta/models/llama-3.1-405b-instruct-maas'\n         * - `/` separated publisher and model name, for example:\n         * 'google/gemini-2.0-flash' or 'meta/llama-3.1-405b-instruct-maas'\n         *\n         * For the `model` parameter, supported formats for Gemini API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The model name starts with 'models/', for example:\n         *  'models/gemini-2.0-flash'\n         * - For tuned models, the model name starts with 'tunedModels/',\n         * for example:\n         *  'tunedModels/1234567890123456789'\n         *\n         * Some models support multimodal input and output.\n         *\n         * @param params - The parameters for generating content with streaming response.\n         * @return The response from generating content.\n         *\n         * @example\n         * ```ts\n         * const response = await ai.models.generateContentStream({\n         *   model: 'gemini-2.0-flash',\n         *   contents: 'why is the sky blue?',\n         *   config: {\n         *     maxOutputTokens: 200,\n         *   }\n         * });\n         * for await (const chunk of response) {\n         *   console.log(chunk);\n         * }\n         * ```\n         */ this.generateContentStream = async (params)=>{\n            var _a, _b, _c, _d, _e;\n            this.maybeMoveToResponseJsonSchem(params);\n            if (shouldDisableAfc(params.config)) {\n                const transformedParams = await this.processParamsMaybeAddMcpUsage(params);\n                return await this.generateContentStreamInternal(transformedParams);\n            }\n            const incompatibleToolIndexes = findAfcIncompatibleToolIndexes(params);\n            if (incompatibleToolIndexes.length > 0) {\n                const formattedIndexes = incompatibleToolIndexes.map((index)=>`tools[${index}]`).join(\", \");\n                throw new Error(`Incompatible tools found at ${formattedIndexes}. Automatic function calling with CallableTools (or MCP objects) and basic FunctionDeclarations\" is not yet supported.`);\n            }\n            // With tool compatibility confirmed, validate that the configuration are\n            // compatible with each other and raise an error if invalid.\n            const streamFunctionCall = (_c = (_b = (_a = params === null || params === void 0 ? void 0 : params.config) === null || _a === void 0 ? void 0 : _a.toolConfig) === null || _b === void 0 ? void 0 : _b.functionCallingConfig) === null || _c === void 0 ? void 0 : _c.streamFunctionCallArguments;\n            const disableAfc = (_e = (_d = params === null || params === void 0 ? void 0 : params.config) === null || _d === void 0 ? void 0 : _d.automaticFunctionCalling) === null || _e === void 0 ? void 0 : _e.disable;\n            if (streamFunctionCall && !disableAfc) {\n                throw new Error(\"Running in streaming mode with 'streamFunctionCallArguments' enabled, \" + \"this feature is not compatible with automatic function calling (AFC). \" + \"Please set 'config.automaticFunctionCalling.disable' to true to disable AFC \" + \"or leave 'config.toolConfig.functionCallingConfig.streamFunctionCallArguments' \" + \"to be undefined or set to false to disable streaming function call arguments feature.\");\n            }\n            return await this.processAfcStream(params);\n        };\n        /**\n         * Generates an image based on a text description and configuration.\n         *\n         * @param params - The parameters for generating images.\n         * @return The response from the API.\n         *\n         * @example\n         * ```ts\n         * const response = await client.models.generateImages({\n         *  model: 'imagen-3.0-generate-002',\n         *  prompt: 'Robot holding a red skateboard',\n         *  config: {\n         *    numberOfImages: 1,\n         *    includeRaiReason: true,\n         *  },\n         * });\n         * console.log(response?.generatedImages?.[0]?.image?.imageBytes);\n         * ```\n         */ this.generateImages = async (params)=>{\n            return await this.generateImagesInternal(params).then((apiResponse)=>{\n                var _a;\n                let positivePromptSafetyAttributes;\n                const generatedImages = [];\n                if (apiResponse === null || apiResponse === void 0 ? void 0 : apiResponse.generatedImages) {\n                    for (const generatedImage of apiResponse.generatedImages){\n                        if (generatedImage && (generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) && ((_a = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) === null || _a === void 0 ? void 0 : _a.contentType) === \"Positive Prompt\") {\n                            positivePromptSafetyAttributes = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes;\n                        } else {\n                            generatedImages.push(generatedImage);\n                        }\n                    }\n                }\n                let response;\n                if (positivePromptSafetyAttributes) {\n                    response = {\n                        generatedImages: generatedImages,\n                        positivePromptSafetyAttributes: positivePromptSafetyAttributes,\n                        sdkHttpResponse: apiResponse.sdkHttpResponse\n                    };\n                } else {\n                    response = {\n                        generatedImages: generatedImages,\n                        sdkHttpResponse: apiResponse.sdkHttpResponse\n                    };\n                }\n                return response;\n            });\n        };\n        this.list = async (params)=>{\n            var _a;\n            const defaultConfig = {\n                queryBase: true\n            };\n            const actualConfig = Object.assign(Object.assign({}, defaultConfig), params === null || params === void 0 ? void 0 : params.config);\n            const actualParams = {\n                config: actualConfig\n            };\n            if (this.apiClient.isVertexAI()) {\n                if (!actualParams.config.queryBase) {\n                    if ((_a = actualParams.config) === null || _a === void 0 ? void 0 : _a.filter) {\n                        throw new Error(\"Filtering tuned models list for Vertex AI is not currently supported\");\n                    } else {\n                        actualParams.config.filter = \"labels.tune-type:*\";\n                    }\n                }\n            }\n            return new Pager(PagedItem.PAGED_ITEM_MODELS, (x)=>this.listInternal(x), await this.listInternal(actualParams), actualParams);\n        };\n        /**\n         * Edits an image based on a prompt, list of reference images, and configuration.\n         *\n         * @param params - The parameters for editing an image.\n         * @return The response from the API.\n         *\n         * @example\n         * ```ts\n         * const response = await client.models.editImage({\n         *  model: 'imagen-3.0-capability-001',\n         *  prompt: 'Generate an image containing a mug with the product logo [1] visible on the side of the mug.',\n         *  referenceImages: [subjectReferenceImage]\n         *  config: {\n         *    numberOfImages: 1,\n         *    includeRaiReason: true,\n         *  },\n         * });\n         * console.log(response?.generatedImages?.[0]?.image?.imageBytes);\n         * ```\n         */ this.editImage = async (params)=>{\n            const paramsInternal = {\n                model: params.model,\n                prompt: params.prompt,\n                referenceImages: [],\n                config: params.config\n            };\n            if (params.referenceImages) {\n                if (params.referenceImages) {\n                    paramsInternal.referenceImages = params.referenceImages.map((img)=>img.toReferenceImageAPI());\n                }\n            }\n            return await this.editImageInternal(paramsInternal);\n        };\n        /**\n         * Upscales an image based on an image, upscale factor, and configuration.\n         * Only supported in Vertex AI currently.\n         *\n         * @param params - The parameters for upscaling an image.\n         * @return The response from the API.\n         *\n         * @example\n         * ```ts\n         * const response = await client.models.upscaleImage({\n         *  model: 'imagen-3.0-generate-002',\n         *  image: image,\n         *  upscaleFactor: 'x2',\n         *  config: {\n         *    includeRaiReason: true,\n         *  },\n         * });\n         * console.log(response?.generatedImages?.[0]?.image?.imageBytes);\n         * ```\n         */ this.upscaleImage = async (params)=>{\n            let apiConfig = {\n                numberOfImages: 1,\n                mode: \"upscale\"\n            };\n            if (params.config) {\n                apiConfig = Object.assign(Object.assign({}, apiConfig), params.config);\n            }\n            const apiParams = {\n                model: params.model,\n                image: params.image,\n                upscaleFactor: params.upscaleFactor,\n                config: apiConfig\n            };\n            return await this.upscaleImageInternal(apiParams);\n        };\n        /**\n         *  Generates videos based on a text description and configuration.\n         *\n         * @param params - The parameters for generating videos.\n         * @return A Promise<GenerateVideosOperation> which allows you to track the progress and eventually retrieve the generated videos using the operations.get method.\n         *\n         * @example\n         * ```ts\n         * const operation = await ai.models.generateVideos({\n         *  model: 'veo-2.0-generate-001',\n         *  source: {\n         *    prompt: 'A neon hologram of a cat driving at top speed',\n         *  },\n         *  config: {\n         *    numberOfVideos: 1\n         * });\n         *\n         * while (!operation.done) {\n         *   await new Promise(resolve => setTimeout(resolve, 10000));\n         *   operation = await ai.operations.getVideosOperation({operation: operation});\n         * }\n         *\n         * console.log(operation.response?.generatedVideos?.[0]?.video?.uri);\n         * ```\n         */ this.generateVideos = async (params)=>{\n            var _a, _b, _c, _d, _e, _f;\n            if ((params.prompt || params.image || params.video) && params.source) {\n                throw new Error(\"Source and prompt/image/video are mutually exclusive. Please only use source.\");\n            }\n            // Gemini API does not support video bytes.\n            if (!this.apiClient.isVertexAI()) {\n                if (((_a = params.video) === null || _a === void 0 ? void 0 : _a.uri) && ((_b = params.video) === null || _b === void 0 ? void 0 : _b.videoBytes)) {\n                    params.video = {\n                        uri: params.video.uri,\n                        mimeType: params.video.mimeType\n                    };\n                } else if (((_d = (_c = params.source) === null || _c === void 0 ? void 0 : _c.video) === null || _d === void 0 ? void 0 : _d.uri) && ((_f = (_e = params.source) === null || _e === void 0 ? void 0 : _e.video) === null || _f === void 0 ? void 0 : _f.videoBytes)) {\n                    params.source.video = {\n                        uri: params.source.video.uri,\n                        mimeType: params.source.video.mimeType\n                    };\n                }\n            }\n            return await this.generateVideosInternal(params);\n        };\n    }\n    /**\n     * This logic is needed for GenerateContentConfig only.\n     * Previously we made GenerateContentConfig.responseSchema field to accept\n     * unknown. Since v1.9.0, we switch to use backend JSON schema support.\n     * To maintain backward compatibility, we move the data that was treated as\n     * JSON schema from the responseSchema field to the responseJsonSchema field.\n     */ maybeMoveToResponseJsonSchem(params) {\n        if (params.config && params.config.responseSchema) {\n            if (!params.config.responseJsonSchema) {\n                if (Object.keys(params.config.responseSchema).includes(\"$schema\")) {\n                    params.config.responseJsonSchema = params.config.responseSchema;\n                    delete params.config.responseSchema;\n                }\n            }\n        }\n        return;\n    }\n    /**\n     * Transforms the CallableTools in the parameters to be simply Tools, it\n     * copies the params into a new object and replaces the tools, it does not\n     * modify the original params. Also sets the MCP usage header if there are\n     * MCP tools in the parameters.\n     */ async processParamsMaybeAddMcpUsage(params) {\n        var _a, _b, _c;\n        const tools = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools;\n        if (!tools) {\n            return params;\n        }\n        const transformedTools = await Promise.all(tools.map(async (tool)=>{\n            if (isCallableTool(tool)) {\n                const callableTool = tool;\n                return await callableTool.tool();\n            }\n            return tool;\n        }));\n        const newParams = {\n            model: params.model,\n            contents: params.contents,\n            config: Object.assign(Object.assign({}, params.config), {\n                tools: transformedTools\n            })\n        };\n        newParams.config.tools = transformedTools;\n        if (params.config && params.config.tools && hasMcpToolUsage(params.config.tools)) {\n            const headers = (_c = (_b = params.config.httpOptions) === null || _b === void 0 ? void 0 : _b.headers) !== null && _c !== void 0 ? _c : {};\n            let newHeaders = Object.assign({}, headers);\n            if (Object.keys(newHeaders).length === 0) {\n                newHeaders = this.apiClient.getDefaultHeaders();\n            }\n            setMcpUsageHeader(newHeaders);\n            newParams.config.httpOptions = Object.assign(Object.assign({}, params.config.httpOptions), {\n                headers: newHeaders\n            });\n        }\n        return newParams;\n    }\n    async initAfcToolsMap(params) {\n        var _a, _b, _c;\n        const afcTools = new Map();\n        for (const tool of (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools) !== null && _b !== void 0 ? _b : []){\n            if (isCallableTool(tool)) {\n                const callableTool = tool;\n                const toolDeclaration = await callableTool.tool();\n                for (const declaration of (_c = toolDeclaration.functionDeclarations) !== null && _c !== void 0 ? _c : []){\n                    if (!declaration.name) {\n                        throw new Error(\"Function declaration name is required.\");\n                    }\n                    if (afcTools.has(declaration.name)) {\n                        throw new Error(`Duplicate tool declaration name: ${declaration.name}`);\n                    }\n                    afcTools.set(declaration.name, callableTool);\n                }\n            }\n        }\n        return afcTools;\n    }\n    async processAfcStream(params) {\n        var _a, _b, _c;\n        const maxRemoteCalls = (_c = (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.automaticFunctionCalling) === null || _b === void 0 ? void 0 : _b.maximumRemoteCalls) !== null && _c !== void 0 ? _c : DEFAULT_MAX_REMOTE_CALLS;\n        let wereFunctionsCalled = false;\n        let remoteCallCount = 0;\n        const afcToolsMap = await this.initAfcToolsMap(params);\n        return function(models, afcTools, params) {\n            var _a, _b;\n            return __asyncGenerator(this, arguments, function*() {\n                var _c, e_1, _d, _e;\n                while(remoteCallCount < maxRemoteCalls){\n                    if (wereFunctionsCalled) {\n                        remoteCallCount++;\n                        wereFunctionsCalled = false;\n                    }\n                    const transformedParams = yield __await(models.processParamsMaybeAddMcpUsage(params));\n                    const response = yield __await(models.generateContentStreamInternal(transformedParams));\n                    const functionResponses = [];\n                    const responseContents = [];\n                    try {\n                        for(var _f = true, response_1 = (e_1 = void 0, __asyncValues(response)), response_1_1; response_1_1 = yield __await(response_1.next()), _c = response_1_1.done, !_c; _f = true){\n                            _e = response_1_1.value;\n                            _f = false;\n                            const chunk = _e;\n                            yield yield __await(chunk);\n                            if (chunk.candidates && ((_a = chunk.candidates[0]) === null || _a === void 0 ? void 0 : _a.content)) {\n                                responseContents.push(chunk.candidates[0].content);\n                                for (const part of (_b = chunk.candidates[0].content.parts) !== null && _b !== void 0 ? _b : []){\n                                    if (remoteCallCount < maxRemoteCalls && part.functionCall) {\n                                        if (!part.functionCall.name) {\n                                            throw new Error(\"Function call name was not returned by the model.\");\n                                        }\n                                        if (!afcTools.has(part.functionCall.name)) {\n                                            throw new Error(`Automatic function calling was requested, but not all the tools the model used implement the CallableTool interface. Available tools: ${afcTools.keys()}, mising tool: ${part.functionCall.name}`);\n                                        } else {\n                                            const responseParts = yield __await(afcTools.get(part.functionCall.name).callTool([\n                                                part.functionCall\n                                            ]));\n                                            functionResponses.push(...responseParts);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    } catch (e_1_1) {\n                        e_1 = {\n                            error: e_1_1\n                        };\n                    } finally{\n                        try {\n                            if (!_f && !_c && (_d = response_1.return)) yield __await(_d.call(response_1));\n                        } finally{\n                            if (e_1) throw e_1.error;\n                        }\n                    }\n                    if (functionResponses.length > 0) {\n                        wereFunctionsCalled = true;\n                        const typedResponseChunk = new GenerateContentResponse();\n                        typedResponseChunk.candidates = [\n                            {\n                                content: {\n                                    role: \"user\",\n                                    parts: functionResponses\n                                }\n                            }\n                        ];\n                        yield yield __await(typedResponseChunk);\n                        const newContents = [];\n                        newContents.push(...responseContents);\n                        newContents.push({\n                            role: \"user\",\n                            parts: functionResponses\n                        });\n                        const updatedContents = tContents(params.contents).concat(newContents);\n                        params.contents = updatedContents;\n                    } else {\n                        break;\n                    }\n                }\n            });\n        }(this, afcToolsMap, params);\n    }\n    async generateContentInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:generateContent\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateContentResponseFromVertex(apiResponse);\n                const typedResp = new GenerateContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = generateContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:generateContent\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateContentResponseFromMldev(apiResponse);\n                const typedResp = new GenerateContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    async generateContentStreamInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:streamGenerateContent?alt=sse\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            const apiClient = this.apiClient;\n            response = apiClient.requestStream({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            });\n            return response.then(function(apiResponse) {\n                return __asyncGenerator(this, arguments, function*() {\n                    var _a, e_2, _b, _c;\n                    try {\n                        for(var _d = true, apiResponse_1 = __asyncValues(apiResponse), apiResponse_1_1; apiResponse_1_1 = yield __await(apiResponse_1.next()), _a = apiResponse_1_1.done, !_a; _d = true){\n                            _c = apiResponse_1_1.value;\n                            _d = false;\n                            const chunk = _c;\n                            const resp = generateContentResponseFromVertex((yield __await(chunk.json())));\n                            resp[\"sdkHttpResponse\"] = {\n                                headers: chunk.headers\n                            };\n                            const typedResp = new GenerateContentResponse();\n                            Object.assign(typedResp, resp);\n                            yield yield __await(typedResp);\n                        }\n                    } catch (e_2_1) {\n                        e_2 = {\n                            error: e_2_1\n                        };\n                    } finally{\n                        try {\n                            if (!_d && !_a && (_b = apiResponse_1.return)) yield __await(_b.call(apiResponse_1));\n                        } finally{\n                            if (e_2) throw e_2.error;\n                        }\n                    }\n                });\n            });\n        } else {\n            const body = generateContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:streamGenerateContent?alt=sse\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            const apiClient = this.apiClient;\n            response = apiClient.requestStream({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            });\n            return response.then(function(apiResponse) {\n                return __asyncGenerator(this, arguments, function*() {\n                    var _a, e_3, _b, _c;\n                    try {\n                        for(var _d = true, apiResponse_2 = __asyncValues(apiResponse), apiResponse_2_1; apiResponse_2_1 = yield __await(apiResponse_2.next()), _a = apiResponse_2_1.done, !_a; _d = true){\n                            _c = apiResponse_2_1.value;\n                            _d = false;\n                            const chunk = _c;\n                            const resp = generateContentResponseFromMldev((yield __await(chunk.json())));\n                            resp[\"sdkHttpResponse\"] = {\n                                headers: chunk.headers\n                            };\n                            const typedResp = new GenerateContentResponse();\n                            Object.assign(typedResp, resp);\n                            yield yield __await(typedResp);\n                        }\n                    } catch (e_3_1) {\n                        e_3 = {\n                            error: e_3_1\n                        };\n                    } finally{\n                        try {\n                            if (!_d && !_a && (_b = apiResponse_2.return)) yield __await(_b.call(apiResponse_2));\n                        } finally{\n                            if (e_3) throw e_3.error;\n                        }\n                    }\n                });\n            });\n        }\n    }\n    /**\n     * Calculates embeddings for the given contents. Only text is supported.\n     *\n     * @param params - The parameters for embedding contents.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.embedContent({\n     *  model: 'text-embedding-004',\n     *  contents: [\n     *    'What is your name?',\n     *    'What is your favorite color?',\n     *  ],\n     *  config: {\n     *    outputDimensionality: 64,\n     *  },\n     * });\n     * console.log(response);\n     * ```\n     */ async embedContent(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = embedContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = embedContentResponseFromVertex(apiResponse);\n                const typedResp = new EmbedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = embedContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:batchEmbedContents\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = embedContentResponseFromMldev(apiResponse);\n                const typedResp = new EmbedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Private method for generating images.\n     */ async generateImagesInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateImagesParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateImagesResponseFromVertex(apiResponse);\n                const typedResp = new GenerateImagesResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = generateImagesParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateImagesResponseFromMldev(apiResponse);\n                const typedResp = new GenerateImagesResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Private method for editing an image.\n     */ async editImageInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = editImageParametersInternalToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = editImageResponseFromVertex(apiResponse);\n                const typedResp = new EditImageResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n    /**\n     * Private method for upscaling an image.\n     */ async upscaleImageInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = upscaleImageAPIParametersInternalToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = upscaleImageResponseFromVertex(apiResponse);\n                const typedResp = new UpscaleImageResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n    /**\n     * Recontextualizes an image.\n     *\n     * There are two types of recontextualization currently supported:\n     * 1) Imagen Product Recontext - Generate images of products in new scenes\n     *    and contexts.\n     * 2) Virtual Try-On: Generate images of persons modeling fashion products.\n     *\n     * @param params - The parameters for recontextualizing an image.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response1 = await ai.models.recontextImage({\n     *  model: 'imagen-product-recontext-preview-06-30',\n     *  source: {\n     *    prompt: 'In a modern kitchen setting.',\n     *    productImages: [productImage],\n     *  },\n     *  config: {\n     *    numberOfImages: 1,\n     *  },\n     * });\n     * console.log(response1?.generatedImages?.[0]?.image?.imageBytes);\n     *\n     * const response2 = await ai.models.recontextImage({\n     *  model: 'virtual-try-on-preview-08-04',\n     *  source: {\n     *    personImage: personImage,\n     *    productImages: [productImage],\n     *  },\n     *  config: {\n     *    numberOfImages: 1,\n     *  },\n     * });\n     * console.log(response2?.generatedImages?.[0]?.image?.imageBytes);\n     * ```\n     */ async recontextImage(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = recontextImageParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = recontextImageResponseFromVertex(apiResponse);\n                const typedResp = new RecontextImageResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n    /**\n     * Segments an image, creating a mask of a specified area.\n     *\n     * @param params - The parameters for segmenting an image.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.segmentImage({\n     *  model: 'image-segmentation-001',\n     *  source: {\n     *    image: image,\n     *  },\n     *  config: {\n     *    mode: 'foreground',\n     *  },\n     * });\n     * console.log(response?.generatedMasks?.[0]?.mask?.imageBytes);\n     * ```\n     */ async segmentImage(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = segmentImageParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = segmentImageResponseFromVertex(apiResponse);\n                const typedResp = new SegmentImageResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n    /**\n     * Fetches information about a model by name.\n     *\n     * @example\n     * ```ts\n     * const modelInfo = await ai.models.get({model: 'gemini-2.0-flash'});\n     * ```\n     */ async get(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getModelParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = modelFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = getModelParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = modelFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = listModelsParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{models_url}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listModelsResponseFromVertex(apiResponse);\n                const typedResp = new ListModelsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = listModelsParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{models_url}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listModelsResponseFromMldev(apiResponse);\n                const typedResp = new ListModelsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Updates a tuned model by its name.\n     *\n     * @param params - The parameters for updating the model.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.update({\n     *   model: 'tuned-model-name',\n     *   config: {\n     *     displayName: 'New display name',\n     *     description: 'New description',\n     *   },\n     * });\n     * ```\n     */ async update(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = updateModelParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"PATCH\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = modelFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = updateModelParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"PATCH\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = modelFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes a tuned model by its name.\n     *\n     * @param params - The parameters for deleting the model.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.delete({model: 'tuned-model-name'});\n     * ```\n     */ async delete(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = deleteModelParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = deleteModelResponseFromVertex(apiResponse);\n                const typedResp = new DeleteModelResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = deleteModelParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = deleteModelResponseFromMldev(apiResponse);\n                const typedResp = new DeleteModelResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Counts the number of tokens in the given contents. Multimodal input is\n     * supported for Gemini models.\n     *\n     * @param params - The parameters for counting tokens.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.countTokens({\n     *  model: 'gemini-2.0-flash',\n     *  contents: 'The quick brown fox jumps over the lazy dog.'\n     * });\n     * console.log(response);\n     * ```\n     */ async countTokens(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = countTokensParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:countTokens\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = countTokensResponseFromVertex(apiResponse);\n                const typedResp = new CountTokensResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = countTokensParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:countTokens\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = countTokensResponseFromMldev(apiResponse);\n                const typedResp = new CountTokensResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Given a list of contents, returns a corresponding TokensInfo containing\n     * the list of tokens and list of token ids.\n     *\n     * This method is not supported by the Gemini Developer API.\n     *\n     * @param params - The parameters for computing tokens.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.computeTokens({\n     *  model: 'gemini-2.0-flash',\n     *  contents: 'What is your name?'\n     * });\n     * console.log(response);\n     * ```\n     */ async computeTokens(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = computeTokensParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:computeTokens\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = computeTokensResponseFromVertex(apiResponse);\n                const typedResp = new ComputeTokensResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n    /**\n     * Private method for generating videos.\n     */ async generateVideosInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateVideosParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predictLongRunning\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateVideosOperationFromVertex(apiResponse);\n                const typedResp = new GenerateVideosOperation();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = generateVideosParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:predictLongRunning\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateVideosOperationFromMldev(apiResponse);\n                const typedResp = new GenerateVideosOperation();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Operations extends BaseModule {\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n    }\n    /**\n     * Gets the status of a long-running operation.\n     *\n     * @param parameters The parameters for the get operation request.\n     * @return The updated Operation object, with the latest status or result.\n     */ async getVideosOperation(parameters) {\n        const operation = parameters.operation;\n        const config = parameters.config;\n        if (operation.name === undefined || operation.name === \"\") {\n            throw new Error(\"Operation name is required.\");\n        }\n        if (this.apiClient.isVertexAI()) {\n            const resourceName = operation.name.split(\"/operations/\")[0];\n            let httpOptions = undefined;\n            if (config && \"httpOptions\" in config) {\n                httpOptions = config.httpOptions;\n            }\n            const rawOperation = await this.fetchPredictVideosOperationInternal({\n                operationName: operation.name,\n                resourceName: resourceName,\n                config: {\n                    httpOptions: httpOptions\n                }\n            });\n            return operation._fromAPIResponse({\n                apiResponse: rawOperation,\n                _isVertexAI: true\n            });\n        } else {\n            const rawOperation = await this.getVideosOperationInternal({\n                operationName: operation.name,\n                config: config\n            });\n            return operation._fromAPIResponse({\n                apiResponse: rawOperation,\n                _isVertexAI: false\n            });\n        }\n    }\n    /**\n     * Gets the status of a long-running operation.\n     *\n     * @param parameters The parameters for the get operation request.\n     * @return The updated Operation object, with the latest status or result.\n     */ async get(parameters) {\n        const operation = parameters.operation;\n        const config = parameters.config;\n        if (operation.name === undefined || operation.name === \"\") {\n            throw new Error(\"Operation name is required.\");\n        }\n        if (this.apiClient.isVertexAI()) {\n            const resourceName = operation.name.split(\"/operations/\")[0];\n            let httpOptions = undefined;\n            if (config && \"httpOptions\" in config) {\n                httpOptions = config.httpOptions;\n            }\n            const rawOperation = await this.fetchPredictVideosOperationInternal({\n                operationName: operation.name,\n                resourceName: resourceName,\n                config: {\n                    httpOptions: httpOptions\n                }\n            });\n            return operation._fromAPIResponse({\n                apiResponse: rawOperation,\n                _isVertexAI: true\n            });\n        } else {\n            const rawOperation = await this.getVideosOperationInternal({\n                operationName: operation.name,\n                config: config\n            });\n            return operation._fromAPIResponse({\n                apiResponse: rawOperation,\n                _isVertexAI: false\n            });\n        }\n    }\n    async getVideosOperationInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getOperationParametersToVertex(params);\n            path = formatMap(\"{operationName}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response;\n        } else {\n            const body = getOperationParametersToMldev(params);\n            path = formatMap(\"{operationName}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response;\n        }\n    }\n    async fetchPredictVideosOperationInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = fetchPredictOperationParametersToVertex(params);\n            path = formatMap(\"{resourceName}:fetchPredictOperation\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response;\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function blobToMldev(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction contentToMldev(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partToMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction createAuthTokenConfigToMldev(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    const fromNewSessionExpireTime = getValueByPath(fromObject, [\n        \"newSessionExpireTime\"\n    ]);\n    if (parentObject !== undefined && fromNewSessionExpireTime != null) {\n        setValueByPath(parentObject, [\n            \"newSessionExpireTime\"\n        ], fromNewSessionExpireTime);\n    }\n    const fromUses = getValueByPath(fromObject, [\n        \"uses\"\n    ]);\n    if (parentObject !== undefined && fromUses != null) {\n        setValueByPath(parentObject, [\n            \"uses\"\n        ], fromUses);\n    }\n    const fromLiveConnectConstraints = getValueByPath(fromObject, [\n        \"liveConnectConstraints\"\n    ]);\n    if (parentObject !== undefined && fromLiveConnectConstraints != null) {\n        setValueByPath(parentObject, [\n            \"bidiGenerateContentSetup\"\n        ], liveConnectConstraintsToMldev(apiClient, fromLiveConnectConstraints));\n    }\n    const fromLockAdditionalFields = getValueByPath(fromObject, [\n        \"lockAdditionalFields\"\n    ]);\n    if (parentObject !== undefined && fromLockAdditionalFields != null) {\n        setValueByPath(parentObject, [\n            \"fieldMask\"\n        ], fromLockAdditionalFields);\n    }\n    return toObject;\n}\nfunction createAuthTokenParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], createAuthTokenConfigToMldev(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction fileDataToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction functionCallToMldev(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, [\n        \"id\"\n    ]);\n    if (fromId != null) {\n        setValueByPath(toObject, [\n            \"id\"\n        ], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, [\n        \"args\"\n    ]);\n    if (fromArgs != null) {\n        setValueByPath(toObject, [\n            \"args\"\n        ], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    if (getValueByPath(fromObject, [\n        \"partialArgs\"\n    ]) !== undefined) {\n        throw new Error(\"partialArgs parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"willContinue\"\n    ]) !== undefined) {\n        throw new Error(\"willContinue parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction googleMapsToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"authConfig\"\n    ]) !== undefined) {\n        throw new Error(\"authConfig parameter is not supported in Gemini API.\");\n    }\n    const fromEnableWidget = getValueByPath(fromObject, [\n        \"enableWidget\"\n    ]);\n    if (fromEnableWidget != null) {\n        setValueByPath(toObject, [\n            \"enableWidget\"\n        ], fromEnableWidget);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"excludeDomains\"\n    ]) !== undefined) {\n        throw new Error(\"excludeDomains parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"blockingConfidence\"\n    ]) !== undefined) {\n        throw new Error(\"blockingConfidence parameter is not supported in Gemini API.\");\n    }\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        \"timeRangeFilter\"\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, [\n            \"timeRangeFilter\"\n        ], fromTimeRangeFilter);\n    }\n    return toObject;\n}\nfunction liveConnectConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        \"generationConfig\"\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\"\n        ], fromGenerationConfig);\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (parentObject !== undefined && fromResponseModalities != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (parentObject !== undefined && fromTemperature != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (parentObject !== undefined && fromTopP != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (parentObject !== undefined && fromTopK != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (parentObject !== undefined && fromMaxOutputTokens != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (parentObject !== undefined && fromMediaResolution != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (parentObject !== undefined && fromSpeechConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"speechConfig\"\n        ], tLiveSpeechConfig(fromSpeechConfig));\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        \"thinkingConfig\"\n    ]);\n    if (parentObject !== undefined && fromThinkingConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"thinkingConfig\"\n        ], fromThinkingConfig);\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        \"enableAffectiveDialog\"\n    ]);\n    if (parentObject !== undefined && fromEnableAffectiveDialog != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"enableAffectiveDialog\"\n        ], fromEnableAffectiveDialog);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"systemInstruction\"\n        ], contentToMldev(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToMldev(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"tools\"\n        ], transformedList);\n    }\n    const fromSessionResumption = getValueByPath(fromObject, [\n        \"sessionResumption\"\n    ]);\n    if (parentObject !== undefined && fromSessionResumption != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"sessionResumption\"\n        ], sessionResumptionConfigToMldev(fromSessionResumption));\n    }\n    const fromInputAudioTranscription = getValueByPath(fromObject, [\n        \"inputAudioTranscription\"\n    ]);\n    if (parentObject !== undefined && fromInputAudioTranscription != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"inputAudioTranscription\"\n        ], fromInputAudioTranscription);\n    }\n    const fromOutputAudioTranscription = getValueByPath(fromObject, [\n        \"outputAudioTranscription\"\n    ]);\n    if (parentObject !== undefined && fromOutputAudioTranscription != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"outputAudioTranscription\"\n        ], fromOutputAudioTranscription);\n    }\n    const fromRealtimeInputConfig = getValueByPath(fromObject, [\n        \"realtimeInputConfig\"\n    ]);\n    if (parentObject !== undefined && fromRealtimeInputConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"realtimeInputConfig\"\n        ], fromRealtimeInputConfig);\n    }\n    const fromContextWindowCompression = getValueByPath(fromObject, [\n        \"contextWindowCompression\"\n    ]);\n    if (parentObject !== undefined && fromContextWindowCompression != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"contextWindowCompression\"\n        ], fromContextWindowCompression);\n    }\n    const fromProactivity = getValueByPath(fromObject, [\n        \"proactivity\"\n    ]);\n    if (parentObject !== undefined && fromProactivity != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"proactivity\"\n        ], fromProactivity);\n    }\n    return toObject;\n}\nfunction liveConnectConstraintsToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"setup\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], liveConnectConfigToMldev(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction partToMldev(fromObject) {\n    const toObject = {};\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, [\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataToMldev(fromFileData));\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], functionCallToMldev(fromFunctionCall));\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobToMldev(fromInlineData));\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], fromVideoMetadata);\n    }\n    return toObject;\n}\nfunction sessionResumptionConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromHandle = getValueByPath(fromObject, [\n        \"handle\"\n    ]);\n    if (fromHandle != null) {\n        setValueByPath(toObject, [\n            \"handle\"\n        ], fromHandle);\n    }\n    if (getValueByPath(fromObject, [\n        \"transparent\"\n    ]) !== undefined) {\n        throw new Error(\"transparent parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction toolToMldev(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    if (getValueByPath(fromObject, [\n        \"retrieval\"\n    ]) !== undefined) {\n        throw new Error(\"retrieval parameter is not supported in Gemini API.\");\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], fromGoogleSearchRetrieval);\n    }\n    const fromComputerUse = getValueByPath(fromObject, [\n        \"computerUse\"\n    ]);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, [\n            \"computerUse\"\n        ], fromComputerUse);\n    }\n    const fromFileSearch = getValueByPath(fromObject, [\n        \"fileSearch\"\n    ]);\n    if (fromFileSearch != null) {\n        setValueByPath(toObject, [\n            \"fileSearch\"\n        ], fromFileSearch);\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    if (getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]) !== undefined) {\n        throw new Error(\"enterpriseWebSearch parameter is not supported in Gemini API.\");\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, [\n            \"googleMaps\"\n        ], googleMapsToMldev(fromGoogleMaps));\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToMldev(fromGoogleSearch));\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], fromUrlContext);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ /**\n * Returns a comma-separated list of field masks from a given object.\n *\n * @param setup The object to extract field masks from.\n * @return A comma-separated list of field masks.\n */ function getFieldMasks(setup) {\n    const fields = [];\n    for(const key in setup){\n        if (Object.prototype.hasOwnProperty.call(setup, key)) {\n            const value = setup[key];\n            // 2nd layer, recursively get field masks see TODO(b/418290100)\n            if (typeof value === \"object\" && value != null && Object.keys(value).length > 0) {\n                const field = Object.keys(value).map((kk)=>`${key}.${kk}`);\n                fields.push(...field);\n            } else {\n                fields.push(key); // 1st layer\n            }\n        }\n    }\n    return fields.join(\",\");\n}\n/**\n * Converts bidiGenerateContentSetup.\n * @param requestDict - The request dictionary.\n * @param config - The configuration object.\n * @return - The modified request dictionary.\n */ function convertBidiSetupToTokenSetup(requestDict, config) {\n    // Convert bidiGenerateContentSetup from bidiGenerateContentSetup.setup.\n    let setupForMaskGeneration = null;\n    const bidiGenerateContentSetupValue = requestDict[\"bidiGenerateContentSetup\"];\n    if (typeof bidiGenerateContentSetupValue === \"object\" && bidiGenerateContentSetupValue !== null && \"setup\" in bidiGenerateContentSetupValue) {\n        // Now we know bidiGenerateContentSetupValue is an object and has a 'setup'\n        // property.\n        const innerSetup = bidiGenerateContentSetupValue.setup;\n        if (typeof innerSetup === \"object\" && innerSetup !== null) {\n            // Valid inner setup found.\n            requestDict[\"bidiGenerateContentSetup\"] = innerSetup;\n            setupForMaskGeneration = innerSetup;\n        } else {\n            // `bidiGenerateContentSetupValue.setup` is not a valid object; treat as\n            // if bidiGenerateContentSetup is invalid.\n            delete requestDict[\"bidiGenerateContentSetup\"];\n        }\n    } else if (bidiGenerateContentSetupValue !== undefined) {\n        // `bidiGenerateContentSetup` exists but not in the expected\n        // shape {setup: {...}}; treat as invalid.\n        delete requestDict[\"bidiGenerateContentSetup\"];\n    }\n    const preExistingFieldMask = requestDict[\"fieldMask\"];\n    // Handle mask generation setup.\n    if (setupForMaskGeneration) {\n        const generatedMaskFromBidi = getFieldMasks(setupForMaskGeneration);\n        if (Array.isArray(config === null || config === void 0 ? void 0 : config.lockAdditionalFields) && (config === null || config === void 0 ? void 0 : config.lockAdditionalFields.length) === 0) {\n            // Case 1: lockAdditionalFields is an empty array. Lock only fields from\n            // bidi setup.\n            if (generatedMaskFromBidi) {\n                // Only assign if mask is not empty\n                requestDict[\"fieldMask\"] = generatedMaskFromBidi;\n            } else {\n                delete requestDict[\"fieldMask\"]; // If mask is empty, effectively no\n            // specific fields locked by bidi\n            }\n        } else if ((config === null || config === void 0 ? void 0 : config.lockAdditionalFields) && config.lockAdditionalFields.length > 0 && preExistingFieldMask !== null && Array.isArray(preExistingFieldMask) && preExistingFieldMask.length > 0) {\n            // Case 2: Lock fields from bidi setup + additional fields\n            // (preExistingFieldMask).\n            const generationConfigFields = [\n                \"temperature\",\n                \"topK\",\n                \"topP\",\n                \"maxOutputTokens\",\n                \"responseModalities\",\n                \"seed\",\n                \"speechConfig\"\n            ];\n            let mappedFieldsFromPreExisting = [];\n            if (preExistingFieldMask.length > 0) {\n                mappedFieldsFromPreExisting = preExistingFieldMask.map((field)=>{\n                    if (generationConfigFields.includes(field)) {\n                        return `generationConfig.${field}`;\n                    }\n                    return field; // Keep original field name if not in\n                // generationConfigFields\n                });\n            }\n            const finalMaskParts = [];\n            if (generatedMaskFromBidi) {\n                finalMaskParts.push(generatedMaskFromBidi);\n            }\n            if (mappedFieldsFromPreExisting.length > 0) {\n                finalMaskParts.push(...mappedFieldsFromPreExisting);\n            }\n            if (finalMaskParts.length > 0) {\n                requestDict[\"fieldMask\"] = finalMaskParts.join(\",\");\n            } else {\n                // If no fields from bidi and no valid additional fields from\n                // pre-existing mask.\n                delete requestDict[\"fieldMask\"];\n            }\n        } else {\n            // Case 3: \"Lock all fields\" (meaning, don't send a field_mask, let server\n            // defaults apply or all are mutable). This is hit if:\n            //  - `config.lockAdditionalFields` is undefined.\n            //  - `config.lockAdditionalFields` is non-empty, BUT\n            //  `preExistingFieldMask` is null, not a string, or an empty string.\n            delete requestDict[\"fieldMask\"];\n        }\n    } else {\n        // No valid `bidiGenerateContentSetup` was found or extracted.\n        // \"Lock additional null fields if any\".\n        if (preExistingFieldMask !== null && Array.isArray(preExistingFieldMask) && preExistingFieldMask.length > 0) {\n            // If there's a pre-existing field mask, it's a string, and it's not\n            // empty, then we should lock all fields.\n            requestDict[\"fieldMask\"] = preExistingFieldMask.join(\",\");\n        } else {\n            delete requestDict[\"fieldMask\"];\n        }\n    }\n    return requestDict;\n}\nclass Tokens extends BaseModule {\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n    }\n    /**\n     * Creates an ephemeral auth token resource.\n     *\n     * @experimental\n     *\n     * @remarks\n     * Ephemeral auth tokens is only supported in the Gemini Developer API.\n     * It can be used for the session connection to the Live constrained API.\n     * Support in v1alpha only.\n     *\n     * @param params - The parameters for the create request.\n     * @return The created auth token.\n     *\n     * @example\n     * ```ts\n     * const ai = new GoogleGenAI({\n     *     apiKey: token.name,\n     *     httpOptions: { apiVersion: 'v1alpha' }  // Support in v1alpha only.\n     * });\n     *\n     * // Case 1: If LiveEphemeralParameters is unset, unlock LiveConnectConfig\n     * // when using the token in Live API sessions. Each session connection can\n     * // use a different configuration.\n     * const config: CreateAuthTokenConfig = {\n     *     uses: 3,\n     *     expireTime: '2025-05-01T00:00:00Z',\n     * }\n     * const token = await ai.tokens.create(config);\n     *\n     * // Case 2: If LiveEphemeralParameters is set, lock all fields in\n     * // LiveConnectConfig when using the token in Live API sessions. For\n     * // example, changing `outputAudioTranscription` in the Live API\n     * // connection will be ignored by the API.\n     * const config: CreateAuthTokenConfig =\n     *     uses: 3,\n     *     expireTime: '2025-05-01T00:00:00Z',\n     *     LiveEphemeralParameters: {\n     *        model: 'gemini-2.0-flash-001',\n     *        config: {\n     *           'responseModalities': ['AUDIO'],\n     *           'systemInstruction': 'Always answer in English.',\n     *        }\n     *     }\n     * }\n     * const token = await ai.tokens.create(config);\n     *\n     * // Case 3: If LiveEphemeralParameters is set and lockAdditionalFields is\n     * // set, lock LiveConnectConfig with set and additional fields (e.g.\n     * // responseModalities, systemInstruction, temperature in this example) when\n     * // using the token in Live API sessions.\n     * const config: CreateAuthTokenConfig =\n     *     uses: 3,\n     *     expireTime: '2025-05-01T00:00:00Z',\n     *     LiveEphemeralParameters: {\n     *        model: 'gemini-2.0-flash-001',\n     *        config: {\n     *           'responseModalities': ['AUDIO'],\n     *           'systemInstruction': 'Always answer in English.',\n     *        }\n     *     },\n     *     lockAdditionalFields: ['temperature'],\n     * }\n     * const token = await ai.tokens.create(config);\n     *\n     * // Case 4: If LiveEphemeralParameters is set and lockAdditionalFields is\n     * // empty array, lock LiveConnectConfig with set fields (e.g.\n     * // responseModalities, systemInstruction in this example) when using the\n     * // token in Live API sessions.\n     * const config: CreateAuthTokenConfig =\n     *     uses: 3,\n     *     expireTime: '2025-05-01T00:00:00Z',\n     *     LiveEphemeralParameters: {\n     *        model: 'gemini-2.0-flash-001',\n     *        config: {\n     *           'responseModalities': ['AUDIO'],\n     *           'systemInstruction': 'Always answer in English.',\n     *        }\n     *     },\n     *     lockAdditionalFields: [],\n     * }\n     * const token = await ai.tokens.create(config);\n     * ```\n     */ async create(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"The client.tokens.create method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = createAuthTokenParametersToMldev(this.apiClient, params);\n            path = formatMap(\"auth_tokens\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            const transformedBody = convertBidiSetupToTokenSetup(body, params.config);\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(transformedBody),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((resp)=>{\n                return resp;\n            });\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ // Code generated by the Google Gen AI SDK generator DO NOT EDIT.\nfunction deleteDocumentConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromForce = getValueByPath(fromObject, [\n        \"force\"\n    ]);\n    if (parentObject !== undefined && fromForce != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"force\"\n        ], fromForce);\n    }\n    return toObject;\n}\nfunction deleteDocumentParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], fromName);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        deleteDocumentConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction getDocumentParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction listDocumentsConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    return toObject;\n}\nfunction listDocumentsParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromParent = getValueByPath(fromObject, [\n        \"parent\"\n    ]);\n    if (fromParent != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"parent\"\n        ], fromParent);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listDocumentsConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listDocumentsResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromDocuments = getValueByPath(fromObject, [\n        \"documents\"\n    ]);\n    if (fromDocuments != null) {\n        let transformedList = fromDocuments;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"documents\"\n        ], transformedList);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Documents extends BaseModule {\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Lists documents.\n         *\n         * @param params - The parameters for the list request.\n         * @return - A pager of documents.\n         *\n         * @example\n         * ```ts\n         * const documents = await ai.documents.list({parent:'rag_store_name', config: {'pageSize': 2}});\n         * for await (const document of documents) {\n         *   console.log(document);\n         * }\n         * ```\n         */ this.list = async (params)=>{\n            return new Pager(PagedItem.PAGED_ITEM_DOCUMENTS, (x)=>this.listInternal({\n                    parent: params.parent,\n                    config: x.config\n                }), await this.listInternal(params), params);\n        };\n    }\n    /**\n     * Gets a Document.\n     *\n     * @param params - The parameters for getting a document.\n     * @return Document.\n     */ async get(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = getDocumentParametersToMldev(params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((resp)=>{\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes a Document.\n     *\n     * @param params - The parameters for deleting a document.\n     */ async delete(params) {\n        var _a, _b;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = deleteDocumentParametersToMldev(params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            await this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = listDocumentsParametersToMldev(params);\n            path = formatMap(\"{parent}/documents\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = listDocumentsResponseFromMldev(apiResponse);\n                const typedResp = new ListDocumentsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class FileSearchStores extends BaseModule {\n    constructor(apiClient, documents = new Documents(apiClient)){\n        super();\n        this.apiClient = apiClient;\n        this.documents = documents;\n        /**\n         * Lists file search stores.\n         *\n         * @param params - The parameters for the list request.\n         * @return - A pager of file search stores.\n         *\n         * @example\n         * ```ts\n         * const fileSearchStores = await ai.fileSearchStores.list({config: {'pageSize': 2}});\n         * for await (const fileSearchStore of fileSearchStores) {\n         *   console.log(fileSearchStore);\n         * }\n         * ```\n         */ this.list = async (params = {})=>{\n            return new Pager(PagedItem.PAGED_ITEM_FILE_SEARCH_STORES, (x)=>this.listInternal(x), await this.listInternal(params), params);\n        };\n    }\n    /**\n     * Uploads a file asynchronously to a given File Search Store.\n     * This method is not available in Vertex AI.\n     * Supported upload sources:\n     * - Node.js: File path (string) or Blob object.\n     * - Browser: Blob object (e.g., File).\n     *\n     * @remarks\n     * The `mimeType` can be specified in the `config` parameter. If omitted:\n     *  - For file path (string) inputs, the `mimeType` will be inferred from the\n     *     file extension.\n     *  - For Blob object inputs, the `mimeType` will be set to the Blob's `type`\n     *     property.\n     *\n     * This section can contain multiple paragraphs and code examples.\n     *\n     * @param params - Optional parameters specified in the\n     *        `types.UploadToFileSearchStoreParameters` interface.\n     *         @see {@link types.UploadToFileSearchStoreParameters#config} for the optional\n     *         config in the parameters.\n     * @return A promise that resolves to a long running operation.\n     * @throws An error if called on a Vertex AI client.\n     * @throws An error if the `mimeType` is not provided and can not be inferred,\n     * the `mimeType` can be provided in the `params.config` parameter.\n     * @throws An error occurs if a suitable upload location cannot be established.\n     *\n     * @example\n     * The following code uploads a file to a given file search store.\n     *\n     * ```ts\n     * const operation = await ai.fileSearchStores.upload({fileSearchStoreName: 'fileSearchStores/foo-bar', file: 'file.txt', config: {\n     *   mimeType: 'text/plain',\n     * }});\n     * console.log(operation.name);\n     * ```\n     */ async uploadToFileSearchStore(params) {\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"Vertex AI does not support uploading files to a file search store.\");\n        }\n        return this.apiClient.uploadFileToFileSearchStore(params.fileSearchStoreName, params.file, params.config);\n    }\n    /**\n     * Creates a File Search Store.\n     *\n     * @param params - The parameters for creating a File Search Store.\n     * @return FileSearchStore.\n     */ async create(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = createFileSearchStoreParametersToMldev(params);\n            path = formatMap(\"fileSearchStores\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((resp)=>{\n                return resp;\n            });\n        }\n    }\n    /**\n     * Gets a File Search Store.\n     *\n     * @param params - The parameters for getting a File Search Store.\n     * @return FileSearchStore.\n     */ async get(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = getFileSearchStoreParametersToMldev(params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((resp)=>{\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes a File Search Store.\n     *\n     * @param params - The parameters for deleting a File Search Store.\n     */ async delete(params) {\n        var _a, _b;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = deleteFileSearchStoreParametersToMldev(params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            await this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = listFileSearchStoresParametersToMldev(params);\n            path = formatMap(\"fileSearchStores\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = listFileSearchStoresResponseFromMldev(apiResponse);\n                const typedResp = new ListFileSearchStoresResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    async uploadToFileSearchStoreInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = uploadToFileSearchStoreParametersToMldev(params);\n            path = formatMap(\"upload/v1beta/{file_search_store_name}:uploadToFileSearchStore\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = uploadToFileSearchStoreResumableResponseFromMldev(apiResponse);\n                const typedResp = new UploadToFileSearchStoreResumableResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Imports a File from File Service to a FileSearchStore.\n     *\n     * This is a long-running operation, see aip.dev/151\n     *\n     * @param params - The parameters for importing a file to a file search store.\n     * @return ImportFileOperation.\n     */ async importFile(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = importFileParametersToMldev(params);\n            path = formatMap(\"{file_search_store_name}:importFile\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = importFileOperationFromMldev(apiResponse);\n                const typedResp = new ImportFileOperation();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ const GOOGLE_API_KEY_HEADER = \"x-goog-api-key\";\nconst REQUIRED_VERTEX_AI_SCOPE = \"https://www.googleapis.com/auth/cloud-platform\";\nclass NodeAuth {\n    constructor(opts){\n        if (opts.apiKey !== undefined) {\n            this.apiKey = opts.apiKey;\n            return;\n        }\n        const vertexAuthOptions = buildGoogleAuthOptions(opts.googleAuthOptions);\n        this.googleAuth = new google_auth_library__WEBPACK_IMPORTED_MODULE_0__.GoogleAuth(vertexAuthOptions);\n    }\n    async addAuthHeaders(headers, url) {\n        if (this.apiKey !== undefined) {\n            if (this.apiKey.startsWith(\"auth_tokens/\")) {\n                throw new Error(\"Ephemeral tokens are only supported by the live API.\");\n            }\n            this.addKeyHeader(headers);\n            return;\n        }\n        return this.addGoogleAuthHeaders(headers, url);\n    }\n    addKeyHeader(headers) {\n        if (headers.get(GOOGLE_API_KEY_HEADER) !== null) {\n            return;\n        }\n        if (this.apiKey === undefined) {\n            // This should never happen, this method is only called\n            // when apiKey is set.\n            throw new Error(\"Trying to set API key header but apiKey is not set\");\n        }\n        headers.append(GOOGLE_API_KEY_HEADER, this.apiKey);\n    }\n    async addGoogleAuthHeaders(headers, url) {\n        if (this.googleAuth === undefined) {\n            // This should never happen, addGoogleAuthHeaders should only be\n            // called when there is no apiKey set and in these cases googleAuth\n            // is set.\n            throw new Error(\"Trying to set google-auth headers but googleAuth is unset\");\n        }\n        const authHeaders = await this.googleAuth.getRequestHeaders(url);\n        for (const [key, value] of authHeaders){\n            if (headers.get(key) !== null) {\n                continue;\n            }\n            headers.append(key, value);\n        }\n    }\n}\nfunction buildGoogleAuthOptions(googleAuthOptions) {\n    let authOptions;\n    if (!googleAuthOptions) {\n        authOptions = {\n            scopes: [\n                REQUIRED_VERTEX_AI_SCOPE\n            ]\n        };\n        return authOptions;\n    } else {\n        authOptions = googleAuthOptions;\n        if (!authOptions.scopes) {\n            authOptions.scopes = [\n                REQUIRED_VERTEX_AI_SCOPE\n            ];\n            return authOptions;\n        } else if (typeof authOptions.scopes === \"string\" && authOptions.scopes !== REQUIRED_VERTEX_AI_SCOPE || Array.isArray(authOptions.scopes) && authOptions.scopes.indexOf(REQUIRED_VERTEX_AI_SCOPE) < 0) {\n            throw new Error(`Invalid auth scopes. Scopes must include: ${REQUIRED_VERTEX_AI_SCOPE}`);\n        }\n        return authOptions;\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class NodeDownloader {\n    async download(params, apiClient) {\n        if (params.downloadPath) {\n            const response = await downloadFile(params, apiClient);\n            if (response instanceof HttpResponse) {\n                const writer = (0,fs__WEBPACK_IMPORTED_MODULE_1__.createWriteStream)(params.downloadPath);\n                const body = node_stream__WEBPACK_IMPORTED_MODULE_3__.Readable.fromWeb(response.responseInternal.body);\n                body.pipe(writer);\n                await (0,node_stream_promises__WEBPACK_IMPORTED_MODULE_4__.finished)(writer);\n            } else {\n                try {\n                    await (0,fs_promises__WEBPACK_IMPORTED_MODULE_2__.writeFile)(params.downloadPath, response, {\n                        encoding: \"base64\"\n                    });\n                } catch (error) {\n                    throw new Error(`Failed to write file to ${params.downloadPath}: ${error}`);\n                }\n            }\n        }\n    }\n}\nasync function downloadFile(params, apiClient) {\n    var _a, _b, _c;\n    const name = tFileName(params.file);\n    if (name !== undefined) {\n        return await apiClient.request({\n            path: `files/${name}:download`,\n            httpMethod: \"GET\",\n            queryParams: {\n                \"alt\": \"media\"\n            },\n            httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n        });\n    } else if (isGeneratedVideo(params.file)) {\n        const videoBytes = (_c = params.file.video) === null || _c === void 0 ? void 0 : _c.videoBytes;\n        if (typeof videoBytes === \"string\") {\n            return videoBytes;\n        } else {\n            throw new Error(\"Failed to download generated video, Uri or videoBytes not found.\");\n        }\n    } else if (isVideo(params.file)) {\n        const videoBytes = params.file.videoBytes;\n        if (typeof videoBytes === \"string\") {\n            return videoBytes;\n        } else {\n            throw new Error(\"Failed to download video, Uri or videoBytes not found.\");\n        }\n    } else {\n        throw new Error(\"Unsupported file type\");\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class NodeWebSocketFactory {\n    create(url, headers, callbacks) {\n        return new NodeWebSocket(url, headers, callbacks);\n    }\n}\nclass NodeWebSocket {\n    constructor(url, headers, callbacks){\n        this.url = url;\n        this.headers = headers;\n        this.callbacks = callbacks;\n    }\n    connect() {\n        this.ws = new ws__WEBPACK_IMPORTED_MODULE_5__.WebSocket(this.url, {\n            headers: this.headers\n        });\n        this.ws.onopen = this.callbacks.onopen;\n        this.ws.onerror = this.callbacks.onerror;\n        this.ws.onclose = this.callbacks.onclose;\n        this.ws.onmessage = this.callbacks.onmessage;\n    }\n    send(message) {\n        if (this.ws === undefined) {\n            throw new Error(\"WebSocket is not connected\");\n        }\n        this.ws.send(message);\n    }\n    close() {\n        if (this.ws === undefined) {\n            throw new Error(\"WebSocket is not connected\");\n        }\n        this.ws.close();\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ // Code generated by the Google Gen AI SDK generator DO NOT EDIT.\nfunction cancelTuningJobParametersToMldev(fromObject, _rootObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction cancelTuningJobParametersToVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction cancelTuningJobResponseFromMldev(fromObject, _rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction cancelTuningJobResponseFromVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction createTuningJobConfigToMldev(fromObject, parentObject, _rootObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"validationDataset\"\n    ]) !== undefined) {\n        throw new Error(\"validationDataset parameter is not supported in Gemini API.\");\n    }\n    const fromTunedModelDisplayName = getValueByPath(fromObject, [\n        \"tunedModelDisplayName\"\n    ]);\n    if (parentObject !== undefined && fromTunedModelDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromTunedModelDisplayName);\n    }\n    if (getValueByPath(fromObject, [\n        \"description\"\n    ]) !== undefined) {\n        throw new Error(\"description parameter is not supported in Gemini API.\");\n    }\n    const fromEpochCount = getValueByPath(fromObject, [\n        \"epochCount\"\n    ]);\n    if (parentObject !== undefined && fromEpochCount != null) {\n        setValueByPath(parentObject, [\n            \"tuningTask\",\n            \"hyperparameters\",\n            \"epochCount\"\n        ], fromEpochCount);\n    }\n    const fromLearningRateMultiplier = getValueByPath(fromObject, [\n        \"learningRateMultiplier\"\n    ]);\n    if (fromLearningRateMultiplier != null) {\n        setValueByPath(toObject, [\n            \"tuningTask\",\n            \"hyperparameters\",\n            \"learningRateMultiplier\"\n        ], fromLearningRateMultiplier);\n    }\n    if (getValueByPath(fromObject, [\n        \"exportLastCheckpointOnly\"\n    ]) !== undefined) {\n        throw new Error(\"exportLastCheckpointOnly parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"preTunedModelCheckpointId\"\n    ]) !== undefined) {\n        throw new Error(\"preTunedModelCheckpointId parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"adapterSize\"\n    ]) !== undefined) {\n        throw new Error(\"adapterSize parameter is not supported in Gemini API.\");\n    }\n    const fromBatchSize = getValueByPath(fromObject, [\n        \"batchSize\"\n    ]);\n    if (parentObject !== undefined && fromBatchSize != null) {\n        setValueByPath(parentObject, [\n            \"tuningTask\",\n            \"hyperparameters\",\n            \"batchSize\"\n        ], fromBatchSize);\n    }\n    const fromLearningRate = getValueByPath(fromObject, [\n        \"learningRate\"\n    ]);\n    if (parentObject !== undefined && fromLearningRate != null) {\n        setValueByPath(parentObject, [\n            \"tuningTask\",\n            \"hyperparameters\",\n            \"learningRate\"\n        ], fromLearningRate);\n    }\n    if (getValueByPath(fromObject, [\n        \"labels\"\n    ]) !== undefined) {\n        throw new Error(\"labels parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"beta\"\n    ]) !== undefined) {\n        throw new Error(\"beta parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction createTuningJobConfigToVertex(fromObject, parentObject, rootObject) {\n    const toObject = {};\n    let discriminatorValidationDataset = getValueByPath(rootObject, [\n        \"config\",\n        \"method\"\n    ]);\n    if (discriminatorValidationDataset === undefined) {\n        discriminatorValidationDataset = \"SUPERVISED_FINE_TUNING\";\n    }\n    if (discriminatorValidationDataset === \"SUPERVISED_FINE_TUNING\") {\n        const fromValidationDataset = getValueByPath(fromObject, [\n            \"validationDataset\"\n        ]);\n        if (parentObject !== undefined && fromValidationDataset != null) {\n            setValueByPath(parentObject, [\n                \"supervisedTuningSpec\"\n            ], tuningValidationDatasetToVertex(fromValidationDataset));\n        }\n    } else if (discriminatorValidationDataset === \"PREFERENCE_TUNING\") {\n        const fromValidationDataset = getValueByPath(fromObject, [\n            \"validationDataset\"\n        ]);\n        if (parentObject !== undefined && fromValidationDataset != null) {\n            setValueByPath(parentObject, [\n                \"preferenceOptimizationSpec\"\n            ], tuningValidationDatasetToVertex(fromValidationDataset));\n        }\n    }\n    const fromTunedModelDisplayName = getValueByPath(fromObject, [\n        \"tunedModelDisplayName\"\n    ]);\n    if (parentObject !== undefined && fromTunedModelDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"tunedModelDisplayName\"\n        ], fromTunedModelDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (parentObject !== undefined && fromDescription != null) {\n        setValueByPath(parentObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    let discriminatorEpochCount = getValueByPath(rootObject, [\n        \"config\",\n        \"method\"\n    ]);\n    if (discriminatorEpochCount === undefined) {\n        discriminatorEpochCount = \"SUPERVISED_FINE_TUNING\";\n    }\n    if (discriminatorEpochCount === \"SUPERVISED_FINE_TUNING\") {\n        const fromEpochCount = getValueByPath(fromObject, [\n            \"epochCount\"\n        ]);\n        if (parentObject !== undefined && fromEpochCount != null) {\n            setValueByPath(parentObject, [\n                \"supervisedTuningSpec\",\n                \"hyperParameters\",\n                \"epochCount\"\n            ], fromEpochCount);\n        }\n    } else if (discriminatorEpochCount === \"PREFERENCE_TUNING\") {\n        const fromEpochCount = getValueByPath(fromObject, [\n            \"epochCount\"\n        ]);\n        if (parentObject !== undefined && fromEpochCount != null) {\n            setValueByPath(parentObject, [\n                \"preferenceOptimizationSpec\",\n                \"hyperParameters\",\n                \"epochCount\"\n            ], fromEpochCount);\n        }\n    }\n    let discriminatorLearningRateMultiplier = getValueByPath(rootObject, [\n        \"config\",\n        \"method\"\n    ]);\n    if (discriminatorLearningRateMultiplier === undefined) {\n        discriminatorLearningRateMultiplier = \"SUPERVISED_FINE_TUNING\";\n    }\n    if (discriminatorLearningRateMultiplier === \"SUPERVISED_FINE_TUNING\") {\n        const fromLearningRateMultiplier = getValueByPath(fromObject, [\n            \"learningRateMultiplier\"\n        ]);\n        if (parentObject !== undefined && fromLearningRateMultiplier != null) {\n            setValueByPath(parentObject, [\n                \"supervisedTuningSpec\",\n                \"hyperParameters\",\n                \"learningRateMultiplier\"\n            ], fromLearningRateMultiplier);\n        }\n    } else if (discriminatorLearningRateMultiplier === \"PREFERENCE_TUNING\") {\n        const fromLearningRateMultiplier = getValueByPath(fromObject, [\n            \"learningRateMultiplier\"\n        ]);\n        if (parentObject !== undefined && fromLearningRateMultiplier != null) {\n            setValueByPath(parentObject, [\n                \"preferenceOptimizationSpec\",\n                \"hyperParameters\",\n                \"learningRateMultiplier\"\n            ], fromLearningRateMultiplier);\n        }\n    }\n    let discriminatorExportLastCheckpointOnly = getValueByPath(rootObject, [\n        \"config\",\n        \"method\"\n    ]);\n    if (discriminatorExportLastCheckpointOnly === undefined) {\n        discriminatorExportLastCheckpointOnly = \"SUPERVISED_FINE_TUNING\";\n    }\n    if (discriminatorExportLastCheckpointOnly === \"SUPERVISED_FINE_TUNING\") {\n        const fromExportLastCheckpointOnly = getValueByPath(fromObject, [\n            \"exportLastCheckpointOnly\"\n        ]);\n        if (parentObject !== undefined && fromExportLastCheckpointOnly != null) {\n            setValueByPath(parentObject, [\n                \"supervisedTuningSpec\",\n                \"exportLastCheckpointOnly\"\n            ], fromExportLastCheckpointOnly);\n        }\n    } else if (discriminatorExportLastCheckpointOnly === \"PREFERENCE_TUNING\") {\n        const fromExportLastCheckpointOnly = getValueByPath(fromObject, [\n            \"exportLastCheckpointOnly\"\n        ]);\n        if (parentObject !== undefined && fromExportLastCheckpointOnly != null) {\n            setValueByPath(parentObject, [\n                \"preferenceOptimizationSpec\",\n                \"exportLastCheckpointOnly\"\n            ], fromExportLastCheckpointOnly);\n        }\n    }\n    let discriminatorAdapterSize = getValueByPath(rootObject, [\n        \"config\",\n        \"method\"\n    ]);\n    if (discriminatorAdapterSize === undefined) {\n        discriminatorAdapterSize = \"SUPERVISED_FINE_TUNING\";\n    }\n    if (discriminatorAdapterSize === \"SUPERVISED_FINE_TUNING\") {\n        const fromAdapterSize = getValueByPath(fromObject, [\n            \"adapterSize\"\n        ]);\n        if (parentObject !== undefined && fromAdapterSize != null) {\n            setValueByPath(parentObject, [\n                \"supervisedTuningSpec\",\n                \"hyperParameters\",\n                \"adapterSize\"\n            ], fromAdapterSize);\n        }\n    } else if (discriminatorAdapterSize === \"PREFERENCE_TUNING\") {\n        const fromAdapterSize = getValueByPath(fromObject, [\n            \"adapterSize\"\n        ]);\n        if (parentObject !== undefined && fromAdapterSize != null) {\n            setValueByPath(parentObject, [\n                \"preferenceOptimizationSpec\",\n                \"hyperParameters\",\n                \"adapterSize\"\n            ], fromAdapterSize);\n        }\n    }\n    if (getValueByPath(fromObject, [\n        \"batchSize\"\n    ]) !== undefined) {\n        throw new Error(\"batchSize parameter is not supported in Vertex AI.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"learningRate\"\n    ]) !== undefined) {\n        throw new Error(\"learningRate parameter is not supported in Vertex AI.\");\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    const fromBeta = getValueByPath(fromObject, [\n        \"beta\"\n    ]);\n    if (parentObject !== undefined && fromBeta != null) {\n        setValueByPath(parentObject, [\n            \"preferenceOptimizationSpec\",\n            \"hyperParameters\",\n            \"beta\"\n        ], fromBeta);\n    }\n    return toObject;\n}\nfunction createTuningJobParametersPrivateToMldev(fromObject, rootObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, [\n        \"baseModel\"\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, [\n            \"baseModel\"\n        ], fromBaseModel);\n    }\n    const fromPreTunedModel = getValueByPath(fromObject, [\n        \"preTunedModel\"\n    ]);\n    if (fromPreTunedModel != null) {\n        setValueByPath(toObject, [\n            \"preTunedModel\"\n        ], fromPreTunedModel);\n    }\n    const fromTrainingDataset = getValueByPath(fromObject, [\n        \"trainingDataset\"\n    ]);\n    if (fromTrainingDataset != null) {\n        tuningDatasetToMldev(fromTrainingDataset);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        createTuningJobConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction createTuningJobParametersPrivateToVertex(fromObject, rootObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, [\n        \"baseModel\"\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, [\n            \"baseModel\"\n        ], fromBaseModel);\n    }\n    const fromPreTunedModel = getValueByPath(fromObject, [\n        \"preTunedModel\"\n    ]);\n    if (fromPreTunedModel != null) {\n        setValueByPath(toObject, [\n            \"preTunedModel\"\n        ], fromPreTunedModel);\n    }\n    const fromTrainingDataset = getValueByPath(fromObject, [\n        \"trainingDataset\"\n    ]);\n    if (fromTrainingDataset != null) {\n        tuningDatasetToVertex(fromTrainingDataset, toObject, rootObject);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        createTuningJobConfigToVertex(fromConfig, toObject, rootObject);\n    }\n    return toObject;\n}\nfunction getTuningJobParametersToMldev(fromObject, _rootObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction getTuningJobParametersToVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction listTuningJobsConfigToMldev(fromObject, parentObject, _rootObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, [\n        \"filter\"\n    ]);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"filter\"\n        ], fromFilter);\n    }\n    return toObject;\n}\nfunction listTuningJobsConfigToVertex(fromObject, parentObject, _rootObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, [\n        \"filter\"\n    ]);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"filter\"\n        ], fromFilter);\n    }\n    return toObject;\n}\nfunction listTuningJobsParametersToMldev(fromObject, rootObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listTuningJobsConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listTuningJobsParametersToVertex(fromObject, rootObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listTuningJobsConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listTuningJobsResponseFromMldev(fromObject, rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromTuningJobs = getValueByPath(fromObject, [\n        \"tunedModels\"\n    ]);\n    if (fromTuningJobs != null) {\n        let transformedList = fromTuningJobs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return tuningJobFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"tuningJobs\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction listTuningJobsResponseFromVertex(fromObject, rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromTuningJobs = getValueByPath(fromObject, [\n        \"tuningJobs\"\n    ]);\n    if (fromTuningJobs != null) {\n        let transformedList = fromTuningJobs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return tuningJobFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"tuningJobs\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction tunedModelFromMldev(fromObject, _rootObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], fromModel);\n    }\n    const fromEndpoint = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromEndpoint != null) {\n        setValueByPath(toObject, [\n            \"endpoint\"\n        ], fromEndpoint);\n    }\n    return toObject;\n}\nfunction tuningDatasetToMldev(fromObject, _rootObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]) !== undefined) {\n        throw new Error(\"gcsUri parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"vertexDatasetResource\"\n    ]) !== undefined) {\n        throw new Error(\"vertexDatasetResource parameter is not supported in Gemini API.\");\n    }\n    const fromExamples = getValueByPath(fromObject, [\n        \"examples\"\n    ]);\n    if (fromExamples != null) {\n        let transformedList = fromExamples;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"examples\",\n            \"examples\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction tuningDatasetToVertex(fromObject, parentObject, rootObject) {\n    const toObject = {};\n    let discriminatorGcsUri = getValueByPath(rootObject, [\n        \"config\",\n        \"method\"\n    ]);\n    if (discriminatorGcsUri === undefined) {\n        discriminatorGcsUri = \"SUPERVISED_FINE_TUNING\";\n    }\n    if (discriminatorGcsUri === \"SUPERVISED_FINE_TUNING\") {\n        const fromGcsUri = getValueByPath(fromObject, [\n            \"gcsUri\"\n        ]);\n        if (parentObject !== undefined && fromGcsUri != null) {\n            setValueByPath(parentObject, [\n                \"supervisedTuningSpec\",\n                \"trainingDatasetUri\"\n            ], fromGcsUri);\n        }\n    } else if (discriminatorGcsUri === \"PREFERENCE_TUNING\") {\n        const fromGcsUri = getValueByPath(fromObject, [\n            \"gcsUri\"\n        ]);\n        if (parentObject !== undefined && fromGcsUri != null) {\n            setValueByPath(parentObject, [\n                \"preferenceOptimizationSpec\",\n                \"trainingDatasetUri\"\n            ], fromGcsUri);\n        }\n    }\n    let discriminatorVertexDatasetResource = getValueByPath(rootObject, [\n        \"config\",\n        \"method\"\n    ]);\n    if (discriminatorVertexDatasetResource === undefined) {\n        discriminatorVertexDatasetResource = \"SUPERVISED_FINE_TUNING\";\n    }\n    if (discriminatorVertexDatasetResource === \"SUPERVISED_FINE_TUNING\") {\n        const fromVertexDatasetResource = getValueByPath(fromObject, [\n            \"vertexDatasetResource\"\n        ]);\n        if (parentObject !== undefined && fromVertexDatasetResource != null) {\n            setValueByPath(parentObject, [\n                \"supervisedTuningSpec\",\n                \"trainingDatasetUri\"\n            ], fromVertexDatasetResource);\n        }\n    } else if (discriminatorVertexDatasetResource === \"PREFERENCE_TUNING\") {\n        const fromVertexDatasetResource = getValueByPath(fromObject, [\n            \"vertexDatasetResource\"\n        ]);\n        if (parentObject !== undefined && fromVertexDatasetResource != null) {\n            setValueByPath(parentObject, [\n                \"preferenceOptimizationSpec\",\n                \"trainingDatasetUri\"\n            ], fromVertexDatasetResource);\n        }\n    }\n    if (getValueByPath(fromObject, [\n        \"examples\"\n    ]) !== undefined) {\n        throw new Error(\"examples parameter is not supported in Vertex AI.\");\n    }\n    return toObject;\n}\nfunction tuningJobFromMldev(fromObject, rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromState = getValueByPath(fromObject, [\n        \"state\"\n    ]);\n    if (fromState != null) {\n        setValueByPath(toObject, [\n            \"state\"\n        ], tTuningJobStatus(fromState));\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromStartTime = getValueByPath(fromObject, [\n        \"tuningTask\",\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"tuningTask\",\n        \"completeTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromBaseModel = getValueByPath(fromObject, [\n        \"baseModel\"\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, [\n            \"baseModel\"\n        ], fromBaseModel);\n    }\n    const fromTunedModel = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromTunedModel != null) {\n        setValueByPath(toObject, [\n            \"tunedModel\"\n        ], tunedModelFromMldev(fromTunedModel));\n    }\n    return toObject;\n}\nfunction tuningJobFromVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromState = getValueByPath(fromObject, [\n        \"state\"\n    ]);\n    if (fromState != null) {\n        setValueByPath(toObject, [\n            \"state\"\n        ], tTuningJobStatus(fromState));\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromStartTime = getValueByPath(fromObject, [\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromBaseModel = getValueByPath(fromObject, [\n        \"baseModel\"\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, [\n            \"baseModel\"\n        ], fromBaseModel);\n    }\n    const fromTunedModel = getValueByPath(fromObject, [\n        \"tunedModel\"\n    ]);\n    if (fromTunedModel != null) {\n        setValueByPath(toObject, [\n            \"tunedModel\"\n        ], fromTunedModel);\n    }\n    const fromPreTunedModel = getValueByPath(fromObject, [\n        \"preTunedModel\"\n    ]);\n    if (fromPreTunedModel != null) {\n        setValueByPath(toObject, [\n            \"preTunedModel\"\n        ], fromPreTunedModel);\n    }\n    const fromSupervisedTuningSpec = getValueByPath(fromObject, [\n        \"supervisedTuningSpec\"\n    ]);\n    if (fromSupervisedTuningSpec != null) {\n        setValueByPath(toObject, [\n            \"supervisedTuningSpec\"\n        ], fromSupervisedTuningSpec);\n    }\n    const fromPreferenceOptimizationSpec = getValueByPath(fromObject, [\n        \"preferenceOptimizationSpec\"\n    ]);\n    if (fromPreferenceOptimizationSpec != null) {\n        setValueByPath(toObject, [\n            \"preferenceOptimizationSpec\"\n        ], fromPreferenceOptimizationSpec);\n    }\n    const fromTuningDataStats = getValueByPath(fromObject, [\n        \"tuningDataStats\"\n    ]);\n    if (fromTuningDataStats != null) {\n        setValueByPath(toObject, [\n            \"tuningDataStats\"\n        ], fromTuningDataStats);\n    }\n    const fromEncryptionSpec = getValueByPath(fromObject, [\n        \"encryptionSpec\"\n    ]);\n    if (fromEncryptionSpec != null) {\n        setValueByPath(toObject, [\n            \"encryptionSpec\"\n        ], fromEncryptionSpec);\n    }\n    const fromPartnerModelTuningSpec = getValueByPath(fromObject, [\n        \"partnerModelTuningSpec\"\n    ]);\n    if (fromPartnerModelTuningSpec != null) {\n        setValueByPath(toObject, [\n            \"partnerModelTuningSpec\"\n        ], fromPartnerModelTuningSpec);\n    }\n    const fromCustomBaseModel = getValueByPath(fromObject, [\n        \"customBaseModel\"\n    ]);\n    if (fromCustomBaseModel != null) {\n        setValueByPath(toObject, [\n            \"customBaseModel\"\n        ], fromCustomBaseModel);\n    }\n    const fromExperiment = getValueByPath(fromObject, [\n        \"experiment\"\n    ]);\n    if (fromExperiment != null) {\n        setValueByPath(toObject, [\n            \"experiment\"\n        ], fromExperiment);\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (fromLabels != null) {\n        setValueByPath(toObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    const fromOutputUri = getValueByPath(fromObject, [\n        \"outputUri\"\n    ]);\n    if (fromOutputUri != null) {\n        setValueByPath(toObject, [\n            \"outputUri\"\n        ], fromOutputUri);\n    }\n    const fromPipelineJob = getValueByPath(fromObject, [\n        \"pipelineJob\"\n    ]);\n    if (fromPipelineJob != null) {\n        setValueByPath(toObject, [\n            \"pipelineJob\"\n        ], fromPipelineJob);\n    }\n    const fromServiceAccount = getValueByPath(fromObject, [\n        \"serviceAccount\"\n    ]);\n    if (fromServiceAccount != null) {\n        setValueByPath(toObject, [\n            \"serviceAccount\"\n        ], fromServiceAccount);\n    }\n    const fromTunedModelDisplayName = getValueByPath(fromObject, [\n        \"tunedModelDisplayName\"\n    ]);\n    if (fromTunedModelDisplayName != null) {\n        setValueByPath(toObject, [\n            \"tunedModelDisplayName\"\n        ], fromTunedModelDisplayName);\n    }\n    const fromVeoTuningSpec = getValueByPath(fromObject, [\n        \"veoTuningSpec\"\n    ]);\n    if (fromVeoTuningSpec != null) {\n        setValueByPath(toObject, [\n            \"veoTuningSpec\"\n        ], fromVeoTuningSpec);\n    }\n    return toObject;\n}\nfunction tuningOperationFromMldev(fromObject, _rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    return toObject;\n}\nfunction tuningValidationDatasetToVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"validationDatasetUri\"\n        ], fromGcsUri);\n    }\n    const fromVertexDatasetResource = getValueByPath(fromObject, [\n        \"vertexDatasetResource\"\n    ]);\n    if (fromVertexDatasetResource != null) {\n        setValueByPath(toObject, [\n            \"validationDatasetUri\"\n        ], fromVertexDatasetResource);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Tunings extends BaseModule {\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Lists tuning jobs.\n         *\n         * @param params - The parameters for the list request.\n         * @return - A pager of tuning jobs.\n         *\n         * @example\n         * ```ts\n         * const tuningJobs = await ai.tunings.list({config: {'pageSize': 2}});\n         * for await (const tuningJob of tuningJobs) {\n         *   console.log(tuningJob);\n         * }\n         * ```\n         */ this.list = async (params = {})=>{\n            return new Pager(PagedItem.PAGED_ITEM_TUNING_JOBS, (x)=>this.listInternal(x), await this.listInternal(params), params);\n        };\n        /**\n         * Gets a TuningJob.\n         *\n         * @param name - The resource name of the tuning job.\n         * @return - A TuningJob object.\n         *\n         * @experimental - The SDK's tuning implementation is experimental, and may\n         * change in future versions.\n         */ this.get = async (params)=>{\n            return await this.getInternal(params);\n        };\n        /**\n         * Creates a supervised fine-tuning job.\n         *\n         * @param params - The parameters for the tuning job.\n         * @return - A TuningJob operation.\n         *\n         * @experimental - The SDK's tuning implementation is experimental, and may\n         * change in future versions.\n         */ this.tune = async (params)=>{\n            var _a;\n            if (this.apiClient.isVertexAI()) {\n                if (params.baseModel.startsWith(\"projects/\")) {\n                    const preTunedModel = {\n                        tunedModelName: params.baseModel\n                    };\n                    if ((_a = params.config) === null || _a === void 0 ? void 0 : _a.preTunedModelCheckpointId) {\n                        preTunedModel.checkpointId = params.config.preTunedModelCheckpointId;\n                    }\n                    const paramsPrivate = Object.assign(Object.assign({}, params), {\n                        preTunedModel: preTunedModel\n                    });\n                    paramsPrivate.baseModel = undefined;\n                    return await this.tuneInternal(paramsPrivate);\n                } else {\n                    const paramsPrivate = Object.assign({}, params);\n                    return await this.tuneInternal(paramsPrivate);\n                }\n            } else {\n                const paramsPrivate = Object.assign({}, params);\n                const operation = await this.tuneMldevInternal(paramsPrivate);\n                let tunedModelName = \"\";\n                if (operation[\"metadata\"] !== undefined && operation[\"metadata\"][\"tunedModel\"] !== undefined) {\n                    tunedModelName = operation[\"metadata\"][\"tunedModel\"];\n                } else if (operation[\"name\"] !== undefined && operation[\"name\"].includes(\"/operations/\")) {\n                    tunedModelName = operation[\"name\"].split(\"/operations/\")[0];\n                }\n                const tuningJob = {\n                    name: tunedModelName,\n                    state: JobState.JOB_STATE_QUEUED\n                };\n                return tuningJob;\n            }\n        };\n    }\n    async getInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getTuningJobParametersToVertex(params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = tuningJobFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = getTuningJobParametersToMldev(params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = tuningJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = listTuningJobsParametersToVertex(params);\n            path = formatMap(\"tuningJobs\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listTuningJobsResponseFromVertex(apiResponse);\n                const typedResp = new ListTuningJobsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = listTuningJobsParametersToMldev(params);\n            path = formatMap(\"tunedModels\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listTuningJobsResponseFromMldev(apiResponse);\n                const typedResp = new ListTuningJobsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Cancels a tuning job.\n     *\n     * @param params - The parameters for the cancel request.\n     * @return The empty response returned by the API.\n     *\n     * @example\n     * ```ts\n     * await ai.tunings.cancel({name: '...'}); // The server-generated resource name.\n     * ```\n     */ async cancel(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = cancelTuningJobParametersToVertex(params);\n            path = formatMap(\"{name}:cancel\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = cancelTuningJobResponseFromVertex(apiResponse);\n                const typedResp = new CancelTuningJobResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = cancelTuningJobParametersToMldev(params);\n            path = formatMap(\"{name}:cancel\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = cancelTuningJobResponseFromMldev(apiResponse);\n                const typedResp = new CancelTuningJobResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    async tuneInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = createTuningJobParametersPrivateToVertex(params, params);\n            path = formatMap(\"tuningJobs\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = tuningJobFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n    async tuneMldevInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = createTuningJobParametersPrivateToMldev(params);\n            path = formatMap(\"tunedModels\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = tuningOperationFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n}\nconst MAX_CHUNK_SIZE = 1024 * 1024 * 8; // bytes\nconst MAX_RETRY_COUNT = 3;\nconst INITIAL_RETRY_DELAY_MS = 1000;\nconst DELAY_MULTIPLIER = 2;\nconst X_GOOG_UPLOAD_STATUS_HEADER_FIELD = \"x-goog-upload-status\";\nasync function uploadBlob(file, uploadUrl, apiClient) {\n    var _a;\n    const response = await uploadBlobInternal(file, uploadUrl, apiClient);\n    const responseJson = await (response === null || response === void 0 ? void 0 : response.json());\n    if (((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== \"final\") {\n        throw new Error(\"Failed to upload file: Upload status is not finalized.\");\n    }\n    return responseJson[\"file\"];\n}\nasync function uploadBlobToFileSearchStore(file, uploadUrl, apiClient) {\n    var _a;\n    const response = await uploadBlobInternal(file, uploadUrl, apiClient);\n    const responseJson = await (response === null || response === void 0 ? void 0 : response.json());\n    if (((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== \"final\") {\n        throw new Error(\"Failed to upload file: Upload status is not finalized.\");\n    }\n    const resp = uploadToFileSearchStoreOperationFromMldev(responseJson);\n    const typedResp = new UploadToFileSearchStoreOperation();\n    Object.assign(typedResp, resp);\n    return typedResp;\n}\nasync function uploadBlobInternal(file, uploadUrl, apiClient) {\n    var _a, _b;\n    let fileSize = 0;\n    let offset = 0;\n    let response = new HttpResponse(new Response());\n    let uploadCommand = \"upload\";\n    fileSize = file.size;\n    while(offset < fileSize){\n        const chunkSize = Math.min(MAX_CHUNK_SIZE, fileSize - offset);\n        const chunk = file.slice(offset, offset + chunkSize);\n        if (offset + chunkSize >= fileSize) {\n            uploadCommand += \", finalize\";\n        }\n        let retryCount = 0;\n        let currentDelayMs = INITIAL_RETRY_DELAY_MS;\n        while(retryCount < MAX_RETRY_COUNT){\n            response = await apiClient.request({\n                path: \"\",\n                body: chunk,\n                httpMethod: \"POST\",\n                httpOptions: {\n                    apiVersion: \"\",\n                    baseUrl: uploadUrl,\n                    headers: {\n                        \"X-Goog-Upload-Command\": uploadCommand,\n                        \"X-Goog-Upload-Offset\": String(offset),\n                        \"Content-Length\": String(chunkSize)\n                    }\n                }\n            });\n            if ((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) {\n                break;\n            }\n            retryCount++;\n            await sleep(currentDelayMs);\n            currentDelayMs = currentDelayMs * DELAY_MULTIPLIER;\n        }\n        offset += chunkSize;\n        // The `x-goog-upload-status` header field can be `active`, `final` and\n        //`cancelled` in resposne.\n        if (((_b = response === null || response === void 0 ? void 0 : response.headers) === null || _b === void 0 ? void 0 : _b[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== \"active\") {\n            break;\n        }\n        // TODO(b/401391430) Investigate why the upload status is not finalized\n        // even though all content has been uploaded.\n        if (fileSize <= offset) {\n            throw new Error(\"All content has been uploaded, but the upload status is not finalized.\");\n        }\n    }\n    return response;\n}\nasync function getBlobStat(file) {\n    const fileStat = {\n        size: file.size,\n        type: file.type\n    };\n    return fileStat;\n}\nfunction sleep(ms) {\n    return new Promise((resolvePromise)=>setTimeout(resolvePromise, ms));\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class NodeUploader {\n    async stat(file) {\n        const fileStat = {\n            size: 0,\n            type: undefined\n        };\n        if (typeof file === \"string\") {\n            const originalStat = await fs_promises__WEBPACK_IMPORTED_MODULE_2__.stat(file);\n            fileStat.size = originalStat.size;\n            fileStat.type = this.inferMimeType(file);\n            return fileStat;\n        } else {\n            return await getBlobStat(file);\n        }\n    }\n    async upload(file, uploadUrl, apiClient) {\n        if (typeof file === \"string\") {\n            return await this.uploadFileFromPath(file, uploadUrl, apiClient);\n        } else {\n            return uploadBlob(file, uploadUrl, apiClient);\n        }\n    }\n    async uploadToFileSearchStore(file, uploadUrl, apiClient) {\n        if (typeof file === \"string\") {\n            return await this.uploadFileToFileSearchStoreFromPath(file, uploadUrl, apiClient);\n        } else {\n            return uploadBlobToFileSearchStore(file, uploadUrl, apiClient);\n        }\n    }\n    /**\n     * Infers the MIME type of a file based on its extension.\n     *\n     * @param filePath The path to the file.\n     * @returns The MIME type of the file, or undefined if it cannot be inferred.\n     */ inferMimeType(filePath) {\n        // Get the file extension.\n        const fileExtension = filePath.slice(filePath.lastIndexOf(\".\") + 1);\n        // Create a map of file extensions to MIME types.\n        const mimeTypes = {\n            \"aac\": \"audio/aac\",\n            \"abw\": \"application/x-abiword\",\n            \"arc\": \"application/x-freearc\",\n            \"avi\": \"video/x-msvideo\",\n            \"azw\": \"application/vnd.amazon.ebook\",\n            \"bin\": \"application/octet-stream\",\n            \"bmp\": \"image/bmp\",\n            \"bz\": \"application/x-bzip\",\n            \"bz2\": \"application/x-bzip2\",\n            \"csh\": \"application/x-csh\",\n            \"css\": \"text/css\",\n            \"csv\": \"text/csv\",\n            \"doc\": \"application/msword\",\n            \"docx\": \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\",\n            \"eot\": \"application/vnd.ms-fontobject\",\n            \"epub\": \"application/epub+zip\",\n            \"gz\": \"application/gzip\",\n            \"gif\": \"image/gif\",\n            \"htm\": \"text/html\",\n            \"html\": \"text/html\",\n            \"ico\": \"image/vnd.microsoft.icon\",\n            \"ics\": \"text/calendar\",\n            \"jar\": \"application/java-archive\",\n            \"jpeg\": \"image/jpeg\",\n            \"jpg\": \"image/jpeg\",\n            \"js\": \"text/javascript\",\n            \"json\": \"application/json\",\n            \"jsonld\": \"application/ld+json\",\n            \"kml\": \"application/vnd.google-earth.kml+xml\",\n            \"kmz\": \"application/vnd.google-earth.kmz+xml\",\n            \"mjs\": \"text/javascript\",\n            \"mp3\": \"audio/mpeg\",\n            \"mp4\": \"video/mp4\",\n            \"mpeg\": \"video/mpeg\",\n            \"mpkg\": \"application/vnd.apple.installer+xml\",\n            \"odt\": \"application/vnd.oasis.opendocument.text\",\n            \"oga\": \"audio/ogg\",\n            \"ogv\": \"video/ogg\",\n            \"ogx\": \"application/ogg\",\n            \"opus\": \"audio/opus\",\n            \"otf\": \"font/otf\",\n            \"png\": \"image/png\",\n            \"pdf\": \"application/pdf\",\n            \"php\": \"application/x-httpd-php\",\n            \"ppt\": \"application/vnd.ms-powerpoint\",\n            \"pptx\": \"application/vnd.openxmlformats-officedocument.presentationml.presentation\",\n            \"rar\": \"application/vnd.rar\",\n            \"rtf\": \"application/rtf\",\n            \"sh\": \"application/x-sh\",\n            \"svg\": \"image/svg+xml\",\n            \"swf\": \"application/x-shockwave-flash\",\n            \"tar\": \"application/x-tar\",\n            \"tif\": \"image/tiff\",\n            \"tiff\": \"image/tiff\",\n            \"ts\": \"video/mp2t\",\n            \"ttf\": \"font/ttf\",\n            \"txt\": \"text/plain\",\n            \"vsd\": \"application/vnd.visio\",\n            \"wav\": \"audio/wav\",\n            \"weba\": \"audio/webm\",\n            \"webm\": \"video/webm\",\n            \"webp\": \"image/webp\",\n            \"woff\": \"font/woff\",\n            \"woff2\": \"font/woff2\",\n            \"xhtml\": \"application/xhtml+xml\",\n            \"xls\": \"application/vnd.ms-excel\",\n            \"xlsx\": \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n            \"xml\": \"application/xml\",\n            \"xul\": \"application/vnd.mozilla.xul+xml\",\n            \"zip\": \"application/zip\",\n            \"3gp\": \"video/3gpp\",\n            \"3g2\": \"video/3gpp2\",\n            \"7z\": \"application/x-7z-compressed\"\n        };\n        // Look up the MIME type based on the file extension.\n        const mimeType = mimeTypes[fileExtension.toLowerCase()];\n        // Return the MIME type.\n        return mimeType;\n    }\n    async uploadFileFromPath(file, uploadUrl, apiClient) {\n        var _a;\n        const response = await this.uploadFileFromPathInternal(file, uploadUrl, apiClient);\n        const responseJson = await (response === null || response === void 0 ? void 0 : response.json());\n        if (((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== \"final\") {\n            throw new Error(\"Failed to upload file: Upload status is not finalized.\");\n        }\n        return responseJson[\"file\"];\n    }\n    async uploadFileToFileSearchStoreFromPath(file, uploadUrl, apiClient) {\n        var _a;\n        const response = await this.uploadFileFromPathInternal(file, uploadUrl, apiClient);\n        const responseJson = await (response === null || response === void 0 ? void 0 : response.json());\n        if (((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== \"final\") {\n            throw new Error(\"Failed to upload file: Upload status is not finalized.\");\n        }\n        const resp = uploadToFileSearchStoreOperationFromMldev(responseJson);\n        const typedResp = new UploadToFileSearchStoreOperation();\n        Object.assign(typedResp, resp);\n        return typedResp;\n    }\n    async uploadFileFromPathInternal(file, uploadUrl, apiClient) {\n        var _a, _b;\n        let fileSize = 0;\n        let offset = 0;\n        let response = new HttpResponse(new Response());\n        let uploadCommand = \"upload\";\n        let fileHandle;\n        const fileName = path__WEBPACK_IMPORTED_MODULE_6__.basename(file);\n        try {\n            fileHandle = await fs_promises__WEBPACK_IMPORTED_MODULE_2__.open(file, \"r\");\n            if (!fileHandle) {\n                throw new Error(`Failed to open file`);\n            }\n            fileSize = (await fileHandle.stat()).size;\n            while(offset < fileSize){\n                const chunkSize = Math.min(MAX_CHUNK_SIZE, fileSize - offset);\n                if (offset + chunkSize >= fileSize) {\n                    uploadCommand += \", finalize\";\n                }\n                const buffer = new Uint8Array(chunkSize);\n                const { bytesRead: bytesRead } = await fileHandle.read(buffer, 0, chunkSize, offset);\n                if (bytesRead !== chunkSize) {\n                    throw new Error(`Failed to read ${chunkSize} bytes from file at offset ${offset}. bytes actually read: ${bytesRead}`);\n                }\n                const chunk = new Blob([\n                    buffer\n                ]);\n                let retryCount = 0;\n                let currentDelayMs = INITIAL_RETRY_DELAY_MS;\n                while(retryCount < MAX_RETRY_COUNT){\n                    response = await apiClient.request({\n                        path: \"\",\n                        body: chunk,\n                        httpMethod: \"POST\",\n                        httpOptions: {\n                            apiVersion: \"\",\n                            baseUrl: uploadUrl,\n                            headers: {\n                                \"X-Goog-Upload-Command\": uploadCommand,\n                                \"X-Goog-Upload-Offset\": String(offset),\n                                \"Content-Length\": String(bytesRead),\n                                \"X-Goog-Upload-File-Name\": fileName\n                            }\n                        }\n                    });\n                    if ((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) {\n                        break;\n                    }\n                    retryCount++;\n                    await sleep(currentDelayMs);\n                    currentDelayMs = currentDelayMs * DELAY_MULTIPLIER;\n                }\n                offset += bytesRead;\n                // The `x-goog-upload-status` header field can be `active`, `final` and\n                //`cancelled` in resposne.\n                if (((_b = response === null || response === void 0 ? void 0 : response.headers) === null || _b === void 0 ? void 0 : _b[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== \"active\") {\n                    break;\n                }\n                if (fileSize <= offset) {\n                    throw new Error(\"All content has been uploaded, but the upload status is not finalized.\");\n                }\n            }\n            return response;\n        } finally{\n            // Ensure the file handle is always closed\n            if (fileHandle) {\n                await fileHandle.close();\n            }\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ const LANGUAGE_LABEL_PREFIX = \"gl-node/\";\n/**\n * The Google GenAI SDK.\n *\n * @remarks\n * Provides access to the GenAI features through either the {@link\n * https://cloud.google.com/vertex-ai/docs/reference/rest | Gemini API} or\n * the {@link https://cloud.google.com/vertex-ai/docs/reference/rest | Vertex AI\n * API}.\n *\n * The {@link GoogleGenAIOptions.vertexai} value determines which of the API\n * services to use.\n *\n * When using the Gemini API, a {@link GoogleGenAIOptions.apiKey} must also be\n * set. When using Vertex AI, both {@link GoogleGenAIOptions.project} and {@link\n * GoogleGenAIOptions.location} must be set, or a {@link\n * GoogleGenAIOptions.apiKey} must be set when using Express Mode.\n *\n * Explicitly passed in values in {@link GoogleGenAIOptions} will always take\n * precedence over environment variables. If both project/location and api_key\n * exist in the environment variables, the project/location will be used.\n *\n * @example\n * Initializing the SDK for using the Gemini API:\n * ```ts\n * import {GoogleGenAI} from '@google/genai';\n * const ai = new GoogleGenAI({apiKey: 'GEMINI_API_KEY'});\n * ```\n *\n * @example\n * Initializing the SDK for using the Vertex AI API:\n * ```ts\n * import {GoogleGenAI} from '@google/genai';\n * const ai = new GoogleGenAI({\n *   vertexai: true,\n *   project: 'PROJECT_ID',\n *   location: 'PROJECT_LOCATION'\n * });\n * ```\n *\n */ class GoogleGenAI {\n    constructor(options){\n        var _a, _b, _c, _d, _e, _f;\n        // Validate explicitly set initializer values.\n        if ((options.project || options.location) && options.apiKey) {\n            throw new Error(\"Project/location and API key are mutually exclusive in the client initializer.\");\n        }\n        this.vertexai = (_b = (_a = options.vertexai) !== null && _a !== void 0 ? _a : getBooleanEnv(\"GOOGLE_GENAI_USE_VERTEXAI\")) !== null && _b !== void 0 ? _b : false;\n        const envApiKey = getApiKeyFromEnv();\n        const envProject = getEnv(\"GOOGLE_CLOUD_PROJECT\");\n        const envLocation = getEnv(\"GOOGLE_CLOUD_LOCATION\");\n        this.apiKey = (_c = options.apiKey) !== null && _c !== void 0 ? _c : envApiKey;\n        this.project = (_d = options.project) !== null && _d !== void 0 ? _d : envProject;\n        this.location = (_e = options.location) !== null && _e !== void 0 ? _e : envLocation;\n        // Handle when to use Vertex AI in express mode (api key)\n        if (options.vertexai) {\n            if ((_f = options.googleAuthOptions) === null || _f === void 0 ? void 0 : _f.credentials) {\n                // Explicit credentials take precedence over implicit api_key.\n                console.debug(\"The user provided Google Cloud credentials will take precedence\" + \" over the API key from the environment variable.\");\n                this.apiKey = undefined;\n            }\n            // Explicit api_key and explicit project/location already handled above.\n            if ((envProject || envLocation) && options.apiKey) {\n                // Explicit api_key takes precedence over implicit project/location.\n                console.debug(\"The user provided Vertex AI API key will take precedence over\" + \" the project/location from the environment variables.\");\n                this.project = undefined;\n                this.location = undefined;\n            } else if ((options.project || options.location) && envApiKey) {\n                // Explicit project/location takes precedence over implicit api_key.\n                console.debug(\"The user provided project/location will take precedence over\" + \" the API key from the environment variables.\");\n                this.apiKey = undefined;\n            } else if ((envProject || envLocation) && envApiKey) {\n                // Implicit project/location takes precedence over implicit api_key.\n                console.debug(\"The project/location from the environment variables will take\" + \" precedence over the API key from the environment variables.\");\n                this.apiKey = undefined;\n            }\n            if (!this.location && !this.apiKey) {\n                this.location = \"global\";\n            }\n        }\n        const baseUrl = getBaseUrl(options.httpOptions, options.vertexai, getEnv(\"GOOGLE_VERTEX_BASE_URL\"), getEnv(\"GOOGLE_GEMINI_BASE_URL\"));\n        if (baseUrl) {\n            if (options.httpOptions) {\n                options.httpOptions.baseUrl = baseUrl;\n            } else {\n                options.httpOptions = {\n                    baseUrl: baseUrl\n                };\n            }\n        }\n        this.apiVersion = options.apiVersion;\n        this.httpOptions = options.httpOptions;\n        const auth = new NodeAuth({\n            apiKey: this.apiKey,\n            googleAuthOptions: options.googleAuthOptions\n        });\n        this.apiClient = new ApiClient({\n            auth: auth,\n            project: this.project,\n            location: this.location,\n            apiVersion: this.apiVersion,\n            apiKey: this.apiKey,\n            vertexai: this.vertexai,\n            httpOptions: this.httpOptions,\n            userAgentExtra: LANGUAGE_LABEL_PREFIX + process.version,\n            uploader: new NodeUploader(),\n            downloader: new NodeDownloader()\n        });\n        this.models = new Models(this.apiClient);\n        this.live = new Live(this.apiClient, auth, new NodeWebSocketFactory());\n        this.batches = new Batches(this.apiClient);\n        this.chats = new Chats(this.models, this.apiClient);\n        this.caches = new Caches(this.apiClient);\n        this.files = new Files(this.apiClient);\n        this.operations = new Operations(this.apiClient);\n        this.authTokens = new Tokens(this.apiClient);\n        this.tunings = new Tunings(this.apiClient);\n        this.fileSearchStores = new FileSearchStores(this.apiClient);\n    }\n}\nfunction getEnv(env) {\n    var _a, _b, _c;\n    return (_c = (_b = (_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a[env]) === null || _b === void 0 ? void 0 : _b.trim()) !== null && _c !== void 0 ? _c : undefined;\n}\nfunction getBooleanEnv(env) {\n    return stringToBoolean(getEnv(env));\n}\nfunction stringToBoolean(str) {\n    if (str === undefined) {\n        return false;\n    }\n    return str.toLowerCase() === \"true\";\n}\nfunction getApiKeyFromEnv() {\n    const envGoogleApiKey = getEnv(\"GOOGLE_API_KEY\");\n    const envGeminiApiKey = getEnv(\"GEMINI_API_KEY\");\n    if (envGoogleApiKey && envGeminiApiKey) {\n        console.warn(\"Both GOOGLE_API_KEY and GEMINI_API_KEY are set. Using GOOGLE_API_KEY.\");\n    }\n    return envGoogleApiKey || envGeminiApiKey || undefined;\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9nZW5haS9kaXN0L25vZGUvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFpRDtBQUNWO0FBQ0w7QUFDTTtBQUNEO0FBQ1M7QUFDbkI7QUFDQTtBQUU3Qjs7OztDQUlDLEdBQ0QsSUFBSVEsd0JBQXdCQztBQUM1QixJQUFJQyx3QkFBd0JEO0FBQzVCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbUJDLEdBQ0QsU0FBU0UsbUJBQW1CQyxhQUFhO0lBQ3JDSix3QkFBd0JJLGNBQWNDLFNBQVM7SUFDL0NILHdCQUF3QkUsY0FBY0UsU0FBUztBQUNuRDtBQUNBOztDQUVDLEdBQ0QsU0FBU0M7SUFDTCxPQUFPO1FBQ0hGLFdBQVdMO1FBQ1hNLFdBQVdKO0lBQ2Y7QUFDSjtBQUNBOzs7OztDQUtDLEdBQ0QsU0FBU00sV0FBV0MsV0FBVyxFQUFFQyxRQUFRLEVBQUVDLG9CQUFvQixFQUFFQyxvQkFBb0I7SUFDakYsSUFBSUMsSUFBSUM7SUFDUixJQUFJLENBQUVMLENBQUFBLGdCQUFnQixRQUFRQSxnQkFBZ0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsWUFBWU0sT0FBTyxHQUFHO1FBQ2xGLE1BQU1DLGtCQUFrQlQ7UUFDeEIsSUFBSUcsVUFBVTtZQUNWLE9BQU8sQ0FBQ0csS0FBS0csZ0JBQWdCVixTQUFTLE1BQU0sUUFBUU8sT0FBTyxLQUFLLElBQUlBLEtBQUtGO1FBQzdFLE9BQ0s7WUFDRCxPQUFPLENBQUNHLEtBQUtFLGdCQUFnQlgsU0FBUyxNQUFNLFFBQVFTLE9BQU8sS0FBSyxJQUFJQSxLQUFLRjtRQUM3RTtJQUNKO0lBQ0EsT0FBT0gsWUFBWU0sT0FBTztBQUM5QjtBQUVB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QUFDNXJDLFNBQVM7UUFDekMsSUFBSSxDQUFDa3dDLGdCQUFnQixHQUFHLElBQUk3SixpQkFBaUIsSUFBSSxDQUFDcm1DLFNBQVM7SUFDL0Q7QUFDSjtBQUNBLFNBQVNvdkMsT0FBT2UsR0FBRztJQUNmLElBQUkxaUQsSUFBSUMsSUFBSW1OO0lBQ1osT0FBTyxDQUFDQSxLQUFLLENBQUNuTixLQUFLLENBQUNELEtBQUsraEQsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVFXLEdBQUcsTUFBTSxRQUFRMWlELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsRUFBRSxDQUFDMGlELElBQUksTUFBTSxRQUFRemlELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3ltQyxJQUFJLEVBQUMsTUFBTyxRQUFRdDVCLE9BQU8sS0FBSyxJQUFJQSxLQUFLaE87QUFDM047QUFDQSxTQUFTbWlELGNBQWNtQixHQUFHO0lBQ3RCLE9BQU9DLGdCQUFnQmhCLE9BQU9lO0FBQ2xDO0FBQ0EsU0FBU0MsZ0JBQWdCQyxHQUFHO0lBQ3hCLElBQUlBLFFBQVF4akQsV0FBVztRQUNuQixPQUFPO0lBQ1g7SUFDQSxPQUFPd2pELElBQUk5QixXQUFXLE9BQU87QUFDakM7QUFDQSxTQUFTVztJQUNMLE1BQU1vQixrQkFBa0JsQixPQUFPO0lBQy9CLE1BQU1tQixrQkFBa0JuQixPQUFPO0lBQy9CLElBQUlrQixtQkFBbUJDLGlCQUFpQjtRQUNwQ2wxQyxRQUFRQyxJQUFJLENBQUM7SUFDakI7SUFDQSxPQUFPZzFDLG1CQUFtQkMsbUJBQW1CMWpEO0FBQ2pEO0FBRTQvRSxDQUM1L0Usa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmF5LXNhYXMtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9nZW5haS9kaXN0L25vZGUvaW5kZXgubWpzPzJkNzgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgR29vZ2xlQXV0aCB9IGZyb20gJ2dvb2dsZS1hdXRoLWxpYnJhcnknO1xuaW1wb3J0IHsgY3JlYXRlV3JpdGVTdHJlYW0gfSBmcm9tICdmcyc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcy9wcm9taXNlcyc7XG5pbXBvcnQgeyB3cml0ZUZpbGUgfSBmcm9tICdmcy9wcm9taXNlcyc7XG5pbXBvcnQgeyBSZWFkYWJsZSB9IGZyb20gJ25vZGU6c3RyZWFtJztcbmltcG9ydCB7IGZpbmlzaGVkIH0gZnJvbSAnbm9kZTpzdHJlYW0vcHJvbWlzZXMnO1xuaW1wb3J0ICogYXMgTm9kZVdzIGZyb20gJ3dzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmxldCBfZGVmYXVsdEJhc2VHZW1pbmlVcmwgPSB1bmRlZmluZWQ7XG5sZXQgX2RlZmF1bHRCYXNlVmVydGV4VXJsID0gdW5kZWZpbmVkO1xuLyoqXG4gKiBPdmVycmlkZXMgdGhlIGJhc2UgVVJMcyBmb3IgdGhlIEdlbWluaSBBUEkgYW5kIFZlcnRleCBBSSBBUEkuXG4gKlxuICogQHJlbWFya3MgVGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgY2FsbGVkIGJlZm9yZSBpbml0aWFsaXppbmcgdGhlIFNESy4gSWYgdGhlXG4gKiBiYXNlIFVSTHMgYXJlIHNldCBhZnRlciBpbml0aWFsaXppbmcgdGhlIFNESywgdGhlIGJhc2UgVVJMcyB3aWxsIG5vdCBiZVxuICogdXBkYXRlZC4gQmFzZSBVUkxzIHByb3ZpZGVkIGluIHRoZSBIdHRwT3B0aW9ucyB3aWxsIGFsc28gdGFrZSBwcmVjZWRlbmNlIG92ZXJcbiAqIFVSTHMgc2V0IGhlcmUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQge0dvb2dsZUdlbkFJLCBzZXREZWZhdWx0QmFzZVVybHN9IGZyb20gJ0Bnb29nbGUvZ2VuYWknO1xuICogLy8gT3ZlcnJpZGUgdGhlIGJhc2UgVVJMIGZvciB0aGUgR2VtaW5pIEFQSS5cbiAqIHNldERlZmF1bHRCYXNlVXJscyh7Z2VtaW5pVXJsOidodHRwczovL2dlbWluaS5nb29nbGUuY29tJ30pO1xuICpcbiAqIC8vIE92ZXJyaWRlIHRoZSBiYXNlIFVSTCBmb3IgdGhlIFZlcnRleCBBSSBBUEkuXG4gKiBzZXREZWZhdWx0QmFzZVVybHMoe3ZlcnRleFVybDogJ2h0dHBzOi8vdmVydGV4YWkuZ29vZ2xlYXBpcy5jb20nfSk7XG4gKlxuICogY29uc3QgYWkgPSBuZXcgR29vZ2xlR2VuQUkoe2FwaUtleTogJ0dFTUlOSV9BUElfS0VZJ30pO1xuICogYGBgXG4gKi9cbmZ1bmN0aW9uIHNldERlZmF1bHRCYXNlVXJscyhiYXNlVXJsUGFyYW1zKSB7XG4gICAgX2RlZmF1bHRCYXNlR2VtaW5pVXJsID0gYmFzZVVybFBhcmFtcy5nZW1pbmlVcmw7XG4gICAgX2RlZmF1bHRCYXNlVmVydGV4VXJsID0gYmFzZVVybFBhcmFtcy52ZXJ0ZXhVcmw7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGRlZmF1bHQgYmFzZSBVUkxzIGZvciB0aGUgR2VtaW5pIEFQSSBhbmQgVmVydGV4IEFJIEFQSS5cbiAqL1xuZnVuY3Rpb24gZ2V0RGVmYXVsdEJhc2VVcmxzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGdlbWluaVVybDogX2RlZmF1bHRCYXNlR2VtaW5pVXJsLFxuICAgICAgICB2ZXJ0ZXhVcmw6IF9kZWZhdWx0QmFzZVZlcnRleFVybCxcbiAgICB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkZWZhdWx0IGJhc2UgVVJMIGJhc2VkIG9uIHRoZSBmb2xsb3dpbmcgcHJpb3JpdHk6XG4gKiAgIDEuIEJhc2UgVVJMcyBzZXQgdmlhIEh0dHBPcHRpb25zLlxuICogICAyLiBCYXNlIFVSTHMgc2V0IHZpYSB0aGUgbGF0ZXN0IGNhbGwgdG8gc2V0RGVmYXVsdEJhc2VVcmxzLlxuICogICAzLiBCYXNlIFVSTHMgc2V0IHZpYSBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKi9cbmZ1bmN0aW9uIGdldEJhc2VVcmwoaHR0cE9wdGlvbnMsIHZlcnRleGFpLCB2ZXJ0ZXhCYXNlVXJsRnJvbUVudiwgZ2VtaW5pQmFzZVVybEZyb21FbnYpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmICghKGh0dHBPcHRpb25zID09PSBudWxsIHx8IGh0dHBPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBodHRwT3B0aW9ucy5iYXNlVXJsKSkge1xuICAgICAgICBjb25zdCBkZWZhdWx0QmFzZVVybHMgPSBnZXREZWZhdWx0QmFzZVVybHMoKTtcbiAgICAgICAgaWYgKHZlcnRleGFpKSB7XG4gICAgICAgICAgICByZXR1cm4gKF9hID0gZGVmYXVsdEJhc2VVcmxzLnZlcnRleFVybCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdmVydGV4QmFzZVVybEZyb21FbnY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKF9iID0gZGVmYXVsdEJhc2VVcmxzLmdlbWluaVVybCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZ2VtaW5pQmFzZVVybEZyb21FbnY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGh0dHBPcHRpb25zLmJhc2VVcmw7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNsYXNzIEJhc2VNb2R1bGUge1xufVxuZnVuY3Rpb24gZm9ybWF0TWFwKHRlbXBsYXRlU3RyaW5nLCB2YWx1ZU1hcCkge1xuICAgIC8vIFVzZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBmaW5kIGFsbCBwbGFjZWhvbGRlcnMgaW4gdGhlIHRlbXBsYXRlIHN0cmluZ1xuICAgIGNvbnN0IHJlZ2V4ID0gL1xceyhbXn1dKylcXH0vZztcbiAgICAvLyBSZXBsYWNlIGVhY2ggcGxhY2Vob2xkZXIgd2l0aCBpdHMgY29ycmVzcG9uZGluZyB2YWx1ZSBmcm9tIHRoZSB2YWx1ZU1hcFxuICAgIHJldHVybiB0ZW1wbGF0ZVN0cmluZy5yZXBsYWNlKHJlZ2V4LCAobWF0Y2gsIGtleSkgPT4ge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlTWFwLCBrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlTWFwW2tleV07XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSB2YWx1ZSB0byBhIHN0cmluZyBpZiBpdCdzIG5vdCBhIHN0cmluZyBhbHJlYWR5XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCA/IFN0cmluZyh2YWx1ZSkgOiAnJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBtaXNzaW5nIGtleXNcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5ICcke2tleX0nIG5vdCBmb3VuZCBpbiB2YWx1ZU1hcC5gKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gc2V0VmFsdWVCeVBhdGgoZGF0YSwga2V5cywgdmFsdWUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmIChrZXkuZW5kc1dpdGgoJ1tdJykpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleU5hbWUgPSBrZXkuc2xpY2UoMCwgLTIpO1xuICAgICAgICAgICAgaWYgKCEoa2V5TmFtZSBpbiBkYXRhKSkge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2tleU5hbWVdID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogdmFsdWUubGVuZ3RoIH0sICgpID0+ICh7fSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBWYWx1ZSBtdXN0IGJlIGEgbGlzdCBnaXZlbiBhbiBhcnJheSBwYXRoICR7a2V5fWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGFba2V5TmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJyYXlEYXRhID0gZGF0YVtrZXlOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBhcnJheURhdGEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gYXJyYXlEYXRhW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgoZW50cnksIGtleXMuc2xpY2UoaSArIDEpLCB2YWx1ZVtqXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZCBvZiBhcnJheURhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKGQsIGtleXMuc2xpY2UoaSArIDEpLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5LmVuZHNXaXRoKCdbMF0nKSkge1xuICAgICAgICAgICAgY29uc3Qga2V5TmFtZSA9IGtleS5zbGljZSgwLCAtMyk7XG4gICAgICAgICAgICBpZiAoIShrZXlOYW1lIGluIGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgZGF0YVtrZXlOYW1lXSA9IFt7fV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcnJheURhdGEgPSBkYXRhW2tleU5hbWVdO1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgoYXJyYXlEYXRhWzBdLCBrZXlzLnNsaWNlKGkgKyAxKSwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YVtrZXldIHx8IHR5cGVvZiBkYXRhW2tleV0gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBkYXRhW2tleV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhID0gZGF0YVtrZXldO1xuICAgIH1cbiAgICBjb25zdCBrZXlUb1NldCA9IGtleXNba2V5cy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBleGlzdGluZ0RhdGEgPSBkYXRhW2tleVRvU2V0XTtcbiAgICBpZiAoZXhpc3RpbmdEYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSB8fFxuICAgICAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPT09IGV4aXN0aW5nRGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZXhpc3RpbmdEYXRhID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgZXhpc3RpbmdEYXRhICE9PSBudWxsICYmXG4gICAgICAgICAgICB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihleGlzdGluZ0RhdGEsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHNldCB2YWx1ZSBmb3IgYW4gZXhpc3Rpbmcga2V5LiBLZXk6ICR7a2V5VG9TZXR9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChrZXlUb1NldCA9PT0gJ19zZWxmJyAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgdmFsdWUgIT09IG51bGwgJiZcbiAgICAgICAgICAgICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVBc1JlY29yZCA9IHZhbHVlO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihkYXRhLCB2YWx1ZUFzUmVjb3JkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFba2V5VG9TZXRdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZXRWYWx1ZUJ5UGF0aChkYXRhLCBrZXlzLCBkZWZhdWx0VmFsdWUgPSB1bmRlZmluZWQpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDEgJiYga2V5c1swXSA9PT0gJ19zZWxmJykge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdvYmplY3QnIHx8IGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGlmIChrZXkuZW5kc1dpdGgoJ1tdJykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlOYW1lID0ga2V5LnNsaWNlKDAsIC0yKTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5TmFtZSBpbiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5RGF0YSA9IGRhdGFba2V5TmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheURhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJheURhdGEubWFwKChkKSA9PiBnZXRWYWx1ZUJ5UGF0aChkLCBrZXlzLnNsaWNlKGkgKyAxKSwgZGVmYXVsdFZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuLyoqXG4gKiBNb3ZlcyB2YWx1ZXMgZnJvbSBzb3VyY2UgcGF0aHMgdG8gZGVzdGluYXRpb24gcGF0aHMuXG4gKlxuICogRXhhbXBsZXM6XG4gKiAgIG1vdmVWYWx1ZUJ5UGF0aChcbiAqICAgICB7J3JlcXVlc3RzJzogW3snY29udGVudCc6IHYxfSwgeydjb250ZW50JzogdjJ9XX0sXG4gKiAgICAgeydyZXF1ZXN0c1tdLionOiAncmVxdWVzdHNbXS5yZXF1ZXN0LionfVxuICogICApXG4gKiAgICAgLT4geydyZXF1ZXN0cyc6IFt7J3JlcXVlc3QnOiB7J2NvbnRlbnQnOiB2MX19LCB7J3JlcXVlc3QnOiB7J2NvbnRlbnQnOiB2Mn19XX1cbiAqL1xuZnVuY3Rpb24gbW92ZVZhbHVlQnlQYXRoKGRhdGEsIHBhdGhzKSB7XG4gICAgZm9yIChjb25zdCBbc291cmNlUGF0aCwgZGVzdFBhdGhdIG9mIE9iamVjdC5lbnRyaWVzKHBhdGhzKSkge1xuICAgICAgICBjb25zdCBzb3VyY2VLZXlzID0gc291cmNlUGF0aC5zcGxpdCgnLicpO1xuICAgICAgICBjb25zdCBkZXN0S2V5cyA9IGRlc3RQYXRoLnNwbGl0KCcuJyk7XG4gICAgICAgIC8vIERldGVybWluZSBrZXlzIHRvIGV4Y2x1ZGUgZnJvbSB3aWxkY2FyZCB0byBhdm9pZCBjeWNsaWMgcmVmZXJlbmNlc1xuICAgICAgICBjb25zdCBleGNsdWRlS2V5cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgbGV0IHdpbGRjYXJkSWR4ID0gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHNvdXJjZUtleXNbaV0gPT09ICcqJykge1xuICAgICAgICAgICAgICAgIHdpbGRjYXJkSWR4ID0gaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAod2lsZGNhcmRJZHggIT09IC0xICYmIGRlc3RLZXlzLmxlbmd0aCA+IHdpbGRjYXJkSWR4KSB7XG4gICAgICAgICAgICAvLyBFeHRyYWN0IHRoZSBpbnRlcm1lZGlhdGUga2V5IGJldHdlZW4gc291cmNlIGFuZCBkZXN0IHBhdGhzXG4gICAgICAgICAgICAvLyBFeGFtcGxlOiBzb3VyY2U9WydyZXF1ZXN0c1tdJywgJyonXSwgZGVzdD1bJ3JlcXVlc3RzW10nLCAncmVxdWVzdCcsICcqJ11cbiAgICAgICAgICAgIC8vIFdlIHdhbnQgdG8gZXhjbHVkZSAncmVxdWVzdCdcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB3aWxkY2FyZElkeDsgaSA8IGRlc3RLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gZGVzdEtleXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gJyonICYmICFrZXkuZW5kc1dpdGgoJ1tdJykgJiYgIWtleS5lbmRzV2l0aCgnWzBdJykpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhjbHVkZUtleXMuYWRkKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF9tb3ZlVmFsdWVSZWN1cnNpdmUoZGF0YSwgc291cmNlS2V5cywgZGVzdEtleXMsIDAsIGV4Y2x1ZGVLZXlzKTtcbiAgICB9XG59XG4vKipcbiAqIFJlY3Vyc2l2ZWx5IG1vdmVzIHZhbHVlcyBmcm9tIHNvdXJjZSBwYXRoIHRvIGRlc3RpbmF0aW9uIHBhdGguXG4gKi9cbmZ1bmN0aW9uIF9tb3ZlVmFsdWVSZWN1cnNpdmUoZGF0YSwgc291cmNlS2V5cywgZGVzdEtleXMsIGtleUlkeCwgZXhjbHVkZUtleXMpIHtcbiAgICBpZiAoa2V5SWR4ID49IHNvdXJjZUtleXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0JyB8fCBkYXRhID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qga2V5ID0gc291cmNlS2V5c1trZXlJZHhdO1xuICAgIGlmIChrZXkuZW5kc1dpdGgoJ1tdJykpIHtcbiAgICAgICAgY29uc3Qga2V5TmFtZSA9IGtleS5zbGljZSgwLCAtMik7XG4gICAgICAgIGNvbnN0IGRhdGFSZWNvcmQgPSBkYXRhO1xuICAgICAgICBpZiAoa2V5TmFtZSBpbiBkYXRhUmVjb3JkICYmIEFycmF5LmlzQXJyYXkoZGF0YVJlY29yZFtrZXlOYW1lXSkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBkYXRhUmVjb3JkW2tleU5hbWVdKSB7XG4gICAgICAgICAgICAgICAgX21vdmVWYWx1ZVJlY3Vyc2l2ZShpdGVtLCBzb3VyY2VLZXlzLCBkZXN0S2V5cywga2V5SWR4ICsgMSwgZXhjbHVkZUtleXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGtleSA9PT0gJyonKSB7XG4gICAgICAgIC8vIHdpbGRjYXJkIC0gbW92ZSBhbGwgZmllbGRzXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiYgZGF0YSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgY29uc3QgZGF0YVJlY29yZCA9IGRhdGE7XG4gICAgICAgICAgICBjb25zdCBrZXlzVG9Nb3ZlID0gT2JqZWN0LmtleXMoZGF0YVJlY29yZCkuZmlsdGVyKChrKSA9PiAhay5zdGFydHNXaXRoKCdfJykgJiYgIWV4Y2x1ZGVLZXlzLmhhcyhrKSk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXNUb01vdmUgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgayBvZiBrZXlzVG9Nb3ZlKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzVG9Nb3ZlW2tdID0gZGF0YVJlY29yZFtrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNldCB2YWx1ZXMgYXQgZGVzdGluYXRpb25cbiAgICAgICAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlc1RvTW92ZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdEZXN0S2V5cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZGsgb2YgZGVzdEtleXMuc2xpY2Uoa2V5SWR4KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGsgPT09ICcqJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RGVzdEtleXMucHVzaChrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0Rlc3RLZXlzLnB1c2goZGspO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKGRhdGFSZWNvcmQsIG5ld0Rlc3RLZXlzLCB2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgayBvZiBrZXlzVG9Nb3ZlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGRhdGFSZWNvcmRba107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE5hdmlnYXRlIHRvIG5leHQgbGV2ZWxcbiAgICAgICAgY29uc3QgZGF0YVJlY29yZCA9IGRhdGE7XG4gICAgICAgIGlmIChrZXkgaW4gZGF0YVJlY29yZCkge1xuICAgICAgICAgICAgX21vdmVWYWx1ZVJlY3Vyc2l2ZShkYXRhUmVjb3JkW2tleV0sIHNvdXJjZUtleXMsIGRlc3RLZXlzLCBrZXlJZHggKyAxLCBleGNsdWRlS2V5cyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmZ1bmN0aW9uIHRCeXRlcyQxKGZyb21CeXRlcykge1xuICAgIGlmICh0eXBlb2YgZnJvbUJ5dGVzICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Zyb21JbWFnZUJ5dGVzIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG4gICAgLy8gVE9ETyhiLzM4OTEzMzkxNCk6IFJlbW92ZSBkdW1teSBieXRlcyBjb252ZXJ0ZXIuXG4gICAgcmV0dXJuIGZyb21CeXRlcztcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuLy8gQ29kZSBnZW5lcmF0ZWQgYnkgdGhlIEdvb2dsZSBHZW4gQUkgU0RLIGdlbmVyYXRvciBETyBOT1QgRURJVC5cbmZ1bmN0aW9uIGZldGNoUHJlZGljdE9wZXJhdGlvblBhcmFtZXRlcnNUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tT3BlcmF0aW9uTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ29wZXJhdGlvbk5hbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tT3BlcmF0aW9uTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ29wZXJhdGlvbk5hbWUnXSwgZnJvbU9wZXJhdGlvbk5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzb3VyY2VOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNvdXJjZU5hbWUnXSk7XG4gICAgaWYgKGZyb21SZXNvdXJjZU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ3Jlc291cmNlTmFtZSddLCBmcm9tUmVzb3VyY2VOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVWaWRlb3NPcGVyYXRpb25Gcm9tTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWV0YWRhdGEnXSwgZnJvbU1ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvbmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RvbmUnXSk7XG4gICAgaWYgKGZyb21Eb25lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9uZSddLCBmcm9tRG9uZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZyb21FcnJvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlJyxcbiAgICAgICAgJ2dlbmVyYXRlVmlkZW9SZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlJ10sIGdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tTWxkZXYkMShmcm9tUmVzcG9uc2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVWaWRlb3NPcGVyYXRpb25Gcm9tVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0YWRhdGEnXSk7XG4gICAgaWYgKGZyb21NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21ldGFkYXRhJ10sIGZyb21NZXRhZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Eb25lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkb25lJ10pO1xuICAgIGlmIChmcm9tRG9uZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RvbmUnXSwgZnJvbURvbmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXJyb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vycm9yJ10pO1xuICAgIGlmIChmcm9tRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlcnJvciddLCBmcm9tRXJyb3IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCBnZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlRnJvbVZlcnRleCQxKGZyb21SZXNwb25zZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlRnJvbU1sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUdlbmVyYXRlZFZpZGVvcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dlbmVyYXRlZFNhbXBsZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR2VuZXJhdGVkVmlkZW9zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21HZW5lcmF0ZWRWaWRlb3M7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVkVmlkZW9Gcm9tTWxkZXYkMShpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRlZFZpZGVvcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmFpTWVkaWFGaWx0ZXJlZENvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JhaU1lZGlhRmlsdGVyZWRDb3VudCddLCBmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyYWlNZWRpYUZpbHRlcmVkUmVhc29ucyddLCBmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlRnJvbVZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21HZW5lcmF0ZWRWaWRlb3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvcyddKTtcbiAgICBpZiAoZnJvbUdlbmVyYXRlZFZpZGVvcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tR2VuZXJhdGVkVmlkZW9zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlZFZpZGVvRnJvbVZlcnRleCQxKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGVkVmlkZW9zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyYWlNZWRpYUZpbHRlcmVkQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmFpTWVkaWFGaWx0ZXJlZENvdW50J10sIGZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyYWlNZWRpYUZpbHRlcmVkUmVhc29ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JhaU1lZGlhRmlsdGVyZWRSZWFzb25zJ10sIGZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlZFZpZGVvRnJvbU1sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZpZGVvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2aWRlbyddKTtcbiAgICBpZiAoZnJvbVZpZGVvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW8nXSwgdmlkZW9Gcm9tTWxkZXYkMShmcm9tVmlkZW8pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVkVmlkZW9Gcm9tVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZpZGVvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydfc2VsZiddKTtcbiAgICBpZiAoZnJvbVZpZGVvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW8nXSwgdmlkZW9Gcm9tVmVydGV4JDEoZnJvbVZpZGVvKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdldE9wZXJhdGlvblBhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21PcGVyYXRpb25OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3BlcmF0aW9uTmFtZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21PcGVyYXRpb25OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdvcGVyYXRpb25OYW1lJ10sIGZyb21PcGVyYXRpb25OYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0T3BlcmF0aW9uUGFyYW1ldGVyc1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21PcGVyYXRpb25OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3BlcmF0aW9uTmFtZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21PcGVyYXRpb25OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdvcGVyYXRpb25OYW1lJ10sIGZyb21PcGVyYXRpb25OYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW1wb3J0RmlsZU9wZXJhdGlvbkZyb21NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJ10pO1xuICAgIGlmIChmcm9tTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZXRhZGF0YSddLCBmcm9tTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRG9uZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZG9uZSddKTtcbiAgICBpZiAoZnJvbURvbmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkb25lJ10sIGZyb21Eb25lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgZnJvbUVycm9yKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZSddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2UnXSwgaW1wb3J0RmlsZVJlc3BvbnNlRnJvbU1sZGV2JDEoZnJvbVJlc3BvbnNlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGltcG9ydEZpbGVSZXNwb25zZUZyb21NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFyZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJlbnQnXSk7XG4gICAgaWYgKGZyb21QYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJlbnQnXSwgZnJvbVBhcmVudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Eb2N1bWVudE5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RvY3VtZW50TmFtZSddKTtcbiAgICBpZiAoZnJvbURvY3VtZW50TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RvY3VtZW50TmFtZSddLCBmcm9tRG9jdW1lbnROYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVPcGVyYXRpb25Gcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0YWRhdGEnXSk7XG4gICAgaWYgKGZyb21NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21ldGFkYXRhJ10sIGZyb21NZXRhZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Eb25lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkb25lJ10pO1xuICAgIGlmIChmcm9tRG9uZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RvbmUnXSwgZnJvbURvbmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXJyb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vycm9yJ10pO1xuICAgIGlmIChmcm9tRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlcnJvciddLCBmcm9tRXJyb3IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCB1cGxvYWRUb0ZpbGVTZWFyY2hTdG9yZVJlc3BvbnNlRnJvbU1sZGV2KGZyb21SZXNwb25zZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cGxvYWRUb0ZpbGVTZWFyY2hTdG9yZVJlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFyZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJlbnQnXSk7XG4gICAgaWYgKGZyb21QYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJlbnQnXSwgZnJvbVBhcmVudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Eb2N1bWVudE5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RvY3VtZW50TmFtZSddKTtcbiAgICBpZiAoZnJvbURvY3VtZW50TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RvY3VtZW50TmFtZSddLCBmcm9tRG9jdW1lbnROYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdmlkZW9Gcm9tTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmknXSk7XG4gICAgaWYgKGZyb21VcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmknXSwgZnJvbVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlb0J5dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmNvZGVkVmlkZW8nXSk7XG4gICAgaWYgKGZyb21WaWRlb0J5dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW9CeXRlcyddLCB0Qnl0ZXMkMShmcm9tVmlkZW9CeXRlcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuY29kaW5nJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb0Zyb21WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NVcmknXSk7XG4gICAgaWYgKGZyb21VcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmknXSwgZnJvbVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlb0J5dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYnl0ZXNCYXNlNjRFbmNvZGVkJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvQnl0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb0J5dGVzJ10sIHRCeXRlcyQxKGZyb21WaWRlb0J5dGVzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuLyoqIE91dGNvbWUgb2YgdGhlIGNvZGUgZXhlY3V0aW9uLiAqL1xudmFyIE91dGNvbWU7XG4oZnVuY3Rpb24gKE91dGNvbWUpIHtcbiAgICAvKipcbiAgICAgKiBVbnNwZWNpZmllZCBzdGF0dXMuIFRoaXMgdmFsdWUgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICAgICAqL1xuICAgIE91dGNvbWVbXCJPVVRDT01FX1VOU1BFQ0lGSUVEXCJdID0gXCJPVVRDT01FX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogQ29kZSBleGVjdXRpb24gY29tcGxldGVkIHN1Y2Nlc3NmdWxseS5cbiAgICAgKi9cbiAgICBPdXRjb21lW1wiT1VUQ09NRV9PS1wiXSA9IFwiT1VUQ09NRV9PS1wiO1xuICAgIC8qKlxuICAgICAqIENvZGUgZXhlY3V0aW9uIGZpbmlzaGVkIGJ1dCB3aXRoIGEgZmFpbHVyZS4gYHN0ZGVycmAgc2hvdWxkIGNvbnRhaW4gdGhlIHJlYXNvbi5cbiAgICAgKi9cbiAgICBPdXRjb21lW1wiT1VUQ09NRV9GQUlMRURcIl0gPSBcIk9VVENPTUVfRkFJTEVEXCI7XG4gICAgLyoqXG4gICAgICogQ29kZSBleGVjdXRpb24gcmFuIGZvciB0b28gbG9uZywgYW5kIHdhcyBjYW5jZWxsZWQuIFRoZXJlIG1heSBvciBtYXkgbm90IGJlIGEgcGFydGlhbCBvdXRwdXQgcHJlc2VudC5cbiAgICAgKi9cbiAgICBPdXRjb21lW1wiT1VUQ09NRV9ERUFETElORV9FWENFRURFRFwiXSA9IFwiT1VUQ09NRV9ERUFETElORV9FWENFRURFRFwiO1xufSkoT3V0Y29tZSB8fCAoT3V0Y29tZSA9IHt9KSk7XG4vKiogUHJvZ3JhbW1pbmcgbGFuZ3VhZ2Ugb2YgdGhlIGBjb2RlYC4gKi9cbnZhciBMYW5ndWFnZTtcbihmdW5jdGlvbiAoTGFuZ3VhZ2UpIHtcbiAgICAvKipcbiAgICAgKiBVbnNwZWNpZmllZCBsYW5ndWFnZS4gVGhpcyB2YWx1ZSBzaG91bGQgbm90IGJlIHVzZWQuXG4gICAgICovXG4gICAgTGFuZ3VhZ2VbXCJMQU5HVUFHRV9VTlNQRUNJRklFRFwiXSA9IFwiTEFOR1VBR0VfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBQeXRob24gPj0gMy4xMCwgd2l0aCBudW1weSBhbmQgc2ltcHkgYXZhaWxhYmxlLlxuICAgICAqL1xuICAgIExhbmd1YWdlW1wiUFlUSE9OXCJdID0gXCJQWVRIT05cIjtcbn0pKExhbmd1YWdlIHx8IChMYW5ndWFnZSA9IHt9KSk7XG4vKiogU3BlY2lmaWVzIGhvdyB0aGUgcmVzcG9uc2Ugc2hvdWxkIGJlIHNjaGVkdWxlZCBpbiB0aGUgY29udmVyc2F0aW9uLiAqL1xudmFyIEZ1bmN0aW9uUmVzcG9uc2VTY2hlZHVsaW5nO1xuKGZ1bmN0aW9uIChGdW5jdGlvblJlc3BvbnNlU2NoZWR1bGluZykge1xuICAgIC8qKlxuICAgICAqIFRoaXMgdmFsdWUgaXMgdW51c2VkLlxuICAgICAqL1xuICAgIEZ1bmN0aW9uUmVzcG9uc2VTY2hlZHVsaW5nW1wiU0NIRURVTElOR19VTlNQRUNJRklFRFwiXSA9IFwiU0NIRURVTElOR19VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIE9ubHkgYWRkIHRoZSByZXN1bHQgdG8gdGhlIGNvbnZlcnNhdGlvbiBjb250ZXh0LCBkbyBub3QgaW50ZXJydXB0IG9yIHRyaWdnZXIgZ2VuZXJhdGlvbi5cbiAgICAgKi9cbiAgICBGdW5jdGlvblJlc3BvbnNlU2NoZWR1bGluZ1tcIlNJTEVOVFwiXSA9IFwiU0lMRU5UXCI7XG4gICAgLyoqXG4gICAgICogQWRkIHRoZSByZXN1bHQgdG8gdGhlIGNvbnZlcnNhdGlvbiBjb250ZXh0LCBhbmQgcHJvbXB0IHRvIGdlbmVyYXRlIG91dHB1dCB3aXRob3V0IGludGVycnVwdGluZyBvbmdvaW5nIGdlbmVyYXRpb24uXG4gICAgICovXG4gICAgRnVuY3Rpb25SZXNwb25zZVNjaGVkdWxpbmdbXCJXSEVOX0lETEVcIl0gPSBcIldIRU5fSURMRVwiO1xuICAgIC8qKlxuICAgICAqIEFkZCB0aGUgcmVzdWx0IHRvIHRoZSBjb252ZXJzYXRpb24gY29udGV4dCwgaW50ZXJydXB0IG9uZ29pbmcgZ2VuZXJhdGlvbiBhbmQgcHJvbXB0IHRvIGdlbmVyYXRlIG91dHB1dC5cbiAgICAgKi9cbiAgICBGdW5jdGlvblJlc3BvbnNlU2NoZWR1bGluZ1tcIklOVEVSUlVQVFwiXSA9IFwiSU5URVJSVVBUXCI7XG59KShGdW5jdGlvblJlc3BvbnNlU2NoZWR1bGluZyB8fCAoRnVuY3Rpb25SZXNwb25zZVNjaGVkdWxpbmcgPSB7fSkpO1xuLyoqIFRoZSB0eXBlIG9mIHRoZSBkYXRhLiAqL1xudmFyIFR5cGU7XG4oZnVuY3Rpb24gKFR5cGUpIHtcbiAgICAvKipcbiAgICAgKiBOb3Qgc3BlY2lmaWVkLCBzaG91bGQgbm90IGJlIHVzZWQuXG4gICAgICovXG4gICAgVHlwZVtcIlRZUEVfVU5TUEVDSUZJRURcIl0gPSBcIlRZUEVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBPcGVuQVBJIHN0cmluZyB0eXBlXG4gICAgICovXG4gICAgVHlwZVtcIlNUUklOR1wiXSA9IFwiU1RSSU5HXCI7XG4gICAgLyoqXG4gICAgICogT3BlbkFQSSBudW1iZXIgdHlwZVxuICAgICAqL1xuICAgIFR5cGVbXCJOVU1CRVJcIl0gPSBcIk5VTUJFUlwiO1xuICAgIC8qKlxuICAgICAqIE9wZW5BUEkgaW50ZWdlciB0eXBlXG4gICAgICovXG4gICAgVHlwZVtcIklOVEVHRVJcIl0gPSBcIklOVEVHRVJcIjtcbiAgICAvKipcbiAgICAgKiBPcGVuQVBJIGJvb2xlYW4gdHlwZVxuICAgICAqL1xuICAgIFR5cGVbXCJCT09MRUFOXCJdID0gXCJCT09MRUFOXCI7XG4gICAgLyoqXG4gICAgICogT3BlbkFQSSBhcnJheSB0eXBlXG4gICAgICovXG4gICAgVHlwZVtcIkFSUkFZXCJdID0gXCJBUlJBWVwiO1xuICAgIC8qKlxuICAgICAqIE9wZW5BUEkgb2JqZWN0IHR5cGVcbiAgICAgKi9cbiAgICBUeXBlW1wiT0JKRUNUXCJdID0gXCJPQkpFQ1RcIjtcbiAgICAvKipcbiAgICAgKiBOdWxsIHR5cGVcbiAgICAgKi9cbiAgICBUeXBlW1wiTlVMTFwiXSA9IFwiTlVMTFwiO1xufSkoVHlwZSB8fCAoVHlwZSA9IHt9KSk7XG4vKiogVGhlIG1vZGUgb2YgdGhlIHByZWRpY3RvciB0byBiZSB1c2VkIGluIGR5bmFtaWMgcmV0cmlldmFsLiAqL1xudmFyIE1vZGU7XG4oZnVuY3Rpb24gKE1vZGUpIHtcbiAgICAvKipcbiAgICAgKiBBbHdheXMgdHJpZ2dlciByZXRyaWV2YWwuXG4gICAgICovXG4gICAgTW9kZVtcIk1PREVfVU5TUEVDSUZJRURcIl0gPSBcIk1PREVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBSdW4gcmV0cmlldmFsIG9ubHkgd2hlbiBzeXN0ZW0gZGVjaWRlcyBpdCBpcyBuZWNlc3NhcnkuXG4gICAgICovXG4gICAgTW9kZVtcIk1PREVfRFlOQU1JQ1wiXSA9IFwiTU9ERV9EWU5BTUlDXCI7XG59KShNb2RlIHx8IChNb2RlID0ge30pKTtcbi8qKiBUaGUgQVBJIHNwZWMgdGhhdCB0aGUgZXh0ZXJuYWwgQVBJIGltcGxlbWVudHMuIFRoaXMgZW51bSBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuICovXG52YXIgQXBpU3BlYztcbihmdW5jdGlvbiAoQXBpU3BlYykge1xuICAgIC8qKlxuICAgICAqIFVuc3BlY2lmaWVkIEFQSSBzcGVjLiBUaGlzIHZhbHVlIHNob3VsZCBub3QgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBBcGlTcGVjW1wiQVBJX1NQRUNfVU5TUEVDSUZJRURcIl0gPSBcIkFQSV9TUEVDX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogU2ltcGxlIHNlYXJjaCBBUEkgc3BlYy5cbiAgICAgKi9cbiAgICBBcGlTcGVjW1wiU0lNUExFX1NFQVJDSFwiXSA9IFwiU0lNUExFX1NFQVJDSFwiO1xuICAgIC8qKlxuICAgICAqIEVsYXN0aWMgc2VhcmNoIEFQSSBzcGVjLlxuICAgICAqL1xuICAgIEFwaVNwZWNbXCJFTEFTVElDX1NFQVJDSFwiXSA9IFwiRUxBU1RJQ19TRUFSQ0hcIjtcbn0pKEFwaVNwZWMgfHwgKEFwaVNwZWMgPSB7fSkpO1xuLyoqIFR5cGUgb2YgYXV0aCBzY2hlbWUuIFRoaXMgZW51bSBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuICovXG52YXIgQXV0aFR5cGU7XG4oZnVuY3Rpb24gKEF1dGhUeXBlKSB7XG4gICAgQXV0aFR5cGVbXCJBVVRIX1RZUEVfVU5TUEVDSUZJRURcIl0gPSBcIkFVVEhfVFlQRV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIE5vIEF1dGguXG4gICAgICovXG4gICAgQXV0aFR5cGVbXCJOT19BVVRIXCJdID0gXCJOT19BVVRIXCI7XG4gICAgLyoqXG4gICAgICogQVBJIEtleSBBdXRoLlxuICAgICAqL1xuICAgIEF1dGhUeXBlW1wiQVBJX0tFWV9BVVRIXCJdID0gXCJBUElfS0VZX0FVVEhcIjtcbiAgICAvKipcbiAgICAgKiBIVFRQIEJhc2ljIEF1dGguXG4gICAgICovXG4gICAgQXV0aFR5cGVbXCJIVFRQX0JBU0lDX0FVVEhcIl0gPSBcIkhUVFBfQkFTSUNfQVVUSFwiO1xuICAgIC8qKlxuICAgICAqIEdvb2dsZSBTZXJ2aWNlIEFjY291bnQgQXV0aC5cbiAgICAgKi9cbiAgICBBdXRoVHlwZVtcIkdPT0dMRV9TRVJWSUNFX0FDQ09VTlRfQVVUSFwiXSA9IFwiR09PR0xFX1NFUlZJQ0VfQUNDT1VOVF9BVVRIXCI7XG4gICAgLyoqXG4gICAgICogT0F1dGggYXV0aC5cbiAgICAgKi9cbiAgICBBdXRoVHlwZVtcIk9BVVRIXCJdID0gXCJPQVVUSFwiO1xuICAgIC8qKlxuICAgICAqIE9wZW5JRCBDb25uZWN0IChPSURDKSBBdXRoLlxuICAgICAqL1xuICAgIEF1dGhUeXBlW1wiT0lEQ19BVVRIXCJdID0gXCJPSURDX0FVVEhcIjtcbn0pKEF1dGhUeXBlIHx8IChBdXRoVHlwZSA9IHt9KSk7XG4vKiogVGhlIGxvY2F0aW9uIG9mIHRoZSBBUEkga2V5LiBUaGlzIGVudW0gaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLiAqL1xudmFyIEh0dHBFbGVtZW50TG9jYXRpb247XG4oZnVuY3Rpb24gKEh0dHBFbGVtZW50TG9jYXRpb24pIHtcbiAgICBIdHRwRWxlbWVudExvY2F0aW9uW1wiSFRUUF9JTl9VTlNQRUNJRklFRFwiXSA9IFwiSFRUUF9JTl9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIEVsZW1lbnQgaXMgaW4gdGhlIEhUVFAgcmVxdWVzdCBxdWVyeS5cbiAgICAgKi9cbiAgICBIdHRwRWxlbWVudExvY2F0aW9uW1wiSFRUUF9JTl9RVUVSWVwiXSA9IFwiSFRUUF9JTl9RVUVSWVwiO1xuICAgIC8qKlxuICAgICAqIEVsZW1lbnQgaXMgaW4gdGhlIEhUVFAgcmVxdWVzdCBoZWFkZXIuXG4gICAgICovXG4gICAgSHR0cEVsZW1lbnRMb2NhdGlvbltcIkhUVFBfSU5fSEVBREVSXCJdID0gXCJIVFRQX0lOX0hFQURFUlwiO1xuICAgIC8qKlxuICAgICAqIEVsZW1lbnQgaXMgaW4gdGhlIEhUVFAgcmVxdWVzdCBwYXRoLlxuICAgICAqL1xuICAgIEh0dHBFbGVtZW50TG9jYXRpb25bXCJIVFRQX0lOX1BBVEhcIl0gPSBcIkhUVFBfSU5fUEFUSFwiO1xuICAgIC8qKlxuICAgICAqIEVsZW1lbnQgaXMgaW4gdGhlIEhUVFAgcmVxdWVzdCBib2R5LlxuICAgICAqL1xuICAgIEh0dHBFbGVtZW50TG9jYXRpb25bXCJIVFRQX0lOX0JPRFlcIl0gPSBcIkhUVFBfSU5fQk9EWVwiO1xuICAgIC8qKlxuICAgICAqIEVsZW1lbnQgaXMgaW4gdGhlIEhUVFAgcmVxdWVzdCBjb29raWUuXG4gICAgICovXG4gICAgSHR0cEVsZW1lbnRMb2NhdGlvbltcIkhUVFBfSU5fQ09PS0lFXCJdID0gXCJIVFRQX0lOX0NPT0tJRVwiO1xufSkoSHR0cEVsZW1lbnRMb2NhdGlvbiB8fCAoSHR0cEVsZW1lbnRMb2NhdGlvbiA9IHt9KSk7XG4vKiogU2l0ZXMgd2l0aCBjb25maWRlbmNlIGxldmVsIGNob3NlbiAmIGFib3ZlIHRoaXMgdmFsdWUgd2lsbCBiZSBibG9ja2VkIGZyb20gdGhlIHNlYXJjaCByZXN1bHRzLiBUaGlzIGVudW0gaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLiAqL1xudmFyIFBoaXNoQmxvY2tUaHJlc2hvbGQ7XG4oZnVuY3Rpb24gKFBoaXNoQmxvY2tUaHJlc2hvbGQpIHtcbiAgICAvKipcbiAgICAgKiBEZWZhdWx0cyB0byB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBQaGlzaEJsb2NrVGhyZXNob2xkW1wiUEhJU0hfQkxPQ0tfVEhSRVNIT0xEX1VOU1BFQ0lGSUVEXCJdID0gXCJQSElTSF9CTE9DS19USFJFU0hPTERfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBCbG9ja3MgTG93IGFuZCBhYm92ZSBjb25maWRlbmNlIFVSTCB0aGF0IGlzIHJpc2t5LlxuICAgICAqL1xuICAgIFBoaXNoQmxvY2tUaHJlc2hvbGRbXCJCTE9DS19MT1dfQU5EX0FCT1ZFXCJdID0gXCJCTE9DS19MT1dfQU5EX0FCT1ZFXCI7XG4gICAgLyoqXG4gICAgICogQmxvY2tzIE1lZGl1bSBhbmQgYWJvdmUgY29uZmlkZW5jZSBVUkwgdGhhdCBpcyByaXNreS5cbiAgICAgKi9cbiAgICBQaGlzaEJsb2NrVGhyZXNob2xkW1wiQkxPQ0tfTUVESVVNX0FORF9BQk9WRVwiXSA9IFwiQkxPQ0tfTUVESVVNX0FORF9BQk9WRVwiO1xuICAgIC8qKlxuICAgICAqIEJsb2NrcyBIaWdoIGFuZCBhYm92ZSBjb25maWRlbmNlIFVSTCB0aGF0IGlzIHJpc2t5LlxuICAgICAqL1xuICAgIFBoaXNoQmxvY2tUaHJlc2hvbGRbXCJCTE9DS19ISUdIX0FORF9BQk9WRVwiXSA9IFwiQkxPQ0tfSElHSF9BTkRfQUJPVkVcIjtcbiAgICAvKipcbiAgICAgKiBCbG9ja3MgSGlnaGVyIGFuZCBhYm92ZSBjb25maWRlbmNlIFVSTCB0aGF0IGlzIHJpc2t5LlxuICAgICAqL1xuICAgIFBoaXNoQmxvY2tUaHJlc2hvbGRbXCJCTE9DS19ISUdIRVJfQU5EX0FCT1ZFXCJdID0gXCJCTE9DS19ISUdIRVJfQU5EX0FCT1ZFXCI7XG4gICAgLyoqXG4gICAgICogQmxvY2tzIFZlcnkgaGlnaCBhbmQgYWJvdmUgY29uZmlkZW5jZSBVUkwgdGhhdCBpcyByaXNreS5cbiAgICAgKi9cbiAgICBQaGlzaEJsb2NrVGhyZXNob2xkW1wiQkxPQ0tfVkVSWV9ISUdIX0FORF9BQk9WRVwiXSA9IFwiQkxPQ0tfVkVSWV9ISUdIX0FORF9BQk9WRVwiO1xuICAgIC8qKlxuICAgICAqIEJsb2NrcyBFeHRyZW1lbHkgaGlnaCBjb25maWRlbmNlIFVSTCB0aGF0IGlzIHJpc2t5LlxuICAgICAqL1xuICAgIFBoaXNoQmxvY2tUaHJlc2hvbGRbXCJCTE9DS19PTkxZX0VYVFJFTUVMWV9ISUdIXCJdID0gXCJCTE9DS19PTkxZX0VYVFJFTUVMWV9ISUdIXCI7XG59KShQaGlzaEJsb2NrVGhyZXNob2xkIHx8IChQaGlzaEJsb2NrVGhyZXNob2xkID0ge30pKTtcbi8qKiBUaGUgbGV2ZWwgb2YgdGhvdWdodHMgdG9rZW5zIHRoYXQgdGhlIG1vZGVsIHNob3VsZCBnZW5lcmF0ZS4gKi9cbnZhciBUaGlua2luZ0xldmVsO1xuKGZ1bmN0aW9uIChUaGlua2luZ0xldmVsKSB7XG4gICAgLyoqXG4gICAgICogRGVmYXVsdCB2YWx1ZS5cbiAgICAgKi9cbiAgICBUaGlua2luZ0xldmVsW1wiVEhJTktJTkdfTEVWRUxfVU5TUEVDSUZJRURcIl0gPSBcIlRISU5LSU5HX0xFVkVMX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogTG93IHRoaW5raW5nIGxldmVsLlxuICAgICAqL1xuICAgIFRoaW5raW5nTGV2ZWxbXCJMT1dcIl0gPSBcIkxPV1wiO1xuICAgIC8qKlxuICAgICAqIEhpZ2ggdGhpbmtpbmcgbGV2ZWwuXG4gICAgICovXG4gICAgVGhpbmtpbmdMZXZlbFtcIkhJR0hcIl0gPSBcIkhJR0hcIjtcbn0pKFRoaW5raW5nTGV2ZWwgfHwgKFRoaW5raW5nTGV2ZWwgPSB7fSkpO1xuLyoqIEhhcm0gY2F0ZWdvcnkuICovXG52YXIgSGFybUNhdGVnb3J5O1xuKGZ1bmN0aW9uIChIYXJtQ2F0ZWdvcnkpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgaGFybSBjYXRlZ29yeSBpcyB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX1VOU1BFQ0lGSUVEXCJdID0gXCJIQVJNX0NBVEVHT1JZX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGhhcm0gY2F0ZWdvcnkgaXMgaGFyYXNzbWVudC5cbiAgICAgKi9cbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX0hBUkFTU01FTlRcIl0gPSBcIkhBUk1fQ0FURUdPUllfSEFSQVNTTUVOVFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGNhdGVnb3J5IGlzIGhhdGUgc3BlZWNoLlxuICAgICAqL1xuICAgIEhhcm1DYXRlZ29yeVtcIkhBUk1fQ0FURUdPUllfSEFURV9TUEVFQ0hcIl0gPSBcIkhBUk1fQ0FURUdPUllfSEFURV9TUEVFQ0hcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgaGFybSBjYXRlZ29yeSBpcyBzZXh1YWxseSBleHBsaWNpdCBjb250ZW50LlxuICAgICAqL1xuICAgIEhhcm1DYXRlZ29yeVtcIkhBUk1fQ0FURUdPUllfU0VYVUFMTFlfRVhQTElDSVRcIl0gPSBcIkhBUk1fQ0FURUdPUllfU0VYVUFMTFlfRVhQTElDSVRcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgaGFybSBjYXRlZ29yeSBpcyBkYW5nZXJvdXMgY29udGVudC5cbiAgICAgKi9cbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX0RBTkdFUk9VU19DT05URU5UXCJdID0gXCJIQVJNX0NBVEVHT1JZX0RBTkdFUk9VU19DT05URU5UXCI7XG4gICAgLyoqXG4gICAgICogRGVwcmVjYXRlZDogRWxlY3Rpb24gZmlsdGVyIGlzIG5vdCBsb25nZXIgc3VwcG9ydGVkLiBUaGUgaGFybSBjYXRlZ29yeSBpcyBjaXZpYyBpbnRlZ3JpdHkuXG4gICAgICovXG4gICAgSGFybUNhdGVnb3J5W1wiSEFSTV9DQVRFR09SWV9DSVZJQ19JTlRFR1JJVFlcIl0gPSBcIkhBUk1fQ0FURUdPUllfQ0lWSUNfSU5URUdSSVRZXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGhhcm0gY2F0ZWdvcnkgaXMgaW1hZ2UgaGF0ZS4gVGhpcyBlbnVtIHZhbHVlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS5cbiAgICAgKi9cbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX0lNQUdFX0hBVEVcIl0gPSBcIkhBUk1fQ0FURUdPUllfSU1BR0VfSEFURVwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGNhdGVnb3J5IGlzIGltYWdlIGRhbmdlcm91cyBjb250ZW50LiBUaGlzIGVudW0gdmFsdWUgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLlxuICAgICAqL1xuICAgIEhhcm1DYXRlZ29yeVtcIkhBUk1fQ0FURUdPUllfSU1BR0VfREFOR0VST1VTX0NPTlRFTlRcIl0gPSBcIkhBUk1fQ0FURUdPUllfSU1BR0VfREFOR0VST1VTX0NPTlRFTlRcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgaGFybSBjYXRlZ29yeSBpcyBpbWFnZSBoYXJhc3NtZW50LiBUaGlzIGVudW0gdmFsdWUgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLlxuICAgICAqL1xuICAgIEhhcm1DYXRlZ29yeVtcIkhBUk1fQ0FURUdPUllfSU1BR0VfSEFSQVNTTUVOVFwiXSA9IFwiSEFSTV9DQVRFR09SWV9JTUFHRV9IQVJBU1NNRU5UXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGhhcm0gY2F0ZWdvcnkgaXMgaW1hZ2Ugc2V4dWFsbHkgZXhwbGljaXQgY29udGVudC4gVGhpcyBlbnVtIHZhbHVlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS5cbiAgICAgKi9cbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX0lNQUdFX1NFWFVBTExZX0VYUExJQ0lUXCJdID0gXCJIQVJNX0NBVEVHT1JZX0lNQUdFX1NFWFVBTExZX0VYUExJQ0lUXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGhhcm0gY2F0ZWdvcnkgaXMgZm9yIGphaWxicmVhayBwcm9tcHRzLiBUaGlzIGVudW0gdmFsdWUgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLlxuICAgICAqL1xuICAgIEhhcm1DYXRlZ29yeVtcIkhBUk1fQ0FURUdPUllfSkFJTEJSRUFLXCJdID0gXCJIQVJNX0NBVEVHT1JZX0pBSUxCUkVBS1wiO1xufSkoSGFybUNhdGVnb3J5IHx8IChIYXJtQ2F0ZWdvcnkgPSB7fSkpO1xuLyoqIFNwZWNpZnkgaWYgdGhlIHRocmVzaG9sZCBpcyB1c2VkIGZvciBwcm9iYWJpbGl0eSBvciBzZXZlcml0eSBzY29yZS4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHRocmVzaG9sZCBpcyB1c2VkIGZvciBwcm9iYWJpbGl0eSBzY29yZS4gVGhpcyBlbnVtIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4gKi9cbnZhciBIYXJtQmxvY2tNZXRob2Q7XG4oZnVuY3Rpb24gKEhhcm1CbG9ja01ldGhvZCkge1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGJsb2NrIG1ldGhvZCBpcyB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBIYXJtQmxvY2tNZXRob2RbXCJIQVJNX0JMT0NLX01FVEhPRF9VTlNQRUNJRklFRFwiXSA9IFwiSEFSTV9CTE9DS19NRVRIT0RfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgaGFybSBibG9jayBtZXRob2QgdXNlcyBib3RoIHByb2JhYmlsaXR5IGFuZCBzZXZlcml0eSBzY29yZXMuXG4gICAgICovXG4gICAgSGFybUJsb2NrTWV0aG9kW1wiU0VWRVJJVFlcIl0gPSBcIlNFVkVSSVRZXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGhhcm0gYmxvY2sgbWV0aG9kIHVzZXMgdGhlIHByb2JhYmlsaXR5IHNjb3JlLlxuICAgICAqL1xuICAgIEhhcm1CbG9ja01ldGhvZFtcIlBST0JBQklMSVRZXCJdID0gXCJQUk9CQUJJTElUWVwiO1xufSkoSGFybUJsb2NrTWV0aG9kIHx8IChIYXJtQmxvY2tNZXRob2QgPSB7fSkpO1xuLyoqIFRoZSBoYXJtIGJsb2NrIHRocmVzaG9sZC4gKi9cbnZhciBIYXJtQmxvY2tUaHJlc2hvbGQ7XG4oZnVuY3Rpb24gKEhhcm1CbG9ja1RocmVzaG9sZCkge1xuICAgIC8qKlxuICAgICAqIFVuc3BlY2lmaWVkIGhhcm0gYmxvY2sgdGhyZXNob2xkLlxuICAgICAqL1xuICAgIEhhcm1CbG9ja1RocmVzaG9sZFtcIkhBUk1fQkxPQ0tfVEhSRVNIT0xEX1VOU1BFQ0lGSUVEXCJdID0gXCJIQVJNX0JMT0NLX1RIUkVTSE9MRF9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIEJsb2NrIGxvdyB0aHJlc2hvbGQgYW5kIGFib3ZlIChpLmUuIGJsb2NrIG1vcmUpLlxuICAgICAqL1xuICAgIEhhcm1CbG9ja1RocmVzaG9sZFtcIkJMT0NLX0xPV19BTkRfQUJPVkVcIl0gPSBcIkJMT0NLX0xPV19BTkRfQUJPVkVcIjtcbiAgICAvKipcbiAgICAgKiBCbG9jayBtZWRpdW0gdGhyZXNob2xkIGFuZCBhYm92ZS5cbiAgICAgKi9cbiAgICBIYXJtQmxvY2tUaHJlc2hvbGRbXCJCTE9DS19NRURJVU1fQU5EX0FCT1ZFXCJdID0gXCJCTE9DS19NRURJVU1fQU5EX0FCT1ZFXCI7XG4gICAgLyoqXG4gICAgICogQmxvY2sgb25seSBoaWdoIHRocmVzaG9sZCAoaS5lLiBibG9jayBsZXNzKS5cbiAgICAgKi9cbiAgICBIYXJtQmxvY2tUaHJlc2hvbGRbXCJCTE9DS19PTkxZX0hJR0hcIl0gPSBcIkJMT0NLX09OTFlfSElHSFwiO1xuICAgIC8qKlxuICAgICAqIEJsb2NrIG5vbmUuXG4gICAgICovXG4gICAgSGFybUJsb2NrVGhyZXNob2xkW1wiQkxPQ0tfTk9ORVwiXSA9IFwiQkxPQ0tfTk9ORVwiO1xuICAgIC8qKlxuICAgICAqIFR1cm4gb2ZmIHRoZSBzYWZldHkgZmlsdGVyLlxuICAgICAqL1xuICAgIEhhcm1CbG9ja1RocmVzaG9sZFtcIk9GRlwiXSA9IFwiT0ZGXCI7XG59KShIYXJtQmxvY2tUaHJlc2hvbGQgfHwgKEhhcm1CbG9ja1RocmVzaG9sZCA9IHt9KSk7XG4vKiogT3V0cHV0IG9ubHkuIFRoZSByZWFzb24gd2h5IHRoZSBtb2RlbCBzdG9wcGVkIGdlbmVyYXRpbmcgdG9rZW5zLlxuXG5JZiBlbXB0eSwgdGhlIG1vZGVsIGhhcyBub3Qgc3RvcHBlZCBnZW5lcmF0aW5nIHRoZSB0b2tlbnMuICovXG52YXIgRmluaXNoUmVhc29uO1xuKGZ1bmN0aW9uIChGaW5pc2hSZWFzb24pIHtcbiAgICAvKipcbiAgICAgKiBUaGUgZmluaXNoIHJlYXNvbiBpcyB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJGSU5JU0hfUkVBU09OX1VOU1BFQ0lGSUVEXCJdID0gXCJGSU5JU0hfUkVBU09OX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogVG9rZW4gZ2VuZXJhdGlvbiByZWFjaGVkIGEgbmF0dXJhbCBzdG9wcGluZyBwb2ludCBvciBhIGNvbmZpZ3VyZWQgc3RvcCBzZXF1ZW5jZS5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJTVE9QXCJdID0gXCJTVE9QXCI7XG4gICAgLyoqXG4gICAgICogVG9rZW4gZ2VuZXJhdGlvbiByZWFjaGVkIHRoZSBjb25maWd1cmVkIG1heGltdW0gb3V0cHV0IHRva2Vucy5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJNQVhfVE9LRU5TXCJdID0gXCJNQVhfVE9LRU5TXCI7XG4gICAgLyoqXG4gICAgICogVG9rZW4gZ2VuZXJhdGlvbiBzdG9wcGVkIGJlY2F1c2UgdGhlIGNvbnRlbnQgcG90ZW50aWFsbHkgY29udGFpbnMgc2FmZXR5IHZpb2xhdGlvbnMuIE5PVEU6IFdoZW4gc3RyZWFtaW5nLCBbY29udGVudF1bXSBpcyBlbXB0eSBpZiBjb250ZW50IGZpbHRlcnMgYmxvY2tzIHRoZSBvdXRwdXQuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiU0FGRVRZXCJdID0gXCJTQUZFVFlcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgdG9rZW4gZ2VuZXJhdGlvbiBzdG9wcGVkIGJlY2F1c2Ugb2YgcG90ZW50aWFsIHJlY2l0YXRpb24uXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiUkVDSVRBVElPTlwiXSA9IFwiUkVDSVRBVElPTlwiO1xuICAgIC8qKlxuICAgICAqIFRoZSB0b2tlbiBnZW5lcmF0aW9uIHN0b3BwZWQgYmVjYXVzZSBvZiB1c2luZyBhbiB1bnN1cHBvcnRlZCBsYW5ndWFnZS5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJMQU5HVUFHRVwiXSA9IFwiTEFOR1VBR0VcIjtcbiAgICAvKipcbiAgICAgKiBBbGwgb3RoZXIgcmVhc29ucyB0aGF0IHN0b3BwZWQgdGhlIHRva2VuIGdlbmVyYXRpb24uXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiT1RIRVJcIl0gPSBcIk9USEVSXCI7XG4gICAgLyoqXG4gICAgICogVG9rZW4gZ2VuZXJhdGlvbiBzdG9wcGVkIGJlY2F1c2UgdGhlIGNvbnRlbnQgY29udGFpbnMgZm9yYmlkZGVuIHRlcm1zLlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIkJMT0NLTElTVFwiXSA9IFwiQkxPQ0tMSVNUXCI7XG4gICAgLyoqXG4gICAgICogVG9rZW4gZ2VuZXJhdGlvbiBzdG9wcGVkIGZvciBwb3RlbnRpYWxseSBjb250YWluaW5nIHByb2hpYml0ZWQgY29udGVudC5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJQUk9ISUJJVEVEX0NPTlRFTlRcIl0gPSBcIlBST0hJQklURURfQ09OVEVOVFwiO1xuICAgIC8qKlxuICAgICAqIFRva2VuIGdlbmVyYXRpb24gc3RvcHBlZCBiZWNhdXNlIHRoZSBjb250ZW50IHBvdGVudGlhbGx5IGNvbnRhaW5zIFNlbnNpdGl2ZSBQZXJzb25hbGx5IElkZW50aWZpYWJsZSBJbmZvcm1hdGlvbiAoU1BJSSkuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiU1BJSVwiXSA9IFwiU1BJSVwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBmdW5jdGlvbiBjYWxsIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwgaXMgaW52YWxpZC5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJNQUxGT1JNRURfRlVOQ1RJT05fQ0FMTFwiXSA9IFwiTUFMRk9STUVEX0ZVTkNUSU9OX0NBTExcIjtcbiAgICAvKipcbiAgICAgKiBUb2tlbiBnZW5lcmF0aW9uIHN0b3BwZWQgYmVjYXVzZSBnZW5lcmF0ZWQgaW1hZ2VzIGhhdmUgc2FmZXR5IHZpb2xhdGlvbnMuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiSU1BR0VfU0FGRVRZXCJdID0gXCJJTUFHRV9TQUZFVFlcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgdG9vbCBjYWxsIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwgaXMgaW52YWxpZC5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJVTkVYUEVDVEVEX1RPT0xfQ0FMTFwiXSA9IFwiVU5FWFBFQ1RFRF9UT09MX0NBTExcIjtcbiAgICAvKipcbiAgICAgKiBJbWFnZSBnZW5lcmF0aW9uIHN0b3BwZWQgYmVjYXVzZSB0aGUgZ2VuZXJhdGVkIGltYWdlcyBoYXZlIHByb2hpYml0ZWQgY29udGVudC5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJJTUFHRV9QUk9ISUJJVEVEX0NPTlRFTlRcIl0gPSBcIklNQUdFX1BST0hJQklURURfQ09OVEVOVFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBtb2RlbCB3YXMgZXhwZWN0ZWQgdG8gZ2VuZXJhdGUgYW4gaW1hZ2UsIGJ1dCBub25lIHdhcyBnZW5lcmF0ZWQuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiTk9fSU1BR0VcIl0gPSBcIk5PX0lNQUdFXCI7XG59KShGaW5pc2hSZWFzb24gfHwgKEZpbmlzaFJlYXNvbiA9IHt9KSk7XG4vKiogT3V0cHV0IG9ubHkuIEhhcm0gcHJvYmFiaWxpdHkgbGV2ZWxzIGluIHRoZSBjb250ZW50LiAqL1xudmFyIEhhcm1Qcm9iYWJpbGl0eTtcbihmdW5jdGlvbiAoSGFybVByb2JhYmlsaXR5KSB7XG4gICAgLyoqXG4gICAgICogSGFybSBwcm9iYWJpbGl0eSB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBIYXJtUHJvYmFiaWxpdHlbXCJIQVJNX1BST0JBQklMSVRZX1VOU1BFQ0lGSUVEXCJdID0gXCJIQVJNX1BST0JBQklMSVRZX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogTmVnbGlnaWJsZSBsZXZlbCBvZiBoYXJtLlxuICAgICAqL1xuICAgIEhhcm1Qcm9iYWJpbGl0eVtcIk5FR0xJR0lCTEVcIl0gPSBcIk5FR0xJR0lCTEVcIjtcbiAgICAvKipcbiAgICAgKiBMb3cgbGV2ZWwgb2YgaGFybS5cbiAgICAgKi9cbiAgICBIYXJtUHJvYmFiaWxpdHlbXCJMT1dcIl0gPSBcIkxPV1wiO1xuICAgIC8qKlxuICAgICAqIE1lZGl1bSBsZXZlbCBvZiBoYXJtLlxuICAgICAqL1xuICAgIEhhcm1Qcm9iYWJpbGl0eVtcIk1FRElVTVwiXSA9IFwiTUVESVVNXCI7XG4gICAgLyoqXG4gICAgICogSGlnaCBsZXZlbCBvZiBoYXJtLlxuICAgICAqL1xuICAgIEhhcm1Qcm9iYWJpbGl0eVtcIkhJR0hcIl0gPSBcIkhJR0hcIjtcbn0pKEhhcm1Qcm9iYWJpbGl0eSB8fCAoSGFybVByb2JhYmlsaXR5ID0ge30pKTtcbi8qKiBPdXRwdXQgb25seS4gSGFybSBzZXZlcml0eSBsZXZlbHMgaW4gdGhlIGNvbnRlbnQuIFRoaXMgZW51bSBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuICovXG52YXIgSGFybVNldmVyaXR5O1xuKGZ1bmN0aW9uIChIYXJtU2V2ZXJpdHkpIHtcbiAgICAvKipcbiAgICAgKiBIYXJtIHNldmVyaXR5IHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIEhhcm1TZXZlcml0eVtcIkhBUk1fU0VWRVJJVFlfVU5TUEVDSUZJRURcIl0gPSBcIkhBUk1fU0VWRVJJVFlfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBOZWdsaWdpYmxlIGxldmVsIG9mIGhhcm0gc2V2ZXJpdHkuXG4gICAgICovXG4gICAgSGFybVNldmVyaXR5W1wiSEFSTV9TRVZFUklUWV9ORUdMSUdJQkxFXCJdID0gXCJIQVJNX1NFVkVSSVRZX05FR0xJR0lCTEVcIjtcbiAgICAvKipcbiAgICAgKiBMb3cgbGV2ZWwgb2YgaGFybSBzZXZlcml0eS5cbiAgICAgKi9cbiAgICBIYXJtU2V2ZXJpdHlbXCJIQVJNX1NFVkVSSVRZX0xPV1wiXSA9IFwiSEFSTV9TRVZFUklUWV9MT1dcIjtcbiAgICAvKipcbiAgICAgKiBNZWRpdW0gbGV2ZWwgb2YgaGFybSBzZXZlcml0eS5cbiAgICAgKi9cbiAgICBIYXJtU2V2ZXJpdHlbXCJIQVJNX1NFVkVSSVRZX01FRElVTVwiXSA9IFwiSEFSTV9TRVZFUklUWV9NRURJVU1cIjtcbiAgICAvKipcbiAgICAgKiBIaWdoIGxldmVsIG9mIGhhcm0gc2V2ZXJpdHkuXG4gICAgICovXG4gICAgSGFybVNldmVyaXR5W1wiSEFSTV9TRVZFUklUWV9ISUdIXCJdID0gXCJIQVJNX1NFVkVSSVRZX0hJR0hcIjtcbn0pKEhhcm1TZXZlcml0eSB8fCAoSGFybVNldmVyaXR5ID0ge30pKTtcbi8qKiBTdGF0dXMgb2YgdGhlIHVybCByZXRyaWV2YWwuICovXG52YXIgVXJsUmV0cmlldmFsU3RhdHVzO1xuKGZ1bmN0aW9uIChVcmxSZXRyaWV2YWxTdGF0dXMpIHtcbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHZhbHVlLiBUaGlzIHZhbHVlIGlzIHVudXNlZC5cbiAgICAgKi9cbiAgICBVcmxSZXRyaWV2YWxTdGF0dXNbXCJVUkxfUkVUUklFVkFMX1NUQVRVU19VTlNQRUNJRklFRFwiXSA9IFwiVVJMX1JFVFJJRVZBTF9TVEFUVVNfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBVcmwgcmV0cmlldmFsIGlzIHN1Y2Nlc3NmdWwuXG4gICAgICovXG4gICAgVXJsUmV0cmlldmFsU3RhdHVzW1wiVVJMX1JFVFJJRVZBTF9TVEFUVVNfU1VDQ0VTU1wiXSA9IFwiVVJMX1JFVFJJRVZBTF9TVEFUVVNfU1VDQ0VTU1wiO1xuICAgIC8qKlxuICAgICAqIFVybCByZXRyaWV2YWwgaXMgZmFpbGVkIGR1ZSB0byBlcnJvci5cbiAgICAgKi9cbiAgICBVcmxSZXRyaWV2YWxTdGF0dXNbXCJVUkxfUkVUUklFVkFMX1NUQVRVU19FUlJPUlwiXSA9IFwiVVJMX1JFVFJJRVZBTF9TVEFUVVNfRVJST1JcIjtcbiAgICAvKipcbiAgICAgKiBVcmwgcmV0cmlldmFsIGlzIGZhaWxlZCBiZWNhdXNlIHRoZSBjb250ZW50IGlzIGJlaGluZCBwYXl3YWxsLiBUaGlzIGVudW0gdmFsdWUgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuXG4gICAgICovXG4gICAgVXJsUmV0cmlldmFsU3RhdHVzW1wiVVJMX1JFVFJJRVZBTF9TVEFUVVNfUEFZV0FMTFwiXSA9IFwiVVJMX1JFVFJJRVZBTF9TVEFUVVNfUEFZV0FMTFwiO1xuICAgIC8qKlxuICAgICAqIFVybCByZXRyaWV2YWwgaXMgZmFpbGVkIGJlY2F1c2UgdGhlIGNvbnRlbnQgaXMgdW5zYWZlLiBUaGlzIGVudW0gdmFsdWUgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuXG4gICAgICovXG4gICAgVXJsUmV0cmlldmFsU3RhdHVzW1wiVVJMX1JFVFJJRVZBTF9TVEFUVVNfVU5TQUZFXCJdID0gXCJVUkxfUkVUUklFVkFMX1NUQVRVU19VTlNBRkVcIjtcbn0pKFVybFJldHJpZXZhbFN0YXR1cyB8fCAoVXJsUmV0cmlldmFsU3RhdHVzID0ge30pKTtcbi8qKiBPdXRwdXQgb25seS4gVGhlIHJlYXNvbiB3aHkgdGhlIHByb21wdCB3YXMgYmxvY2tlZC4gKi9cbnZhciBCbG9ja2VkUmVhc29uO1xuKGZ1bmN0aW9uIChCbG9ja2VkUmVhc29uKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGJsb2NrZWQgcmVhc29uIGlzIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIEJsb2NrZWRSZWFzb25bXCJCTE9DS0VEX1JFQVNPTl9VTlNQRUNJRklFRFwiXSA9IFwiQkxPQ0tFRF9SRUFTT05fVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJvbXB0IHdhcyBibG9ja2VkIGZvciBzYWZldHkgcmVhc29ucy5cbiAgICAgKi9cbiAgICBCbG9ja2VkUmVhc29uW1wiU0FGRVRZXCJdID0gXCJTQUZFVFlcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJvbXB0IHdhcyBibG9ja2VkIGZvciBvdGhlciByZWFzb25zLiBGb3IgZXhhbXBsZSwgaXQgbWF5IGJlIGR1ZSB0byB0aGUgcHJvbXB0J3MgbGFuZ3VhZ2UsIG9yIGJlY2F1c2UgaXQgY29udGFpbnMgb3RoZXIgaGFybWZ1bCBjb250ZW50LlxuICAgICAqL1xuICAgIEJsb2NrZWRSZWFzb25bXCJPVEhFUlwiXSA9IFwiT1RIRVJcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJvbXB0IHdhcyBibG9ja2VkIGJlY2F1c2UgaXQgY29udGFpbnMgYSB0ZXJtIGZyb20gdGhlIHRlcm1pbm9sb2d5IGJsb2NrbGlzdC5cbiAgICAgKi9cbiAgICBCbG9ja2VkUmVhc29uW1wiQkxPQ0tMSVNUXCJdID0gXCJCTE9DS0xJU1RcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJvbXB0IHdhcyBibG9ja2VkIGJlY2F1c2UgaXQgY29udGFpbnMgcHJvaGliaXRlZCBjb250ZW50LlxuICAgICAqL1xuICAgIEJsb2NrZWRSZWFzb25bXCJQUk9ISUJJVEVEX0NPTlRFTlRcIl0gPSBcIlBST0hJQklURURfQ09OVEVOVFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBwcm9tcHQgd2FzIGJsb2NrZWQgYmVjYXVzZSBpdCBjb250YWlucyBjb250ZW50IHRoYXQgaXMgdW5zYWZlIGZvciBpbWFnZSBnZW5lcmF0aW9uLlxuICAgICAqL1xuICAgIEJsb2NrZWRSZWFzb25bXCJJTUFHRV9TQUZFVFlcIl0gPSBcIklNQUdFX1NBRkVUWVwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBwcm9tcHQgd2FzIGJsb2NrZWQgYnkgTW9kZWwgQXJtb3IuIFRoaXMgZW51bSB2YWx1ZSBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuXG4gICAgICovXG4gICAgQmxvY2tlZFJlYXNvbltcIk1PREVMX0FSTU9SXCJdID0gXCJNT0RFTF9BUk1PUlwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBwcm9tcHQgd2FzIGJsb2NrZWQgYXMgYSBqYWlsYnJlYWsgYXR0ZW1wdC4gVGhpcyBlbnVtIHZhbHVlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS5cbiAgICAgKi9cbiAgICBCbG9ja2VkUmVhc29uW1wiSkFJTEJSRUFLXCJdID0gXCJKQUlMQlJFQUtcIjtcbn0pKEJsb2NrZWRSZWFzb24gfHwgKEJsb2NrZWRSZWFzb24gPSB7fSkpO1xuLyoqIE91dHB1dCBvbmx5LiBUaGUgdHJhZmZpYyB0eXBlIGZvciB0aGlzIHJlcXVlc3QuIFRoaXMgZW51bSBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuICovXG52YXIgVHJhZmZpY1R5cGU7XG4oZnVuY3Rpb24gKFRyYWZmaWNUeXBlKSB7XG4gICAgLyoqXG4gICAgICogVW5zcGVjaWZpZWQgcmVxdWVzdCB0cmFmZmljIHR5cGUuXG4gICAgICovXG4gICAgVHJhZmZpY1R5cGVbXCJUUkFGRklDX1RZUEVfVU5TUEVDSUZJRURcIl0gPSBcIlRSQUZGSUNfVFlQRV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSByZXF1ZXN0IHdhcyBwcm9jZXNzZWQgdXNpbmcgUGF5LUFzLVlvdS1HbyBxdW90YS5cbiAgICAgKi9cbiAgICBUcmFmZmljVHlwZVtcIk9OX0RFTUFORFwiXSA9IFwiT05fREVNQU5EXCI7XG4gICAgLyoqXG4gICAgICogVHlwZSBmb3IgUHJvdmlzaW9uZWQgVGhyb3VnaHB1dCB0cmFmZmljLlxuICAgICAqL1xuICAgIFRyYWZmaWNUeXBlW1wiUFJPVklTSU9ORURfVEhST1VHSFBVVFwiXSA9IFwiUFJPVklTSU9ORURfVEhST1VHSFBVVFwiO1xufSkoVHJhZmZpY1R5cGUgfHwgKFRyYWZmaWNUeXBlID0ge30pKTtcbi8qKiBTZXJ2ZXIgY29udGVudCBtb2RhbGl0aWVzLiAqL1xudmFyIE1vZGFsaXR5O1xuKGZ1bmN0aW9uIChNb2RhbGl0eSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBtb2RhbGl0eSBpcyB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBNb2RhbGl0eVtcIk1PREFMSVRZX1VOU1BFQ0lGSUVEXCJdID0gXCJNT0RBTElUWV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGUgbW9kZWwgc2hvdWxkIHJldHVybiB0ZXh0XG4gICAgICovXG4gICAgTW9kYWxpdHlbXCJURVhUXCJdID0gXCJURVhUXCI7XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoZSBtb2RlbCBzaG91bGQgcmV0dXJuIGltYWdlcy5cbiAgICAgKi9cbiAgICBNb2RhbGl0eVtcIklNQUdFXCJdID0gXCJJTUFHRVwiO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGUgbW9kZWwgc2hvdWxkIHJldHVybiBhdWRpby5cbiAgICAgKi9cbiAgICBNb2RhbGl0eVtcIkFVRElPXCJdID0gXCJBVURJT1wiO1xufSkoTW9kYWxpdHkgfHwgKE1vZGFsaXR5ID0ge30pKTtcbi8qKiBUaGUgbWVkaWEgcmVzb2x1dGlvbiB0byB1c2UuICovXG52YXIgTWVkaWFSZXNvbHV0aW9uO1xuKGZ1bmN0aW9uIChNZWRpYVJlc29sdXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBNZWRpYSByZXNvbHV0aW9uIGhhcyBub3QgYmVlbiBzZXRcbiAgICAgKi9cbiAgICBNZWRpYVJlc29sdXRpb25bXCJNRURJQV9SRVNPTFVUSU9OX1VOU1BFQ0lGSUVEXCJdID0gXCJNRURJQV9SRVNPTFVUSU9OX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogTWVkaWEgcmVzb2x1dGlvbiBzZXQgdG8gbG93ICg2NCB0b2tlbnMpLlxuICAgICAqL1xuICAgIE1lZGlhUmVzb2x1dGlvbltcIk1FRElBX1JFU09MVVRJT05fTE9XXCJdID0gXCJNRURJQV9SRVNPTFVUSU9OX0xPV1wiO1xuICAgIC8qKlxuICAgICAqIE1lZGlhIHJlc29sdXRpb24gc2V0IHRvIG1lZGl1bSAoMjU2IHRva2VucykuXG4gICAgICovXG4gICAgTWVkaWFSZXNvbHV0aW9uW1wiTUVESUFfUkVTT0xVVElPTl9NRURJVU1cIl0gPSBcIk1FRElBX1JFU09MVVRJT05fTUVESVVNXCI7XG4gICAgLyoqXG4gICAgICogTWVkaWEgcmVzb2x1dGlvbiBzZXQgdG8gaGlnaCAoem9vbWVkIHJlZnJhbWluZyB3aXRoIDI1NiB0b2tlbnMpLlxuICAgICAqL1xuICAgIE1lZGlhUmVzb2x1dGlvbltcIk1FRElBX1JFU09MVVRJT05fSElHSFwiXSA9IFwiTUVESUFfUkVTT0xVVElPTl9ISUdIXCI7XG59KShNZWRpYVJlc29sdXRpb24gfHwgKE1lZGlhUmVzb2x1dGlvbiA9IHt9KSk7XG4vKiogVHVuaW5nIG1vZGUuIFRoaXMgZW51bSBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuICovXG52YXIgVHVuaW5nTW9kZTtcbihmdW5jdGlvbiAoVHVuaW5nTW9kZSkge1xuICAgIC8qKlxuICAgICAqIFR1bmluZyBtb2RlIGlzIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIFR1bmluZ01vZGVbXCJUVU5JTkdfTU9ERV9VTlNQRUNJRklFRFwiXSA9IFwiVFVOSU5HX01PREVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBGdWxsIGZpbmUtdHVuaW5nIG1vZGUuXG4gICAgICovXG4gICAgVHVuaW5nTW9kZVtcIlRVTklOR19NT0RFX0ZVTExcIl0gPSBcIlRVTklOR19NT0RFX0ZVTExcIjtcbiAgICAvKipcbiAgICAgKiBQRUZUIGFkYXB0ZXIgdHVuaW5nIG1vZGUuXG4gICAgICovXG4gICAgVHVuaW5nTW9kZVtcIlRVTklOR19NT0RFX1BFRlRfQURBUFRFUlwiXSA9IFwiVFVOSU5HX01PREVfUEVGVF9BREFQVEVSXCI7XG59KShUdW5pbmdNb2RlIHx8IChUdW5pbmdNb2RlID0ge30pKTtcbi8qKiBBZGFwdGVyIHNpemUgZm9yIHR1bmluZy4gVGhpcyBlbnVtIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4gKi9cbnZhciBBZGFwdGVyU2l6ZTtcbihmdW5jdGlvbiAoQWRhcHRlclNpemUpIHtcbiAgICAvKipcbiAgICAgKiBBZGFwdGVyIHNpemUgaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgQWRhcHRlclNpemVbXCJBREFQVEVSX1NJWkVfVU5TUEVDSUZJRURcIl0gPSBcIkFEQVBURVJfU0laRV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIEFkYXB0ZXIgc2l6ZSAxLlxuICAgICAqL1xuICAgIEFkYXB0ZXJTaXplW1wiQURBUFRFUl9TSVpFX09ORVwiXSA9IFwiQURBUFRFUl9TSVpFX09ORVwiO1xuICAgIC8qKlxuICAgICAqIEFkYXB0ZXIgc2l6ZSAyLlxuICAgICAqL1xuICAgIEFkYXB0ZXJTaXplW1wiQURBUFRFUl9TSVpFX1RXT1wiXSA9IFwiQURBUFRFUl9TSVpFX1RXT1wiO1xuICAgIC8qKlxuICAgICAqIEFkYXB0ZXIgc2l6ZSA0LlxuICAgICAqL1xuICAgIEFkYXB0ZXJTaXplW1wiQURBUFRFUl9TSVpFX0ZPVVJcIl0gPSBcIkFEQVBURVJfU0laRV9GT1VSXCI7XG4gICAgLyoqXG4gICAgICogQWRhcHRlciBzaXplIDguXG4gICAgICovXG4gICAgQWRhcHRlclNpemVbXCJBREFQVEVSX1NJWkVfRUlHSFRcIl0gPSBcIkFEQVBURVJfU0laRV9FSUdIVFwiO1xuICAgIC8qKlxuICAgICAqIEFkYXB0ZXIgc2l6ZSAxNi5cbiAgICAgKi9cbiAgICBBZGFwdGVyU2l6ZVtcIkFEQVBURVJfU0laRV9TSVhURUVOXCJdID0gXCJBREFQVEVSX1NJWkVfU0lYVEVFTlwiO1xuICAgIC8qKlxuICAgICAqIEFkYXB0ZXIgc2l6ZSAzMi5cbiAgICAgKi9cbiAgICBBZGFwdGVyU2l6ZVtcIkFEQVBURVJfU0laRV9USElSVFlfVFdPXCJdID0gXCJBREFQVEVSX1NJWkVfVEhJUlRZX1RXT1wiO1xufSkoQWRhcHRlclNpemUgfHwgKEFkYXB0ZXJTaXplID0ge30pKTtcbi8qKiBKb2Igc3RhdGUuICovXG52YXIgSm9iU3RhdGU7XG4oZnVuY3Rpb24gKEpvYlN0YXRlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGpvYiBzdGF0ZSBpcyB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9VTlNQRUNJRklFRFwiXSA9IFwiSk9CX1NUQVRFX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGpvYiBoYXMgYmVlbiBqdXN0IGNyZWF0ZWQgb3IgcmVzdW1lZCBhbmQgcHJvY2Vzc2luZyBoYXMgbm90IHlldCBiZWd1bi5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9RVUVVRURcIl0gPSBcIkpPQl9TVEFURV9RVUVVRURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgc2VydmljZSBpcyBwcmVwYXJpbmcgdG8gcnVuIHRoZSBqb2IuXG4gICAgICovXG4gICAgSm9iU3RhdGVbXCJKT0JfU1RBVEVfUEVORElOR1wiXSA9IFwiSk9CX1NUQVRFX1BFTkRJTkdcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIGlzIGluIHByb2dyZXNzLlxuICAgICAqL1xuICAgIEpvYlN0YXRlW1wiSk9CX1NUQVRFX1JVTk5JTkdcIl0gPSBcIkpPQl9TVEFURV9SVU5OSU5HXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGpvYiBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LlxuICAgICAqL1xuICAgIEpvYlN0YXRlW1wiSk9CX1NUQVRFX1NVQ0NFRURFRFwiXSA9IFwiSk9CX1NUQVRFX1NVQ0NFRURFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBqb2IgZmFpbGVkLlxuICAgICAqL1xuICAgIEpvYlN0YXRlW1wiSk9CX1NUQVRFX0ZBSUxFRFwiXSA9IFwiSk9CX1NUQVRFX0ZBSUxFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBqb2IgaXMgYmVpbmcgY2FuY2VsbGVkLiBGcm9tIHRoaXMgc3RhdGUgdGhlIGpvYiBtYXkgb25seSBnbyB0byBlaXRoZXIgYEpPQl9TVEFURV9TVUNDRUVERURgLCBgSk9CX1NUQVRFX0ZBSUxFRGAgb3IgYEpPQl9TVEFURV9DQU5DRUxMRURgLlxuICAgICAqL1xuICAgIEpvYlN0YXRlW1wiSk9CX1NUQVRFX0NBTkNFTExJTkdcIl0gPSBcIkpPQl9TVEFURV9DQU5DRUxMSU5HXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGpvYiBoYXMgYmVlbiBjYW5jZWxsZWQuXG4gICAgICovXG4gICAgSm9iU3RhdGVbXCJKT0JfU1RBVEVfQ0FOQ0VMTEVEXCJdID0gXCJKT0JfU1RBVEVfQ0FOQ0VMTEVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGpvYiBoYXMgYmVlbiBzdG9wcGVkLCBhbmQgY2FuIGJlIHJlc3VtZWQuXG4gICAgICovXG4gICAgSm9iU3RhdGVbXCJKT0JfU1RBVEVfUEFVU0VEXCJdID0gXCJKT0JfU1RBVEVfUEFVU0VEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGpvYiBoYXMgZXhwaXJlZC5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9FWFBJUkVEXCJdID0gXCJKT0JfU1RBVEVfRVhQSVJFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBqb2IgaXMgYmVpbmcgdXBkYXRlZC4gT25seSBqb2JzIGluIHRoZSBgSk9CX1NUQVRFX1JVTk5JTkdgIHN0YXRlIGNhbiBiZSB1cGRhdGVkLiBBZnRlciB1cGRhdGluZywgdGhlIGpvYiBnb2VzIGJhY2sgdG8gdGhlIGBKT0JfU1RBVEVfUlVOTklOR2Agc3RhdGUuXG4gICAgICovXG4gICAgSm9iU3RhdGVbXCJKT0JfU1RBVEVfVVBEQVRJTkdcIl0gPSBcIkpPQl9TVEFURV9VUERBVElOR1wiO1xuICAgIC8qKlxuICAgICAqIFRoZSBqb2IgaXMgcGFydGlhbGx5IHN1Y2NlZWRlZCwgc29tZSByZXN1bHRzIG1heSBiZSBtaXNzaW5nIGR1ZSB0byBlcnJvcnMuXG4gICAgICovXG4gICAgSm9iU3RhdGVbXCJKT0JfU1RBVEVfUEFSVElBTExZX1NVQ0NFRURFRFwiXSA9IFwiSk9CX1NUQVRFX1BBUlRJQUxMWV9TVUNDRUVERURcIjtcbn0pKEpvYlN0YXRlIHx8IChKb2JTdGF0ZSA9IHt9KSk7XG4vKiogVGhlIHR1bmluZyB0YXNrLiBFaXRoZXIgSTJWIG9yIFQyVi4gVGhpcyBlbnVtIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4gKi9cbnZhciBUdW5pbmdUYXNrO1xuKGZ1bmN0aW9uIChUdW5pbmdUYXNrKSB7XG4gICAgLyoqXG4gICAgICogRGVmYXVsdCB2YWx1ZS4gVGhpcyB2YWx1ZSBpcyB1bnVzZWQuXG4gICAgICovXG4gICAgVHVuaW5nVGFza1tcIlRVTklOR19UQVNLX1VOU1BFQ0lGSUVEXCJdID0gXCJUVU5JTkdfVEFTS19VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFR1bmluZyB0YXNrIGZvciBpbWFnZSB0byB2aWRlby5cbiAgICAgKi9cbiAgICBUdW5pbmdUYXNrW1wiVFVOSU5HX1RBU0tfSTJWXCJdID0gXCJUVU5JTkdfVEFTS19JMlZcIjtcbiAgICAvKipcbiAgICAgKiBUdW5pbmcgdGFzayBmb3IgdGV4dCB0byB2aWRlby5cbiAgICAgKi9cbiAgICBUdW5pbmdUYXNrW1wiVFVOSU5HX1RBU0tfVDJWXCJdID0gXCJUVU5JTkdfVEFTS19UMlZcIjtcbiAgICAvKipcbiAgICAgKiBUdW5pbmcgdGFzayBmb3IgcmVmZXJlbmNlIHRvIHZpZGVvLlxuICAgICAqL1xuICAgIFR1bmluZ1Rhc2tbXCJUVU5JTkdfVEFTS19SMlZcIl0gPSBcIlRVTklOR19UQVNLX1IyVlwiO1xufSkoVHVuaW5nVGFzayB8fCAoVHVuaW5nVGFzayA9IHt9KSk7XG4vKiogVGhlIHRva2VuaXphdGlvbiBxdWFsaXR5IHVzZWQgZm9yIGdpdmVuIG1lZGlhLiAqL1xudmFyIFBhcnRNZWRpYVJlc29sdXRpb25MZXZlbDtcbihmdW5jdGlvbiAoUGFydE1lZGlhUmVzb2x1dGlvbkxldmVsKSB7XG4gICAgLyoqXG4gICAgICogTWVkaWEgcmVzb2x1dGlvbiBoYXMgbm90IGJlZW4gc2V0LlxuICAgICAqL1xuICAgIFBhcnRNZWRpYVJlc29sdXRpb25MZXZlbFtcIk1FRElBX1JFU09MVVRJT05fVU5TUEVDSUZJRURcIl0gPSBcIk1FRElBX1JFU09MVVRJT05fVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBNZWRpYSByZXNvbHV0aW9uIHNldCB0byBsb3cuXG4gICAgICovXG4gICAgUGFydE1lZGlhUmVzb2x1dGlvbkxldmVsW1wiTUVESUFfUkVTT0xVVElPTl9MT1dcIl0gPSBcIk1FRElBX1JFU09MVVRJT05fTE9XXCI7XG4gICAgLyoqXG4gICAgICogTWVkaWEgcmVzb2x1dGlvbiBzZXQgdG8gbWVkaXVtLlxuICAgICAqL1xuICAgIFBhcnRNZWRpYVJlc29sdXRpb25MZXZlbFtcIk1FRElBX1JFU09MVVRJT05fTUVESVVNXCJdID0gXCJNRURJQV9SRVNPTFVUSU9OX01FRElVTVwiO1xuICAgIC8qKlxuICAgICAqIE1lZGlhIHJlc29sdXRpb24gc2V0IHRvIGhpZ2guXG4gICAgICovXG4gICAgUGFydE1lZGlhUmVzb2x1dGlvbkxldmVsW1wiTUVESUFfUkVTT0xVVElPTl9ISUdIXCJdID0gXCJNRURJQV9SRVNPTFVUSU9OX0hJR0hcIjtcbn0pKFBhcnRNZWRpYVJlc29sdXRpb25MZXZlbCB8fCAoUGFydE1lZGlhUmVzb2x1dGlvbkxldmVsID0ge30pKTtcbi8qKiBPcHRpb25zIGZvciBmZWF0dXJlIHNlbGVjdGlvbiBwcmVmZXJlbmNlLiAqL1xudmFyIEZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlO1xuKGZ1bmN0aW9uIChGZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZSkge1xuICAgIEZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlW1wiRkVBVFVSRV9TRUxFQ1RJT05fUFJFRkVSRU5DRV9VTlNQRUNJRklFRFwiXSA9IFwiRkVBVFVSRV9TRUxFQ1RJT05fUFJFRkVSRU5DRV9VTlNQRUNJRklFRFwiO1xuICAgIEZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlW1wiUFJJT1JJVElaRV9RVUFMSVRZXCJdID0gXCJQUklPUklUSVpFX1FVQUxJVFlcIjtcbiAgICBGZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZVtcIkJBTEFOQ0VEXCJdID0gXCJCQUxBTkNFRFwiO1xuICAgIEZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlW1wiUFJJT1JJVElaRV9DT1NUXCJdID0gXCJQUklPUklUSVpFX0NPU1RcIjtcbn0pKEZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlIHx8IChGZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZSA9IHt9KSk7XG4vKiogRGVmaW5lcyB0aGUgZnVuY3Rpb24gYmVoYXZpb3IuIERlZmF1bHRzIHRvIGBCTE9DS0lOR2AuICovXG52YXIgQmVoYXZpb3I7XG4oZnVuY3Rpb24gKEJlaGF2aW9yKSB7XG4gICAgLyoqXG4gICAgICogVGhpcyB2YWx1ZSBpcyB1bnVzZWQuXG4gICAgICovXG4gICAgQmVoYXZpb3JbXCJVTlNQRUNJRklFRFwiXSA9IFwiVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBJZiBzZXQsIHRoZSBzeXN0ZW0gd2lsbCB3YWl0IHRvIHJlY2VpdmUgdGhlIGZ1bmN0aW9uIHJlc3BvbnNlIGJlZm9yZSBjb250aW51aW5nIHRoZSBjb252ZXJzYXRpb24uXG4gICAgICovXG4gICAgQmVoYXZpb3JbXCJCTE9DS0lOR1wiXSA9IFwiQkxPQ0tJTkdcIjtcbiAgICAvKipcbiAgICAgKiBJZiBzZXQsIHRoZSBzeXN0ZW0gd2lsbCBub3Qgd2FpdCB0byByZWNlaXZlIHRoZSBmdW5jdGlvbiByZXNwb25zZS4gSW5zdGVhZCwgaXQgd2lsbCBhdHRlbXB0IHRvIGhhbmRsZSBmdW5jdGlvbiByZXNwb25zZXMgYXMgdGhleSBiZWNvbWUgYXZhaWxhYmxlIHdoaWxlIG1haW50YWluaW5nIHRoZSBjb252ZXJzYXRpb24gYmV0d2VlbiB0aGUgdXNlciBhbmQgdGhlIG1vZGVsLlxuICAgICAqL1xuICAgIEJlaGF2aW9yW1wiTk9OX0JMT0NLSU5HXCJdID0gXCJOT05fQkxPQ0tJTkdcIjtcbn0pKEJlaGF2aW9yIHx8IChCZWhhdmlvciA9IHt9KSk7XG4vKiogQ29uZmlnIGZvciB0aGUgZHluYW1pYyByZXRyaWV2YWwgY29uZmlnIG1vZGUuICovXG52YXIgRHluYW1pY1JldHJpZXZhbENvbmZpZ01vZGU7XG4oZnVuY3Rpb24gKER5bmFtaWNSZXRyaWV2YWxDb25maWdNb2RlKSB7XG4gICAgLyoqXG4gICAgICogQWx3YXlzIHRyaWdnZXIgcmV0cmlldmFsLlxuICAgICAqL1xuICAgIER5bmFtaWNSZXRyaWV2YWxDb25maWdNb2RlW1wiTU9ERV9VTlNQRUNJRklFRFwiXSA9IFwiTU9ERV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFJ1biByZXRyaWV2YWwgb25seSB3aGVuIHN5c3RlbSBkZWNpZGVzIGl0IGlzIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBEeW5hbWljUmV0cmlldmFsQ29uZmlnTW9kZVtcIk1PREVfRFlOQU1JQ1wiXSA9IFwiTU9ERV9EWU5BTUlDXCI7XG59KShEeW5hbWljUmV0cmlldmFsQ29uZmlnTW9kZSB8fCAoRHluYW1pY1JldHJpZXZhbENvbmZpZ01vZGUgPSB7fSkpO1xuLyoqIFRoZSBlbnZpcm9ubWVudCBiZWluZyBvcGVyYXRlZC4gKi9cbnZhciBFbnZpcm9ubWVudDtcbihmdW5jdGlvbiAoRW52aXJvbm1lbnQpIHtcbiAgICAvKipcbiAgICAgKiBEZWZhdWx0cyB0byBicm93c2VyLlxuICAgICAqL1xuICAgIEVudmlyb25tZW50W1wiRU5WSVJPTk1FTlRfVU5TUEVDSUZJRURcIl0gPSBcIkVOVklST05NRU5UX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogT3BlcmF0ZXMgaW4gYSB3ZWIgYnJvd3Nlci5cbiAgICAgKi9cbiAgICBFbnZpcm9ubWVudFtcIkVOVklST05NRU5UX0JST1dTRVJcIl0gPSBcIkVOVklST05NRU5UX0JST1dTRVJcIjtcbn0pKEVudmlyb25tZW50IHx8IChFbnZpcm9ubWVudCA9IHt9KSk7XG4vKiogQ29uZmlnIGZvciB0aGUgZnVuY3Rpb24gY2FsbGluZyBjb25maWcgbW9kZS4gKi9cbnZhciBGdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlO1xuKGZ1bmN0aW9uIChGdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGZ1bmN0aW9uIGNhbGxpbmcgY29uZmlnIG1vZGUgaXMgdW5zcGVjaWZpZWQuIFNob3VsZCBub3QgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBGdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlW1wiTU9ERV9VTlNQRUNJRklFRFwiXSA9IFwiTU9ERV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIERlZmF1bHQgbW9kZWwgYmVoYXZpb3IsIG1vZGVsIGRlY2lkZXMgdG8gcHJlZGljdCBlaXRoZXIgZnVuY3Rpb24gY2FsbHMgb3IgbmF0dXJhbCBsYW5ndWFnZSByZXNwb25zZS5cbiAgICAgKi9cbiAgICBGdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlW1wiQVVUT1wiXSA9IFwiQVVUT1wiO1xuICAgIC8qKlxuICAgICAqIE1vZGVsIGlzIGNvbnN0cmFpbmVkIHRvIGFsd2F5cyBwcmVkaWN0aW5nIGZ1bmN0aW9uIGNhbGxzIG9ubHkuIElmIFwiYWxsb3dlZF9mdW5jdGlvbl9uYW1lc1wiIGFyZSBzZXQsIHRoZSBwcmVkaWN0ZWQgZnVuY3Rpb24gY2FsbHMgd2lsbCBiZSBsaW1pdGVkIHRvIGFueSBvbmUgb2YgXCJhbGxvd2VkX2Z1bmN0aW9uX25hbWVzXCIsIGVsc2UgdGhlIHByZWRpY3RlZCBmdW5jdGlvbiBjYWxscyB3aWxsIGJlIGFueSBvbmUgb2YgdGhlIHByb3ZpZGVkIFwiZnVuY3Rpb25fZGVjbGFyYXRpb25zXCIuXG4gICAgICovXG4gICAgRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZVtcIkFOWVwiXSA9IFwiQU5ZXCI7XG4gICAgLyoqXG4gICAgICogTW9kZWwgd2lsbCBub3QgcHJlZGljdCBhbnkgZnVuY3Rpb24gY2FsbHMuIE1vZGVsIGJlaGF2aW9yIGlzIHNhbWUgYXMgd2hlbiBub3QgcGFzc2luZyBhbnkgZnVuY3Rpb24gZGVjbGFyYXRpb25zLlxuICAgICAqL1xuICAgIEZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ01vZGVbXCJOT05FXCJdID0gXCJOT05FXCI7XG4gICAgLyoqXG4gICAgICogTW9kZWwgZGVjaWRlcyB0byBwcmVkaWN0IGVpdGhlciBhIGZ1bmN0aW9uIGNhbGwgb3IgYSBuYXR1cmFsIGxhbmd1YWdlIHJlc3BvbnNlLCBidXQgd2lsbCB2YWxpZGF0ZSBmdW5jdGlvbiBjYWxscyB3aXRoIGNvbnN0cmFpbmVkIGRlY29kaW5nLiBJZiBcImFsbG93ZWRfZnVuY3Rpb25fbmFtZXNcIiBhcmUgc2V0LCB0aGUgcHJlZGljdGVkIGZ1bmN0aW9uIGNhbGwgd2lsbCBiZSBsaW1pdGVkIHRvIGFueSBvbmUgb2YgXCJhbGxvd2VkX2Z1bmN0aW9uX25hbWVzXCIsIGVsc2UgdGhlIHByZWRpY3RlZCBmdW5jdGlvbiBjYWxsIHdpbGwgYmUgYW55IG9uZSBvZiB0aGUgcHJvdmlkZWQgXCJmdW5jdGlvbl9kZWNsYXJhdGlvbnNcIi5cbiAgICAgKi9cbiAgICBGdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlW1wiVkFMSURBVEVEXCJdID0gXCJWQUxJREFURURcIjtcbn0pKEZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ01vZGUgfHwgKEZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ01vZGUgPSB7fSkpO1xuLyoqIEVudW0gdGhhdCBjb250cm9scyB0aGUgc2FmZXR5IGZpbHRlciBsZXZlbCBmb3Igb2JqZWN0aW9uYWJsZSBjb250ZW50LiAqL1xudmFyIFNhZmV0eUZpbHRlckxldmVsO1xuKGZ1bmN0aW9uIChTYWZldHlGaWx0ZXJMZXZlbCkge1xuICAgIFNhZmV0eUZpbHRlckxldmVsW1wiQkxPQ0tfTE9XX0FORF9BQk9WRVwiXSA9IFwiQkxPQ0tfTE9XX0FORF9BQk9WRVwiO1xuICAgIFNhZmV0eUZpbHRlckxldmVsW1wiQkxPQ0tfTUVESVVNX0FORF9BQk9WRVwiXSA9IFwiQkxPQ0tfTUVESVVNX0FORF9BQk9WRVwiO1xuICAgIFNhZmV0eUZpbHRlckxldmVsW1wiQkxPQ0tfT05MWV9ISUdIXCJdID0gXCJCTE9DS19PTkxZX0hJR0hcIjtcbiAgICBTYWZldHlGaWx0ZXJMZXZlbFtcIkJMT0NLX05PTkVcIl0gPSBcIkJMT0NLX05PTkVcIjtcbn0pKFNhZmV0eUZpbHRlckxldmVsIHx8IChTYWZldHlGaWx0ZXJMZXZlbCA9IHt9KSk7XG4vKiogRW51bSB0aGF0IGNvbnRyb2xzIHRoZSBnZW5lcmF0aW9uIG9mIHBlb3BsZS4gKi9cbnZhciBQZXJzb25HZW5lcmF0aW9uO1xuKGZ1bmN0aW9uIChQZXJzb25HZW5lcmF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQmxvY2sgZ2VuZXJhdGlvbiBvZiBpbWFnZXMgb2YgcGVvcGxlLlxuICAgICAqL1xuICAgIFBlcnNvbkdlbmVyYXRpb25bXCJET05UX0FMTE9XXCJdID0gXCJET05UX0FMTE9XXCI7XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgaW1hZ2VzIG9mIGFkdWx0cywgYnV0IG5vdCBjaGlsZHJlbi5cbiAgICAgKi9cbiAgICBQZXJzb25HZW5lcmF0aW9uW1wiQUxMT1dfQURVTFRcIl0gPSBcIkFMTE9XX0FEVUxUXCI7XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgaW1hZ2VzIHRoYXQgaW5jbHVkZSBhZHVsdHMgYW5kIGNoaWxkcmVuLlxuICAgICAqL1xuICAgIFBlcnNvbkdlbmVyYXRpb25bXCJBTExPV19BTExcIl0gPSBcIkFMTE9XX0FMTFwiO1xufSkoUGVyc29uR2VuZXJhdGlvbiB8fCAoUGVyc29uR2VuZXJhdGlvbiA9IHt9KSk7XG4vKiogRW51bSB0aGF0IHNwZWNpZmllcyB0aGUgbGFuZ3VhZ2Ugb2YgdGhlIHRleHQgaW4gdGhlIHByb21wdC4gKi9cbnZhciBJbWFnZVByb21wdExhbmd1YWdlO1xuKGZ1bmN0aW9uIChJbWFnZVByb21wdExhbmd1YWdlKSB7XG4gICAgLyoqXG4gICAgICogQXV0by1kZXRlY3QgdGhlIGxhbmd1YWdlLlxuICAgICAqL1xuICAgIEltYWdlUHJvbXB0TGFuZ3VhZ2VbXCJhdXRvXCJdID0gXCJhdXRvXCI7XG4gICAgLyoqXG4gICAgICogRW5nbGlzaFxuICAgICAqL1xuICAgIEltYWdlUHJvbXB0TGFuZ3VhZ2VbXCJlblwiXSA9IFwiZW5cIjtcbiAgICAvKipcbiAgICAgKiBKYXBhbmVzZVxuICAgICAqL1xuICAgIEltYWdlUHJvbXB0TGFuZ3VhZ2VbXCJqYVwiXSA9IFwiamFcIjtcbiAgICAvKipcbiAgICAgKiBLb3JlYW5cbiAgICAgKi9cbiAgICBJbWFnZVByb21wdExhbmd1YWdlW1wia29cIl0gPSBcImtvXCI7XG4gICAgLyoqXG4gICAgICogSGluZGlcbiAgICAgKi9cbiAgICBJbWFnZVByb21wdExhbmd1YWdlW1wiaGlcIl0gPSBcImhpXCI7XG4gICAgLyoqXG4gICAgICogQ2hpbmVzZVxuICAgICAqL1xuICAgIEltYWdlUHJvbXB0TGFuZ3VhZ2VbXCJ6aFwiXSA9IFwiemhcIjtcbiAgICAvKipcbiAgICAgKiBQb3J0dWd1ZXNlXG4gICAgICovXG4gICAgSW1hZ2VQcm9tcHRMYW5ndWFnZVtcInB0XCJdID0gXCJwdFwiO1xuICAgIC8qKlxuICAgICAqIFNwYW5pc2hcbiAgICAgKi9cbiAgICBJbWFnZVByb21wdExhbmd1YWdlW1wiZXNcIl0gPSBcImVzXCI7XG59KShJbWFnZVByb21wdExhbmd1YWdlIHx8IChJbWFnZVByb21wdExhbmd1YWdlID0ge30pKTtcbi8qKiBFbnVtIHJlcHJlc2VudGluZyB0aGUgbWFzayBtb2RlIG9mIGEgbWFzayByZWZlcmVuY2UgaW1hZ2UuICovXG52YXIgTWFza1JlZmVyZW5jZU1vZGU7XG4oZnVuY3Rpb24gKE1hc2tSZWZlcmVuY2VNb2RlKSB7XG4gICAgTWFza1JlZmVyZW5jZU1vZGVbXCJNQVNLX01PREVfREVGQVVMVFwiXSA9IFwiTUFTS19NT0RFX0RFRkFVTFRcIjtcbiAgICBNYXNrUmVmZXJlbmNlTW9kZVtcIk1BU0tfTU9ERV9VU0VSX1BST1ZJREVEXCJdID0gXCJNQVNLX01PREVfVVNFUl9QUk9WSURFRFwiO1xuICAgIE1hc2tSZWZlcmVuY2VNb2RlW1wiTUFTS19NT0RFX0JBQ0tHUk9VTkRcIl0gPSBcIk1BU0tfTU9ERV9CQUNLR1JPVU5EXCI7XG4gICAgTWFza1JlZmVyZW5jZU1vZGVbXCJNQVNLX01PREVfRk9SRUdST1VORFwiXSA9IFwiTUFTS19NT0RFX0ZPUkVHUk9VTkRcIjtcbiAgICBNYXNrUmVmZXJlbmNlTW9kZVtcIk1BU0tfTU9ERV9TRU1BTlRJQ1wiXSA9IFwiTUFTS19NT0RFX1NFTUFOVElDXCI7XG59KShNYXNrUmVmZXJlbmNlTW9kZSB8fCAoTWFza1JlZmVyZW5jZU1vZGUgPSB7fSkpO1xuLyoqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBjb250cm9sIHR5cGUgb2YgYSBjb250cm9sIHJlZmVyZW5jZSBpbWFnZS4gKi9cbnZhciBDb250cm9sUmVmZXJlbmNlVHlwZTtcbihmdW5jdGlvbiAoQ29udHJvbFJlZmVyZW5jZVR5cGUpIHtcbiAgICBDb250cm9sUmVmZXJlbmNlVHlwZVtcIkNPTlRST0xfVFlQRV9ERUZBVUxUXCJdID0gXCJDT05UUk9MX1RZUEVfREVGQVVMVFwiO1xuICAgIENvbnRyb2xSZWZlcmVuY2VUeXBlW1wiQ09OVFJPTF9UWVBFX0NBTk5ZXCJdID0gXCJDT05UUk9MX1RZUEVfQ0FOTllcIjtcbiAgICBDb250cm9sUmVmZXJlbmNlVHlwZVtcIkNPTlRST0xfVFlQRV9TQ1JJQkJMRVwiXSA9IFwiQ09OVFJPTF9UWVBFX1NDUklCQkxFXCI7XG4gICAgQ29udHJvbFJlZmVyZW5jZVR5cGVbXCJDT05UUk9MX1RZUEVfRkFDRV9NRVNIXCJdID0gXCJDT05UUk9MX1RZUEVfRkFDRV9NRVNIXCI7XG59KShDb250cm9sUmVmZXJlbmNlVHlwZSB8fCAoQ29udHJvbFJlZmVyZW5jZVR5cGUgPSB7fSkpO1xuLyoqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBzdWJqZWN0IHR5cGUgb2YgYSBzdWJqZWN0IHJlZmVyZW5jZSBpbWFnZS4gKi9cbnZhciBTdWJqZWN0UmVmZXJlbmNlVHlwZTtcbihmdW5jdGlvbiAoU3ViamVjdFJlZmVyZW5jZVR5cGUpIHtcbiAgICBTdWJqZWN0UmVmZXJlbmNlVHlwZVtcIlNVQkpFQ1RfVFlQRV9ERUZBVUxUXCJdID0gXCJTVUJKRUNUX1RZUEVfREVGQVVMVFwiO1xuICAgIFN1YmplY3RSZWZlcmVuY2VUeXBlW1wiU1VCSkVDVF9UWVBFX1BFUlNPTlwiXSA9IFwiU1VCSkVDVF9UWVBFX1BFUlNPTlwiO1xuICAgIFN1YmplY3RSZWZlcmVuY2VUeXBlW1wiU1VCSkVDVF9UWVBFX0FOSU1BTFwiXSA9IFwiU1VCSkVDVF9UWVBFX0FOSU1BTFwiO1xuICAgIFN1YmplY3RSZWZlcmVuY2VUeXBlW1wiU1VCSkVDVF9UWVBFX1BST0RVQ1RcIl0gPSBcIlNVQkpFQ1RfVFlQRV9QUk9EVUNUXCI7XG59KShTdWJqZWN0UmVmZXJlbmNlVHlwZSB8fCAoU3ViamVjdFJlZmVyZW5jZVR5cGUgPSB7fSkpO1xuLyoqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBlZGl0aW5nIG1vZGUuICovXG52YXIgRWRpdE1vZGU7XG4oZnVuY3Rpb24gKEVkaXRNb2RlKSB7XG4gICAgRWRpdE1vZGVbXCJFRElUX01PREVfREVGQVVMVFwiXSA9IFwiRURJVF9NT0RFX0RFRkFVTFRcIjtcbiAgICBFZGl0TW9kZVtcIkVESVRfTU9ERV9JTlBBSU5UX1JFTU9WQUxcIl0gPSBcIkVESVRfTU9ERV9JTlBBSU5UX1JFTU9WQUxcIjtcbiAgICBFZGl0TW9kZVtcIkVESVRfTU9ERV9JTlBBSU5UX0lOU0VSVElPTlwiXSA9IFwiRURJVF9NT0RFX0lOUEFJTlRfSU5TRVJUSU9OXCI7XG4gICAgRWRpdE1vZGVbXCJFRElUX01PREVfT1VUUEFJTlRcIl0gPSBcIkVESVRfTU9ERV9PVVRQQUlOVFwiO1xuICAgIEVkaXRNb2RlW1wiRURJVF9NT0RFX0NPTlRST0xMRURfRURJVElOR1wiXSA9IFwiRURJVF9NT0RFX0NPTlRST0xMRURfRURJVElOR1wiO1xuICAgIEVkaXRNb2RlW1wiRURJVF9NT0RFX1NUWUxFXCJdID0gXCJFRElUX01PREVfU1RZTEVcIjtcbiAgICBFZGl0TW9kZVtcIkVESVRfTU9ERV9CR1NXQVBcIl0gPSBcIkVESVRfTU9ERV9CR1NXQVBcIjtcbiAgICBFZGl0TW9kZVtcIkVESVRfTU9ERV9QUk9EVUNUX0lNQUdFXCJdID0gXCJFRElUX01PREVfUFJPRFVDVF9JTUFHRVwiO1xufSkoRWRpdE1vZGUgfHwgKEVkaXRNb2RlID0ge30pKTtcbi8qKiBFbnVtIHRoYXQgcmVwcmVzZW50cyB0aGUgc2VnbWVudGF0aW9uIG1vZGUuICovXG52YXIgU2VnbWVudE1vZGU7XG4oZnVuY3Rpb24gKFNlZ21lbnRNb2RlKSB7XG4gICAgU2VnbWVudE1vZGVbXCJGT1JFR1JPVU5EXCJdID0gXCJGT1JFR1JPVU5EXCI7XG4gICAgU2VnbWVudE1vZGVbXCJCQUNLR1JPVU5EXCJdID0gXCJCQUNLR1JPVU5EXCI7XG4gICAgU2VnbWVudE1vZGVbXCJQUk9NUFRcIl0gPSBcIlBST01QVFwiO1xuICAgIFNlZ21lbnRNb2RlW1wiU0VNQU5USUNcIl0gPSBcIlNFTUFOVElDXCI7XG4gICAgU2VnbWVudE1vZGVbXCJJTlRFUkFDVElWRVwiXSA9IFwiSU5URVJBQ1RJVkVcIjtcbn0pKFNlZ21lbnRNb2RlIHx8IChTZWdtZW50TW9kZSA9IHt9KSk7XG4vKiogRW51bSBmb3IgdGhlIHJlZmVyZW5jZSB0eXBlIG9mIGEgdmlkZW8gZ2VuZXJhdGlvbiByZWZlcmVuY2UgaW1hZ2UuICovXG52YXIgVmlkZW9HZW5lcmF0aW9uUmVmZXJlbmNlVHlwZTtcbihmdW5jdGlvbiAoVmlkZW9HZW5lcmF0aW9uUmVmZXJlbmNlVHlwZSkge1xuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIGltYWdlIHRoYXQgcHJvdmlkZXMgYXNzZXRzIHRvIHRoZSBnZW5lcmF0ZWQgdmlkZW8sXG4gICAgICAgIHN1Y2ggYXMgdGhlIHNjZW5lLCBhbiBvYmplY3QsIGEgY2hhcmFjdGVyLCBldGMuXG4gICAgICovXG4gICAgVmlkZW9HZW5lcmF0aW9uUmVmZXJlbmNlVHlwZVtcIkFTU0VUXCJdID0gXCJBU1NFVFwiO1xuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIGltYWdlIHRoYXQgcHJvdmlkZXMgYWVzdGhldGljcyBpbmNsdWRpbmcgY29sb3JzLFxuICAgICAgICBsaWdodGluZywgdGV4dHVyZSwgZXRjLiwgdG8gYmUgdXNlZCBhcyB0aGUgc3R5bGUgb2YgdGhlIGdlbmVyYXRlZCB2aWRlbyxcbiAgICAgICAgc3VjaCBhcyAnYW5pbWUnLCAncGhvdG9ncmFwaHknLCAnb3JpZ2FtaScsIGV0Yy5cbiAgICAgKi9cbiAgICBWaWRlb0dlbmVyYXRpb25SZWZlcmVuY2VUeXBlW1wiU1RZTEVcIl0gPSBcIlNUWUxFXCI7XG59KShWaWRlb0dlbmVyYXRpb25SZWZlcmVuY2VUeXBlIHx8IChWaWRlb0dlbmVyYXRpb25SZWZlcmVuY2VUeXBlID0ge30pKTtcbi8qKiBFbnVtIGZvciB0aGUgbWFzayBtb2RlIG9mIGEgdmlkZW8gZ2VuZXJhdGlvbiBtYXNrLiAqL1xudmFyIFZpZGVvR2VuZXJhdGlvbk1hc2tNb2RlO1xuKGZ1bmN0aW9uIChWaWRlb0dlbmVyYXRpb25NYXNrTW9kZSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBpbWFnZSBtYXNrIGNvbnRhaW5zIGEgbWFza2VkIHJlY3Rhbmd1bGFyIHJlZ2lvbiB3aGljaCBpc1xuICAgICAgICBhcHBsaWVkIG9uIHRoZSBmaXJzdCBmcmFtZSBvZiB0aGUgaW5wdXQgdmlkZW8uIFRoZSBvYmplY3QgZGVzY3JpYmVkIGluXG4gICAgICAgIHRoZSBwcm9tcHQgaXMgaW5zZXJ0ZWQgaW50byB0aGlzIHJlZ2lvbiBhbmQgd2lsbCBhcHBlYXIgaW4gc3Vic2VxdWVudFxuICAgICAgICBmcmFtZXMuXG4gICAgICovXG4gICAgVmlkZW9HZW5lcmF0aW9uTWFza01vZGVbXCJJTlNFUlRcIl0gPSBcIklOU0VSVFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBpbWFnZSBtYXNrIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGFuIG9iamVjdCBpbiB0aGVcbiAgICAgICAgZmlyc3QgdmlkZW8gZnJhbWUgdG8gdHJhY2suIFRoaXMgb2JqZWN0IGlzIHJlbW92ZWQgZnJvbSB0aGUgdmlkZW8uXG4gICAgICovXG4gICAgVmlkZW9HZW5lcmF0aW9uTWFza01vZGVbXCJSRU1PVkVcIl0gPSBcIlJFTU9WRVwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBpbWFnZSBtYXNrIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGEgcmVnaW9uIGluIHRoZVxuICAgICAgICB2aWRlby4gT2JqZWN0cyBpbiB0aGlzIHJlZ2lvbiB3aWxsIGJlIHJlbW92ZWQuXG4gICAgICovXG4gICAgVmlkZW9HZW5lcmF0aW9uTWFza01vZGVbXCJSRU1PVkVfU1RBVElDXCJdID0gXCJSRU1PVkVfU1RBVElDXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGltYWdlIG1hc2sgY29udGFpbnMgYSBtYXNrZWQgcmVjdGFuZ3VsYXIgcmVnaW9uIHdoZXJlXG4gICAgICAgIHRoZSBpbnB1dCB2aWRlbyB3aWxsIGdvLiBUaGUgcmVtYWluaW5nIGFyZWEgd2lsbCBiZSBnZW5lcmF0ZWQuIFZpZGVvXG4gICAgICAgIG1hc2tzIGFyZSBub3Qgc3VwcG9ydGVkLlxuICAgICAqL1xuICAgIFZpZGVvR2VuZXJhdGlvbk1hc2tNb2RlW1wiT1VUUEFJTlRcIl0gPSBcIk9VVFBBSU5UXCI7XG59KShWaWRlb0dlbmVyYXRpb25NYXNrTW9kZSB8fCAoVmlkZW9HZW5lcmF0aW9uTWFza01vZGUgPSB7fSkpO1xuLyoqIEVudW0gdGhhdCBjb250cm9scyB0aGUgY29tcHJlc3Npb24gcXVhbGl0eSBvZiB0aGUgZ2VuZXJhdGVkIHZpZGVvcy4gKi9cbnZhciBWaWRlb0NvbXByZXNzaW9uUXVhbGl0eTtcbihmdW5jdGlvbiAoVmlkZW9Db21wcmVzc2lvblF1YWxpdHkpIHtcbiAgICAvKipcbiAgICAgKiBPcHRpbWl6ZWQgdmlkZW8gY29tcHJlc3Npb24gcXVhbGl0eS4gVGhpcyB3aWxsIHByb2R1Y2UgdmlkZW9zXG4gICAgICAgIHdpdGggYSBjb21wcmVzc2VkLCBzbWFsbGVyIGZpbGUgc2l6ZS5cbiAgICAgKi9cbiAgICBWaWRlb0NvbXByZXNzaW9uUXVhbGl0eVtcIk9QVElNSVpFRFwiXSA9IFwiT1BUSU1JWkVEXCI7XG4gICAgLyoqXG4gICAgICogTG9zc2xlc3MgdmlkZW8gY29tcHJlc3Npb24gcXVhbGl0eS4gVGhpcyB3aWxsIHByb2R1Y2UgdmlkZW9zXG4gICAgICAgIHdpdGggYSBsYXJnZXIgZmlsZSBzaXplLlxuICAgICAqL1xuICAgIFZpZGVvQ29tcHJlc3Npb25RdWFsaXR5W1wiTE9TU0xFU1NcIl0gPSBcIkxPU1NMRVNTXCI7XG59KShWaWRlb0NvbXByZXNzaW9uUXVhbGl0eSB8fCAoVmlkZW9Db21wcmVzc2lvblF1YWxpdHkgPSB7fSkpO1xuLyoqIEVudW0gcmVwcmVzZW50aW5nIHRoZSB0dW5pbmcgbWV0aG9kLiAqL1xudmFyIFR1bmluZ01ldGhvZDtcbihmdW5jdGlvbiAoVHVuaW5nTWV0aG9kKSB7XG4gICAgLyoqXG4gICAgICogU3VwZXJ2aXNlZCBmaW5lIHR1bmluZy5cbiAgICAgKi9cbiAgICBUdW5pbmdNZXRob2RbXCJTVVBFUlZJU0VEX0ZJTkVfVFVOSU5HXCJdID0gXCJTVVBFUlZJU0VEX0ZJTkVfVFVOSU5HXCI7XG4gICAgLyoqXG4gICAgICogUHJlZmVyZW5jZSBvcHRpbWl6YXRpb24gdHVuaW5nLlxuICAgICAqL1xuICAgIFR1bmluZ01ldGhvZFtcIlBSRUZFUkVOQ0VfVFVOSU5HXCJdID0gXCJQUkVGRVJFTkNFX1RVTklOR1wiO1xufSkoVHVuaW5nTWV0aG9kIHx8IChUdW5pbmdNZXRob2QgPSB7fSkpO1xuLyoqIFN0YXRlIGZvciB0aGUgbGlmZWN5Y2xlIG9mIGEgRG9jdW1lbnQuICovXG52YXIgRG9jdW1lbnRTdGF0ZTtcbihmdW5jdGlvbiAoRG9jdW1lbnRTdGF0ZSkge1xuICAgIERvY3VtZW50U3RhdGVbXCJTVEFURV9VTlNQRUNJRklFRFwiXSA9IFwiU1RBVEVfVU5TUEVDSUZJRURcIjtcbiAgICBEb2N1bWVudFN0YXRlW1wiU1RBVEVfUEVORElOR1wiXSA9IFwiU1RBVEVfUEVORElOR1wiO1xuICAgIERvY3VtZW50U3RhdGVbXCJTVEFURV9BQ1RJVkVcIl0gPSBcIlNUQVRFX0FDVElWRVwiO1xuICAgIERvY3VtZW50U3RhdGVbXCJTVEFURV9GQUlMRURcIl0gPSBcIlNUQVRFX0ZBSUxFRFwiO1xufSkoRG9jdW1lbnRTdGF0ZSB8fCAoRG9jdW1lbnRTdGF0ZSA9IHt9KSk7XG4vKiogU3RhdGUgZm9yIHRoZSBsaWZlY3ljbGUgb2YgYSBGaWxlLiAqL1xudmFyIEZpbGVTdGF0ZTtcbihmdW5jdGlvbiAoRmlsZVN0YXRlKSB7XG4gICAgRmlsZVN0YXRlW1wiU1RBVEVfVU5TUEVDSUZJRURcIl0gPSBcIlNUQVRFX1VOU1BFQ0lGSUVEXCI7XG4gICAgRmlsZVN0YXRlW1wiUFJPQ0VTU0lOR1wiXSA9IFwiUFJPQ0VTU0lOR1wiO1xuICAgIEZpbGVTdGF0ZVtcIkFDVElWRVwiXSA9IFwiQUNUSVZFXCI7XG4gICAgRmlsZVN0YXRlW1wiRkFJTEVEXCJdID0gXCJGQUlMRURcIjtcbn0pKEZpbGVTdGF0ZSB8fCAoRmlsZVN0YXRlID0ge30pKTtcbi8qKiBTb3VyY2Ugb2YgdGhlIEZpbGUuICovXG52YXIgRmlsZVNvdXJjZTtcbihmdW5jdGlvbiAoRmlsZVNvdXJjZSkge1xuICAgIEZpbGVTb3VyY2VbXCJTT1VSQ0VfVU5TUEVDSUZJRURcIl0gPSBcIlNPVVJDRV9VTlNQRUNJRklFRFwiO1xuICAgIEZpbGVTb3VyY2VbXCJVUExPQURFRFwiXSA9IFwiVVBMT0FERURcIjtcbiAgICBGaWxlU291cmNlW1wiR0VORVJBVEVEXCJdID0gXCJHRU5FUkFURURcIjtcbn0pKEZpbGVTb3VyY2UgfHwgKEZpbGVTb3VyY2UgPSB7fSkpO1xuLyoqIFRoZSByZWFzb24gd2h5IHRoZSB0dXJuIGlzIGNvbXBsZXRlLiAqL1xudmFyIFR1cm5Db21wbGV0ZVJlYXNvbjtcbihmdW5jdGlvbiAoVHVybkNvbXBsZXRlUmVhc29uKSB7XG4gICAgLyoqXG4gICAgICogRGVmYXVsdCB2YWx1ZS4gUmVhc29uIGlzIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIFR1cm5Db21wbGV0ZVJlYXNvbltcIlRVUk5fQ09NUExFVEVfUkVBU09OX1VOU1BFQ0lGSUVEXCJdID0gXCJUVVJOX0NPTVBMRVRFX1JFQVNPTl9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBmdW5jdGlvbiBjYWxsIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwgaXMgaW52YWxpZC5cbiAgICAgKi9cbiAgICBUdXJuQ29tcGxldGVSZWFzb25bXCJNQUxGT1JNRURfRlVOQ1RJT05fQ0FMTFwiXSA9IFwiTUFMRk9STUVEX0ZVTkNUSU9OX0NBTExcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgcmVzcG9uc2UgaXMgcmVqZWN0ZWQgYnkgdGhlIG1vZGVsLlxuICAgICAqL1xuICAgIFR1cm5Db21wbGV0ZVJlYXNvbltcIlJFU1BPTlNFX1JFSkVDVEVEXCJdID0gXCJSRVNQT05TRV9SRUpFQ1RFRFwiO1xuICAgIC8qKlxuICAgICAqIE5lZWRzIG1vcmUgaW5wdXQgZnJvbSB0aGUgdXNlci5cbiAgICAgKi9cbiAgICBUdXJuQ29tcGxldGVSZWFzb25bXCJORUVEX01PUkVfSU5QVVRcIl0gPSBcIk5FRURfTU9SRV9JTlBVVFwiO1xufSkoVHVybkNvbXBsZXRlUmVhc29uIHx8IChUdXJuQ29tcGxldGVSZWFzb24gPSB7fSkpO1xuLyoqIFNlcnZlciBjb250ZW50IG1vZGFsaXRpZXMuICovXG52YXIgTWVkaWFNb2RhbGl0eTtcbihmdW5jdGlvbiAoTWVkaWFNb2RhbGl0eSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBtb2RhbGl0eSBpcyB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBNZWRpYU1vZGFsaXR5W1wiTU9EQUxJVFlfVU5TUEVDSUZJRURcIl0gPSBcIk1PREFMSVRZX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogUGxhaW4gdGV4dC5cbiAgICAgKi9cbiAgICBNZWRpYU1vZGFsaXR5W1wiVEVYVFwiXSA9IFwiVEVYVFwiO1xuICAgIC8qKlxuICAgICAqIEltYWdlcy5cbiAgICAgKi9cbiAgICBNZWRpYU1vZGFsaXR5W1wiSU1BR0VcIl0gPSBcIklNQUdFXCI7XG4gICAgLyoqXG4gICAgICogVmlkZW8uXG4gICAgICovXG4gICAgTWVkaWFNb2RhbGl0eVtcIlZJREVPXCJdID0gXCJWSURFT1wiO1xuICAgIC8qKlxuICAgICAqIEF1ZGlvLlxuICAgICAqL1xuICAgIE1lZGlhTW9kYWxpdHlbXCJBVURJT1wiXSA9IFwiQVVESU9cIjtcbiAgICAvKipcbiAgICAgKiBEb2N1bWVudCwgZS5nLiBQREYuXG4gICAgICovXG4gICAgTWVkaWFNb2RhbGl0eVtcIkRPQ1VNRU5UXCJdID0gXCJET0NVTUVOVFwiO1xufSkoTWVkaWFNb2RhbGl0eSB8fCAoTWVkaWFNb2RhbGl0eSA9IHt9KSk7XG4vKiogU3RhcnQgb2Ygc3BlZWNoIHNlbnNpdGl2aXR5LiAqL1xudmFyIFN0YXJ0U2Vuc2l0aXZpdHk7XG4oZnVuY3Rpb24gKFN0YXJ0U2Vuc2l0aXZpdHkpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBpcyBTVEFSVF9TRU5TSVRJVklUWV9MT1cuXG4gICAgICovXG4gICAgU3RhcnRTZW5zaXRpdml0eVtcIlNUQVJUX1NFTlNJVElWSVRZX1VOU1BFQ0lGSUVEXCJdID0gXCJTVEFSVF9TRU5TSVRJVklUWV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIEF1dG9tYXRpYyBkZXRlY3Rpb24gd2lsbCBkZXRlY3QgdGhlIHN0YXJ0IG9mIHNwZWVjaCBtb3JlIG9mdGVuLlxuICAgICAqL1xuICAgIFN0YXJ0U2Vuc2l0aXZpdHlbXCJTVEFSVF9TRU5TSVRJVklUWV9ISUdIXCJdID0gXCJTVEFSVF9TRU5TSVRJVklUWV9ISUdIXCI7XG4gICAgLyoqXG4gICAgICogQXV0b21hdGljIGRldGVjdGlvbiB3aWxsIGRldGVjdCB0aGUgc3RhcnQgb2Ygc3BlZWNoIGxlc3Mgb2Z0ZW4uXG4gICAgICovXG4gICAgU3RhcnRTZW5zaXRpdml0eVtcIlNUQVJUX1NFTlNJVElWSVRZX0xPV1wiXSA9IFwiU1RBUlRfU0VOU0lUSVZJVFlfTE9XXCI7XG59KShTdGFydFNlbnNpdGl2aXR5IHx8IChTdGFydFNlbnNpdGl2aXR5ID0ge30pKTtcbi8qKiBFbmQgb2Ygc3BlZWNoIHNlbnNpdGl2aXR5LiAqL1xudmFyIEVuZFNlbnNpdGl2aXR5O1xuKGZ1bmN0aW9uIChFbmRTZW5zaXRpdml0eSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGlzIEVORF9TRU5TSVRJVklUWV9MT1cuXG4gICAgICovXG4gICAgRW5kU2Vuc2l0aXZpdHlbXCJFTkRfU0VOU0lUSVZJVFlfVU5TUEVDSUZJRURcIl0gPSBcIkVORF9TRU5TSVRJVklUWV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIEF1dG9tYXRpYyBkZXRlY3Rpb24gZW5kcyBzcGVlY2ggbW9yZSBvZnRlbi5cbiAgICAgKi9cbiAgICBFbmRTZW5zaXRpdml0eVtcIkVORF9TRU5TSVRJVklUWV9ISUdIXCJdID0gXCJFTkRfU0VOU0lUSVZJVFlfSElHSFwiO1xuICAgIC8qKlxuICAgICAqIEF1dG9tYXRpYyBkZXRlY3Rpb24gZW5kcyBzcGVlY2ggbGVzcyBvZnRlbi5cbiAgICAgKi9cbiAgICBFbmRTZW5zaXRpdml0eVtcIkVORF9TRU5TSVRJVklUWV9MT1dcIl0gPSBcIkVORF9TRU5TSVRJVklUWV9MT1dcIjtcbn0pKEVuZFNlbnNpdGl2aXR5IHx8IChFbmRTZW5zaXRpdml0eSA9IHt9KSk7XG4vKiogVGhlIGRpZmZlcmVudCB3YXlzIG9mIGhhbmRsaW5nIHVzZXIgYWN0aXZpdHkuICovXG52YXIgQWN0aXZpdHlIYW5kbGluZztcbihmdW5jdGlvbiAoQWN0aXZpdHlIYW5kbGluZykge1xuICAgIC8qKlxuICAgICAqIElmIHVuc3BlY2lmaWVkLCB0aGUgZGVmYXVsdCBiZWhhdmlvciBpcyBgU1RBUlRfT0ZfQUNUSVZJVFlfSU5URVJSVVBUU2AuXG4gICAgICovXG4gICAgQWN0aXZpdHlIYW5kbGluZ1tcIkFDVElWSVRZX0hBTkRMSU5HX1VOU1BFQ0lGSUVEXCJdID0gXCJBQ1RJVklUWV9IQU5ETElOR19VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHN0YXJ0IG9mIGFjdGl2aXR5IHdpbGwgaW50ZXJydXB0IHRoZSBtb2RlbCdzIHJlc3BvbnNlIChhbHNvIGNhbGxlZCBcImJhcmdlIGluXCIpLiBUaGUgbW9kZWwncyBjdXJyZW50IHJlc3BvbnNlIHdpbGwgYmUgY3V0LW9mZiBpbiB0aGUgbW9tZW50IG9mIHRoZSBpbnRlcnJ1cHRpb24uIFRoaXMgaXMgdGhlIGRlZmF1bHQgYmVoYXZpb3IuXG4gICAgICovXG4gICAgQWN0aXZpdHlIYW5kbGluZ1tcIlNUQVJUX09GX0FDVElWSVRZX0lOVEVSUlVQVFNcIl0gPSBcIlNUQVJUX09GX0FDVElWSVRZX0lOVEVSUlVQVFNcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgbW9kZWwncyByZXNwb25zZSB3aWxsIG5vdCBiZSBpbnRlcnJ1cHRlZC5cbiAgICAgKi9cbiAgICBBY3Rpdml0eUhhbmRsaW5nW1wiTk9fSU5URVJSVVBUSU9OXCJdID0gXCJOT19JTlRFUlJVUFRJT05cIjtcbn0pKEFjdGl2aXR5SGFuZGxpbmcgfHwgKEFjdGl2aXR5SGFuZGxpbmcgPSB7fSkpO1xuLyoqIE9wdGlvbnMgYWJvdXQgd2hpY2ggaW5wdXQgaXMgaW5jbHVkZWQgaW4gdGhlIHVzZXIncyB0dXJuLiAqL1xudmFyIFR1cm5Db3ZlcmFnZTtcbihmdW5jdGlvbiAoVHVybkNvdmVyYWdlKSB7XG4gICAgLyoqXG4gICAgICogSWYgdW5zcGVjaWZpZWQsIHRoZSBkZWZhdWx0IGJlaGF2aW9yIGlzIGBUVVJOX0lOQ0xVREVTX09OTFlfQUNUSVZJVFlgLlxuICAgICAqL1xuICAgIFR1cm5Db3ZlcmFnZVtcIlRVUk5fQ09WRVJBR0VfVU5TUEVDSUZJRURcIl0gPSBcIlRVUk5fQ09WRVJBR0VfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgdXNlcnMgdHVybiBvbmx5IGluY2x1ZGVzIGFjdGl2aXR5IHNpbmNlIHRoZSBsYXN0IHR1cm4sIGV4Y2x1ZGluZyBpbmFjdGl2aXR5IChlLmcuIHNpbGVuY2Ugb24gdGhlIGF1ZGlvIHN0cmVhbSkuIFRoaXMgaXMgdGhlIGRlZmF1bHQgYmVoYXZpb3IuXG4gICAgICovXG4gICAgVHVybkNvdmVyYWdlW1wiVFVSTl9JTkNMVURFU19PTkxZX0FDVElWSVRZXCJdID0gXCJUVVJOX0lOQ0xVREVTX09OTFlfQUNUSVZJVFlcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgdXNlcnMgdHVybiBpbmNsdWRlcyBhbGwgcmVhbHRpbWUgaW5wdXQgc2luY2UgdGhlIGxhc3QgdHVybiwgaW5jbHVkaW5nIGluYWN0aXZpdHkgKGUuZy4gc2lsZW5jZSBvbiB0aGUgYXVkaW8gc3RyZWFtKS5cbiAgICAgKi9cbiAgICBUdXJuQ292ZXJhZ2VbXCJUVVJOX0lOQ0xVREVTX0FMTF9JTlBVVFwiXSA9IFwiVFVSTl9JTkNMVURFU19BTExfSU5QVVRcIjtcbn0pKFR1cm5Db3ZlcmFnZSB8fCAoVHVybkNvdmVyYWdlID0ge30pKTtcbi8qKiBTY2FsZSBvZiB0aGUgZ2VuZXJhdGVkIG11c2ljLiAqL1xudmFyIFNjYWxlO1xuKGZ1bmN0aW9uIChTY2FsZSkge1xuICAgIC8qKlxuICAgICAqIERlZmF1bHQgdmFsdWUuIFRoaXMgdmFsdWUgaXMgdW51c2VkLlxuICAgICAqL1xuICAgIFNjYWxlW1wiU0NBTEVfVU5TUEVDSUZJRURcIl0gPSBcIlNDQUxFX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogQyBtYWpvciBvciBBIG1pbm9yLlxuICAgICAqL1xuICAgIFNjYWxlW1wiQ19NQUpPUl9BX01JTk9SXCJdID0gXCJDX01BSk9SX0FfTUlOT1JcIjtcbiAgICAvKipcbiAgICAgKiBEYiBtYWpvciBvciBCYiBtaW5vci5cbiAgICAgKi9cbiAgICBTY2FsZVtcIkRfRkxBVF9NQUpPUl9CX0ZMQVRfTUlOT1JcIl0gPSBcIkRfRkxBVF9NQUpPUl9CX0ZMQVRfTUlOT1JcIjtcbiAgICAvKipcbiAgICAgKiBEIG1ham9yIG9yIEIgbWlub3IuXG4gICAgICovXG4gICAgU2NhbGVbXCJEX01BSk9SX0JfTUlOT1JcIl0gPSBcIkRfTUFKT1JfQl9NSU5PUlwiO1xuICAgIC8qKlxuICAgICAqIEViIG1ham9yIG9yIEMgbWlub3JcbiAgICAgKi9cbiAgICBTY2FsZVtcIkVfRkxBVF9NQUpPUl9DX01JTk9SXCJdID0gXCJFX0ZMQVRfTUFKT1JfQ19NSU5PUlwiO1xuICAgIC8qKlxuICAgICAqIEUgbWFqb3Igb3IgRGIgbWlub3IuXG4gICAgICovXG4gICAgU2NhbGVbXCJFX01BSk9SX0RfRkxBVF9NSU5PUlwiXSA9IFwiRV9NQUpPUl9EX0ZMQVRfTUlOT1JcIjtcbiAgICAvKipcbiAgICAgKiBGIG1ham9yIG9yIEQgbWlub3IuXG4gICAgICovXG4gICAgU2NhbGVbXCJGX01BSk9SX0RfTUlOT1JcIl0gPSBcIkZfTUFKT1JfRF9NSU5PUlwiO1xuICAgIC8qKlxuICAgICAqIEdiIG1ham9yIG9yIEViIG1pbm9yLlxuICAgICAqL1xuICAgIFNjYWxlW1wiR19GTEFUX01BSk9SX0VfRkxBVF9NSU5PUlwiXSA9IFwiR19GTEFUX01BSk9SX0VfRkxBVF9NSU5PUlwiO1xuICAgIC8qKlxuICAgICAqIEcgbWFqb3Igb3IgRSBtaW5vci5cbiAgICAgKi9cbiAgICBTY2FsZVtcIkdfTUFKT1JfRV9NSU5PUlwiXSA9IFwiR19NQUpPUl9FX01JTk9SXCI7XG4gICAgLyoqXG4gICAgICogQWIgbWFqb3Igb3IgRiBtaW5vci5cbiAgICAgKi9cbiAgICBTY2FsZVtcIkFfRkxBVF9NQUpPUl9GX01JTk9SXCJdID0gXCJBX0ZMQVRfTUFKT1JfRl9NSU5PUlwiO1xuICAgIC8qKlxuICAgICAqIEEgbWFqb3Igb3IgR2IgbWlub3IuXG4gICAgICovXG4gICAgU2NhbGVbXCJBX01BSk9SX0dfRkxBVF9NSU5PUlwiXSA9IFwiQV9NQUpPUl9HX0ZMQVRfTUlOT1JcIjtcbiAgICAvKipcbiAgICAgKiBCYiBtYWpvciBvciBHIG1pbm9yLlxuICAgICAqL1xuICAgIFNjYWxlW1wiQl9GTEFUX01BSk9SX0dfTUlOT1JcIl0gPSBcIkJfRkxBVF9NQUpPUl9HX01JTk9SXCI7XG4gICAgLyoqXG4gICAgICogQiBtYWpvciBvciBBYiBtaW5vci5cbiAgICAgKi9cbiAgICBTY2FsZVtcIkJfTUFKT1JfQV9GTEFUX01JTk9SXCJdID0gXCJCX01BSk9SX0FfRkxBVF9NSU5PUlwiO1xufSkoU2NhbGUgfHwgKFNjYWxlID0ge30pKTtcbi8qKiBUaGUgbW9kZSBvZiBtdXNpYyBnZW5lcmF0aW9uLiAqL1xudmFyIE11c2ljR2VuZXJhdGlvbk1vZGU7XG4oZnVuY3Rpb24gKE11c2ljR2VuZXJhdGlvbk1vZGUpIHtcbiAgICAvKipcbiAgICAgKiBSZWx5IG9uIHRoZSBzZXJ2ZXIgZGVmYXVsdCBnZW5lcmF0aW9uIG1vZGUuXG4gICAgICovXG4gICAgTXVzaWNHZW5lcmF0aW9uTW9kZVtcIk1VU0lDX0dFTkVSQVRJT05fTU9ERV9VTlNQRUNJRklFRFwiXSA9IFwiTVVTSUNfR0VORVJBVElPTl9NT0RFX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogU3RlZXIgdGV4dCBwcm9tcHRzIHRvIHJlZ2lvbnMgb2YgbGF0ZW50IHNwYWNlIHdpdGggaGlnaGVyIHF1YWxpdHlcbiAgICAgICAgbXVzaWMuXG4gICAgICovXG4gICAgTXVzaWNHZW5lcmF0aW9uTW9kZVtcIlFVQUxJVFlcIl0gPSBcIlFVQUxJVFlcIjtcbiAgICAvKipcbiAgICAgKiBTdGVlciB0ZXh0IHByb21wdHMgdG8gcmVnaW9ucyBvZiBsYXRlbnQgc3BhY2Ugd2l0aCBhIGxhcmdlclxuICAgICAgICBkaXZlcnNpdHkgb2YgbXVzaWMuXG4gICAgICovXG4gICAgTXVzaWNHZW5lcmF0aW9uTW9kZVtcIkRJVkVSU0lUWVwiXSA9IFwiRElWRVJTSVRZXCI7XG4gICAgLyoqXG4gICAgICogU3RlZXIgdGV4dCBwcm9tcHRzIHRvIHJlZ2lvbnMgb2YgbGF0ZW50IHNwYWNlIG1vcmUgbGlrZWx5IHRvXG4gICAgICAgIGdlbmVyYXRlIG11c2ljIHdpdGggdm9jYWxzLlxuICAgICAqL1xuICAgIE11c2ljR2VuZXJhdGlvbk1vZGVbXCJWT0NBTElaQVRJT05cIl0gPSBcIlZPQ0FMSVpBVElPTlwiO1xufSkoTXVzaWNHZW5lcmF0aW9uTW9kZSB8fCAoTXVzaWNHZW5lcmF0aW9uTW9kZSA9IHt9KSk7XG4vKiogVGhlIHBsYXliYWNrIGNvbnRyb2wgc2lnbmFsIHRvIGFwcGx5IHRvIHRoZSBtdXNpYyBnZW5lcmF0aW9uLiAqL1xudmFyIExpdmVNdXNpY1BsYXliYWNrQ29udHJvbDtcbihmdW5jdGlvbiAoTGl2ZU11c2ljUGxheWJhY2tDb250cm9sKSB7XG4gICAgLyoqXG4gICAgICogVGhpcyB2YWx1ZSBpcyB1bnVzZWQuXG4gICAgICovXG4gICAgTGl2ZU11c2ljUGxheWJhY2tDb250cm9sW1wiUExBWUJBQ0tfQ09OVFJPTF9VTlNQRUNJRklFRFwiXSA9IFwiUExBWUJBQ0tfQ09OVFJPTF9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFN0YXJ0IGdlbmVyYXRpbmcgdGhlIG11c2ljLlxuICAgICAqL1xuICAgIExpdmVNdXNpY1BsYXliYWNrQ29udHJvbFtcIlBMQVlcIl0gPSBcIlBMQVlcIjtcbiAgICAvKipcbiAgICAgKiBIb2xkIHRoZSBtdXNpYyBnZW5lcmF0aW9uLiBVc2UgUExBWSB0byByZXN1bWUgZnJvbSB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgKi9cbiAgICBMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2xbXCJQQVVTRVwiXSA9IFwiUEFVU0VcIjtcbiAgICAvKipcbiAgICAgKiBTdG9wIHRoZSBtdXNpYyBnZW5lcmF0aW9uIGFuZCByZXNldCB0aGUgY29udGV4dCAocHJvbXB0cyByZXRhaW5lZCkuXG4gICAgICAgIFVzZSBQTEFZIHRvIHJlc3RhcnQgdGhlIG11c2ljIGdlbmVyYXRpb24uXG4gICAgICovXG4gICAgTGl2ZU11c2ljUGxheWJhY2tDb250cm9sW1wiU1RPUFwiXSA9IFwiU1RPUFwiO1xuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSBjb250ZXh0IG9mIHRoZSBtdXNpYyBnZW5lcmF0aW9uIHdpdGhvdXQgc3RvcHBpbmcgaXQuXG4gICAgICAgIFJldGFpbnMgdGhlIGN1cnJlbnQgcHJvbXB0cyBhbmQgY29uZmlnLlxuICAgICAqL1xuICAgIExpdmVNdXNpY1BsYXliYWNrQ29udHJvbFtcIlJFU0VUX0NPTlRFWFRcIl0gPSBcIlJFU0VUX0NPTlRFWFRcIjtcbn0pKExpdmVNdXNpY1BsYXliYWNrQ29udHJvbCB8fCAoTGl2ZU11c2ljUGxheWJhY2tDb250cm9sID0ge30pKTtcbi8qKiBSYXcgbWVkaWEgYnl0ZXMgZm9yIGZ1bmN0aW9uIHJlc3BvbnNlLlxuXG5UZXh0IHNob3VsZCBub3QgYmUgc2VudCBhcyByYXcgYnl0ZXMsIHVzZSB0aGUgRnVuY3Rpb25SZXNwb25zZS5yZXNwb25zZVxuZmllbGQuICovXG5jbGFzcyBGdW5jdGlvblJlc3BvbnNlQmxvYiB7XG59XG4vKiogVVJJIGJhc2VkIGRhdGEgZm9yIGZ1bmN0aW9uIHJlc3BvbnNlLiAqL1xuY2xhc3MgRnVuY3Rpb25SZXNwb25zZUZpbGVEYXRhIHtcbn1cbi8qKiBBIGRhdGF0eXBlIGNvbnRhaW5pbmcgbWVkaWEgdGhhdCBpcyBwYXJ0IG9mIGEgYEZ1bmN0aW9uUmVzcG9uc2VgIG1lc3NhZ2UuXG5cbkEgYEZ1bmN0aW9uUmVzcG9uc2VQYXJ0YCBjb25zaXN0cyBvZiBkYXRhIHdoaWNoIGhhcyBhbiBhc3NvY2lhdGVkIGRhdGF0eXBlLiBBXG5gRnVuY3Rpb25SZXNwb25zZVBhcnRgIGNhbiBvbmx5IGNvbnRhaW4gb25lIG9mIHRoZSBhY2NlcHRlZCB0eXBlcyBpblxuYEZ1bmN0aW9uUmVzcG9uc2VQYXJ0LmRhdGFgLlxuXG5BIGBGdW5jdGlvblJlc3BvbnNlUGFydGAgbXVzdCBoYXZlIGEgZml4ZWQgSUFOQSBNSU1FIHR5cGUgaWRlbnRpZnlpbmcgdGhlXG50eXBlIGFuZCBzdWJ0eXBlIG9mIHRoZSBtZWRpYSBpZiB0aGUgYGlubGluZV9kYXRhYCBmaWVsZCBpcyBmaWxsZWQgd2l0aCByYXdcbmJ5dGVzLiAqL1xuY2xhc3MgRnVuY3Rpb25SZXNwb25zZVBhcnQge1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYEZ1bmN0aW9uUmVzcG9uc2VQYXJ0YCBvYmplY3QgZnJvbSBhIGBiYXNlNjRgIGVuY29kZWQgYHN0cmluZ2AuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uUmVzcG9uc2VQYXJ0RnJvbUJhc2U2NChkYXRhLCBtaW1lVHlwZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlubGluZURhdGE6IHtcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICBtaW1lVHlwZTogbWltZVR5cGUsXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBGdW5jdGlvblJlc3BvbnNlUGFydGAgb2JqZWN0IGZyb20gYSBgVVJJYCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uUmVzcG9uc2VQYXJ0RnJvbVVyaSh1cmksIG1pbWVUeXBlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmlsZURhdGE6IHtcbiAgICAgICAgICAgIGZpbGVVcmk6IHVyaSxcbiAgICAgICAgICAgIG1pbWVUeXBlOiBtaW1lVHlwZSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqIEEgZnVuY3Rpb24gcmVzcG9uc2UuICovXG5jbGFzcyBGdW5jdGlvblJlc3BvbnNlIHtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBQYXJ0YCBvYmplY3QgZnJvbSBhIGBVUklgIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGFydEZyb21VcmkodXJpLCBtaW1lVHlwZSwgbWVkaWFSZXNvbHV0aW9uKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyBmaWxlRGF0YToge1xuICAgICAgICAgICAgZmlsZVVyaTogdXJpLFxuICAgICAgICAgICAgbWltZVR5cGU6IG1pbWVUeXBlLFxuICAgICAgICB9IH0sIChtZWRpYVJlc29sdXRpb24gJiYgeyBtZWRpYVJlc29sdXRpb246IHsgbGV2ZWw6IG1lZGlhUmVzb2x1dGlvbiB9IH0pKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBQYXJ0YCBvYmplY3QgZnJvbSBhIGB0ZXh0YCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBhcnRGcm9tVGV4dCh0ZXh0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGV4dDogdGV4dCxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYFBhcnRgIG9iamVjdCBmcm9tIGEgYEZ1bmN0aW9uQ2FsbGAgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjcmVhdGVQYXJ0RnJvbUZ1bmN0aW9uQ2FsbChuYW1lLCBhcmdzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnVuY3Rpb25DYWxsOiB7XG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgYXJnczogYXJncyxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYFBhcnRgIG9iamVjdCBmcm9tIGEgYEZ1bmN0aW9uUmVzcG9uc2VgIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGFydEZyb21GdW5jdGlvblJlc3BvbnNlKGlkLCBuYW1lLCByZXNwb25zZSwgcGFydHMgPSBbXSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZ1bmN0aW9uUmVzcG9uc2U6IE9iamVjdC5hc3NpZ24oeyBpZDogaWQsIG5hbWU6IG5hbWUsIHJlc3BvbnNlOiByZXNwb25zZSB9LCAocGFydHMubGVuZ3RoID4gMCAmJiB7IHBhcnRzIH0pKSxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYFBhcnRgIG9iamVjdCBmcm9tIGEgYGJhc2U2NGAgZW5jb2RlZCBgc3RyaW5nYC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGFydEZyb21CYXNlNjQoZGF0YSwgbWltZVR5cGUsIG1lZGlhUmVzb2x1dGlvbikge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgaW5saW5lRGF0YToge1xuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIG1pbWVUeXBlOiBtaW1lVHlwZSxcbiAgICAgICAgfSB9LCAobWVkaWFSZXNvbHV0aW9uICYmIHsgbWVkaWFSZXNvbHV0aW9uOiB7IGxldmVsOiBtZWRpYVJlc29sdXRpb24gfSB9KSk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBgUGFydGAgb2JqZWN0IGZyb20gdGhlIGBvdXRjb21lYCBhbmQgYG91dHB1dGAgb2YgYSBgQ29kZUV4ZWN1dGlvblJlc3VsdGAgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjcmVhdGVQYXJ0RnJvbUNvZGVFeGVjdXRpb25SZXN1bHQob3V0Y29tZSwgb3V0cHV0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29kZUV4ZWN1dGlvblJlc3VsdDoge1xuICAgICAgICAgICAgb3V0Y29tZTogb3V0Y29tZSxcbiAgICAgICAgICAgIG91dHB1dDogb3V0cHV0LFxuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBgUGFydGAgb2JqZWN0IGZyb20gdGhlIGBjb2RlYCBhbmQgYGxhbmd1YWdlYCBvZiBhbiBgRXhlY3V0YWJsZUNvZGVgIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGFydEZyb21FeGVjdXRhYmxlQ29kZShjb2RlLCBsYW5ndWFnZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGV4ZWN1dGFibGVDb2RlOiB7XG4gICAgICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICAgICAgbGFuZ3VhZ2U6IGxhbmd1YWdlLFxuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBfaXNQYXJ0KG9iaikge1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICgnZmlsZURhdGEnIGluIG9iaiB8fFxuICAgICAgICAgICAgJ3RleHQnIGluIG9iaiB8fFxuICAgICAgICAgICAgJ2Z1bmN0aW9uQ2FsbCcgaW4gb2JqIHx8XG4gICAgICAgICAgICAnZnVuY3Rpb25SZXNwb25zZScgaW4gb2JqIHx8XG4gICAgICAgICAgICAnaW5saW5lRGF0YScgaW4gb2JqIHx8XG4gICAgICAgICAgICAndmlkZW9NZXRhZGF0YScgaW4gb2JqIHx8XG4gICAgICAgICAgICAnY29kZUV4ZWN1dGlvblJlc3VsdCcgaW4gb2JqIHx8XG4gICAgICAgICAgICAnZXhlY3V0YWJsZUNvZGUnIGluIG9iaik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIF90b1BhcnRzKHBhcnRPclN0cmluZykge1xuICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgaWYgKHR5cGVvZiBwYXJ0T3JTdHJpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhcnRzLnB1c2goY3JlYXRlUGFydEZyb21UZXh0KHBhcnRPclN0cmluZykpO1xuICAgIH1cbiAgICBlbHNlIGlmIChfaXNQYXJ0KHBhcnRPclN0cmluZykpIHtcbiAgICAgICAgcGFydHMucHVzaChwYXJ0T3JTdHJpbmcpO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBhcnRPclN0cmluZykpIHtcbiAgICAgICAgaWYgKHBhcnRPclN0cmluZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFydE9yU3RyaW5nIGNhbm5vdCBiZSBhbiBlbXB0eSBhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0T3JTdHJpbmcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGNyZWF0ZVBhcnRGcm9tVGV4dChwYXJ0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChfaXNQYXJ0KHBhcnQpKSB7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZWxlbWVudCBpbiBQYXJ0VW5pb24gbXVzdCBiZSBhIFBhcnQgb2JqZWN0IG9yIHN0cmluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcnRPclN0cmluZyBtdXN0IGJlIGEgUGFydCBvYmplY3QsIHN0cmluZywgb3IgYXJyYXknKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYENvbnRlbnRgIG9iamVjdCB3aXRoIGEgdXNlciByb2xlIGZyb20gYSBgUGFydExpc3RVbmlvbmAgb2JqZWN0IG9yIGBzdHJpbmdgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVVc2VyQ29udGVudChwYXJ0T3JTdHJpbmcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgIHBhcnRzOiBfdG9QYXJ0cyhwYXJ0T3JTdHJpbmcpLFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBgQ29udGVudGAgb2JqZWN0IHdpdGggYSBtb2RlbCByb2xlIGZyb20gYSBgUGFydExpc3RVbmlvbmAgb2JqZWN0IG9yIGBzdHJpbmdgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVNb2RlbENvbnRlbnQocGFydE9yU3RyaW5nKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogJ21vZGVsJyxcbiAgICAgICAgcGFydHM6IF90b1BhcnRzKHBhcnRPclN0cmluZyksXG4gICAgfTtcbn1cbi8qKiBBIHdyYXBwZXIgY2xhc3MgZm9yIHRoZSBodHRwIHJlc3BvbnNlLiAqL1xuY2xhc3MgSHR0cFJlc3BvbnNlIHtcbiAgICBjb25zdHJ1Y3RvcihyZXNwb25zZSkge1xuICAgICAgICAvLyBQcm9jZXNzIHRoZSBoZWFkZXJzLlxuICAgICAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgcGFpciBvZiByZXNwb25zZS5oZWFkZXJzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaGVhZGVyc1twYWlyWzBdXSA9IHBhaXJbMV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgICAgLy8gS2VlcCB0aGUgb3JpZ2luYWwgcmVzcG9uc2UuXG4gICAgICAgIHRoaXMucmVzcG9uc2VJbnRlcm5hbCA9IHJlc3BvbnNlO1xuICAgIH1cbiAgICBqc29uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNwb25zZUludGVybmFsLmpzb24oKTtcbiAgICB9XG59XG4vKiogQ29udGVudCBmaWx0ZXIgcmVzdWx0cyBmb3IgYSBwcm9tcHQgc2VudCBpbiB0aGUgcmVxdWVzdC4gTm90ZTogVGhpcyBpcyBzZW50IG9ubHkgaW4gdGhlIGZpcnN0IHN0cmVhbSBjaHVuayBhbmQgb25seSBpZiBubyBjYW5kaWRhdGVzIHdlcmUgZ2VuZXJhdGVkIGR1ZSB0byBjb250ZW50IHZpb2xhdGlvbnMuICovXG5jbGFzcyBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZVByb21wdEZlZWRiYWNrIHtcbn1cbi8qKiBVc2FnZSBtZXRhZGF0YSBhYm91dCB0aGUgY29udGVudCBnZW5lcmF0aW9uIHJlcXVlc3QgYW5kIHJlc3BvbnNlLiBUaGlzIG1lc3NhZ2UgcHJvdmlkZXMgYSBkZXRhaWxlZCBicmVha2Rvd24gb2YgdG9rZW4gdXNhZ2UgYW5kIG90aGVyIHJlbGV2YW50IG1ldHJpY3MuIFRoaXMgZGF0YSB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4gKi9cbmNsYXNzIEdlbmVyYXRlQ29udGVudFJlc3BvbnNlVXNhZ2VNZXRhZGF0YSB7XG59XG4vKiogUmVzcG9uc2UgbWVzc2FnZSBmb3IgUHJlZGljdGlvblNlcnZpY2UuR2VuZXJhdGVDb250ZW50LiAqL1xuY2xhc3MgR2VuZXJhdGVDb250ZW50UmVzcG9uc2Uge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIHRleHQgcGFydHMgZnJvbSB0aGUgZmlyc3QgY2FuZGlkYXRlIGluIHRoZSByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSWYgdGhlcmUgYXJlIG11bHRpcGxlIGNhbmRpZGF0ZXMgaW4gdGhlIHJlc3BvbnNlLCB0aGUgdGV4dCBmcm9tIHRoZSBmaXJzdFxuICAgICAqIG9uZSB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIElmIHRoZXJlIGFyZSBub24tdGV4dCBwYXJ0cyBpbiB0aGUgcmVzcG9uc2UsIHRoZSBjb25jYXRlbmF0aW9uIG9mIGFsbCB0ZXh0XG4gICAgICogcGFydHMgd2lsbCBiZSByZXR1cm5lZCwgYW5kIGEgd2FybmluZyB3aWxsIGJlIGxvZ2dlZC5cbiAgICAgKiBJZiB0aGVyZSBhcmUgdGhvdWdodCBwYXJ0cyBpbiB0aGUgcmVzcG9uc2UsIHRoZSBjb25jYXRlbmF0aW9uIG9mIGFsbCB0ZXh0XG4gICAgICogcGFydHMgZXhjbHVkaW5nIHRoZSB0aG91Z2h0IHBhcnRzIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5tb2RlbHMuZ2VuZXJhdGVDb250ZW50KHtcbiAgICAgKiAgIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaCcsXG4gICAgICogICBjb250ZW50czpcbiAgICAgKiAgICAgJ1doeSBpcyB0aGUgc2t5IGJsdWU/JyxcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUuZGVidWcocmVzcG9uc2UudGV4dCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IHRleHQoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2g7XG4gICAgICAgIGlmICgoKF9kID0gKF9jID0gKF9iID0gKF9hID0gdGhpcy5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb250ZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucGFydHMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5sZW5ndGgpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNhbmRpZGF0ZXMgJiYgdGhpcy5jYW5kaWRhdGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigndGhlcmUgYXJlIG11bHRpcGxlIGNhbmRpZGF0ZXMgaW4gdGhlIHJlc3BvbnNlLCByZXR1cm5pbmcgdGV4dCBmcm9tIHRoZSBmaXJzdCBvbmUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRleHQgPSAnJztcbiAgICAgICAgbGV0IGFueVRleHRQYXJ0VGV4dCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBub25UZXh0UGFydHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIChfaCA9IChfZyA9IChfZiA9IChfZSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lWzBdKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY29udGVudCkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLnBhcnRzKSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiBbXSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbZmllbGROYW1lLCBmaWVsZFZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwYXJ0KSkge1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZE5hbWUgIT09ICd0ZXh0JyAmJlxuICAgICAgICAgICAgICAgICAgICBmaWVsZE5hbWUgIT09ICd0aG91Z2h0JyAmJlxuICAgICAgICAgICAgICAgICAgICBmaWVsZE5hbWUgIT09ICd0aG91Z2h0U2lnbmF0dXJlJyAmJlxuICAgICAgICAgICAgICAgICAgICAoZmllbGRWYWx1ZSAhPT0gbnVsbCB8fCBmaWVsZFZhbHVlICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vblRleHRQYXJ0cy5wdXNoKGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0LnRleHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0LnRob3VnaHQgPT09ICdib29sZWFuJyAmJiBwYXJ0LnRob3VnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFueVRleHRQYXJ0VGV4dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGV4dCArPSBwYXJ0LnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vblRleHRQYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYHRoZXJlIGFyZSBub24tdGV4dCBwYXJ0cyAke25vblRleHRQYXJ0c30gaW4gdGhlIHJlc3BvbnNlLCByZXR1cm5pbmcgY29uY2F0ZW5hdGlvbiBvZiBhbGwgdGV4dCBwYXJ0cy4gUGxlYXNlIHJlZmVyIHRvIHRoZSBub24gdGV4dCBwYXJ0cyBmb3IgYSBmdWxsIHJlc3BvbnNlIGZyb20gbW9kZWwuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGFydC50ZXh0ID09PSAnJyBpcyBkaWZmZXJlbnQgZnJvbSBwYXJ0LnRleHQgaXMgbnVsbFxuICAgICAgICByZXR1cm4gYW55VGV4dFBhcnRUZXh0ID8gdGV4dCA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29uY2F0ZW5hdGlvbiBvZiBhbGwgaW5saW5lIGRhdGEgcGFydHMgZnJvbSB0aGUgZmlyc3QgY2FuZGlkYXRlXG4gICAgICogaW4gdGhlIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgY2FuZGlkYXRlcyBpbiB0aGUgcmVzcG9uc2UsIHRoZSBpbmxpbmUgZGF0YSBmcm9tIHRoZVxuICAgICAqIGZpcnN0IG9uZSB3aWxsIGJlIHJldHVybmVkLiBJZiB0aGVyZSBhcmUgbm9uLWlubGluZSBkYXRhIHBhcnRzIGluIHRoZVxuICAgICAqIHJlc3BvbnNlLCB0aGUgY29uY2F0ZW5hdGlvbiBvZiBhbGwgaW5saW5lIGRhdGEgcGFydHMgd2lsbCBiZSByZXR1cm5lZCwgYW5kXG4gICAgICogYSB3YXJuaW5nIHdpbGwgYmUgbG9nZ2VkLlxuICAgICAqL1xuICAgIGdldCBkYXRhKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oO1xuICAgICAgICBpZiAoKChfZCA9IChfYyA9IChfYiA9IChfYSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY29udGVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnBhcnRzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jYW5kaWRhdGVzICYmIHRoaXMuY2FuZGlkYXRlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3RoZXJlIGFyZSBtdWx0aXBsZSBjYW5kaWRhdGVzIGluIHRoZSByZXNwb25zZSwgcmV0dXJuaW5nIGRhdGEgZnJvbSB0aGUgZmlyc3Qgb25lLicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkYXRhID0gJyc7XG4gICAgICAgIGNvbnN0IG5vbkRhdGFQYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgKF9oID0gKF9nID0gKF9mID0gKF9lID0gdGhpcy5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2VbMF0pID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jb250ZW50KSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cucGFydHMpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IFtdKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIGZpZWxkVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcnQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSAhPT0gJ2lubGluZURhdGEnICYmXG4gICAgICAgICAgICAgICAgICAgIChmaWVsZFZhbHVlICE9PSBudWxsIHx8IGZpZWxkVmFsdWUgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9uRGF0YVBhcnRzLnB1c2goZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFydC5pbmxpbmVEYXRhICYmIHR5cGVvZiBwYXJ0LmlubGluZURhdGEuZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBkYXRhICs9IGF0b2IocGFydC5pbmxpbmVEYXRhLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub25EYXRhUGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGB0aGVyZSBhcmUgbm9uLWRhdGEgcGFydHMgJHtub25EYXRhUGFydHN9IGluIHRoZSByZXNwb25zZSwgcmV0dXJuaW5nIGNvbmNhdGVuYXRpb24gb2YgYWxsIGRhdGEgcGFydHMuIFBsZWFzZSByZWZlciB0byB0aGUgbm9uIGRhdGEgcGFydHMgZm9yIGEgZnVsbCByZXNwb25zZSBmcm9tIG1vZGVsLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhLmxlbmd0aCA+IDAgPyBidG9hKGRhdGEpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmdW5jdGlvbiBjYWxscyBmcm9tIHRoZSBmaXJzdCBjYW5kaWRhdGUgaW4gdGhlIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgY2FuZGlkYXRlcyBpbiB0aGUgcmVzcG9uc2UsIHRoZSBmdW5jdGlvbiBjYWxscyBmcm9tXG4gICAgICogdGhlIGZpcnN0IG9uZSB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIElmIHRoZXJlIGFyZSBubyBmdW5jdGlvbiBjYWxscyBpbiB0aGUgcmVzcG9uc2UsIHVuZGVmaW5lZCB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGNvbnRyb2xMaWdodEZ1bmN0aW9uRGVjbGFyYXRpb246IEZ1bmN0aW9uRGVjbGFyYXRpb24gPSB7XG4gICAgICogICBuYW1lOiAnY29udHJvbExpZ2h0JyxcbiAgICAgKiAgIHBhcmFtZXRlcnM6IHtcbiAgICAgKiAgIHR5cGU6IFR5cGUuT0JKRUNULFxuICAgICAqICAgZGVzY3JpcHRpb246ICdTZXQgdGhlIGJyaWdodG5lc3MgYW5kIGNvbG9yIHRlbXBlcmF0dXJlIG9mIGEgcm9vbSBsaWdodC4nLFxuICAgICAqICAgcHJvcGVydGllczoge1xuICAgICAqICAgICBicmlnaHRuZXNzOiB7XG4gICAgICogICAgICAgdHlwZTogVHlwZS5OVU1CRVIsXG4gICAgICogICAgICAgZGVzY3JpcHRpb246XG4gICAgICogICAgICAgICAnTGlnaHQgbGV2ZWwgZnJvbSAwIHRvIDEwMC4gWmVybyBpcyBvZmYgYW5kIDEwMCBpcyBmdWxsIGJyaWdodG5lc3MuJyxcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgY29sb3JUZW1wZXJhdHVyZToge1xuICAgICAqICAgICAgIHR5cGU6IFR5cGUuU1RSSU5HLFxuICAgICAqICAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAqICAgICAgICAgJ0NvbG9yIHRlbXBlcmF0dXJlIG9mIHRoZSBsaWdodCBmaXh0dXJlIHdoaWNoIGNhbiBiZSBgZGF5bGlnaHRgLCBgY29vbGAgb3IgYHdhcm1gLicsXG4gICAgICogICAgIH0sXG4gICAgICogICB9LFxuICAgICAqICAgcmVxdWlyZWQ6IFsnYnJpZ2h0bmVzcycsICdjb2xvclRlbXBlcmF0dXJlJ10sXG4gICAgICogIH07XG4gICAgICogIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmdlbmVyYXRlQ29udGVudCh7XG4gICAgICogICAgIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaCcsXG4gICAgICogICAgIGNvbnRlbnRzOiAnRGltIHRoZSBsaWdodHMgc28gdGhlIHJvb20gZmVlbHMgY296eSBhbmQgd2FybS4nLFxuICAgICAqICAgICBjb25maWc6IHtcbiAgICAgKiAgICAgICB0b29sczogW3tmdW5jdGlvbkRlY2xhcmF0aW9uczogW2NvbnRyb2xMaWdodEZ1bmN0aW9uRGVjbGFyYXRpb25dfV0sXG4gICAgICogICAgICAgdG9vbENvbmZpZzoge1xuICAgICAqICAgICAgICAgZnVuY3Rpb25DYWxsaW5nQ29uZmlnOiB7XG4gICAgICogICAgICAgICAgIG1vZGU6IEZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ01vZGUuQU5ZLFxuICAgICAqICAgICAgICAgICBhbGxvd2VkRnVuY3Rpb25OYW1lczogWydjb250cm9sTGlnaHQnXSxcbiAgICAgKiAgICAgICAgIH0sXG4gICAgICogICAgICAgfSxcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgIH0pO1xuICAgICAqICBjb25zb2xlLmRlYnVnKEpTT04uc3RyaW5naWZ5KHJlc3BvbnNlLmZ1bmN0aW9uQ2FsbHMpKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgZnVuY3Rpb25DYWxscygpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICAgICAgaWYgKCgoX2QgPSAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvbnRlbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5wYXJ0cykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmxlbmd0aCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2FuZGlkYXRlcyAmJiB0aGlzLmNhbmRpZGF0ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCd0aGVyZSBhcmUgbXVsdGlwbGUgY2FuZGlkYXRlcyBpbiB0aGUgcmVzcG9uc2UsIHJldHVybmluZyBmdW5jdGlvbiBjYWxscyBmcm9tIHRoZSBmaXJzdCBvbmUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnVuY3Rpb25DYWxscyA9IChfaCA9IChfZyA9IChfZiA9IChfZSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lWzBdKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY29udGVudCkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLnBhcnRzKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2guZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LmZ1bmN0aW9uQ2FsbCkubWFwKChwYXJ0KSA9PiBwYXJ0LmZ1bmN0aW9uQ2FsbCkuZmlsdGVyKChmdW5jdGlvbkNhbGwpID0+IGZ1bmN0aW9uQ2FsbCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKChmdW5jdGlvbkNhbGxzID09PSBudWxsIHx8IGZ1bmN0aW9uQ2FsbHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZ1bmN0aW9uQ2FsbHMubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb25DYWxscztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgZXhlY3V0YWJsZSBjb2RlIGZyb20gdGhlIGZpcnN0IGNhbmRpZGF0ZSBpbiB0aGUgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBjYW5kaWRhdGVzIGluIHRoZSByZXNwb25zZSwgdGhlIGV4ZWN1dGFibGUgY29kZSBmcm9tXG4gICAgICogdGhlIGZpcnN0IG9uZSB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIElmIHRoZXJlIGFyZSBubyBleGVjdXRhYmxlIGNvZGUgaW4gdGhlIHJlc3BvbnNlLCB1bmRlZmluZWQgd2lsbCBiZVxuICAgICAqIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmdlbmVyYXRlQ29udGVudCh7XG4gICAgICogICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnLFxuICAgICAqICAgY29udGVudHM6XG4gICAgICogICAgICdXaGF0IGlzIHRoZSBzdW0gb2YgdGhlIGZpcnN0IDUwIHByaW1lIG51bWJlcnM/IEdlbmVyYXRlIGFuZCBydW4gY29kZSBmb3IgdGhlIGNhbGN1bGF0aW9uLCBhbmQgbWFrZSBzdXJlIHlvdSBnZXQgYWxsIDUwLidcbiAgICAgKiAgIGNvbmZpZzoge1xuICAgICAqICAgICB0b29sczogW3tjb2RlRXhlY3V0aW9uOiB7fX1dLFxuICAgICAqICAgfSxcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUuZGVidWcocmVzcG9uc2UuZXhlY3V0YWJsZUNvZGUpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBleGVjdXRhYmxlQ29kZSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2o7XG4gICAgICAgIGlmICgoKF9kID0gKF9jID0gKF9iID0gKF9hID0gdGhpcy5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb250ZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucGFydHMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5sZW5ndGgpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNhbmRpZGF0ZXMgJiYgdGhpcy5jYW5kaWRhdGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigndGhlcmUgYXJlIG11bHRpcGxlIGNhbmRpZGF0ZXMgaW4gdGhlIHJlc3BvbnNlLCByZXR1cm5pbmcgZXhlY3V0YWJsZSBjb2RlIGZyb20gdGhlIGZpcnN0IG9uZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleGVjdXRhYmxlQ29kZSA9IChfaCA9IChfZyA9IChfZiA9IChfZSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lWzBdKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY29udGVudCkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLnBhcnRzKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2guZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LmV4ZWN1dGFibGVDb2RlKS5tYXAoKHBhcnQpID0+IHBhcnQuZXhlY3V0YWJsZUNvZGUpLmZpbHRlcigoZXhlY3V0YWJsZUNvZGUpID0+IGV4ZWN1dGFibGVDb2RlICE9PSB1bmRlZmluZWQpO1xuICAgICAgICBpZiAoKGV4ZWN1dGFibGVDb2RlID09PSBudWxsIHx8IGV4ZWN1dGFibGVDb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleGVjdXRhYmxlQ29kZS5sZW5ndGgpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoX2ogPSBleGVjdXRhYmxlQ29kZSA9PT0gbnVsbCB8fCBleGVjdXRhYmxlQ29kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXhlY3V0YWJsZUNvZGVbMF0pID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfai5jb2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBjb2RlIGV4ZWN1dGlvbiByZXN1bHQgZnJvbSB0aGUgZmlyc3QgY2FuZGlkYXRlIGluIHRoZSByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSWYgdGhlcmUgYXJlIG11bHRpcGxlIGNhbmRpZGF0ZXMgaW4gdGhlIHJlc3BvbnNlLCB0aGUgY29kZSBleGVjdXRpb24gcmVzdWx0IGZyb21cbiAgICAgKiB0aGUgZmlyc3Qgb25lIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICogSWYgdGhlcmUgYXJlIG5vIGNvZGUgZXhlY3V0aW9uIHJlc3VsdCBpbiB0aGUgcmVzcG9uc2UsIHVuZGVmaW5lZCB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmdlbmVyYXRlQ29udGVudCh7XG4gICAgICogICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnLFxuICAgICAqICAgY29udGVudHM6XG4gICAgICogICAgICdXaGF0IGlzIHRoZSBzdW0gb2YgdGhlIGZpcnN0IDUwIHByaW1lIG51bWJlcnM/IEdlbmVyYXRlIGFuZCBydW4gY29kZSBmb3IgdGhlIGNhbGN1bGF0aW9uLCBhbmQgbWFrZSBzdXJlIHlvdSBnZXQgYWxsIDUwLidcbiAgICAgKiAgIGNvbmZpZzoge1xuICAgICAqICAgICB0b29sczogW3tjb2RlRXhlY3V0aW9uOiB7fX1dLFxuICAgICAqICAgfSxcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUuZGVidWcocmVzcG9uc2UuY29kZUV4ZWN1dGlvblJlc3VsdCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IGNvZGVFeGVjdXRpb25SZXN1bHQoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qO1xuICAgICAgICBpZiAoKChfZCA9IChfYyA9IChfYiA9IChfYSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY29udGVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnBhcnRzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jYW5kaWRhdGVzICYmIHRoaXMuY2FuZGlkYXRlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3RoZXJlIGFyZSBtdWx0aXBsZSBjYW5kaWRhdGVzIGluIHRoZSByZXNwb25zZSwgcmV0dXJuaW5nIGNvZGUgZXhlY3V0aW9uIHJlc3VsdCBmcm9tIHRoZSBmaXJzdCBvbmUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29kZUV4ZWN1dGlvblJlc3VsdCA9IChfaCA9IChfZyA9IChfZiA9IChfZSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lWzBdKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY29udGVudCkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLnBhcnRzKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2guZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LmNvZGVFeGVjdXRpb25SZXN1bHQpLm1hcCgocGFydCkgPT4gcGFydC5jb2RlRXhlY3V0aW9uUmVzdWx0KS5maWx0ZXIoKGNvZGVFeGVjdXRpb25SZXN1bHQpID0+IGNvZGVFeGVjdXRpb25SZXN1bHQgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmICgoY29kZUV4ZWN1dGlvblJlc3VsdCA9PT0gbnVsbCB8fCBjb2RlRXhlY3V0aW9uUmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb2RlRXhlY3V0aW9uUmVzdWx0Lmxlbmd0aCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChfaiA9IGNvZGVFeGVjdXRpb25SZXN1bHQgPT09IG51bGwgfHwgY29kZUV4ZWN1dGlvblJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29kZUV4ZWN1dGlvblJlc3VsdFswXSkgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qLm91dHB1dDtcbiAgICB9XG59XG4vKiogUmVzcG9uc2UgZm9yIHRoZSBlbWJlZF9jb250ZW50IG1ldGhvZC4gKi9cbmNsYXNzIEVtYmVkQ29udGVudFJlc3BvbnNlIHtcbn1cbi8qKiBUaGUgb3V0cHV0IGltYWdlcyByZXNwb25zZS4gKi9cbmNsYXNzIEdlbmVyYXRlSW1hZ2VzUmVzcG9uc2Uge1xufVxuLyoqIFJlc3BvbnNlIGZvciB0aGUgcmVxdWVzdCB0byBlZGl0IGFuIGltYWdlLiAqL1xuY2xhc3MgRWRpdEltYWdlUmVzcG9uc2Uge1xufVxuY2xhc3MgVXBzY2FsZUltYWdlUmVzcG9uc2Uge1xufVxuLyoqIFRoZSBvdXRwdXQgaW1hZ2VzIHJlc3BvbnNlLiAqL1xuY2xhc3MgUmVjb250ZXh0SW1hZ2VSZXNwb25zZSB7XG59XG4vKiogVGhlIG91dHB1dCBpbWFnZXMgcmVzcG9uc2UuICovXG5jbGFzcyBTZWdtZW50SW1hZ2VSZXNwb25zZSB7XG59XG5jbGFzcyBMaXN0TW9kZWxzUmVzcG9uc2Uge1xufVxuY2xhc3MgRGVsZXRlTW9kZWxSZXNwb25zZSB7XG59XG4vKiogUmVzcG9uc2UgZm9yIGNvdW50aW5nIHRva2Vucy4gKi9cbmNsYXNzIENvdW50VG9rZW5zUmVzcG9uc2Uge1xufVxuLyoqIFJlc3BvbnNlIGZvciBjb21wdXRpbmcgdG9rZW5zLiAqL1xuY2xhc3MgQ29tcHV0ZVRva2Vuc1Jlc3BvbnNlIHtcbn1cbi8qKiBSZXNwb25zZSB3aXRoIGdlbmVyYXRlZCB2aWRlb3MuICovXG5jbGFzcyBHZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlIHtcbn1cbi8qKiBBIHZpZGVvIGdlbmVyYXRpb24gb3BlcmF0aW9uLiAqL1xuY2xhc3MgR2VuZXJhdGVWaWRlb3NPcGVyYXRpb24ge1xuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlcyBhbiBPcGVyYXRpb24gb2YgdGhlIHNhbWUgdHlwZSBhcyB0aGUgb25lIGJlaW5nIGNhbGxlZCB3aXRoIHRoZSBmaWVsZHMgc2V0IGZyb20gdGhlIEFQSSByZXNwb25zZS5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfZnJvbUFQSVJlc3BvbnNlKHsgYXBpUmVzcG9uc2UsIF9pc1ZlcnRleEFJLCB9KSB7XG4gICAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IG5ldyBHZW5lcmF0ZVZpZGVvc09wZXJhdGlvbigpO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGNvbnN0IG9wID0gYXBpUmVzcG9uc2U7XG4gICAgICAgIGlmIChfaXNWZXJ0ZXhBSSkge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBnZW5lcmF0ZVZpZGVvc09wZXJhdGlvbkZyb21WZXJ0ZXgkMShvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IGdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uRnJvbU1sZGV2JDEob3ApO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5hc3NpZ24ob3BlcmF0aW9uLCByZXNwb25zZSk7XG4gICAgICAgIHJldHVybiBvcGVyYXRpb247XG4gICAgfVxufVxuLyoqIFJlc3BvbnNlIGZvciB0aGUgbGlzdCB0dW5pbmcgam9icyBtZXRob2QuICovXG5jbGFzcyBMaXN0VHVuaW5nSm9ic1Jlc3BvbnNlIHtcbn1cbi8qKiBFbXB0eSByZXNwb25zZSBmb3IgdHVuaW5ncy5jYW5jZWwgbWV0aG9kLiAqL1xuY2xhc3MgQ2FuY2VsVHVuaW5nSm9iUmVzcG9uc2Uge1xufVxuLyoqIEVtcHR5IHJlc3BvbnNlIGZvciBjYWNoZXMuZGVsZXRlIG1ldGhvZC4gKi9cbmNsYXNzIERlbGV0ZUNhY2hlZENvbnRlbnRSZXNwb25zZSB7XG59XG5jbGFzcyBMaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZSB7XG59XG4vKiogQ29uZmlnIGZvciBkb2N1bWVudHMubGlzdCByZXR1cm4gdmFsdWUuICovXG5jbGFzcyBMaXN0RG9jdW1lbnRzUmVzcG9uc2Uge1xufVxuLyoqIENvbmZpZyBmb3IgZmlsZV9zZWFyY2hfc3RvcmVzLmxpc3QgcmV0dXJuIHZhbHVlLiAqL1xuY2xhc3MgTGlzdEZpbGVTZWFyY2hTdG9yZXNSZXNwb25zZSB7XG59XG4vKiogUmVzcG9uc2UgZm9yIHRoZSByZXN1bWFibGUgdXBsb2FkIG1ldGhvZC4gKi9cbmNsYXNzIFVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlUmVzdW1hYmxlUmVzcG9uc2Uge1xufVxuLyoqIFJlc3BvbnNlIGZvciBJbXBvcnRGaWxlIHRvIGltcG9ydCBhIEZpbGUgQVBJIGZpbGUgd2l0aCBhIGZpbGUgc2VhcmNoIHN0b3JlLiAqL1xuY2xhc3MgSW1wb3J0RmlsZVJlc3BvbnNlIHtcbn1cbi8qKiBMb25nLXJ1bm5pbmcgb3BlcmF0aW9uIGZvciBpbXBvcnRpbmcgYSBmaWxlIHRvIGEgRmlsZVNlYXJjaFN0b3JlLiAqL1xuY2xhc3MgSW1wb3J0RmlsZU9wZXJhdGlvbiB7XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGVzIGFuIE9wZXJhdGlvbiBvZiB0aGUgc2FtZSB0eXBlIGFzIHRoZSBvbmUgYmVpbmcgY2FsbGVkIHdpdGggdGhlIGZpZWxkcyBzZXQgZnJvbSB0aGUgQVBJIHJlc3BvbnNlLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9mcm9tQVBJUmVzcG9uc2UoeyBhcGlSZXNwb25zZSwgX2lzVmVydGV4QUksIH0pIHtcbiAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gbmV3IEltcG9ydEZpbGVPcGVyYXRpb24oKTtcbiAgICAgICAgY29uc3Qgb3AgPSBhcGlSZXNwb25zZTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBpbXBvcnRGaWxlT3BlcmF0aW9uRnJvbU1sZGV2JDEob3ApO1xuICAgICAgICBPYmplY3QuYXNzaWduKG9wZXJhdGlvbiwgcmVzcG9uc2UpO1xuICAgICAgICByZXR1cm4gb3BlcmF0aW9uO1xuICAgIH1cbn1cbi8qKiBSZXNwb25zZSBmb3IgdGhlIGxpc3QgZmlsZXMgbWV0aG9kLiAqL1xuY2xhc3MgTGlzdEZpbGVzUmVzcG9uc2Uge1xufVxuLyoqIFJlc3BvbnNlIGZvciB0aGUgY3JlYXRlIGZpbGUgbWV0aG9kLiAqL1xuY2xhc3MgQ3JlYXRlRmlsZVJlc3BvbnNlIHtcbn1cbi8qKiBSZXNwb25zZSBmb3IgdGhlIGRlbGV0ZSBmaWxlIG1ldGhvZC4gKi9cbmNsYXNzIERlbGV0ZUZpbGVSZXNwb25zZSB7XG59XG4vKiogQ29uZmlnIGZvciBgaW5saW5lZF9yZXNwb25zZXNgIHBhcmFtZXRlci4gKi9cbmNsYXNzIElubGluZWRSZXNwb25zZSB7XG59XG4vKiogQ29uZmlnIGZvciBgcmVzcG9uc2VgIHBhcmFtZXRlci4gKi9cbmNsYXNzIFNpbmdsZUVtYmVkQ29udGVudFJlc3BvbnNlIHtcbn1cbi8qKiBDb25maWcgZm9yIGBpbmxpbmVkX2VtYmVkZGluZ19yZXNwb25zZXNgIHBhcmFtZXRlci4gKi9cbmNsYXNzIElubGluZWRFbWJlZENvbnRlbnRSZXNwb25zZSB7XG59XG4vKiogQ29uZmlnIGZvciBiYXRjaGVzLmxpc3QgcmV0dXJuIHZhbHVlLiAqL1xuY2xhc3MgTGlzdEJhdGNoSm9ic1Jlc3BvbnNlIHtcbn1cbi8qKiBSZXByZXNlbnRzIGEgc2luZ2xlIHJlc3BvbnNlIGluIGEgcmVwbGF5LiAqL1xuY2xhc3MgUmVwbGF5UmVzcG9uc2Uge1xufVxuLyoqIEEgcmF3IHJlZmVyZW5jZSBpbWFnZS5cblxuQSByYXcgcmVmZXJlbmNlIGltYWdlIHJlcHJlc2VudHMgdGhlIGJhc2UgaW1hZ2UgdG8gZWRpdCwgcHJvdmlkZWQgYnkgdGhlIHVzZXIuXG5JdCBjYW4gb3B0aW9uYWxseSBiZSBwcm92aWRlZCBpbiBhZGRpdGlvbiB0byBhIG1hc2sgcmVmZXJlbmNlIGltYWdlIG9yXG5hIHN0eWxlIHJlZmVyZW5jZSBpbWFnZS4gKi9cbmNsYXNzIFJhd1JlZmVyZW5jZUltYWdlIHtcbiAgICAvKiogSW50ZXJuYWwgbWV0aG9kIHRvIGNvbnZlcnQgdG8gUmVmZXJlbmNlSW1hZ2VBUElJbnRlcm5hbC4gKi9cbiAgICB0b1JlZmVyZW5jZUltYWdlQVBJKCkge1xuICAgICAgICBjb25zdCByZWZlcmVuY2VJbWFnZUFQSSA9IHtcbiAgICAgICAgICAgIHJlZmVyZW5jZVR5cGU6ICdSRUZFUkVOQ0VfVFlQRV9SQVcnLFxuICAgICAgICAgICAgcmVmZXJlbmNlSW1hZ2U6IHRoaXMucmVmZXJlbmNlSW1hZ2UsXG4gICAgICAgICAgICByZWZlcmVuY2VJZDogdGhpcy5yZWZlcmVuY2VJZCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZUltYWdlQVBJO1xuICAgIH1cbn1cbi8qKiBBIG1hc2sgcmVmZXJlbmNlIGltYWdlLlxuXG5UaGlzIGVuY2Fwc3VsYXRlcyBlaXRoZXIgYSBtYXNrIGltYWdlIHByb3ZpZGVkIGJ5IHRoZSB1c2VyIGFuZCBjb25maWdzIGZvclxudGhlIHVzZXIgcHJvdmlkZWQgbWFzaywgb3Igb25seSBjb25maWcgcGFyYW1ldGVycyBmb3IgdGhlIG1vZGVsIHRvIGdlbmVyYXRlXG5hIG1hc2suXG5cbkEgbWFzayBpbWFnZSBpcyBhbiBpbWFnZSB3aG9zZSBub24temVybyB2YWx1ZXMgaW5kaWNhdGUgd2hlcmUgdG8gZWRpdCB0aGUgYmFzZVxuaW1hZ2UuIElmIHRoZSB1c2VyIHByb3ZpZGVzIGEgbWFzayBpbWFnZSwgdGhlIG1hc2sgbXVzdCBiZSBpbiB0aGUgc2FtZVxuZGltZW5zaW9ucyBhcyB0aGUgcmF3IGltYWdlLiAqL1xuY2xhc3MgTWFza1JlZmVyZW5jZUltYWdlIHtcbiAgICAvKiogSW50ZXJuYWwgbWV0aG9kIHRvIGNvbnZlcnQgdG8gUmVmZXJlbmNlSW1hZ2VBUElJbnRlcm5hbC4gKi9cbiAgICB0b1JlZmVyZW5jZUltYWdlQVBJKCkge1xuICAgICAgICBjb25zdCByZWZlcmVuY2VJbWFnZUFQSSA9IHtcbiAgICAgICAgICAgIHJlZmVyZW5jZVR5cGU6ICdSRUZFUkVOQ0VfVFlQRV9NQVNLJyxcbiAgICAgICAgICAgIHJlZmVyZW5jZUltYWdlOiB0aGlzLnJlZmVyZW5jZUltYWdlLFxuICAgICAgICAgICAgcmVmZXJlbmNlSWQ6IHRoaXMucmVmZXJlbmNlSWQsXG4gICAgICAgICAgICBtYXNrSW1hZ2VDb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVmZXJlbmNlSW1hZ2VBUEk7XG4gICAgfVxufVxuLyoqIEEgY29udHJvbCByZWZlcmVuY2UgaW1hZ2UuXG5cblRoZSBpbWFnZSBvZiB0aGUgY29udHJvbCByZWZlcmVuY2UgaW1hZ2UgaXMgZWl0aGVyIGEgY29udHJvbCBpbWFnZSBwcm92aWRlZFxuYnkgdGhlIHVzZXIsIG9yIGEgcmVndWxhciBpbWFnZSB3aGljaCB0aGUgYmFja2VuZCB3aWxsIHVzZSB0byBnZW5lcmF0ZSBhXG5jb250cm9sIGltYWdlIG9mLiBJbiB0aGUgY2FzZSBvZiB0aGUgbGF0dGVyLCB0aGVcbmVuYWJsZV9jb250cm9sX2ltYWdlX2NvbXB1dGF0aW9uIGZpZWxkIGluIHRoZSBjb25maWcgc2hvdWxkIGJlIHNldCB0byBUcnVlLlxuXG5BIGNvbnRyb2wgaW1hZ2UgaXMgYW4gaW1hZ2UgdGhhdCByZXByZXNlbnRzIGEgc2tldGNoIGltYWdlIG9mIGFyZWFzIGZvciB0aGVcbm1vZGVsIHRvIGZpbGwgaW4gYmFzZWQgb24gdGhlIHByb21wdC4gKi9cbmNsYXNzIENvbnRyb2xSZWZlcmVuY2VJbWFnZSB7XG4gICAgLyoqIEludGVybmFsIG1ldGhvZCB0byBjb252ZXJ0IHRvIFJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWwuICovXG4gICAgdG9SZWZlcmVuY2VJbWFnZUFQSSgpIHtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlSW1hZ2VBUEkgPSB7XG4gICAgICAgICAgICByZWZlcmVuY2VUeXBlOiAnUkVGRVJFTkNFX1RZUEVfQ09OVFJPTCcsXG4gICAgICAgICAgICByZWZlcmVuY2VJbWFnZTogdGhpcy5yZWZlcmVuY2VJbWFnZSxcbiAgICAgICAgICAgIHJlZmVyZW5jZUlkOiB0aGlzLnJlZmVyZW5jZUlkLFxuICAgICAgICAgICAgY29udHJvbEltYWdlQ29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZUltYWdlQVBJO1xuICAgIH1cbn1cbi8qKiBBIHN0eWxlIHJlZmVyZW5jZSBpbWFnZS5cblxuVGhpcyBlbmNhcHN1bGF0ZXMgYSBzdHlsZSByZWZlcmVuY2UgaW1hZ2UgcHJvdmlkZWQgYnkgdGhlIHVzZXIsIGFuZFxuYWRkaXRpb25hbGx5IG9wdGlvbmFsIGNvbmZpZyBwYXJhbWV0ZXJzIGZvciB0aGUgc3R5bGUgcmVmZXJlbmNlIGltYWdlLlxuXG5BIHJhdyByZWZlcmVuY2UgaW1hZ2UgY2FuIGFsc28gYmUgcHJvdmlkZWQgYXMgYSBkZXN0aW5hdGlvbiBmb3IgdGhlIHN0eWxlIHRvXG5iZSBhcHBsaWVkIHRvLiAqL1xuY2xhc3MgU3R5bGVSZWZlcmVuY2VJbWFnZSB7XG4gICAgLyoqIEludGVybmFsIG1ldGhvZCB0byBjb252ZXJ0IHRvIFJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWwuICovXG4gICAgdG9SZWZlcmVuY2VJbWFnZUFQSSgpIHtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlSW1hZ2VBUEkgPSB7XG4gICAgICAgICAgICByZWZlcmVuY2VUeXBlOiAnUkVGRVJFTkNFX1RZUEVfU1RZTEUnLFxuICAgICAgICAgICAgcmVmZXJlbmNlSW1hZ2U6IHRoaXMucmVmZXJlbmNlSW1hZ2UsXG4gICAgICAgICAgICByZWZlcmVuY2VJZDogdGhpcy5yZWZlcmVuY2VJZCxcbiAgICAgICAgICAgIHN0eWxlSW1hZ2VDb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVmZXJlbmNlSW1hZ2VBUEk7XG4gICAgfVxufVxuLyoqIEEgc3ViamVjdCByZWZlcmVuY2UgaW1hZ2UuXG5cblRoaXMgZW5jYXBzdWxhdGVzIGEgc3ViamVjdCByZWZlcmVuY2UgaW1hZ2UgcHJvdmlkZWQgYnkgdGhlIHVzZXIsIGFuZFxuYWRkaXRpb25hbGx5IG9wdGlvbmFsIGNvbmZpZyBwYXJhbWV0ZXJzIGZvciB0aGUgc3ViamVjdCByZWZlcmVuY2UgaW1hZ2UuXG5cbkEgcmF3IHJlZmVyZW5jZSBpbWFnZSBjYW4gYWxzbyBiZSBwcm92aWRlZCBhcyBhIGRlc3RpbmF0aW9uIGZvciB0aGUgc3ViamVjdCB0b1xuYmUgYXBwbGllZCB0by4gKi9cbmNsYXNzIFN1YmplY3RSZWZlcmVuY2VJbWFnZSB7XG4gICAgLyogSW50ZXJuYWwgbWV0aG9kIHRvIGNvbnZlcnQgdG8gUmVmZXJlbmNlSW1hZ2VBUElJbnRlcm5hbC4gKi9cbiAgICB0b1JlZmVyZW5jZUltYWdlQVBJKCkge1xuICAgICAgICBjb25zdCByZWZlcmVuY2VJbWFnZUFQSSA9IHtcbiAgICAgICAgICAgIHJlZmVyZW5jZVR5cGU6ICdSRUZFUkVOQ0VfVFlQRV9TVUJKRUNUJyxcbiAgICAgICAgICAgIHJlZmVyZW5jZUltYWdlOiB0aGlzLnJlZmVyZW5jZUltYWdlLFxuICAgICAgICAgICAgcmVmZXJlbmNlSWQ6IHRoaXMucmVmZXJlbmNlSWQsXG4gICAgICAgICAgICBzdWJqZWN0SW1hZ2VDb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVmZXJlbmNlSW1hZ2VBUEk7XG4gICAgfVxufVxuLyoqIEEgY29udGVudCByZWZlcmVuY2UgaW1hZ2UuXG5cbkEgY29udGVudCByZWZlcmVuY2UgaW1hZ2UgcmVwcmVzZW50cyBhIHN1YmplY3QgdG8gcmVmZXJlbmNlIChleC4gcGVyc29uLFxucHJvZHVjdCwgYW5pbWFsKSBwcm92aWRlZCBieSB0aGUgdXNlci4gSXQgY2FuIG9wdGlvbmFsbHkgYmUgcHJvdmlkZWQgaW5cbmFkZGl0aW9uIHRvIGEgc3R5bGUgcmVmZXJlbmNlIGltYWdlIChleC4gYmFja2dyb3VuZCwgc3R5bGUgcmVmZXJlbmNlKS4gKi9cbmNsYXNzIENvbnRlbnRSZWZlcmVuY2VJbWFnZSB7XG4gICAgLyoqIEludGVybmFsIG1ldGhvZCB0byBjb252ZXJ0IHRvIFJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWwuICovXG4gICAgdG9SZWZlcmVuY2VJbWFnZUFQSSgpIHtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlSW1hZ2VBUEkgPSB7XG4gICAgICAgICAgICByZWZlcmVuY2VUeXBlOiAnUkVGRVJFTkNFX1RZUEVfQ09OVEVOVCcsXG4gICAgICAgICAgICByZWZlcmVuY2VJbWFnZTogdGhpcy5yZWZlcmVuY2VJbWFnZSxcbiAgICAgICAgICAgIHJlZmVyZW5jZUlkOiB0aGlzLnJlZmVyZW5jZUlkLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVmZXJlbmNlSW1hZ2VBUEk7XG4gICAgfVxufVxuLyoqIFJlc3BvbnNlIG1lc3NhZ2UgZm9yIEFQSSBjYWxsLiAqL1xuY2xhc3MgTGl2ZVNlcnZlck1lc3NhZ2Uge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIHRleHQgcGFydHMgZnJvbSB0aGUgc2VydmVyIGNvbnRlbnQgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSWYgdGhlcmUgYXJlIG5vbi10ZXh0IHBhcnRzIGluIHRoZSByZXNwb25zZSwgdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIHRleHRcbiAgICAgKiBwYXJ0cyB3aWxsIGJlIHJldHVybmVkLCBhbmQgYSB3YXJuaW5nIHdpbGwgYmUgbG9nZ2VkLlxuICAgICAqL1xuICAgIGdldCB0ZXh0KCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgbGV0IHRleHQgPSAnJztcbiAgICAgICAgbGV0IGFueVRleHRQYXJ0Rm91bmQgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgbm9uVGV4dFBhcnRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLnNlcnZlckNvbnRlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tb2RlbFR1cm4pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wYXJ0cykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogW10pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgZmllbGRWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocGFydCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGROYW1lICE9PSAndGV4dCcgJiZcbiAgICAgICAgICAgICAgICAgICAgZmllbGROYW1lICE9PSAndGhvdWdodCcgJiZcbiAgICAgICAgICAgICAgICAgICAgZmllbGRWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBub25UZXh0UGFydHMucHVzaChmaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydC50ZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydC50aG91Z2h0ID09PSAnYm9vbGVhbicgJiYgcGFydC50aG91Z2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhbnlUZXh0UGFydEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0ZXh0ICs9IHBhcnQudGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9uVGV4dFBhcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgdGhlcmUgYXJlIG5vbi10ZXh0IHBhcnRzICR7bm9uVGV4dFBhcnRzfSBpbiB0aGUgcmVzcG9uc2UsIHJldHVybmluZyBjb25jYXRlbmF0aW9uIG9mIGFsbCB0ZXh0IHBhcnRzLiBQbGVhc2UgcmVmZXIgdG8gdGhlIG5vbiB0ZXh0IHBhcnRzIGZvciBhIGZ1bGwgcmVzcG9uc2UgZnJvbSBtb2RlbC5gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYXJ0LnRleHQgPT09ICcnIGlzIGRpZmZlcmVudCBmcm9tIHBhcnQudGV4dCBpcyBudWxsXG4gICAgICAgIHJldHVybiBhbnlUZXh0UGFydEZvdW5kID8gdGV4dCA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29uY2F0ZW5hdGlvbiBvZiBhbGwgaW5saW5lIGRhdGEgcGFydHMgZnJvbSB0aGUgc2VydmVyIGNvbnRlbnQgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSWYgdGhlcmUgYXJlIG5vbi1pbmxpbmUgZGF0YSBwYXJ0cyBpbiB0aGVcbiAgICAgKiByZXNwb25zZSwgdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIGlubGluZSBkYXRhIHBhcnRzIHdpbGwgYmUgcmV0dXJuZWQsIGFuZFxuICAgICAqIGEgd2FybmluZyB3aWxsIGJlIGxvZ2dlZC5cbiAgICAgKi9cbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGxldCBkYXRhID0gJyc7XG4gICAgICAgIGNvbnN0IG5vbkRhdGFQYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgKF9jID0gKF9iID0gKF9hID0gdGhpcy5zZXJ2ZXJDb250ZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubW9kZWxUdXJuKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucGFydHMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFtdKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIGZpZWxkVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcnQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSAhPT0gJ2lubGluZURhdGEnICYmIGZpZWxkVmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9uRGF0YVBhcnRzLnB1c2goZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFydC5pbmxpbmVEYXRhICYmIHR5cGVvZiBwYXJ0LmlubGluZURhdGEuZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBkYXRhICs9IGF0b2IocGFydC5pbmxpbmVEYXRhLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub25EYXRhUGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGB0aGVyZSBhcmUgbm9uLWRhdGEgcGFydHMgJHtub25EYXRhUGFydHN9IGluIHRoZSByZXNwb25zZSwgcmV0dXJuaW5nIGNvbmNhdGVuYXRpb24gb2YgYWxsIGRhdGEgcGFydHMuIFBsZWFzZSByZWZlciB0byB0aGUgbm9uIGRhdGEgcGFydHMgZm9yIGEgZnVsbCByZXNwb25zZSBmcm9tIG1vZGVsLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhLmxlbmd0aCA+IDAgPyBidG9hKGRhdGEpIDogdW5kZWZpbmVkO1xuICAgIH1cbn1cbi8qKiBDbGllbnQgZ2VuZXJhdGVkIHJlc3BvbnNlIHRvIGEgYFRvb2xDYWxsYCByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIuXG5cbkluZGl2aWR1YWwgYEZ1bmN0aW9uUmVzcG9uc2VgIG9iamVjdHMgYXJlIG1hdGNoZWQgdG8gdGhlIHJlc3BlY3RpdmVcbmBGdW5jdGlvbkNhbGxgIG9iamVjdHMgYnkgdGhlIGBpZGAgZmllbGQuXG5cbk5vdGUgdGhhdCBpbiB0aGUgdW5hcnkgYW5kIHNlcnZlci1zdHJlYW1pbmcgR2VuZXJhdGVDb250ZW50IEFQSXMgZnVuY3Rpb25cbmNhbGxpbmcgaGFwcGVucyBieSBleGNoYW5naW5nIHRoZSBgQ29udGVudGAgcGFydHMsIHdoaWxlIGluIHRoZSBiaWRpXG5HZW5lcmF0ZUNvbnRlbnQgQVBJcyBmdW5jdGlvbiBjYWxsaW5nIGhhcHBlbnMgb3ZlciB0aGlzIGRlZGljYXRlZCBzZXQgb2Zcbm1lc3NhZ2VzLiAqL1xuY2xhc3MgTGl2ZUNsaWVudFRvb2xSZXNwb25zZSB7XG59XG4vKiogUGFyYW1ldGVycyBmb3Igc2VuZGluZyB0b29sIHJlc3BvbnNlcyB0byB0aGUgbGl2ZSBBUEkuICovXG5jbGFzcyBMaXZlU2VuZFRvb2xSZXNwb25zZVBhcmFtZXRlcnMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKiogVG9vbCByZXNwb25zZXMgdG8gc2VuZCB0byB0aGUgc2Vzc2lvbi4gKi9cbiAgICAgICAgdGhpcy5mdW5jdGlvblJlc3BvbnNlcyA9IFtdO1xuICAgIH1cbn1cbi8qKiBSZXNwb25zZSBtZXNzYWdlIGZvciB0aGUgTGl2ZU11c2ljQ2xpZW50TWVzc2FnZSBjYWxsLiAqL1xuY2xhc3MgTGl2ZU11c2ljU2VydmVyTWVzc2FnZSB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgYXVkaW8gY2h1bmsgZnJvbSB0aGUgc2VydmVyIGNvbnRlbnQsIGlmIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIHRoZXJlIGFyZSBubyBhdWRpbyBjaHVua3MgaW4gdGhlIHJlc3BvbnNlLCB1bmRlZmluZWQgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBnZXQgYXVkaW9DaHVuaygpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VydmVyQ29udGVudCAmJlxuICAgICAgICAgICAgdGhpcy5zZXJ2ZXJDb250ZW50LmF1ZGlvQ2h1bmtzICYmXG4gICAgICAgICAgICB0aGlzLnNlcnZlckNvbnRlbnQuYXVkaW9DaHVua3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VydmVyQ29udGVudC5hdWRpb0NodW5rc1swXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbi8qKiBUaGUgcmVzcG9uc2Ugd2hlbiBsb25nLXJ1bm5pbmcgb3BlcmF0aW9uIGZvciB1cGxvYWRpbmcgYSBmaWxlIHRvIGEgRmlsZVNlYXJjaFN0b3JlIGNvbXBsZXRlLiAqL1xuY2xhc3MgVXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVSZXNwb25zZSB7XG59XG4vKiogTG9uZy1ydW5uaW5nIG9wZXJhdGlvbiBmb3IgdXBsb2FkaW5nIGEgZmlsZSB0byBhIEZpbGVTZWFyY2hTdG9yZS4gKi9cbmNsYXNzIFVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlT3BlcmF0aW9uIHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZXMgYW4gT3BlcmF0aW9uIG9mIHRoZSBzYW1lIHR5cGUgYXMgdGhlIG9uZSBiZWluZyBjYWxsZWQgd2l0aCB0aGUgZmllbGRzIHNldCBmcm9tIHRoZSBBUEkgcmVzcG9uc2UuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX2Zyb21BUElSZXNwb25zZSh7IGFwaVJlc3BvbnNlLCBfaXNWZXJ0ZXhBSSwgfSkge1xuICAgICAgICBjb25zdCBvcGVyYXRpb24gPSBuZXcgVXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVPcGVyYXRpb24oKTtcbiAgICAgICAgY29uc3Qgb3AgPSBhcGlSZXNwb25zZTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB1cGxvYWRUb0ZpbGVTZWFyY2hTdG9yZU9wZXJhdGlvbkZyb21NbGRldihvcCk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ob3BlcmF0aW9uLCByZXNwb25zZSk7XG4gICAgICAgIHJldHVybiBvcGVyYXRpb247XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5mdW5jdGlvbiB0TW9kZWwoYXBpQ2xpZW50LCBtb2RlbCkge1xuICAgIGlmICghbW9kZWwgfHwgdHlwZW9mIG1vZGVsICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21vZGVsIGlzIHJlcXVpcmVkIGFuZCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuICAgIGlmIChtb2RlbC5pbmNsdWRlcygnLi4nKSB8fCBtb2RlbC5pbmNsdWRlcygnPycpIHx8IG1vZGVsLmluY2x1ZGVzKCcmJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG1vZGVsIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBpZiAoYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICBpZiAobW9kZWwuc3RhcnRzV2l0aCgncHVibGlzaGVycy8nKSB8fFxuICAgICAgICAgICAgbW9kZWwuc3RhcnRzV2l0aCgncHJvamVjdHMvJykgfHxcbiAgICAgICAgICAgIG1vZGVsLnN0YXJ0c1dpdGgoJ21vZGVscy8nKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1vZGVsLmluZGV4T2YoJy8nKSA+PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0cyA9IG1vZGVsLnNwbGl0KCcvJywgMik7XG4gICAgICAgICAgICByZXR1cm4gYHB1Ymxpc2hlcnMvJHtwYXJ0c1swXX0vbW9kZWxzLyR7cGFydHNbMV19YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgcHVibGlzaGVycy9nb29nbGUvbW9kZWxzLyR7bW9kZWx9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKG1vZGVsLnN0YXJ0c1dpdGgoJ21vZGVscy8nKSB8fCBtb2RlbC5zdGFydHNXaXRoKCd0dW5lZE1vZGVscy8nKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGBtb2RlbHMvJHttb2RlbH1gO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdENhY2hlc01vZGVsKGFwaUNsaWVudCwgbW9kZWwpIHtcbiAgICBjb25zdCB0cmFuc2Zvcm1lZE1vZGVsID0gdE1vZGVsKGFwaUNsaWVudCwgbW9kZWwpO1xuICAgIGlmICghdHJhbnNmb3JtZWRNb2RlbCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGlmICh0cmFuc2Zvcm1lZE1vZGVsLnN0YXJ0c1dpdGgoJ3B1Ymxpc2hlcnMvJykgJiYgYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAvLyB2ZXJ0ZXggY2FjaGVzIG9ubHkgc3VwcG9ydCBtb2RlbCBuYW1lIHN0YXJ0IHdpdGggcHJvamVjdHMuXG4gICAgICAgIHJldHVybiBgcHJvamVjdHMvJHthcGlDbGllbnQuZ2V0UHJvamVjdCgpfS9sb2NhdGlvbnMvJHthcGlDbGllbnQuZ2V0TG9jYXRpb24oKX0vJHt0cmFuc2Zvcm1lZE1vZGVsfWA7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRyYW5zZm9ybWVkTW9kZWwuc3RhcnRzV2l0aCgnbW9kZWxzLycpICYmIGFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgcmV0dXJuIGBwcm9qZWN0cy8ke2FwaUNsaWVudC5nZXRQcm9qZWN0KCl9L2xvY2F0aW9ucy8ke2FwaUNsaWVudC5nZXRMb2NhdGlvbigpfS9wdWJsaXNoZXJzL2dvb2dsZS8ke3RyYW5zZm9ybWVkTW9kZWx9YDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZE1vZGVsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRCbG9icyhibG9icykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGJsb2JzKSkge1xuICAgICAgICByZXR1cm4gYmxvYnMubWFwKChibG9iKSA9PiB0QmxvYihibG9iKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gW3RCbG9iKGJsb2JzKV07XG4gICAgfVxufVxuZnVuY3Rpb24gdEJsb2IoYmxvYikge1xuICAgIGlmICh0eXBlb2YgYmxvYiA9PT0gJ29iamVjdCcgJiYgYmxvYiAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYmxvYjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgcGFyc2UgaW5wdXQgYXMgQmxvYi4gVW5zdXBwb3J0ZWQgYmxvYiB0eXBlOiAke3R5cGVvZiBibG9ifWApO1xufVxuZnVuY3Rpb24gdEltYWdlQmxvYihibG9iKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtZWRCbG9iID0gdEJsb2IoYmxvYik7XG4gICAgaWYgKHRyYW5zZm9ybWVkQmxvYi5taW1lVHlwZSAmJlxuICAgICAgICB0cmFuc2Zvcm1lZEJsb2IubWltZVR5cGUuc3RhcnRzV2l0aCgnaW1hZ2UvJykpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkQmxvYjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBtaW1lIHR5cGU6ICR7dHJhbnNmb3JtZWRCbG9iLm1pbWVUeXBlfWApO1xufVxuZnVuY3Rpb24gdEF1ZGlvQmxvYihibG9iKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtZWRCbG9iID0gdEJsb2IoYmxvYik7XG4gICAgaWYgKHRyYW5zZm9ybWVkQmxvYi5taW1lVHlwZSAmJlxuICAgICAgICB0cmFuc2Zvcm1lZEJsb2IubWltZVR5cGUuc3RhcnRzV2l0aCgnYXVkaW8vJykpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkQmxvYjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBtaW1lIHR5cGU6ICR7dHJhbnNmb3JtZWRCbG9iLm1pbWVUeXBlfWApO1xufVxuZnVuY3Rpb24gdFBhcnQob3JpZ2luKSB7XG4gICAgaWYgKG9yaWdpbiA9PT0gbnVsbCB8fCBvcmlnaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcnRVbmlvbiBpcyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9yaWdpbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcmlnaW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB7IHRleHQ6IG9yaWdpbiB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHBhcnQgdHlwZTogJHt0eXBlb2Ygb3JpZ2lufWApO1xufVxuZnVuY3Rpb24gdFBhcnRzKG9yaWdpbikge1xuICAgIGlmIChvcmlnaW4gPT09IG51bGwgfHxcbiAgICAgICAgb3JpZ2luID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgKEFycmF5LmlzQXJyYXkob3JpZ2luKSAmJiBvcmlnaW4ubGVuZ3RoID09PSAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcnRMaXN0VW5pb24gaXMgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3JpZ2luKSkge1xuICAgICAgICByZXR1cm4gb3JpZ2luLm1hcCgoaXRlbSkgPT4gdFBhcnQoaXRlbSkpO1xuICAgIH1cbiAgICByZXR1cm4gW3RQYXJ0KG9yaWdpbildO1xufVxuZnVuY3Rpb24gX2lzQ29udGVudChvcmlnaW4pIHtcbiAgICByZXR1cm4gKG9yaWdpbiAhPT0gbnVsbCAmJlxuICAgICAgICBvcmlnaW4gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICB0eXBlb2Ygb3JpZ2luID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAncGFydHMnIGluIG9yaWdpbiAmJlxuICAgICAgICBBcnJheS5pc0FycmF5KG9yaWdpbi5wYXJ0cykpO1xufVxuZnVuY3Rpb24gX2lzRnVuY3Rpb25DYWxsUGFydChvcmlnaW4pIHtcbiAgICByZXR1cm4gKG9yaWdpbiAhPT0gbnVsbCAmJlxuICAgICAgICBvcmlnaW4gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICB0eXBlb2Ygb3JpZ2luID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAnZnVuY3Rpb25DYWxsJyBpbiBvcmlnaW4pO1xufVxuZnVuY3Rpb24gX2lzRnVuY3Rpb25SZXNwb25zZVBhcnQob3JpZ2luKSB7XG4gICAgcmV0dXJuIChvcmlnaW4gIT09IG51bGwgJiZcbiAgICAgICAgb3JpZ2luICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdHlwZW9mIG9yaWdpbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ2Z1bmN0aW9uUmVzcG9uc2UnIGluIG9yaWdpbik7XG59XG5mdW5jdGlvbiB0Q29udGVudChvcmlnaW4pIHtcbiAgICBpZiAob3JpZ2luID09PSBudWxsIHx8IG9yaWdpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ29udGVudFVuaW9uIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmIChfaXNDb250ZW50KG9yaWdpbikpIHtcbiAgICAgICAgLy8gX2lzQ29udGVudCBpcyBhIHV0aWxpdHkgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgdGhlXG4gICAgICAgIC8vIG9yaWdpbiBpcyBhIENvbnRlbnQuXG4gICAgICAgIHJldHVybiBvcmlnaW47XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgcGFydHM6IHRQYXJ0cyhvcmlnaW4pLFxuICAgIH07XG59XG5mdW5jdGlvbiB0Q29udGVudHNGb3JFbWJlZChhcGlDbGllbnQsIG9yaWdpbikge1xuICAgIGlmICghb3JpZ2luKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKGFwaUNsaWVudC5pc1ZlcnRleEFJKCkgJiYgQXJyYXkuaXNBcnJheShvcmlnaW4pKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW4uZmxhdE1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IHRDb250ZW50KGl0ZW0pO1xuICAgICAgICAgICAgaWYgKGNvbnRlbnQucGFydHMgJiZcbiAgICAgICAgICAgICAgICBjb250ZW50LnBhcnRzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICBjb250ZW50LnBhcnRzWzBdLnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbY29udGVudC5wYXJ0c1swXS50ZXh0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IHRDb250ZW50KG9yaWdpbik7XG4gICAgICAgIGlmIChjb250ZW50LnBhcnRzICYmXG4gICAgICAgICAgICBjb250ZW50LnBhcnRzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIGNvbnRlbnQucGFydHNbMF0udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gW2NvbnRlbnQucGFydHNbMF0udGV4dF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcmlnaW4pKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW4ubWFwKChpdGVtKSA9PiB0Q29udGVudChpdGVtKSk7XG4gICAgfVxuICAgIHJldHVybiBbdENvbnRlbnQob3JpZ2luKV07XG59XG5mdW5jdGlvbiB0Q29udGVudHMob3JpZ2luKSB7XG4gICAgaWYgKG9yaWdpbiA9PT0gbnVsbCB8fFxuICAgICAgICBvcmlnaW4gPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAoQXJyYXkuaXNBcnJheShvcmlnaW4pICYmIG9yaWdpbi5sZW5ndGggPT09IDApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY29udGVudHMgYXJlIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShvcmlnaW4pKSB7XG4gICAgICAgIC8vIElmIGl0J3Mgbm90IGFuIGFycmF5LCBpdCdzIGEgc2luZ2xlIGNvbnRlbnQgb3IgYSBzaW5nbGUgUGFydFVuaW9uLlxuICAgICAgICBpZiAoX2lzRnVuY3Rpb25DYWxsUGFydChvcmlnaW4pIHx8IF9pc0Z1bmN0aW9uUmVzcG9uc2VQYXJ0KG9yaWdpbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG8gc3BlY2lmeSBmdW5jdGlvbkNhbGwgb3IgZnVuY3Rpb25SZXNwb25zZSBwYXJ0cywgcGxlYXNlIHdyYXAgdGhlbSBpbiBhIENvbnRlbnQgb2JqZWN0LCBzcGVjaWZ5aW5nIHRoZSByb2xlIGZvciB0aGVtJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt0Q29udGVudChvcmlnaW4pXTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3QgYWNjdW11bGF0ZWRQYXJ0cyA9IFtdO1xuICAgIGNvbnN0IGlzQ29udGVudEFycmF5ID0gX2lzQ29udGVudChvcmlnaW5bMF0pO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBvcmlnaW4pIHtcbiAgICAgICAgY29uc3QgaXNDb250ZW50ID0gX2lzQ29udGVudChpdGVtKTtcbiAgICAgICAgaWYgKGlzQ29udGVudCAhPSBpc0NvbnRlbnRBcnJheSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXhpbmcgQ29udGVudCBhbmQgUGFydHMgaXMgbm90IHN1cHBvcnRlZCwgcGxlYXNlIGdyb3VwIHRoZSBwYXJ0cyBpbnRvIGEgdGhlIGFwcHJvcHJpYXRlIENvbnRlbnQgb2JqZWN0cyBhbmQgc3BlY2lmeSB0aGUgcm9sZXMgZm9yIHRoZW0nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDb250ZW50KSB7XG4gICAgICAgICAgICAvLyBgaXNDb250ZW50YCBjb250YWlucyB0aGUgcmVzdWx0IG9mIF9pc0NvbnRlbnQsIHdoaWNoIGlzIGEgdXRpbGl0eVxuICAgICAgICAgICAgLy8gZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgdGhlIGl0ZW0gaXMgYSBDb250ZW50LlxuICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoX2lzRnVuY3Rpb25DYWxsUGFydChpdGVtKSB8fCBfaXNGdW5jdGlvblJlc3BvbnNlUGFydChpdGVtKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUbyBzcGVjaWZ5IGZ1bmN0aW9uQ2FsbCBvciBmdW5jdGlvblJlc3BvbnNlIHBhcnRzLCBwbGVhc2Ugd3JhcCB0aGVtLCBhbmQgYW55IG90aGVyIHBhcnRzLCBpbiBDb250ZW50IG9iamVjdHMgYXMgYXBwcm9wcmlhdGUsIHNwZWNpZnlpbmcgdGhlIHJvbGUgZm9yIHRoZW0nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFjY3VtdWxhdGVkUGFydHMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzQ29udGVudEFycmF5KSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHsgcm9sZTogJ3VzZXInLCBwYXJ0czogdFBhcnRzKGFjY3VtdWxhdGVkUGFydHMpIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLypcblRyYW5zZm9ybSB0aGUgdHlwZSBmaWVsZCBmcm9tIGFuIGFycmF5IG9mIHR5cGVzIHRvIGFuIGFycmF5IG9mIGFueU9mIGZpZWxkcy5cbkV4YW1wbGU6XG4gIHt0eXBlOiBbJ1NUUklORycsICdOVU1CRVInXX1cbndpbGwgYmUgdHJhbnNmb3JtZWQgdG9cbiAge2FueU9mOiBbe3R5cGU6ICdTVFJJTkcnfSwge3R5cGU6ICdOVU1CRVInfV19XG4qL1xuZnVuY3Rpb24gZmxhdHRlblR5cGVBcnJheVRvQW55T2YodHlwZUxpc3QsIHJlc3VsdGluZ1NjaGVtYSkge1xuICAgIGlmICh0eXBlTGlzdC5pbmNsdWRlcygnbnVsbCcpKSB7XG4gICAgICAgIHJlc3VsdGluZ1NjaGVtYVsnbnVsbGFibGUnXSA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGxpc3RXaXRob3V0TnVsbCA9IHR5cGVMaXN0LmZpbHRlcigodHlwZSkgPT4gdHlwZSAhPT0gJ251bGwnKTtcbiAgICBpZiAobGlzdFdpdGhvdXROdWxsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXN1bHRpbmdTY2hlbWFbJ3R5cGUnXSA9IE9iamVjdC52YWx1ZXMoVHlwZSkuaW5jbHVkZXMobGlzdFdpdGhvdXROdWxsWzBdLnRvVXBwZXJDYXNlKCkpXG4gICAgICAgICAgICA/IGxpc3RXaXRob3V0TnVsbFswXS50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgICA6IFR5cGUuVFlQRV9VTlNQRUNJRklFRDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdGluZ1NjaGVtYVsnYW55T2YnXSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgbGlzdFdpdGhvdXROdWxsKSB7XG4gICAgICAgICAgICByZXN1bHRpbmdTY2hlbWFbJ2FueU9mJ10ucHVzaCh7XG4gICAgICAgICAgICAgICAgJ3R5cGUnOiBPYmplY3QudmFsdWVzKFR5cGUpLmluY2x1ZGVzKGkudG9VcHBlckNhc2UoKSlcbiAgICAgICAgICAgICAgICAgICAgPyBpLnRvVXBwZXJDYXNlKClcbiAgICAgICAgICAgICAgICAgICAgOiBUeXBlLlRZUEVfVU5TUEVDSUZJRUQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHByb2Nlc3NKc29uU2NoZW1hKF9qc29uU2NoZW1hKSB7XG4gICAgY29uc3QgZ2VuQUlTY2hlbWEgPSB7fTtcbiAgICBjb25zdCBzY2hlbWFGaWVsZE5hbWVzID0gWydpdGVtcyddO1xuICAgIGNvbnN0IGxpc3RTY2hlbWFGaWVsZE5hbWVzID0gWydhbnlPZiddO1xuICAgIGNvbnN0IGRpY3RTY2hlbWFGaWVsZE5hbWVzID0gWydwcm9wZXJ0aWVzJ107XG4gICAgaWYgKF9qc29uU2NoZW1hWyd0eXBlJ10gJiYgX2pzb25TY2hlbWFbJ2FueU9mJ10pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0eXBlIGFuZCBhbnlPZiBjYW5ub3QgYmUgYm90aCBwb3B1bGF0ZWQuJyk7XG4gICAgfVxuICAgIC8qXG4gICAgVGhpcyBpcyB0byBoYW5kbGUgdGhlIG51bGxhYmxlIGFycmF5IG9yIG9iamVjdC4gVGhlIF9qc29uU2NoZW1hIHdpbGxcbiAgICBiZSBpbiB0aGUgZm9ybWF0IG9mIHthbnlPZjogW3t0eXBlOiAnbnVsbCd9LCB7dHlwZTogJ29iamVjdCd9XX0uIFRoZVxuICAgIGxvZ2ljIGlzIHRvIGNoZWNrIGlmIGFueU9mIGhhcyAyIGVsZW1lbnRzIGFuZCBvbmUgb2YgdGhlIGVsZW1lbnQgaXMgbnVsbCxcbiAgICBpZiBzbywgdGhlIGFueU9mIGZpZWxkIGlzIHVubmVjZXNzYXJ5LCBzbyB3ZSBuZWVkIHRvIGdldCByaWQgb2YgdGhlIGFueU9mXG4gICAgZmllbGQgYW5kIG1ha2UgdGhlIHNjaGVtYSBudWxsYWJsZS4gVGhlbiB1c2UgdGhlIG90aGVyIGVsZW1lbnQgYXMgdGhlIG5ld1xuICAgIF9qc29uU2NoZW1hIGZvciBwcm9jZXNzaW5nLiBUaGlzIGlzIGJlY2F1c2UgdGhlIGJhY2tlbmQgZG9lc24ndCBoYXZlIGEgbnVsbFxuICAgIHR5cGUuXG4gICAgVGhpcyBoYXMgdG8gYmUgY2hlY2tlZCBiZWZvcmUgd2UgcHJvY2VzcyBhbnkgb3RoZXIgZmllbGRzLlxuICAgIEZvciBleGFtcGxlOlxuICAgICAgY29uc3Qgb2JqZWN0TnVsbGFibGUgPSB6Lm9iamVjdCh7XG4gICAgICAgIG51bGxhYmxlQXJyYXk6IHouYXJyYXkoei5zdHJpbmcoKSkubnVsbGFibGUoKSxcbiAgICAgIH0pO1xuICAgIFdpbGwgaGF2ZSB0aGUgcmF3IF9qc29uU2NoZW1hIGFzOlxuICAgIHtcbiAgICAgIHR5cGU6ICdPQkpFQ1QnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIG51bGxhYmxlQXJyYXk6IHtcbiAgICAgICAgICAgICBhbnlPZjogW1xuICAgICAgICAgICAgICAgIHt0eXBlOiAnbnVsbCd9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgICAgICAgICAgICBpdGVtczoge3R5cGU6ICdzdHJpbmcnfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZXF1aXJlZDogWyAnbnVsbGFibGVBcnJheScgXSxcbiAgICB9XG4gICAgV2lsbCByZXN1bHQgaW4gZm9sbG93aW5nIHNjaGVtYSBjb21wYXRpYmxlIHdpdGggR2VtaW5pIEFQSTpcbiAgICAgIHtcbiAgICAgICAgdHlwZTogJ09CSkVDVCcsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgbnVsbGFibGVBcnJheToge1xuICAgICAgICAgICAgICBudWxsYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogJ0FSUkFZJyxcbiAgICAgICAgICAgICAgaXRlbXM6IHt0eXBlOiAnc3RyaW5nJ30sXG4gICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVxdWlyZWQ6IFsgJ251bGxhYmxlQXJyYXknIF0sXG4gICAgICB9XG4gICAgKi9cbiAgICBjb25zdCBpbmNvbWluZ0FueU9mID0gX2pzb25TY2hlbWFbJ2FueU9mJ107XG4gICAgaWYgKGluY29taW5nQW55T2YgIT0gbnVsbCAmJiBpbmNvbWluZ0FueU9mLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgIGlmIChpbmNvbWluZ0FueU9mWzBdWyd0eXBlJ10gPT09ICdudWxsJykge1xuICAgICAgICAgICAgZ2VuQUlTY2hlbWFbJ251bGxhYmxlJ10gPSB0cnVlO1xuICAgICAgICAgICAgX2pzb25TY2hlbWEgPSBpbmNvbWluZ0FueU9mWzFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluY29taW5nQW55T2ZbMV1bJ3R5cGUnXSA9PT0gJ251bGwnKSB7XG4gICAgICAgICAgICBnZW5BSVNjaGVtYVsnbnVsbGFibGUnXSA9IHRydWU7XG4gICAgICAgICAgICBfanNvblNjaGVtYSA9IGluY29taW5nQW55T2ZbMF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKF9qc29uU2NoZW1hWyd0eXBlJ10gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBmbGF0dGVuVHlwZUFycmF5VG9BbnlPZihfanNvblNjaGVtYVsndHlwZSddLCBnZW5BSVNjaGVtYSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgZmllbGRWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoX2pzb25TY2hlbWEpKSB7XG4gICAgICAgIC8vIFNraXAgaWYgdGhlIGZpZWxkdmFsdWUgaXMgdW5kZWZpbmVkIG9yIG51bGwuXG4gICAgICAgIGlmIChmaWVsZFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWVsZE5hbWUgPT0gJ3R5cGUnKSB7XG4gICAgICAgICAgICBpZiAoZmllbGRWYWx1ZSA9PT0gJ251bGwnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0eXBlOiBudWxsIGNhbiBub3QgYmUgdGhlIG9ubHkgcG9zc2libGUgdHlwZSBmb3IgdGhlIGZpZWxkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpZWxkVmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIC8vIHdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkIHRoZSB0eXBlIGZpZWxkIHdpdGggYXJyYXkgb2YgdHlwZXMgaW4gdGhlXG4gICAgICAgICAgICAgICAgLy8gYmVnaW5uaW5nIG9mIHRoaXMgZnVuY3Rpb24uXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZW5BSVNjaGVtYVsndHlwZSddID0gT2JqZWN0LnZhbHVlcyhUeXBlKS5pbmNsdWRlcyhmaWVsZFZhbHVlLnRvVXBwZXJDYXNlKCkpXG4gICAgICAgICAgICAgICAgPyBmaWVsZFZhbHVlLnRvVXBwZXJDYXNlKClcbiAgICAgICAgICAgICAgICA6IFR5cGUuVFlQRV9VTlNQRUNJRklFRDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzY2hlbWFGaWVsZE5hbWVzLmluY2x1ZGVzKGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICAgIGdlbkFJU2NoZW1hW2ZpZWxkTmFtZV0gPVxuICAgICAgICAgICAgICAgIHByb2Nlc3NKc29uU2NoZW1hKGZpZWxkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxpc3RTY2hlbWFGaWVsZE5hbWVzLmluY2x1ZGVzKGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RTY2hlbWFGaWVsZFZhbHVlID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgZmllbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtWyd0eXBlJ10gPT0gJ251bGwnKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlbkFJU2NoZW1hWydudWxsYWJsZSddID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpc3RTY2hlbWFGaWVsZFZhbHVlLnB1c2gocHJvY2Vzc0pzb25TY2hlbWEoaXRlbSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2VuQUlTY2hlbWFbZmllbGROYW1lXSA9XG4gICAgICAgICAgICAgICAgbGlzdFNjaGVtYUZpZWxkVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGljdFNjaGVtYUZpZWxkTmFtZXMuaW5jbHVkZXMoZmllbGROYW1lKSkge1xuICAgICAgICAgICAgY29uc3QgZGljdFNjaGVtYUZpZWxkVmFsdWUgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGZpZWxkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZGljdFNjaGVtYUZpZWxkVmFsdWVba2V5XSA9IHByb2Nlc3NKc29uU2NoZW1hKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdlbkFJU2NoZW1hW2ZpZWxkTmFtZV0gPVxuICAgICAgICAgICAgICAgIGRpY3RTY2hlbWFGaWVsZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gYWRkaXRpb25hbFByb3BlcnRpZXMgaXMgbm90IGluY2x1ZGVkIGluIEpTT05TY2hlbWEsIHNraXBwaW5nIGl0LlxuICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSA9PT0gJ2FkZGl0aW9uYWxQcm9wZXJ0aWVzJykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2VuQUlTY2hlbWFbZmllbGROYW1lXSA9IGZpZWxkVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdlbkFJU2NoZW1hO1xufVxuLy8gd2UgdGFrZSB0aGUgdW5rbm93biBpbiB0aGUgc2NoZW1hIGZpZWxkIGJlY2F1c2Ugd2Ugd2FudCBlbmFibGUgdXNlciB0byBwYXNzXG4vLyB0aGUgb3V0cHV0IG9mIG1ham9yIHNjaGVtYSBkZWNsYXJhdGlvbiB0b29scyB3aXRob3V0IGNhc3RpbmcuIFRvb2xzIHN1Y2ggYXNcbi8vIHpvZFRvSnNvblNjaGVtYSwgdHlwZWJveCwgem9kVG9Kc29uU2NoZW1hIGZ1bmN0aW9uIGNhbiByZXR1cm4gSnNvblNjaGVtYTdUeXBlXG4vLyBvciBvYmplY3QsIHNlZSBkZXRhaWxzIGluXG4vLyBodHRwczovL2dpdGh1Yi5jb20vU3RlZmFuVGVyZGVsbC96b2QtdG8tanNvbi1zY2hlbWEvYmxvYi83MDUyNWVmZTU1NWNkMjI2NjkxZTA5M2QxNzEzNzBhM2IxMDkyMWQxL3NyYy96b2RUb0pzb25TY2hlbWEudHMjTDdcbi8vIHR5cGVib3ggY2FuIHJldHVybiB1bmtub3duLCBzZWUgZGV0YWlscyBpblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmNsYWlyeng4MS90eXBlYm94L2Jsb2IvNWE1NDMxNDM5ZjdkNWNhNmI0OTRkMGQxOGZiZmQ3YjFhMzU2ZDY3Yy9zcmMvdHlwZS9jcmVhdGUvdHlwZS50cyNMMzVcbi8vIE5vdGU6IHByb3BlciBqc29uIHNjaGVtYXMgd2l0aCB0aGUgJHNjaGVtYSBmaWVsZCBzZXQgbmV2ZXIgYXJyaXZlIHRvIHRoaXNcbi8vIHRyYW5zZm9ybWVyLiBTY2hlbWFzIHdpdGggJHNjaGVtYSBhcmUgcm91dGVkIHRvIHRoZSBlcXVpdmFsZW50IEFQSSBqc29uXG4vLyBzY2hlbWEgZmllbGQuXG5mdW5jdGlvbiB0U2NoZW1hKHNjaGVtYSkge1xuICAgIHJldHVybiBwcm9jZXNzSnNvblNjaGVtYShzY2hlbWEpO1xufVxuZnVuY3Rpb24gdFNwZWVjaENvbmZpZyhzcGVlY2hDb25maWcpIHtcbiAgICBpZiAodHlwZW9mIHNwZWVjaENvbmZpZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIHNwZWVjaENvbmZpZztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHNwZWVjaENvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZvaWNlQ29uZmlnOiB7XG4gICAgICAgICAgICAgICAgcHJlYnVpbHRWb2ljZUNvbmZpZzoge1xuICAgICAgICAgICAgICAgICAgICB2b2ljZU5hbWU6IHNwZWVjaENvbmZpZyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgc3BlZWNoQ29uZmlnIHR5cGU6ICR7dHlwZW9mIHNwZWVjaENvbmZpZ31gKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0TGl2ZVNwZWVjaENvbmZpZyhzcGVlY2hDb25maWcpIHtcbiAgICBpZiAoJ211bHRpU3BlYWtlclZvaWNlQ29uZmlnJyBpbiBzcGVlY2hDb25maWcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdWx0aVNwZWFrZXJWb2ljZUNvbmZpZyBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBsaXZlIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHNwZWVjaENvbmZpZztcbn1cbmZ1bmN0aW9uIHRUb29sKHRvb2wpIHtcbiAgICBpZiAodG9vbC5mdW5jdGlvbkRlY2xhcmF0aW9ucykge1xuICAgICAgICBmb3IgKGNvbnN0IGZ1bmN0aW9uRGVjbGFyYXRpb24gb2YgdG9vbC5mdW5jdGlvbkRlY2xhcmF0aW9ucykge1xuICAgICAgICAgICAgaWYgKGZ1bmN0aW9uRGVjbGFyYXRpb24ucGFyYW1ldGVycykge1xuICAgICAgICAgICAgICAgIGlmICghT2JqZWN0LmtleXMoZnVuY3Rpb25EZWNsYXJhdGlvbi5wYXJhbWV0ZXJzKS5pbmNsdWRlcygnJHNjaGVtYScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb24ucGFyYW1ldGVycyA9IHByb2Nlc3NKc29uU2NoZW1hKGZ1bmN0aW9uRGVjbGFyYXRpb24ucGFyYW1ldGVycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZ1bmN0aW9uRGVjbGFyYXRpb24ucGFyYW1ldGVyc0pzb25TY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb24ucGFyYW1ldGVyc0pzb25TY2hlbWEgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb24ucGFyYW1ldGVycztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBmdW5jdGlvbkRlY2xhcmF0aW9uLnBhcmFtZXRlcnM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnVuY3Rpb25EZWNsYXJhdGlvbi5yZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGlmICghT2JqZWN0LmtleXMoZnVuY3Rpb25EZWNsYXJhdGlvbi5yZXNwb25zZSkuaW5jbHVkZXMoJyRzY2hlbWEnKSkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uLnJlc3BvbnNlID0gcHJvY2Vzc0pzb25TY2hlbWEoZnVuY3Rpb25EZWNsYXJhdGlvbi5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZ1bmN0aW9uRGVjbGFyYXRpb24ucmVzcG9uc2VKc29uU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uLnJlc3BvbnNlSnNvblNjaGVtYSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbi5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBmdW5jdGlvbkRlY2xhcmF0aW9uLnJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0b29sO1xufVxuZnVuY3Rpb24gdFRvb2xzKHRvb2xzKSB7XG4gICAgLy8gQ2hlY2sgaWYgdGhlIGluY29taW5nIHR5cGUgaXMgZGVmaW5lZC5cbiAgICBpZiAodG9vbHMgPT09IHVuZGVmaW5lZCB8fCB0b29scyA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Rvb2xzIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheSh0b29scykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b29scyBpcyByZXF1aXJlZCBhbmQgbXVzdCBiZSBhbiBhcnJheSBvZiBUb29scycpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHRvb2wgb2YgdG9vbHMpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godG9vbCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIFByZXBlbmRzIHJlc291cmNlIG5hbWUgd2l0aCBwcm9qZWN0LCBsb2NhdGlvbiwgcmVzb3VyY2VfcHJlZml4IGlmIG5lZWRlZC5cbiAqXG4gKiBAcGFyYW0gY2xpZW50IFRoZSBBUEkgY2xpZW50LlxuICogQHBhcmFtIHJlc291cmNlTmFtZSBUaGUgcmVzb3VyY2UgbmFtZS5cbiAqIEBwYXJhbSByZXNvdXJjZVByZWZpeCBUaGUgcmVzb3VyY2UgcHJlZml4LlxuICogQHBhcmFtIHNwbGl0c0FmdGVyUHJlZml4IFRoZSBudW1iZXIgb2Ygc3BsaXRzIGFmdGVyIHRoZSBwcmVmaXguXG4gKiBAcmV0dXJucyBUaGUgY29tcGxldGVkIHJlc291cmNlIG5hbWUuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogYGBgXG4gKiByZXNvdXJjZV9uYW1lID0gJzEyMydcbiAqIHJlc291cmNlX3ByZWZpeCA9ICdjYWNoZWRDb250ZW50cydcbiAqIHNwbGl0c19hZnRlcl9wcmVmaXggPSAxXG4gKiBjbGllbnQudmVydGV4YWkgPSBUcnVlXG4gKiBjbGllbnQucHJvamVjdCA9ICdiYXInXG4gKiBjbGllbnQubG9jYXRpb24gPSAndXMtd2VzdDEnXG4gKiBfcmVzb3VyY2VfbmFtZShjbGllbnQsIHJlc291cmNlX25hbWUsIHJlc291cmNlX3ByZWZpeCwgc3BsaXRzX2FmdGVyX3ByZWZpeClcbiAqIHJldHVybnM6ICdwcm9qZWN0cy9iYXIvbG9jYXRpb25zL3VzLXdlc3QxL2NhY2hlZENvbnRlbnRzLzEyMydcbiAqIGBgYFxuICpcbiAqIGBgYFxuICogcmVzb3VyY2VfbmFtZSA9ICdwcm9qZWN0cy9mb28vbG9jYXRpb25zL3VzLWNlbnRyYWwxL2NhY2hlZENvbnRlbnRzLzEyMydcbiAqIHJlc291cmNlX3ByZWZpeCA9ICdjYWNoZWRDb250ZW50cydcbiAqIHNwbGl0c19hZnRlcl9wcmVmaXggPSAxXG4gKiBjbGllbnQudmVydGV4YWkgPSBUcnVlXG4gKiBjbGllbnQucHJvamVjdCA9ICdiYXInXG4gKiBjbGllbnQubG9jYXRpb24gPSAndXMtd2VzdDEnXG4gKiBfcmVzb3VyY2VfbmFtZShjbGllbnQsIHJlc291cmNlX25hbWUsIHJlc291cmNlX3ByZWZpeCwgc3BsaXRzX2FmdGVyX3ByZWZpeClcbiAqIHJldHVybnM6ICdwcm9qZWN0cy9mb28vbG9jYXRpb25zL3VzLWNlbnRyYWwxL2NhY2hlZENvbnRlbnRzLzEyMydcbiAqIGBgYFxuICpcbiAqIGBgYFxuICogcmVzb3VyY2VfbmFtZSA9ICcxMjMnXG4gKiByZXNvdXJjZV9wcmVmaXggPSAnY2FjaGVkQ29udGVudHMnXG4gKiBzcGxpdHNfYWZ0ZXJfcHJlZml4ID0gMVxuICogY2xpZW50LnZlcnRleGFpID0gRmFsc2VcbiAqIF9yZXNvdXJjZV9uYW1lKGNsaWVudCwgcmVzb3VyY2VfbmFtZSwgcmVzb3VyY2VfcHJlZml4LCBzcGxpdHNfYWZ0ZXJfcHJlZml4KVxuICogcmV0dXJucyAnY2FjaGVkQ29udGVudHMvMTIzJ1xuICogYGBgXG4gKlxuICogYGBgXG4gKiByZXNvdXJjZV9uYW1lID0gJ3NvbWUvd3JvbmcvY2FjaGVkQ29udGVudHMvcmVzb3VyY2UvbmFtZS8xMjMnXG4gKiByZXNvdXJjZV9wcmVmaXggPSAnY2FjaGVkQ29udGVudHMnXG4gKiBzcGxpdHNfYWZ0ZXJfcHJlZml4ID0gMVxuICogY2xpZW50LnZlcnRleGFpID0gRmFsc2VcbiAqICMgY2xpZW50LnZlcnRleGFpID0gVHJ1ZVxuICogX3Jlc291cmNlX25hbWUoY2xpZW50LCByZXNvdXJjZV9uYW1lLCByZXNvdXJjZV9wcmVmaXgsIHNwbGl0c19hZnRlcl9wcmVmaXgpXG4gKiAtPiAnc29tZS93cm9uZy9yZXNvdXJjZS9uYW1lLzEyMydcbiAqIGBgYFxuICovXG5mdW5jdGlvbiByZXNvdXJjZU5hbWUoY2xpZW50LCByZXNvdXJjZU5hbWUsIHJlc291cmNlUHJlZml4LCBzcGxpdHNBZnRlclByZWZpeCA9IDEpIHtcbiAgICBjb25zdCBzaG91bGRBcHBlbmRQcmVmaXggPSAhcmVzb3VyY2VOYW1lLnN0YXJ0c1dpdGgoYCR7cmVzb3VyY2VQcmVmaXh9L2ApICYmXG4gICAgICAgIHJlc291cmNlTmFtZS5zcGxpdCgnLycpLmxlbmd0aCA9PT0gc3BsaXRzQWZ0ZXJQcmVmaXg7XG4gICAgaWYgKGNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgaWYgKHJlc291cmNlTmFtZS5zdGFydHNXaXRoKCdwcm9qZWN0cy8nKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc291cmNlTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXNvdXJjZU5hbWUuc3RhcnRzV2l0aCgnbG9jYXRpb25zLycpKSB7XG4gICAgICAgICAgICByZXR1cm4gYHByb2plY3RzLyR7Y2xpZW50LmdldFByb2plY3QoKX0vJHtyZXNvdXJjZU5hbWV9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXNvdXJjZU5hbWUuc3RhcnRzV2l0aChgJHtyZXNvdXJjZVByZWZpeH0vYCkpIHtcbiAgICAgICAgICAgIHJldHVybiBgcHJvamVjdHMvJHtjbGllbnQuZ2V0UHJvamVjdCgpfS9sb2NhdGlvbnMvJHtjbGllbnQuZ2V0TG9jYXRpb24oKX0vJHtyZXNvdXJjZU5hbWV9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzaG91bGRBcHBlbmRQcmVmaXgpIHtcbiAgICAgICAgICAgIHJldHVybiBgcHJvamVjdHMvJHtjbGllbnQuZ2V0UHJvamVjdCgpfS9sb2NhdGlvbnMvJHtjbGllbnQuZ2V0TG9jYXRpb24oKX0vJHtyZXNvdXJjZVByZWZpeH0vJHtyZXNvdXJjZU5hbWV9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvdXJjZU5hbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNob3VsZEFwcGVuZFByZWZpeCkge1xuICAgICAgICByZXR1cm4gYCR7cmVzb3VyY2VQcmVmaXh9LyR7cmVzb3VyY2VOYW1lfWA7XG4gICAgfVxuICAgIHJldHVybiByZXNvdXJjZU5hbWU7XG59XG5mdW5jdGlvbiB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBuYW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25hbWUgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzb3VyY2VOYW1lKGFwaUNsaWVudCwgbmFtZSwgJ2NhY2hlZENvbnRlbnRzJyk7XG59XG5mdW5jdGlvbiB0VHVuaW5nSm9iU3RhdHVzKHN0YXR1cykge1xuICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgJ1NUQVRFX1VOU1BFQ0lGSUVEJzpcbiAgICAgICAgICAgIHJldHVybiAnSk9CX1NUQVRFX1VOU1BFQ0lGSUVEJztcbiAgICAgICAgY2FzZSAnQ1JFQVRJTkcnOlxuICAgICAgICAgICAgcmV0dXJuICdKT0JfU1RBVEVfUlVOTklORyc7XG4gICAgICAgIGNhc2UgJ0FDVElWRSc6XG4gICAgICAgICAgICByZXR1cm4gJ0pPQl9TVEFURV9TVUNDRUVERUQnO1xuICAgICAgICBjYXNlICdGQUlMRUQnOlxuICAgICAgICAgICAgcmV0dXJuICdKT0JfU1RBVEVfRkFJTEVEJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgfVxufVxuZnVuY3Rpb24gdEJ5dGVzKGZyb21JbWFnZUJ5dGVzKSB7XG4gICAgcmV0dXJuIHRCeXRlcyQxKGZyb21JbWFnZUJ5dGVzKTtcbn1cbmZ1bmN0aW9uIF9pc0ZpbGUob3JpZ2luKSB7XG4gICAgcmV0dXJuIChvcmlnaW4gIT09IG51bGwgJiZcbiAgICAgICAgb3JpZ2luICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdHlwZW9mIG9yaWdpbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ25hbWUnIGluIG9yaWdpbik7XG59XG5mdW5jdGlvbiBpc0dlbmVyYXRlZFZpZGVvKG9yaWdpbikge1xuICAgIHJldHVybiAob3JpZ2luICE9PSBudWxsICYmXG4gICAgICAgIG9yaWdpbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHR5cGVvZiBvcmlnaW4gPT09ICdvYmplY3QnICYmXG4gICAgICAgICd2aWRlbycgaW4gb3JpZ2luKTtcbn1cbmZ1bmN0aW9uIGlzVmlkZW8ob3JpZ2luKSB7XG4gICAgcmV0dXJuIChvcmlnaW4gIT09IG51bGwgJiZcbiAgICAgICAgb3JpZ2luICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdHlwZW9mIG9yaWdpbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ3VyaScgaW4gb3JpZ2luKTtcbn1cbmZ1bmN0aW9uIHRGaWxlTmFtZShmcm9tTmFtZSkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgbmFtZTtcbiAgICBpZiAoX2lzRmlsZShmcm9tTmFtZSkpIHtcbiAgICAgICAgbmFtZSA9IGZyb21OYW1lLm5hbWU7XG4gICAgfVxuICAgIGlmIChpc1ZpZGVvKGZyb21OYW1lKSkge1xuICAgICAgICBuYW1lID0gZnJvbU5hbWUudXJpO1xuICAgICAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc0dlbmVyYXRlZFZpZGVvKGZyb21OYW1lKSkge1xuICAgICAgICBuYW1lID0gKF9hID0gZnJvbU5hbWUudmlkZW8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51cmk7XG4gICAgICAgIGlmIChuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBmcm9tTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbmFtZSA9IGZyb21OYW1lO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGV4dHJhY3QgZmlsZSBuYW1lIGZyb20gdGhlIHByb3ZpZGVkIGlucHV0LicpO1xuICAgIH1cbiAgICBpZiAobmFtZS5zdGFydHNXaXRoKCdodHRwczovLycpKSB7XG4gICAgICAgIGNvbnN0IHN1ZmZpeCA9IG5hbWUuc3BsaXQoJ2ZpbGVzLycpWzFdO1xuICAgICAgICBjb25zdCBtYXRjaCA9IHN1ZmZpeC5tYXRjaCgvW2EtejAtOV0rLyk7XG4gICAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZXh0cmFjdCBmaWxlIG5hbWUgZnJvbSBVUkkgJHtuYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgPSBtYXRjaFswXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZS5zdGFydHNXaXRoKCdmaWxlcy8nKSkge1xuICAgICAgICBuYW1lID0gbmFtZS5zcGxpdCgnZmlsZXMvJylbMV07XG4gICAgfVxuICAgIHJldHVybiBuYW1lO1xufVxuZnVuY3Rpb24gdE1vZGVsc1VybChhcGlDbGllbnQsIGJhc2VNb2RlbHMpIHtcbiAgICBsZXQgcmVzO1xuICAgIGlmIChhcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgIHJlcyA9IGJhc2VNb2RlbHMgPyAncHVibGlzaGVycy9nb29nbGUvbW9kZWxzJyA6ICdtb2RlbHMnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzID0gYmFzZU1vZGVscyA/ICdtb2RlbHMnIDogJ3R1bmVkTW9kZWxzJztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIHRFeHRyYWN0TW9kZWxzKHJlc3BvbnNlKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgWydtb2RlbHMnLCAndHVuZWRNb2RlbHMnLCAncHVibGlzaGVyTW9kZWxzJ10pIHtcbiAgICAgICAgaWYgKGhhc0ZpZWxkKHJlc3BvbnNlLCBrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2Vba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW107XG59XG5mdW5jdGlvbiBoYXNGaWVsZChkYXRhLCBmaWVsZE5hbWUpIHtcbiAgICByZXR1cm4gZGF0YSAhPT0gbnVsbCAmJiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiYgZmllbGROYW1lIGluIGRhdGE7XG59XG5mdW5jdGlvbiBtY3BUb0dlbWluaVRvb2wobWNwVG9vbCwgY29uZmlnID0ge30pIHtcbiAgICBjb25zdCBtY3BUb29sU2NoZW1hID0gbWNwVG9vbDtcbiAgICBjb25zdCBmdW5jdGlvbkRlY2xhcmF0aW9uID0ge1xuICAgICAgICBuYW1lOiBtY3BUb29sU2NoZW1hWyduYW1lJ10sXG4gICAgICAgIGRlc2NyaXB0aW9uOiBtY3BUb29sU2NoZW1hWydkZXNjcmlwdGlvbiddLFxuICAgICAgICBwYXJhbWV0ZXJzSnNvblNjaGVtYTogbWNwVG9vbFNjaGVtYVsnaW5wdXRTY2hlbWEnXSxcbiAgICB9O1xuICAgIGlmIChtY3BUb29sU2NoZW1hWydvdXRwdXRTY2hlbWEnXSkge1xuICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uWydyZXNwb25zZUpzb25TY2hlbWEnXSA9IG1jcFRvb2xTY2hlbWFbJ291dHB1dFNjaGVtYSddO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmJlaGF2aW9yKSB7XG4gICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb25bJ2JlaGF2aW9yJ10gPSBjb25maWcuYmVoYXZpb3I7XG4gICAgfVxuICAgIGNvbnN0IGdlbWluaVRvb2wgPSB7XG4gICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uLFxuICAgICAgICBdLFxuICAgIH07XG4gICAgcmV0dXJuIGdlbWluaVRvb2w7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgbGlzdCBvZiBNQ1AgdG9vbHMgdG8gYSBzaW5nbGUgR2VtaW5pIHRvb2wgd2l0aCBhIGxpc3Qgb2YgZnVuY3Rpb25cbiAqIGRlY2xhcmF0aW9ucy5cbiAqL1xuZnVuY3Rpb24gbWNwVG9vbHNUb0dlbWluaVRvb2wobWNwVG9vbHMsIGNvbmZpZyA9IHt9KSB7XG4gICAgY29uc3QgZnVuY3Rpb25EZWNsYXJhdGlvbnMgPSBbXTtcbiAgICBjb25zdCB0b29sTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBtY3BUb29sIG9mIG1jcFRvb2xzKSB7XG4gICAgICAgIGNvbnN0IG1jcFRvb2xOYW1lID0gbWNwVG9vbC5uYW1lO1xuICAgICAgICBpZiAodG9vbE5hbWVzLmhhcyhtY3BUb29sTmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGZ1bmN0aW9uIG5hbWUgJHttY3BUb29sTmFtZX0gZm91bmQgaW4gTUNQIHRvb2xzLiBQbGVhc2UgZW5zdXJlIGZ1bmN0aW9uIG5hbWVzIGFyZSB1bmlxdWUuYCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9vbE5hbWVzLmFkZChtY3BUb29sTmFtZSk7XG4gICAgICAgIGNvbnN0IGdlbWluaVRvb2wgPSBtY3BUb0dlbWluaVRvb2wobWNwVG9vbCwgY29uZmlnKTtcbiAgICAgICAgaWYgKGdlbWluaVRvb2wuZnVuY3Rpb25EZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb25zLnB1c2goLi4uZ2VtaW5pVG9vbC5mdW5jdGlvbkRlY2xhcmF0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgZnVuY3Rpb25EZWNsYXJhdGlvbnM6IGZ1bmN0aW9uRGVjbGFyYXRpb25zIH07XG59XG4vLyBUcmFuc2Zvcm1zIGEgc291cmNlIGlucHV0IGludG8gYSBCYXRjaEpvYlNvdXJjZSBvYmplY3Qgd2l0aCB2YWxpZGF0aW9uLlxuZnVuY3Rpb24gdEJhdGNoSm9iU291cmNlKGNsaWVudCwgc3JjKSB7XG4gICAgbGV0IHNvdXJjZU9iajtcbiAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGlmIChzcmMuc3RhcnRzV2l0aCgnZ3M6Ly8nKSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZU9iaiA9IHsgZm9ybWF0OiAnanNvbmwnLCBnY3NVcmk6IFtzcmNdIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzcmMuc3RhcnRzV2l0aCgnYnE6Ly8nKSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZU9iaiA9IHsgZm9ybWF0OiAnYmlncXVlcnknLCBiaWdxdWVyeVVyaTogc3JjIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHN0cmluZyBzb3VyY2UgZm9yIFZlcnRleCBBSTogJHtzcmN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBNTERFVlxuICAgICAgICAgICAgaWYgKHNyYy5zdGFydHNXaXRoKCdmaWxlcy8nKSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZU9iaiA9IHsgZmlsZU5hbWU6IHNyYyB9OyAvLyBEZWZhdWx0IHRvIGZpbGVOYW1lIGZvciBzdHJpbmcgaW5wdXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgc3RyaW5nIHNvdXJjZSBmb3IgR2VtaW5pIEFQSTogJHtzcmN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzcmMpKSB7XG4gICAgICAgIGlmIChjbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lubGluZWRSZXF1ZXN0W10gaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgc291cmNlT2JqID0geyBpbmxpbmVkUmVxdWVzdHM6IHNyYyB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gSXQncyBhbHJlYWR5IGEgQmF0Y2hKb2JTb3VyY2Ugb2JqZWN0XG4gICAgICAgIHNvdXJjZU9iaiA9IHNyYztcbiAgICB9XG4gICAgLy8gVmFsaWRhdGlvbiBsb2dpY1xuICAgIGNvbnN0IHZlcnRleFNvdXJjZXNDb3VudCA9IFtzb3VyY2VPYmouZ2NzVXJpLCBzb3VyY2VPYmouYmlncXVlcnlVcmldLmZpbHRlcihCb29sZWFuKS5sZW5ndGg7XG4gICAgY29uc3QgbWxkZXZTb3VyY2VzQ291bnQgPSBbXG4gICAgICAgIHNvdXJjZU9iai5pbmxpbmVkUmVxdWVzdHMsXG4gICAgICAgIHNvdXJjZU9iai5maWxlTmFtZSxcbiAgICBdLmZpbHRlcihCb29sZWFuKS5sZW5ndGg7XG4gICAgaWYgKGNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgaWYgKG1sZGV2U291cmNlc0NvdW50ID4gMCB8fCB2ZXJ0ZXhTb3VyY2VzQ291bnQgIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhhY3RseSBvbmUgb2YgYGdjc1VyaWAgb3IgYGJpZ3F1ZXJ5VXJpYCBtdXN0IGJlIHNldCBmb3IgVmVydGV4IEFJLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBNTERFVlxuICAgICAgICBpZiAodmVydGV4U291cmNlc0NvdW50ID4gMCB8fCBtbGRldlNvdXJjZXNDb3VudCAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeGFjdGx5IG9uZSBvZiBgaW5saW5lZFJlcXVlc3RzYCwgYGZpbGVOYW1lYCwgJyArXG4gICAgICAgICAgICAgICAgJ211c3QgYmUgc2V0IGZvciBHZW1pbmkgQVBJLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2VPYmo7XG59XG5mdW5jdGlvbiB0QmF0Y2hKb2JEZXN0aW5hdGlvbihkZXN0KSB7XG4gICAgaWYgKHR5cGVvZiBkZXN0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9XG4gICAgY29uc3QgZGVzdFN0cmluZyA9IGRlc3Q7XG4gICAgaWYgKGRlc3RTdHJpbmcuc3RhcnRzV2l0aCgnZ3M6Ly8nKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZm9ybWF0OiAnanNvbmwnLFxuICAgICAgICAgICAgZ2NzVXJpOiBkZXN0U3RyaW5nLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChkZXN0U3RyaW5nLnN0YXJ0c1dpdGgoJ2JxOi8vJykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZvcm1hdDogJ2JpZ3F1ZXJ5JyxcbiAgICAgICAgICAgIGJpZ3F1ZXJ5VXJpOiBkZXN0U3RyaW5nLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkZXN0aW5hdGlvbjogJHtkZXN0U3RyaW5nfWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRSZWN2QmF0Y2hKb2JEZXN0aW5hdGlvbihkZXN0KSB7XG4gICAgLy8gRW5zdXJlIGRlc3QgaXMgYSBub24tbnVsbCBvYmplY3QgYmVmb3JlIHByb2NlZWRpbmcuXG4gICAgaWYgKHR5cGVvZiBkZXN0ICE9PSAnb2JqZWN0JyB8fCBkZXN0ID09PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHRoZSBpbnB1dCBpcyBub3QgYW4gb2JqZWN0LCBpdCBjYW5ub3QgYmUgYSB2YWxpZCBCYXRjaEpvYkRlc3RpbmF0aW9uXG4gICAgICAgIC8vIGJhc2VkIG9uIHRoZSBvcGVyYXRpb25zIHBlcmZvcm1lZC4gUmV0dXJuIGl0IGNhc3QsIG9yIGhhbmRsZSBhcyBhbiBlcnJvci5cbiAgICAgICAgLy8gQ2FzdGluZyBhbiBlbXB0eSBvYmplY3QgbWlnaHQgYmUgYSBzYWZlIGRlZmF1bHQuXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgLy8gQ2FzdCB0byBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB0byBhbGxvdyBzdHJpbmcgcHJvcGVydHkgYWNjZXNzLlxuICAgIGNvbnN0IG9iaiA9IGRlc3Q7XG4gICAgLy8gU2FmZWx5IGFjY2VzcyBuZXN0ZWQgcHJvcGVydGllcy5cbiAgICBjb25zdCBpbmxpbmVSZXNwb25zZXNWYWwgPSBvYmpbJ2lubGluZWRSZXNwb25zZXMnXTtcbiAgICBpZiAodHlwZW9mIGlubGluZVJlc3BvbnNlc1ZhbCAhPT0gJ29iamVjdCcgfHwgaW5saW5lUmVzcG9uc2VzVmFsID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH1cbiAgICBjb25zdCBpbmxpbmVSZXNwb25zZXNPYmogPSBpbmxpbmVSZXNwb25zZXNWYWw7XG4gICAgY29uc3QgcmVzcG9uc2VzQXJyYXkgPSBpbmxpbmVSZXNwb25zZXNPYmpbJ2lubGluZWRSZXNwb25zZXMnXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVzcG9uc2VzQXJyYXkpIHx8IHJlc3BvbnNlc0FycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgYW55IHJlc3BvbnNlIGhhcyB0aGUgJ2VtYmVkZGluZycgcHJvcGVydHkuXG4gICAgbGV0IGhhc0VtYmVkZGluZyA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgcmVzcG9uc2VJdGVtIG9mIHJlc3BvbnNlc0FycmF5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2VJdGVtICE9PSAnb2JqZWN0JyB8fCByZXNwb25zZUl0ZW0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlSXRlbU9iaiA9IHJlc3BvbnNlSXRlbTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VWYWwgPSByZXNwb25zZUl0ZW1PYmpbJ3Jlc3BvbnNlJ107XG4gICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2VWYWwgIT09ICdvYmplY3QnIHx8IHJlc3BvbnNlVmFsID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZU9iaiA9IHJlc3BvbnNlVmFsO1xuICAgICAgICAvLyBDaGVjayBmb3IgdGhlIGV4aXN0ZW5jZSBvZiB0aGUgJ2VtYmVkZGluZycga2V5LlxuICAgICAgICBpZiAocmVzcG9uc2VPYmpbJ2VtYmVkZGluZyddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGhhc0VtYmVkZGluZyA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBQZXJmb3JtIHRoZSB0cmFuc2Zvcm1hdGlvbiBpZiBhbiBlbWJlZGRpbmcgd2FzIGZvdW5kLlxuICAgIGlmIChoYXNFbWJlZGRpbmcpIHtcbiAgICAgICAgb2JqWydpbmxpbmVkRW1iZWRDb250ZW50UmVzcG9uc2VzJ10gPSBvYmpbJ2lubGluZWRSZXNwb25zZXMnXTtcbiAgICAgICAgZGVsZXRlIG9ialsnaW5saW5lZFJlc3BvbnNlcyddO1xuICAgIH1cbiAgICAvLyBDYXN0IHRoZSAocG90ZW50aWFsbHkpIG1vZGlmaWVkIG9iamVjdCB0byB0aGUgdGFyZ2V0IHR5cGUuXG4gICAgcmV0dXJuIGRlc3Q7XG59XG5mdW5jdGlvbiB0QmF0Y2hKb2JOYW1lKGFwaUNsaWVudCwgbmFtZSkge1xuICAgIGNvbnN0IG5hbWVTdHJpbmcgPSBuYW1lO1xuICAgIGlmICghYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICBjb25zdCBtbGRldlBhdHRlcm4gPSAvYmF0Y2hlc1xcL1teL10rJC87XG4gICAgICAgIGlmIChtbGRldlBhdHRlcm4udGVzdChuYW1lU3RyaW5nKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWVTdHJpbmcuc3BsaXQoJy8nKS5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBiYXRjaCBqb2IgbmFtZTogJHtuYW1lU3RyaW5nfS5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB2ZXJ0ZXhQYXR0ZXJuID0gL15wcm9qZWN0c1xcL1teL10rXFwvbG9jYXRpb25zXFwvW14vXStcXC9iYXRjaFByZWRpY3Rpb25Kb2JzXFwvW14vXSskLztcbiAgICBpZiAodmVydGV4UGF0dGVybi50ZXN0KG5hbWVTdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiBuYW1lU3RyaW5nLnNwbGl0KCcvJykucG9wKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKC9eXFxkKyQvLnRlc3QobmFtZVN0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIG5hbWVTdHJpbmc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYmF0Y2ggam9iIG5hbWU6ICR7bmFtZVN0cmluZ30uYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdEpvYlN0YXRlKHN0YXRlKSB7XG4gICAgY29uc3Qgc3RhdGVTdHJpbmcgPSBzdGF0ZTtcbiAgICBpZiAoc3RhdGVTdHJpbmcgPT09ICdCQVRDSF9TVEFURV9VTlNQRUNJRklFRCcpIHtcbiAgICAgICAgcmV0dXJuICdKT0JfU1RBVEVfVU5TUEVDSUZJRUQnO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdGF0ZVN0cmluZyA9PT0gJ0JBVENIX1NUQVRFX1BFTkRJTkcnKSB7XG4gICAgICAgIHJldHVybiAnSk9CX1NUQVRFX1BFTkRJTkcnO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdGF0ZVN0cmluZyA9PT0gJ0JBVENIX1NUQVRFX1JVTk5JTkcnKSB7XG4gICAgICAgIHJldHVybiAnSk9CX1NUQVRFX1JVTk5JTkcnO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdGF0ZVN0cmluZyA9PT0gJ0JBVENIX1NUQVRFX1NVQ0NFRURFRCcpIHtcbiAgICAgICAgcmV0dXJuICdKT0JfU1RBVEVfU1VDQ0VFREVEJztcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhdGVTdHJpbmcgPT09ICdCQVRDSF9TVEFURV9GQUlMRUQnKSB7XG4gICAgICAgIHJldHVybiAnSk9CX1NUQVRFX0ZBSUxFRCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0YXRlU3RyaW5nID09PSAnQkFUQ0hfU1RBVEVfQ0FOQ0VMTEVEJykge1xuICAgICAgICByZXR1cm4gJ0pPQl9TVEFURV9DQU5DRUxMRUQnO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdGF0ZVN0cmluZyA9PT0gJ0JBVENIX1NUQVRFX0VYUElSRUQnKSB7XG4gICAgICAgIHJldHVybiAnSk9CX1NUQVRFX0VYUElSRUQnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlU3RyaW5nO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuZnVuY3Rpb24gYmF0Y2hKb2JEZXN0aW5hdGlvbkZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRmlsZU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlc0ZpbGUnXSk7XG4gICAgaWYgKGZyb21GaWxlTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVOYW1lJ10sIGZyb21GaWxlTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVkUmVzcG9uc2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5saW5lZFJlc3BvbnNlcycsXG4gICAgICAgICdpbmxpbmVkUmVzcG9uc2VzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUlubGluZWRSZXNwb25zZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUlubGluZWRSZXNwb25zZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5saW5lZFJlc3BvbnNlRnJvbU1sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5saW5lZFJlc3BvbnNlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lZEVtYmVkQ29udGVudFJlc3BvbnNlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2lubGluZWRFbWJlZENvbnRlbnRSZXNwb25zZXMnLFxuICAgICAgICAnaW5saW5lZFJlc3BvbnNlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21JbmxpbmVkRW1iZWRDb250ZW50UmVzcG9uc2VzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21JbmxpbmVkRW1iZWRDb250ZW50UmVzcG9uc2VzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmxpbmVkRW1iZWRDb250ZW50UmVzcG9uc2VzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJhdGNoSm9iRGVzdGluYXRpb25Gcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Gb3JtYXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ByZWRpY3Rpb25zRm9ybWF0J10pO1xuICAgIGlmIChmcm9tRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZm9ybWF0J10sIGZyb21Gb3JtYXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ2NzRGVzdGluYXRpb24nLFxuICAgICAgICAnb3V0cHV0VXJpUHJlZml4JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2djc1VyaSddLCBmcm9tR2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJpZ3F1ZXJ5VXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYmlncXVlcnlEZXN0aW5hdGlvbicsXG4gICAgICAgICdvdXRwdXRVcmknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQmlncXVlcnlVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiaWdxdWVyeVVyaSddLCBmcm9tQmlncXVlcnlVcmkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBiYXRjaEpvYkRlc3RpbmF0aW9uVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZvcm1hdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZm9ybWF0J10pO1xuICAgIGlmIChmcm9tRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJlZGljdGlvbnNGb3JtYXQnXSwgZnJvbUZvcm1hdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HY3NVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKTtcbiAgICBpZiAoZnJvbUdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2djc0Rlc3RpbmF0aW9uJywgJ291dHB1dFVyaVByZWZpeCddLCBmcm9tR2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJpZ3F1ZXJ5VXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiaWdxdWVyeVVyaSddKTtcbiAgICBpZiAoZnJvbUJpZ3F1ZXJ5VXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmlncXVlcnlEZXN0aW5hdGlvbicsICdvdXRwdXRVcmknXSwgZnJvbUJpZ3F1ZXJ5VXJpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpbGVOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5saW5lZFJlc3BvbnNlcyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW5saW5lZFJlc3BvbnNlcyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lubGluZWRFbWJlZENvbnRlbnRSZXNwb25zZXMnXSkgIT09XG4gICAgICAgIHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lubGluZWRFbWJlZENvbnRlbnRSZXNwb25zZXMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBiYXRjaEpvYkZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWV0YWRhdGEnLFxuICAgICAgICAnZGlzcGxheU5hbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhdGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJywgJ3N0YXRlJ10pO1xuICAgIGlmIChmcm9tU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGF0ZSddLCB0Sm9iU3RhdGUoZnJvbVN0YXRlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DcmVhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWV0YWRhdGEnLFxuICAgICAgICAnY3JlYXRlVGltZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DcmVhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY3JlYXRlVGltZSddLCBmcm9tQ3JlYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWV0YWRhdGEnLFxuICAgICAgICAnZW5kVGltZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbmRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kVGltZSddLCBmcm9tRW5kVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcGRhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWV0YWRhdGEnLFxuICAgICAgICAndXBkYXRlVGltZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21VcGRhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXBkYXRlVGltZSddLCBmcm9tVXBkYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0YWRhdGEnLCAnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsJ10sIGZyb21Nb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXN0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YScsICdvdXRwdXQnXSk7XG4gICAgaWYgKGZyb21EZXN0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzdCddLCBiYXRjaEpvYkRlc3RpbmF0aW9uRnJvbU1sZGV2KHRSZWN2QmF0Y2hKb2JEZXN0aW5hdGlvbihmcm9tRGVzdCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmF0Y2hKb2JGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhdGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXRlJ10pO1xuICAgIGlmIChmcm9tU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGF0ZSddLCB0Sm9iU3RhdGUoZnJvbVN0YXRlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZyb21FcnJvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DcmVhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjcmVhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tQ3JlYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSwgZnJvbUNyZWF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhcnRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGFydFRpbWUnXSk7XG4gICAgaWYgKGZyb21TdGFydFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGFydFRpbWUnXSwgZnJvbVN0YXJ0VGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmRUaW1lJ10pO1xuICAgIGlmIChmcm9tRW5kVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZFRpbWUnXSwgZnJvbUVuZFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXBkYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXBkYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbVVwZGF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cGRhdGVUaW1lJ10sIGZyb21VcGRhdGVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWwnXSwgZnJvbU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNyYyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5wdXRDb25maWcnXSk7XG4gICAgaWYgKGZyb21TcmMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzcmMnXSwgYmF0Y2hKb2JTb3VyY2VGcm9tVmVydGV4KGZyb21TcmMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc3QgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ291dHB1dENvbmZpZyddKTtcbiAgICBpZiAoZnJvbURlc3QgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXN0J10sIGJhdGNoSm9iRGVzdGluYXRpb25Gcm9tVmVydGV4KHRSZWN2QmF0Y2hKb2JEZXN0aW5hdGlvbihmcm9tRGVzdCkpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbXBsZXRpb25TdGF0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvbXBsZXRpb25TdGF0cycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db21wbGV0aW9uU3RhdHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb21wbGV0aW9uU3RhdHMnXSwgZnJvbUNvbXBsZXRpb25TdGF0cyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJhdGNoSm9iU291cmNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRm9ybWF0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbnN0YW5jZXNGb3JtYXQnXSk7XG4gICAgaWYgKGZyb21Gb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmb3JtYXQnXSwgZnJvbUZvcm1hdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HY3NVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1NvdXJjZScsICd1cmlzJ10pO1xuICAgIGlmIChmcm9tR2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2NzVXJpJ10sIGZyb21HY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmlncXVlcnlVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdiaWdxdWVyeVNvdXJjZScsXG4gICAgICAgICdpbnB1dFVyaScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21CaWdxdWVyeVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JpZ3F1ZXJ5VXJpJ10sIGZyb21CaWdxdWVyeVVyaSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJhdGNoSm9iU291cmNlVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Zvcm1hdCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZm9ybWF0IHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2NzVXJpIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JpZ3F1ZXJ5VXJpJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiaWdxdWVyeVVyaSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVOYW1lJ10pO1xuICAgIGlmIChmcm9tRmlsZU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlTmFtZSddLCBmcm9tRmlsZU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lZFJlcXVlc3RzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5saW5lZFJlcXVlc3RzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUlubGluZWRSZXF1ZXN0cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tSW5saW5lZFJlcXVlc3RzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlubGluZWRSZXF1ZXN0VG9NbGRldihhcGlDbGllbnQsIGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVxdWVzdHMnLCAncmVxdWVzdHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmF0Y2hKb2JTb3VyY2VUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRm9ybWF0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmb3JtYXQnXSk7XG4gICAgaWYgKGZyb21Gb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNGb3JtYXQnXSwgZnJvbUZvcm1hdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HY3NVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKTtcbiAgICBpZiAoZnJvbUdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2djc1NvdXJjZScsICd1cmlzJ10sIGZyb21HY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmlncXVlcnlVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JpZ3F1ZXJ5VXJpJ10pO1xuICAgIGlmIChmcm9tQmlncXVlcnlVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiaWdxdWVyeVNvdXJjZScsICdpbnB1dFVyaSddLCBmcm9tQmlncXVlcnlVcmkpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlTmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmlsZU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVkUmVxdWVzdHMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lubGluZWRSZXF1ZXN0cyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJsb2JUb01sZGV2JDQoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RhdGEnXSk7XG4gICAgaWYgKGZyb21EYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGF0YSddLCBmcm9tRGF0YSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaXNwbGF5TmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjYW5jZWxCYXRjaEpvYlBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRCYXRjaEpvYk5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjYW5jZWxCYXRjaEpvYlBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0QmF0Y2hKb2JOYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY2FuZGlkYXRlRnJvbU1sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbnRlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnQnXSk7XG4gICAgaWYgKGZyb21Db250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29udGVudCddLCBmcm9tQ29udGVudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DaXRhdGlvbk1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2l0YXRpb25NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DaXRhdGlvbk1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2l0YXRpb25NZXRhZGF0YSddLCBjaXRhdGlvbk1ldGFkYXRhRnJvbU1sZGV2JDEoZnJvbUNpdGF0aW9uTWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rva2VuQ291bnQnXSk7XG4gICAgaWYgKGZyb21Ub2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9rZW5Db3VudCddLCBmcm9tVG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaW5pc2hSZWFzb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbmlzaFJlYXNvbiddKTtcbiAgICBpZiAoZnJvbUZpbmlzaFJlYXNvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbmlzaFJlYXNvbiddLCBmcm9tRmluaXNoUmVhc29uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF2Z0xvZ3Byb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdmdMb2dwcm9icyddKTtcbiAgICBpZiAoZnJvbUF2Z0xvZ3Byb2JzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXZnTG9ncHJvYnMnXSwgZnJvbUF2Z0xvZ3Byb2JzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdyb3VuZGluZ01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ3JvdW5kaW5nTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR3JvdW5kaW5nTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydncm91bmRpbmdNZXRhZGF0YSddLCBmcm9tR3JvdW5kaW5nTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5kZXggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2luZGV4J10pO1xuICAgIGlmIChmcm9tSW5kZXggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmRleCddLCBmcm9tSW5kZXgpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTG9ncHJvYnNSZXN1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdsb2dwcm9ic1Jlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Mb2dwcm9ic1Jlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xvZ3Byb2JzUmVzdWx0J10sIGZyb21Mb2dwcm9ic1Jlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlSYXRpbmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5UmF0aW5ncycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TYWZldHlSYXRpbmdzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21TYWZldHlSYXRpbmdzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzYWZldHlSYXRpbmdzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0TWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd1cmxDb250ZXh0TWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dE1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsQ29udGV4dE1ldGFkYXRhJ10sIGZyb21VcmxDb250ZXh0TWV0YWRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjaXRhdGlvbk1ldGFkYXRhRnJvbU1sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNpdGF0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY2l0YXRpb25Tb3VyY2VzJ10pO1xuICAgIGlmIChmcm9tQ2l0YXRpb25zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21DaXRhdGlvbnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NpdGF0aW9ucyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZW50VG9NbGRldiQ0KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYXJ0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFydHMnXSk7XG4gICAgaWYgKGZyb21QYXJ0cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUGFydHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydFRvTWxkZXYkNChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Sb2xlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyb2xlJ10pO1xuICAgIGlmIChmcm9tUm9sZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JvbGUnXSwgZnJvbVJvbGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVCYXRjaEpvYkNvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnYmF0Y2gnLCAnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzdCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGVzdCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVCYXRjaEpvYkNvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXN0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXN0J10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGVzdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydvdXRwdXRDb25maWcnXSwgYmF0Y2hKb2JEZXN0aW5hdGlvblRvVmVydGV4KHRCYXRjaEpvYkRlc3RpbmF0aW9uKGZyb21EZXN0KSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVCYXRjaEpvYlBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNyYyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3JjJ10pO1xuICAgIGlmIChmcm9tU3JjICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmF0Y2gnLCAnaW5wdXRDb25maWcnXSwgYmF0Y2hKb2JTb3VyY2VUb01sZGV2KGFwaUNsaWVudCwgdEJhdGNoSm9iU291cmNlKGFwaUNsaWVudCwgZnJvbVNyYykpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgY3JlYXRlQmF0Y2hKb2JDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNyYyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3JjJ10pO1xuICAgIGlmIChmcm9tU3JjICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5wdXRDb25maWcnXSwgYmF0Y2hKb2JTb3VyY2VUb1ZlcnRleCh0QmF0Y2hKb2JTb3VyY2UoYXBpQ2xpZW50LCBmcm9tU3JjKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBjcmVhdGVCYXRjaEpvYkNvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlRW1iZWRkaW5nc0JhdGNoSm9iQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydiYXRjaCcsICdkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVFbWJlZGRpbmdzQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcmMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NyYyddKTtcbiAgICBpZiAoZnJvbVNyYyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JhdGNoJywgJ2lucHV0Q29uZmlnJ10sIGVtYmVkZGluZ3NCYXRjaEpvYlNvdXJjZVRvTWxkZXYoYXBpQ2xpZW50LCBmcm9tU3JjKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGNyZWF0ZUVtYmVkZGluZ3NCYXRjaEpvYkNvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVCYXRjaEpvYlBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRCYXRjaEpvYk5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVCYXRjaEpvYlBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0QmF0Y2hKb2JOYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlUmVzb3VyY2VKb2JGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRG9uZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZG9uZSddKTtcbiAgICBpZiAoZnJvbURvbmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkb25lJ10sIGZyb21Eb25lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgZnJvbUVycm9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlUmVzb3VyY2VKb2JGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvbmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RvbmUnXSk7XG4gICAgaWYgKGZyb21Eb25lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9uZSddLCBmcm9tRG9uZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZyb21FcnJvcik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVtYmVkQ29udGVudEJhdGNoVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudHMnXSk7XG4gICAgaWYgKGZyb21Db250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0Q29udGVudHNGb3JFbWJlZChhcGlDbGllbnQsIGZyb21Db250ZW50cyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlcXVlc3RzW10nLCAncmVxdWVzdCcsICdjb250ZW50J10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ19zZWxmJ10sIGVtYmVkQ29udGVudENvbmZpZ1RvTWxkZXYkMShmcm9tQ29uZmlnLCB0b09iamVjdCkpO1xuICAgICAgICBtb3ZlVmFsdWVCeVBhdGgodG9PYmplY3QsIHsgJ3JlcXVlc3RzW10uKic6ICdyZXF1ZXN0c1tdLnJlcXVlc3QuKicgfSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVtYmVkQ29udGVudENvbmZpZ1RvTWxkZXYkMShmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UYXNrVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGFza1R5cGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UYXNrVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydyZXF1ZXN0c1tdJywgJ3Rhc2tUeXBlJ10sIGZyb21UYXNrVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaXRsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGl0bGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UaXRsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydyZXF1ZXN0c1tdJywgJ3RpdGxlJ10sIGZyb21UaXRsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXREaW1lbnNpb25hbGl0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dERpbWVuc2lvbmFsaXR5JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dERpbWVuc2lvbmFsaXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3JlcXVlc3RzW10nLCAnb3V0cHV0RGltZW5zaW9uYWxpdHknXSwgZnJvbU91dHB1dERpbWVuc2lvbmFsaXR5KTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pbWVUeXBlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1dG9UcnVuY2F0ZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXV0b1RydW5jYXRlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVtYmVkZGluZ3NCYXRjaEpvYlNvdXJjZVRvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRmlsZU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVOYW1lJ10pO1xuICAgIGlmIChmcm9tRmlsZU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlX25hbWUnXSwgZnJvbUZpbGVOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlubGluZWRSZXF1ZXN0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2lubGluZWRSZXF1ZXN0cycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21JbmxpbmVkUmVxdWVzdHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXF1ZXN0cyddLCBlbWJlZENvbnRlbnRCYXRjaFRvTWxkZXYoYXBpQ2xpZW50LCBmcm9tSW5saW5lZFJlcXVlc3RzKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZpbGVEYXRhVG9NbGRldiQ0KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaXNwbGF5TmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZVVyaSddKTtcbiAgICBpZiAoZnJvbUZpbGVVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlVXJpJ10sIGZyb21GaWxlVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25DYWxsVG9NbGRldiQ0KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaWQnXSk7XG4gICAgaWYgKGZyb21JZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lkJ10sIGZyb21JZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BcmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhcmdzJ10pO1xuICAgIGlmIChmcm9tQXJncyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FyZ3MnXSwgZnJvbUFyZ3MpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFydGlhbEFyZ3MnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcnRpYWxBcmdzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3dpbGxDb250aW51ZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignd2lsbENvbnRpbnVlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ1RvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZSddKTtcbiAgICBpZiAoZnJvbU1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlJ10sIGZyb21Nb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYWxsb3dlZEZ1bmN0aW9uTmFtZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhbGxvd2VkRnVuY3Rpb25OYW1lcyddLCBmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdHJlYW1GdW5jdGlvbkNhbGxBcmd1bWVudHMnXSkgIT09XG4gICAgICAgIHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0cmVhbUZ1bmN0aW9uQ2FsbEFyZ3VtZW50cyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUNvbnRlbnRDb25maWdUb01sZGV2JDEoYXBpQ2xpZW50LCBmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TeXN0ZW1JbnN0cnVjdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVN5c3RlbUluc3RydWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N5c3RlbUluc3RydWN0aW9uJ10sIGNvbnRlbnRUb01sZGV2JDQodENvbnRlbnQoZnJvbVN5c3RlbUluc3RydWN0aW9uKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGVtcGVyYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10pO1xuICAgIGlmIChmcm9tVGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZW1wZXJhdHVyZSddLCBmcm9tVGVtcGVyYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wUCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wUCddKTtcbiAgICBpZiAoZnJvbVRvcFAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3BQJ10sIGZyb21Ub3BQKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcEsgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcEsnXSk7XG4gICAgaWYgKGZyb21Ub3BLICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9wSyddLCBmcm9tVG9wSyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYW5kaWRhdGVDb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhbmRpZGF0ZUNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNhbmRpZGF0ZUNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FuZGlkYXRlQ291bnQnXSwgZnJvbUNhbmRpZGF0ZUNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heE91dHB1dFRva2VucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21heE91dHB1dFRva2VucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NYXhPdXRwdXRUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXhPdXRwdXRUb2tlbnMnXSwgZnJvbU1heE91dHB1dFRva2Vucyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdG9wU2VxdWVuY2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3RvcFNlcXVlbmNlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TdG9wU2VxdWVuY2VzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RvcFNlcXVlbmNlcyddLCBmcm9tU3RvcFNlcXVlbmNlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUxvZ3Byb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VMb2dwcm9icycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUxvZ3Byb2JzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VMb2dwcm9icyddLCBmcm9tUmVzcG9uc2VMb2dwcm9icyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Mb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbG9ncHJvYnMnXSk7XG4gICAgaWYgKGZyb21Mb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xvZ3Byb2JzJ10sIGZyb21Mb2dwcm9icyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QcmVzZW5jZVBlbmFsdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVzZW5jZVBlbmFsdHknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlc2VuY2VQZW5hbHR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJlc2VuY2VQZW5hbHR5J10sIGZyb21QcmVzZW5jZVBlbmFsdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnJlcXVlbmN5UGVuYWx0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2ZyZXF1ZW5jeVBlbmFsdHknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnJlcXVlbmN5UGVuYWx0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZyZXF1ZW5jeVBlbmFsdHknXSwgZnJvbUZyZXF1ZW5jeVBlbmFsdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKTtcbiAgICBpZiAoZnJvbVNlZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZWVkJ10sIGZyb21TZWVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZU1pbWVUeXBlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZU1pbWVUeXBlJ10sIGZyb21SZXNwb25zZU1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VTY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VTY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZVNjaGVtYSddLCB0U2NoZW1hKGZyb21SZXNwb25zZVNjaGVtYSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSnNvblNjaGVtYSddLCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm91dGluZ0NvbmZpZyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncm91dGluZ0NvbmZpZyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbFNlbGVjdGlvbkNvbmZpZyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbW9kZWxTZWxlY3Rpb25Db25maWcgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNhZmV0eVNldHRpbmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5U2V0dGluZ3MnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2FmZXR5U2V0dGluZ3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVNhZmV0eVNldHRpbmdzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNhZmV0eVNldHRpbmdUb01sZGV2JDEoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2FmZXR5U2V0dGluZ3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29scyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRUb29scyhmcm9tVG9vbHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvb2xUb01sZGV2JDQodFRvb2woaXRlbSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3Rvb2xzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29sQ29uZmlnJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29sQ29uZmlnJ10sIHRvb2xDb25maWdUb01sZGV2JDIoZnJvbVRvb2xDb25maWcpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsYWJlbHMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhY2hlZENvbnRlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYWNoZWRDb250ZW50JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUNhY2hlZENvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnY2FjaGVkQ29udGVudCddLCB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBmcm9tQ2FjaGVkQ29udGVudCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNb2RhbGl0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTW9kYWxpdGllcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTW9kYWxpdGllcyddLCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1lZGlhUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21lZGlhUmVzb2x1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NZWRpYVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZWRpYVJlc29sdXRpb24nXSwgZnJvbU1lZGlhUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcGVlY2hDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddKTtcbiAgICBpZiAoZnJvbVNwZWVjaENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddLCB0U3BlZWNoQ29uZmlnKGZyb21TcGVlY2hDb25maWcpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXVkaW9UaW1lc3RhbXAnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F1ZGlvVGltZXN0YW1wIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaGlua2luZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RoaW5raW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRoaW5raW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhpbmtpbmdDb25maWcnXSwgZnJvbVRoaW5raW5nQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZUNvbmZpZyddKTtcbiAgICBpZiAoZnJvbUltYWdlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2VDb25maWcnXSwgaW1hZ2VDb25maWdUb01sZGV2JDEoZnJvbUltYWdlQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYW5kaWRhdGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjYW5kaWRhdGVzJ10pO1xuICAgIGlmIChmcm9tQ2FuZGlkYXRlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQ2FuZGlkYXRlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYW5kaWRhdGVGcm9tTWxkZXYkMShpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhbmRpZGF0ZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1vZGVsVmVyc2lvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWxWZXJzaW9uJ10pO1xuICAgIGlmIChmcm9tTW9kZWxWZXJzaW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWxWZXJzaW9uJ10sIGZyb21Nb2RlbFZlcnNpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvbXB0RmVlZGJhY2sgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcm9tcHRGZWVkYmFjaycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Qcm9tcHRGZWVkYmFjayAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Byb21wdEZlZWRiYWNrJ10sIGZyb21Qcm9tcHRGZWVkYmFjayk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUlkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZUlkJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VJZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSWQnXSwgZnJvbVJlc3BvbnNlSWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXNhZ2VNZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3VzYWdlTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVXNhZ2VNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VzYWdlTWV0YWRhdGEnXSwgZnJvbVVzYWdlTWV0YWRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZXRCYXRjaEpvYlBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRCYXRjaEpvYk5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZXRCYXRjaEpvYlBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0QmF0Y2hKb2JOYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlTWFwc1RvTWxkZXYkNChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdXRoQ29uZmlnJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdXRoQ29uZmlnIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmFibGVXaWRnZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuYWJsZVdpZGdldCddKTtcbiAgICBpZiAoZnJvbUVuYWJsZVdpZGdldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuYWJsZVdpZGdldCddLCBmcm9tRW5hYmxlV2lkZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlU2VhcmNoVG9NbGRldiQ0KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4Y2x1ZGVEb21haW5zJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleGNsdWRlRG9tYWlucyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydibG9ja2luZ0NvbmZpZGVuY2UnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Jsb2NraW5nQ29uZmlkZW5jZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGltZVJhbmdlRmlsdGVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGltZVJhbmdlRmlsdGVyJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRpbWVSYW5nZUZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RpbWVSYW5nZUZpbHRlciddLCBmcm9tVGltZVJhbmdlRmlsdGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW1hZ2VDb25maWdUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUFzcGVjdFJhdGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhc3BlY3RSYXRpbyddKTtcbiAgICBpZiAoZnJvbUFzcGVjdFJhdGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXNwZWN0UmF0aW8nXSwgZnJvbUFzcGVjdFJhdGlvKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2VTaXplJ10pO1xuICAgIGlmIChmcm9tSW1hZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2VTaXplJ10sIGZyb21JbWFnZVNpemUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRNaW1lVHlwZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3V0cHV0TWltZVR5cGUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5J10pICE9PVxuICAgICAgICB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvdXRwdXRDb21wcmVzc2lvblF1YWxpdHkgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW5saW5lZFJlcXVlc3RUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVxdWVzdCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50cyddKTtcbiAgICBpZiAoZnJvbUNvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRDb250ZW50cyhmcm9tQ29udGVudHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRUb01sZGV2JDQoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXF1ZXN0JywgJ2NvbnRlbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0YWRhdGEnXSk7XG4gICAgaWYgKGZyb21NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21ldGFkYXRhJ10sIGZyb21NZXRhZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlcXVlc3QnLCAnZ2VuZXJhdGlvbkNvbmZpZyddLCBnZW5lcmF0ZUNvbnRlbnRDb25maWdUb01sZGV2JDEoYXBpQ2xpZW50LCBmcm9tQ29uZmlnLCBnZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXF1ZXN0J10sIHt9KSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbmxpbmVkUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZSddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2UnXSwgZ2VuZXJhdGVDb250ZW50UmVzcG9uc2VGcm9tTWxkZXYkMShmcm9tUmVzcG9uc2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgZnJvbUVycm9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdEJhdGNoSm9ic0NvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFnZVNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VTaXplJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VTaXplJ10sIGZyb21QYWdlU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VUb2tlbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVRva2VuJ10sIGZyb21QYWdlVG9rZW4pO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWx0ZXInXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpbHRlciBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0QmF0Y2hKb2JzQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFnZVNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VTaXplJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VTaXplJ10sIGZyb21QYWdlU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VUb2tlbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVRva2VuJ10sIGZyb21QYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsdGVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWx0ZXInXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21GaWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ2ZpbHRlciddLCBmcm9tRmlsdGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdEJhdGNoSm9ic1BhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGxpc3RCYXRjaEpvYnNDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdEJhdGNoSm9ic1BhcmFtZXRlcnNUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBsaXN0QmF0Y2hKb2JzQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0QmF0Y2hKb2JzUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZXh0UGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmV4dFBhZ2VUb2tlbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21OZXh0UGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmV4dFBhZ2VUb2tlbiddLCBmcm9tTmV4dFBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CYXRjaEpvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ29wZXJhdGlvbnMnXSk7XG4gICAgaWYgKGZyb21CYXRjaEpvYnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUJhdGNoSm9icztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBiYXRjaEpvYkZyb21NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JhdGNoSm9icyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0QmF0Y2hKb2JzUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmV4dFBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25leHRQYWdlVG9rZW4nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTmV4dFBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25leHRQYWdlVG9rZW4nXSwgZnJvbU5leHRQYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmF0Y2hKb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYmF0Y2hQcmVkaWN0aW9uSm9icycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21CYXRjaEpvYnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUJhdGNoSm9icztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBiYXRjaEpvYkZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiYXRjaEpvYnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcGFydFRvTWxkZXYkNChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTWVkaWFSZXNvbHV0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWVkaWFSZXNvbHV0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1lZGlhUmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21lZGlhUmVzb2x1dGlvbiddLCBmcm9tTWVkaWFSZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uUmVzdWx0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uUmVzdWx0J10sIGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4ZWN1dGFibGVDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhlY3V0YWJsZUNvZGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhlY3V0YWJsZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGVjdXRhYmxlQ29kZSddLCBmcm9tRXhlY3V0YWJsZUNvZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVEYXRhJ10pO1xuICAgIGlmIChmcm9tRmlsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlRGF0YSddLCBmaWxlRGF0YVRvTWxkZXYkNChmcm9tRmlsZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10sIGZ1bmN0aW9uQ2FsbFRvTWxkZXYkNChmcm9tRnVuY3Rpb25DYWxsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvblJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25SZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvblJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25SZXNwb25zZSddLCBmcm9tRnVuY3Rpb25SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVEYXRhJ10pO1xuICAgIGlmIChmcm9tSW5saW5lRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lubGluZURhdGEnXSwgYmxvYlRvTWxkZXYkNChmcm9tSW5saW5lRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGV4dCddKTtcbiAgICBpZiAoZnJvbVRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZXh0J10sIGZyb21UZXh0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rob3VnaHQnXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodCddLCBmcm9tVGhvdWdodCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0U2lnbmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhvdWdodFNpZ25hdHVyZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0U2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodFNpZ25hdHVyZSddLCBmcm9tVGhvdWdodFNpZ25hdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlb01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmlkZW9NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WaWRlb01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW9NZXRhZGF0YSddLCBmcm9tVmlkZW9NZXRhZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNhZmV0eVNldHRpbmdUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNhdGVnb3J5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjYXRlZ29yeSddKTtcbiAgICBpZiAoZnJvbUNhdGVnb3J5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2F0ZWdvcnknXSwgZnJvbUNhdGVnb3J5KTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0aG9kJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRocmVzaG9sZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGhyZXNob2xkJ10pO1xuICAgIGlmIChmcm9tVGhyZXNob2xkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhyZXNob2xkJ10sIGZyb21UaHJlc2hvbGQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0b29sQ29uZmlnVG9NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkNhbGxpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxsaW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxsaW5nQ29uZmlnJ10sIGZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ1RvTWxkZXYkMihmcm9tRnVuY3Rpb25DYWxsaW5nQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXRyaWV2YWxDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXRyaWV2YWxDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmV0cmlldmFsQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmV0cmlldmFsQ29uZmlnJ10sIGZyb21SZXRyaWV2YWxDb25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0b29sVG9NbGRldiQ0KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25EZWNsYXJhdGlvbnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmV0cmlldmFsJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXRyaWV2YWwgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2hSZXRyaWV2YWwnXSwgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db21wdXRlclVzZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSk7XG4gICAgaWYgKGZyb21Db21wdXRlclVzZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10sIGZyb21Db21wdXRlclVzZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlU2VhcmNoJ10pO1xuICAgIGlmIChmcm9tRmlsZVNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVTZWFyY2gnXSwgZnJvbUZpbGVTZWFyY2gpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb24nXSwgZnJvbUNvZGVFeGVjdXRpb24pO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbnRlcnByaXNlV2ViU2VhcmNoJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbnRlcnByaXNlV2ViU2VhcmNoIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVNYXBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVNYXBzJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlTWFwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSwgZ29vZ2xlTWFwc1RvTWxkZXYkNChmcm9tR29vZ2xlTWFwcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2gnXSwgZ29vZ2xlU2VhcmNoVG9NbGRldiQ0KGZyb21Hb29nbGVTZWFyY2gpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVybENvbnRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VybENvbnRleHQnXSk7XG4gICAgaWYgKGZyb21VcmxDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsQ29udGV4dCddLCBmcm9tVXJsQ29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xudmFyIFBhZ2VkSXRlbTtcbihmdW5jdGlvbiAoUGFnZWRJdGVtKSB7XG4gICAgUGFnZWRJdGVtW1wiUEFHRURfSVRFTV9CQVRDSF9KT0JTXCJdID0gXCJiYXRjaEpvYnNcIjtcbiAgICBQYWdlZEl0ZW1bXCJQQUdFRF9JVEVNX01PREVMU1wiXSA9IFwibW9kZWxzXCI7XG4gICAgUGFnZWRJdGVtW1wiUEFHRURfSVRFTV9UVU5JTkdfSk9CU1wiXSA9IFwidHVuaW5nSm9ic1wiO1xuICAgIFBhZ2VkSXRlbVtcIlBBR0VEX0lURU1fRklMRVNcIl0gPSBcImZpbGVzXCI7XG4gICAgUGFnZWRJdGVtW1wiUEFHRURfSVRFTV9DQUNIRURfQ09OVEVOVFNcIl0gPSBcImNhY2hlZENvbnRlbnRzXCI7XG4gICAgUGFnZWRJdGVtW1wiUEFHRURfSVRFTV9GSUxFX1NFQVJDSF9TVE9SRVNcIl0gPSBcImZpbGVTZWFyY2hTdG9yZXNcIjtcbiAgICBQYWdlZEl0ZW1bXCJQQUdFRF9JVEVNX0RPQ1VNRU5UU1wiXSA9IFwiZG9jdW1lbnRzXCI7XG59KShQYWdlZEl0ZW0gfHwgKFBhZ2VkSXRlbSA9IHt9KSk7XG4vKipcbiAqIFBhZ2VyIGNsYXNzIGZvciBpdGVyYXRpbmcgdGhyb3VnaCBwYWdpbmF0ZWQgcmVzdWx0cy5cbiAqL1xuY2xhc3MgUGFnZXIge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHJlcXVlc3QsIHJlc3BvbnNlLCBwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5wYWdlSW50ZXJuYWwgPSBbXTtcbiAgICAgICAgdGhpcy5wYXJhbXNJbnRlcm5hbCA9IHt9O1xuICAgICAgICB0aGlzLnJlcXVlc3RJbnRlcm5hbCA9IHJlcXVlc3Q7XG4gICAgICAgIHRoaXMuaW5pdChuYW1lLCByZXNwb25zZSwgcGFyYW1zKTtcbiAgICB9XG4gICAgaW5pdChuYW1lLCByZXNwb25zZSwgcGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMubmFtZUludGVybmFsID0gbmFtZTtcbiAgICAgICAgdGhpcy5wYWdlSW50ZXJuYWwgPSByZXNwb25zZVt0aGlzLm5hbWVJbnRlcm5hbF0gfHwgW107XG4gICAgICAgIHRoaXMuc2RrSHR0cFJlc3BvbnNlSW50ZXJuYWwgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlO1xuICAgICAgICB0aGlzLmlkeEludGVybmFsID0gMDtcbiAgICAgICAgbGV0IHJlcXVlc3RQYXJhbXMgPSB7IGNvbmZpZzoge30gfTtcbiAgICAgICAgaWYgKCFwYXJhbXMgfHwgT2JqZWN0LmtleXMocGFyYW1zKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJlcXVlc3RQYXJhbXMgPSB7IGNvbmZpZzoge30gfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgcGFyYW1zID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmVxdWVzdFBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXF1ZXN0UGFyYW1zID0gcGFyYW1zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXF1ZXN0UGFyYW1zWydjb25maWcnXSkge1xuICAgICAgICAgICAgcmVxdWVzdFBhcmFtc1snY29uZmlnJ11bJ3BhZ2VUb2tlbiddID0gcmVzcG9uc2VbJ25leHRQYWdlVG9rZW4nXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcmFtc0ludGVybmFsID0gcmVxdWVzdFBhcmFtcztcbiAgICAgICAgdGhpcy5wYWdlSW50ZXJuYWxTaXplID1cbiAgICAgICAgICAgIChfYiA9IChfYSA9IHJlcXVlc3RQYXJhbXNbJ2NvbmZpZyddKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbJ3BhZ2VTaXplJ10pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRoaXMucGFnZUludGVybmFsLmxlbmd0aDtcbiAgICB9XG4gICAgaW5pdE5leHRQYWdlKHJlc3BvbnNlKSB7XG4gICAgICAgIHRoaXMuaW5pdCh0aGlzLm5hbWVJbnRlcm5hbCwgcmVzcG9uc2UsIHRoaXMucGFyYW1zSW50ZXJuYWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHBhZ2UsIHdoaWNoIGlzIGEgbGlzdCBvZiBpdGVtcy5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhlIGZpcnN0IHBhZ2UgaXMgcmV0cmlldmVkIHdoZW4gdGhlIHBhZ2VyIGlzIGNyZWF0ZWQuIFRoZSByZXR1cm5lZCBsaXN0IG9mXG4gICAgICogaXRlbXMgY291bGQgYmUgYSBzdWJzZXQgb2YgdGhlIGVudGlyZSBsaXN0LlxuICAgICAqL1xuICAgIGdldCBwYWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYWdlSW50ZXJuYWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHR5cGUgb2YgcGFnZWQgaXRlbSAoZm9yIGV4YW1wbGUsIGBgYmF0Y2hfam9ic2BgKS5cbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZUludGVybmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIHBhZ2UgZmV0Y2hlZCBlYWNoIHRpbWUgYnkgdGhpcyBwYWdlci5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhlIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgcGFnZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHBhZ2UgbGVuZ3RoLlxuICAgICAqL1xuICAgIGdldCBwYWdlU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFnZUludGVybmFsU2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaGVhZGVycyBvZiB0aGUgQVBJIHJlc3BvbnNlLlxuICAgICAqL1xuICAgIGdldCBzZGtIdHRwUmVzcG9uc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNka0h0dHBSZXNwb25zZUludGVybmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwYXJhbWV0ZXJzIHdoZW4gbWFraW5nIHRoZSBBUEkgcmVxdWVzdCBmb3IgdGhlIG5leHQgcGFnZS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogUGFyYW1ldGVycyBjb250YWluIGEgc2V0IG9mIG9wdGlvbmFsIGNvbmZpZ3MgdGhhdCBjYW4gYmVcbiAgICAgKiB1c2VkIHRvIGN1c3RvbWl6ZSB0aGUgQVBJIHJlcXVlc3QuIEZvciBleGFtcGxlLCB0aGUgYHBhZ2VUb2tlbmAgcGFyYW1ldGVyXG4gICAgICogY29udGFpbnMgdGhlIHRva2VuIHRvIHJlcXVlc3QgdGhlIG5leHQgcGFnZS5cbiAgICAgKi9cbiAgICBnZXQgcGFyYW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXNJbnRlcm5hbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdG90YWwgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBjdXJyZW50IHBhZ2UuXG4gICAgICovXG4gICAgZ2V0IHBhZ2VMZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhZ2VJbnRlcm5hbC5sZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGl0ZW0gYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgICAqL1xuICAgIGdldEl0ZW0oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFnZUludGVybmFsW2luZGV4XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhc3luYyBpdGVyYXRvciB0aGF0IHN1cHBvcnQgaXRlcmF0aW5nIHRocm91Z2ggYWxsIGl0ZW1zXG4gICAgICogcmV0cmlldmVkIGZyb20gdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhlIGl0ZXJhdG9yIHdpbGwgYXV0b21hdGljYWxseSBmZXRjaCB0aGUgbmV4dCBwYWdlIGlmIHRoZXJlIGFyZSBtb3JlIGl0ZW1zXG4gICAgICogdG8gZmV0Y2ggZnJvbSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcGFnZXIgPSBhd2FpdCBhaS5maWxlcy5saXN0KHtjb25maWc6IHtwYWdlU2l6ZTogMTB9fSk7XG4gICAgICogZm9yIGF3YWl0IChjb25zdCBmaWxlIG9mIHBhZ2VyKSB7XG4gICAgICogICBjb25zb2xlLmxvZyhmaWxlLm5hbWUpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV4dDogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkeEludGVybmFsID49IHRoaXMucGFnZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNOZXh0UGFnZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm5leHRQYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuZ2V0SXRlbSh0aGlzLmlkeEludGVybmFsKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkeEludGVybmFsICs9IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGl0ZW0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmV0dXJuOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyB0aGUgbmV4dCBwYWdlIG9mIGl0ZW1zLiBUaGlzIG1ha2VzIGEgbmV3IEFQSSByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIGFyZSBubyBtb3JlIHBhZ2VzIHRvIGZldGNoLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcGFnZXIgPSBhd2FpdCBhaS5maWxlcy5saXN0KHtjb25maWc6IHtwYWdlU2l6ZTogMTB9fSk7XG4gICAgICogbGV0IHBhZ2UgPSBwYWdlci5wYWdlO1xuICAgICAqIHdoaWxlICh0cnVlKSB7XG4gICAgICogICBmb3IgKGNvbnN0IGZpbGUgb2YgcGFnZSkge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhmaWxlLm5hbWUpO1xuICAgICAqICAgfVxuICAgICAqICAgaWYgKCFwYWdlci5oYXNOZXh0UGFnZSgpKSB7XG4gICAgICogICAgIGJyZWFrO1xuICAgICAqICAgfVxuICAgICAqICAgcGFnZSA9IGF3YWl0IHBhZ2VyLm5leHRQYWdlKCk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIG5leHRQYWdlKCkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzTmV4dFBhZ2UoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBtb3JlIHBhZ2VzIHRvIGZldGNoLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5yZXF1ZXN0SW50ZXJuYWwodGhpcy5wYXJhbXMpO1xuICAgICAgICB0aGlzLmluaXROZXh0UGFnZShyZXNwb25zZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhZ2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGVyZSBhcmUgbW9yZSBwYWdlcyB0byBmZXRjaCBmcm9tIHRoZSBBUEkuXG4gICAgICovXG4gICAgaGFzTmV4dFBhZ2UoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCgoX2EgPSB0aGlzLnBhcmFtc1snY29uZmlnJ10pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVsncGFnZVRva2VuJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNsYXNzIEJhdGNoZXMgZXh0ZW5kcyBCYXNlTW9kdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcGlDbGllbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0cyBiYXRjaCBqb2JzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBsaXN0IHJlcXVlc3QuXG4gICAgICAgICAqIEByZXR1cm4gLSBBIHBhZ2VyIG9mIGJhdGNoIGpvYnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IGJhdGNoSm9icyA9IGF3YWl0IGFpLmJhdGNoZXMubGlzdCh7Y29uZmlnOiB7J3BhZ2VTaXplJzogMn19KTtcbiAgICAgICAgICogZm9yIGF3YWl0IChjb25zdCBiYXRjaEpvYiBvZiBiYXRjaEpvYnMpIHtcbiAgICAgICAgICogICBjb25zb2xlLmxvZyhiYXRjaEpvYik7XG4gICAgICAgICAqIH1cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxpc3QgPSBhc3luYyAocGFyYW1zID0ge30pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGFnZXIoUGFnZWRJdGVtLlBBR0VEX0lURU1fQkFUQ0hfSk9CUywgKHgpID0+IHRoaXMubGlzdEludGVybmFsKHgpLCBhd2FpdCB0aGlzLmxpc3RJbnRlcm5hbChwYXJhbXMpLCBwYXJhbXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGJhdGNoIGpvYi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBjcmVhdGUgYmF0Y2ggam9iIHJlcXVlc3QuXG4gICAgICAgICAqIEByZXR1cm4gVGhlIGNyZWF0ZWQgYmF0Y2ggam9iLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLmJhdGNoZXMuY3JlYXRlKHtcbiAgICAgICAgICogICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnLFxuICAgICAgICAgKiAgIHNyYzoge2djc1VyaTogJ2dzOi8vYnVja2V0L3BhdGgvdG8vZmlsZS5qc29ubCcsIGZvcm1hdDogJ2pzb25sJ30sXG4gICAgICAgICAqICAgY29uZmlnOiB7XG4gICAgICAgICAqICAgICBkZXN0OiB7Z2NzVXJpOiAnZ3M6Ly9idWNrZXQvcGF0aC9vdXRwdXQvZGlyZWN0b3J5JywgZm9ybWF0OiAnanNvbmwnfSxcbiAgICAgICAgICogICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jcmVhdGUgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9ybWF0IGRlc3RpbmF0aW9uIGlmIG5vdCBwcm92aWRlZFxuICAgICAgICAgICAgICAgIC8vIENhc3QgcGFyYW1zLnNyYyBhcyBWZXJ0ZXggQUkgcGF0aCBkb2VzIG5vdCBoYW5kbGUgSW5saW5lZFJlcXVlc3RbXVxuICAgICAgICAgICAgICAgIHBhcmFtcy5jb25maWcgPSB0aGlzLmZvcm1hdERlc3RpbmF0aW9uKHBhcmFtcy5zcmMsIHBhcmFtcy5jb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlSW50ZXJuYWwocGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqICoqRXhwZXJpbWVudGFsKiogQ3JlYXRlcyBhbiBlbWJlZGRpbmcgYmF0Y2ggam9iLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGNyZWF0ZSBlbWJlZGRpbmcgYmF0Y2ggam9iIHJlcXVlc3QuXG4gICAgICAgICAqIEByZXR1cm4gVGhlIGNyZWF0ZWQgYmF0Y2ggam9iLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLmJhdGNoZXMuY3JlYXRlRW1iZWRkaW5ncyh7XG4gICAgICAgICAqICAgbW9kZWw6ICd0ZXh0LWVtYmVkZGluZy0wMDQnLFxuICAgICAgICAgKiAgIHNyYzoge2ZpbGVOYW1lOiAnZmlsZXMvbXlfZW1iZWRkaW5nX2lucHV0J30sXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jcmVhdGVFbWJlZGRpbmdzID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdiYXRjaGVzLmNyZWF0ZUVtYmVkZGluZ3MoKSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2Ugd2l0aG91dCBub3RpY2UuJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWZXJ0ZXggQUkgZG9lcyBub3Qgc3VwcG9ydCBiYXRjaGVzLmNyZWF0ZUVtYmVkZGluZ3MuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFbWJlZGRpbmdzSW50ZXJuYWwocGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGhhbmRsZSBpbmxpbmVkIGdlbmVyYXRlIGNvbnRlbnQgcmVxdWVzdHNcbiAgICBjcmVhdGVJbmxpbmVkR2VuZXJhdGVDb250ZW50UmVxdWVzdChwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgYm9keSA9IGNyZWF0ZUJhdGNoSm9iUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIC8vIFVzZSBpbnN0YW5jZSBhcGlDbGllbnRcbiAgICAgICAgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgdXJsUGFyYW1zID0gYm9keVsnX3VybCddO1xuICAgICAgICBjb25zdCBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OmJhdGNoR2VuZXJhdGVDb250ZW50JywgdXJsUGFyYW1zKTtcbiAgICAgICAgY29uc3QgYmF0Y2ggPSBib2R5WydiYXRjaCddO1xuICAgICAgICBjb25zdCBpbnB1dENvbmZpZyA9IGJhdGNoWydpbnB1dENvbmZpZyddO1xuICAgICAgICBjb25zdCByZXF1ZXN0c1dyYXBwZXIgPSBpbnB1dENvbmZpZ1sncmVxdWVzdHMnXTtcbiAgICAgICAgY29uc3QgcmVxdWVzdHMgPSByZXF1ZXN0c1dyYXBwZXJbJ3JlcXVlc3RzJ107XG4gICAgICAgIGNvbnN0IG5ld1JlcXVlc3RzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcmVxdWVzdCBvZiByZXF1ZXN0cykge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdERpY3QgPSBPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0KTsgLy8gQ2xvbmVcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0RGljdFsnc3lzdGVtSW5zdHJ1Y3Rpb24nXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN5c3RlbUluc3RydWN0aW9uVmFsdWUgPSByZXF1ZXN0RGljdFsnc3lzdGVtSW5zdHJ1Y3Rpb24nXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgcmVxdWVzdERpY3RbJ3N5c3RlbUluc3RydWN0aW9uJ107XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdENvbnRlbnQgPSByZXF1ZXN0RGljdFsncmVxdWVzdCddO1xuICAgICAgICAgICAgICAgIHJlcXVlc3RDb250ZW50WydzeXN0ZW1JbnN0cnVjdGlvbiddID0gc3lzdGVtSW5zdHJ1Y3Rpb25WYWx1ZTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0RGljdFsncmVxdWVzdCddID0gcmVxdWVzdENvbnRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdSZXF1ZXN0cy5wdXNoKHJlcXVlc3REaWN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0c1dyYXBwZXJbJ3JlcXVlc3RzJ10gPSBuZXdSZXF1ZXN0cztcbiAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgIHJldHVybiB7IHBhdGgsIGJvZHkgfTtcbiAgICB9XG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgZmlyc3QgR0NTIFVSSVxuICAgIGdldEdjc1VyaShzcmMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gc3JjLnN0YXJ0c1dpdGgoJ2dzOi8vJykgPyBzcmMgOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNyYykgJiYgc3JjLmdjc1VyaSAmJiBzcmMuZ2NzVXJpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBzcmMuZ2NzVXJpWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIEJpZ1F1ZXJ5IFVSSVxuICAgIGdldEJpZ3F1ZXJ5VXJpKHNyYykge1xuICAgICAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBzcmMuc3RhcnRzV2l0aCgnYnE6Ly8nKSA/IHNyYyA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3JjKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNyYy5iaWdxdWVyeVVyaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBGdW5jdGlvbiB0byBmb3JtYXQgdGhlIGRlc3RpbmF0aW9uIGNvbmZpZ3VyYXRpb24gZm9yIFZlcnRleCBBSVxuICAgIGZvcm1hdERlc3RpbmF0aW9uKHNyYywgY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IG5ld0NvbmZpZyA9IGNvbmZpZyA/IE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZykgOiB7fTtcbiAgICAgICAgY29uc3QgdGltZXN0YW1wU3RyID0gRGF0ZS5ub3coKS50b1N0cmluZygpO1xuICAgICAgICBpZiAoIW5ld0NvbmZpZy5kaXNwbGF5TmFtZSkge1xuICAgICAgICAgICAgbmV3Q29uZmlnLmRpc3BsYXlOYW1lID0gYGdlbmFpQmF0Y2hKb2JfJHt0aW1lc3RhbXBTdHJ9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3Q29uZmlnLmRlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZ2NzVXJpID0gdGhpcy5nZXRHY3NVcmkoc3JjKTtcbiAgICAgICAgICAgIGNvbnN0IGJpZ3F1ZXJ5VXJpID0gdGhpcy5nZXRCaWdxdWVyeVVyaShzcmMpO1xuICAgICAgICAgICAgaWYgKGdjc1VyaSkge1xuICAgICAgICAgICAgICAgIGlmIChnY3NVcmkuZW5kc1dpdGgoJy5qc29ubCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciAuanNvbmwgZmlsZXMsIHJlbW92ZSBzdWZmaXggYW5kIGFkZCAvZGVzdFxuICAgICAgICAgICAgICAgICAgICBuZXdDb25maWcuZGVzdCA9IGAke2djc1VyaS5zbGljZSgwLCAtNil9L2Rlc3RgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgZm9yIG90aGVyIEdDUyBVUklzXG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbmZpZy5kZXN0ID0gYCR7Z2NzVXJpfV9kZXN0XyR7dGltZXN0YW1wU3RyfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmlncXVlcnlVcmkpIHtcbiAgICAgICAgICAgICAgICBuZXdDb25maWcuZGVzdCA9IGAke2JpZ3F1ZXJ5VXJpfV9kZXN0XyR7dGltZXN0YW1wU3RyfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHNvdXJjZSBmb3IgVmVydGV4IEFJOiBObyBHQ1Mgb3IgQmlnUXVlcnkgVVJJIGZvdW5kLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdDb25maWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVybmFsIG1ldGhvZCB0byBjcmVhdGUgYmF0Y2ggam9iLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBjcmVhdGUgYmF0Y2ggam9iIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgY3JlYXRlZCBiYXRjaCBqb2IuXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdiYXRjaFByZWRpY3Rpb25Kb2JzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBiYXRjaEpvYkZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06YmF0Y2hHZW5lcmF0ZUNvbnRlbnQnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGJhdGNoSm9iRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVybmFsIG1ldGhvZCB0byBjcmVhdGUgYmF0Y2ggam9iLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBjcmVhdGUgYmF0Y2ggam9iIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgY3JlYXRlZCBiYXRjaCBqb2IuXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVFbWJlZGRpbmdzSW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNyZWF0ZUVtYmVkZGluZ3NCYXRjaEpvYlBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTphc3luY0JhdGNoRW1iZWRDb250ZW50JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBiYXRjaEpvYkZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGJhdGNoIGpvYiBjb25maWd1cmF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGdldCByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIGJhdGNoIGpvYi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBhd2FpdCBhaS5iYXRjaGVzLmdldCh7bmFtZTogJy4uLid9KTsgLy8gVGhlIHNlcnZlci1nZW5lcmF0ZWQgcmVzb3VyY2UgbmFtZS5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBnZXQocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldEJhdGNoSm9iUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnYmF0Y2hQcmVkaWN0aW9uSm9icy97bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gYmF0Y2hKb2JGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldEJhdGNoSm9iUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdiYXRjaGVzL3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBiYXRjaEpvYkZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYW5jZWxzIGEgYmF0Y2ggam9iLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgY2FuY2VsIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgZW1wdHkgcmVzcG9uc2UgcmV0dXJuZWQgYnkgdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBhd2FpdCBhaS5iYXRjaGVzLmNhbmNlbCh7bmFtZTogJy4uLid9KTsgLy8gVGhlIHNlcnZlci1nZW5lcmF0ZWQgcmVzb3VyY2UgbmFtZS5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBjYW5jZWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjYW5jZWxCYXRjaEpvYlBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2JhdGNoUHJlZGljdGlvbkpvYnMve25hbWV9OmNhbmNlbCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBpQ2xpZW50LnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjYW5jZWxCYXRjaEpvYlBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnYmF0Y2hlcy97bmFtZX06Y2FuY2VsJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hcGlDbGllbnQucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGxpc3RJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbGlzdEJhdGNoSm9ic1BhcmFtZXRlcnNUb1ZlcnRleChwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnYmF0Y2hQcmVkaWN0aW9uSm9icycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gbGlzdEJhdGNoSm9ic1Jlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IExpc3RCYXRjaEpvYnNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbGlzdEJhdGNoSm9ic1BhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdiYXRjaGVzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0QmF0Y2hKb2JzUmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBMaXN0QmF0Y2hKb2JzUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYSBiYXRjaCBqb2IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBkZWxldGUgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSBlbXB0eSByZXNwb25zZSByZXR1cm5lZCBieSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGF3YWl0IGFpLmJhdGNoZXMuZGVsZXRlKHtuYW1lOiAnLi4uJ30pOyAvLyBUaGUgc2VydmVyLWdlbmVyYXRlZCByZXNvdXJjZSBuYW1lLlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZGVsZXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdiYXRjaFByZWRpY3Rpb25Kb2JzL3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZGVsZXRlUmVzb3VyY2VKb2JGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGRlbGV0ZUJhdGNoSm9iUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdiYXRjaGVzL3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZGVsZXRlUmVzb3VyY2VKb2JGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmZ1bmN0aW9uIGJsb2JUb01sZGV2JDMoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RhdGEnXSk7XG4gICAgaWYgKGZyb21EYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGF0YSddLCBmcm9tRGF0YSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaXNwbGF5TmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZW50VG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYXJ0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFydHMnXSk7XG4gICAgaWYgKGZyb21QYXJ0cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUGFydHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydFRvTWxkZXYkMyhpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Sb2xlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyb2xlJ10pO1xuICAgIGlmIChmcm9tUm9sZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JvbGUnXSwgZnJvbVJvbGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVDYWNoZWRDb250ZW50Q29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UdGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R0bCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVR0bCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0dGwnXSwgZnJvbVR0bCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeHBpcmVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleHBpcmVUaW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRXhwaXJlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydleHBpcmVUaW1lJ10sIGZyb21FeHBpcmVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Db250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0Q29udGVudHMoZnJvbUNvbnRlbnRzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50VG9NbGRldiQzKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2NvbnRlbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TeXN0ZW1JbnN0cnVjdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVN5c3RlbUluc3RydWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N5c3RlbUluc3RydWN0aW9uJ10sIGNvbnRlbnRUb01sZGV2JDModENvbnRlbnQoZnJvbVN5c3RlbUluc3RydWN0aW9uKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVRvb2xzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvb2xUb01sZGV2JDMoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndG9vbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xDb25maWcnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29sQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3Rvb2xDb25maWcnXSwgdG9vbENvbmZpZ1RvTWxkZXYkMShmcm9tVG9vbENvbmZpZykpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydrbXNLZXlOYW1lJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdrbXNLZXlOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlZENvbnRlbnRDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UdGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R0bCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVR0bCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0dGwnXSwgZnJvbVR0bCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeHBpcmVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleHBpcmVUaW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRXhwaXJlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydleHBpcmVUaW1lJ10sIGZyb21FeHBpcmVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Db250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0Q29udGVudHMoZnJvbUNvbnRlbnRzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2NvbnRlbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TeXN0ZW1JbnN0cnVjdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVN5c3RlbUluc3RydWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N5c3RlbUluc3RydWN0aW9uJ10sIHRDb250ZW50KGZyb21TeXN0ZW1JbnN0cnVjdGlvbikpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVRvb2xzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvb2xUb1ZlcnRleCQyKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3Rvb2xzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29sQ29uZmlnJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29sQ29uZmlnJ10sIGZyb21Ub29sQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUttc0tleU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ttc0tleU5hbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21LbXNLZXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2VuY3J5cHRpb25fc3BlYycsICdrbXNLZXlOYW1lJ10sIGZyb21LbXNLZXlOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWwnXSwgdENhY2hlc01vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGNyZWF0ZUNhY2hlZENvbnRlbnRDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsJ10sIHRDYWNoZXNNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBjcmVhdGVDYWNoZWRDb250ZW50Q29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdENhY2hlZENvbnRlbnROYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVDYWNoZWRDb250ZW50UmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUNhY2hlZENvbnRlbnRSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZpbGVEYXRhVG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaXNwbGF5TmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZVVyaSddKTtcbiAgICBpZiAoZnJvbUZpbGVVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlVXJpJ10sIGZyb21GaWxlVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25DYWxsVG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaWQnXSk7XG4gICAgaWYgKGZyb21JZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lkJ10sIGZyb21JZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BcmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhcmdzJ10pO1xuICAgIGlmIChmcm9tQXJncyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FyZ3MnXSwgZnJvbUFyZ3MpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFydGlhbEFyZ3MnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcnRpYWxBcmdzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3dpbGxDb250aW51ZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignd2lsbENvbnRpbnVlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ1RvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZSddKTtcbiAgICBpZiAoZnJvbU1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlJ10sIGZyb21Nb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYWxsb3dlZEZ1bmN0aW9uTmFtZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhbGxvd2VkRnVuY3Rpb25OYW1lcyddLCBmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdHJlYW1GdW5jdGlvbkNhbGxBcmd1bWVudHMnXSkgIT09XG4gICAgICAgIHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0cmVhbUZ1bmN0aW9uQ2FsbEFyZ3VtZW50cyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkRlY2xhcmF0aW9uVG9WZXJ0ZXgkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiZWhhdmlvciddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmVoYXZpb3IgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmFtZXRlcnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcmFtZXRlcnMnXSk7XG4gICAgaWYgKGZyb21QYXJhbWV0ZXJzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFyYW1ldGVycyddLCBmcm9tUGFyYW1ldGVycyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BhcmFtZXRlcnNKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFyYW1ldGVyc0pzb25TY2hlbWEnXSwgZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZSddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2UnXSwgZnJvbVJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUpzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUpzb25TY2hlbWEnXSwgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdldENhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZXRDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRDYWNoZWRDb250ZW50TmFtZShhcGlDbGllbnQsIGZyb21OYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZU1hcHNUb01sZGV2JDMoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXV0aENvbmZpZyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXV0aENvbmZpZyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5hYmxlV2lkZ2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmFibGVXaWRnZXQnXSk7XG4gICAgaWYgKGZyb21FbmFibGVXaWRnZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmFibGVXaWRnZXQnXSwgZnJvbUVuYWJsZVdpZGdldCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFRvTWxkZXYkMyhmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleGNsdWRlRG9tYWlucyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhjbHVkZURvbWFpbnMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmxvY2tpbmdDb25maWRlbmNlJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdibG9ja2luZ0NvbmZpZGVuY2UgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRpbWVSYW5nZUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RpbWVSYW5nZUZpbHRlcicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaW1lUmFuZ2VGaWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aW1lUmFuZ2VGaWx0ZXInXSwgZnJvbVRpbWVSYW5nZUZpbHRlcik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RDYWNoZWRDb250ZW50c0NvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFnZVNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VTaXplJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VTaXplJ10sIGZyb21QYWdlU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VUb2tlbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVRva2VuJ10sIGZyb21QYWdlVG9rZW4pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0Q2FjaGVkQ29udGVudHNDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVNpemUnXSwgZnJvbVBhZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVRva2VuJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlVG9rZW4nXSwgZnJvbVBhZ2VUb2tlbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RDYWNoZWRDb250ZW50c1BhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGxpc3RDYWNoZWRDb250ZW50c0NvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0Q2FjaGVkQ29udGVudHNQYXJhbWV0ZXJzVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgbGlzdENhY2hlZENvbnRlbnRzQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5leHRQYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXh0UGFnZVRva2VuJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU5leHRQYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXh0UGFnZVRva2VuJ10sIGZyb21OZXh0UGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhY2hlZENvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FjaGVkQ29udGVudHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2FjaGVkQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUNhY2hlZENvbnRlbnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYWNoZWRDb250ZW50cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZXh0UGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmV4dFBhZ2VUb2tlbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21OZXh0UGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmV4dFBhZ2VUb2tlbiddLCBmcm9tTmV4dFBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYWNoZWRDb250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhY2hlZENvbnRlbnRzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNhY2hlZENvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21DYWNoZWRDb250ZW50cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FjaGVkQ29udGVudHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcGFydFRvTWxkZXYkMyhmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTWVkaWFSZXNvbHV0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWVkaWFSZXNvbHV0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1lZGlhUmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21lZGlhUmVzb2x1dGlvbiddLCBmcm9tTWVkaWFSZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uUmVzdWx0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uUmVzdWx0J10sIGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4ZWN1dGFibGVDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhlY3V0YWJsZUNvZGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhlY3V0YWJsZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGVjdXRhYmxlQ29kZSddLCBmcm9tRXhlY3V0YWJsZUNvZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVEYXRhJ10pO1xuICAgIGlmIChmcm9tRmlsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlRGF0YSddLCBmaWxlRGF0YVRvTWxkZXYkMyhmcm9tRmlsZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10sIGZ1bmN0aW9uQ2FsbFRvTWxkZXYkMyhmcm9tRnVuY3Rpb25DYWxsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvblJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25SZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvblJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25SZXNwb25zZSddLCBmcm9tRnVuY3Rpb25SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVEYXRhJ10pO1xuICAgIGlmIChmcm9tSW5saW5lRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lubGluZURhdGEnXSwgYmxvYlRvTWxkZXYkMyhmcm9tSW5saW5lRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGV4dCddKTtcbiAgICBpZiAoZnJvbVRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZXh0J10sIGZyb21UZXh0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rob3VnaHQnXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodCddLCBmcm9tVGhvdWdodCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0U2lnbmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhvdWdodFNpZ25hdHVyZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0U2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodFNpZ25hdHVyZSddLCBmcm9tVGhvdWdodFNpZ25hdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlb01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmlkZW9NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WaWRlb01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW9NZXRhZGF0YSddLCBmcm9tVmlkZW9NZXRhZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xDb25maWdUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uQ2FsbGluZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGxpbmdDb25maWcnXSwgZnVuY3Rpb25DYWxsaW5nQ29uZmlnVG9NbGRldiQxKGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJldHJpZXZhbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JldHJpZXZhbENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXRyaWV2YWxDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXRyaWV2YWxDb25maWcnXSwgZnJvbVJldHJpZXZhbENvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xUb01sZGV2JDMoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25EZWNsYXJhdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkRlY2xhcmF0aW9ucyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXRyaWV2YWwnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JldHJpZXZhbCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCddLCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbXB1dGVyVXNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb21wdXRlclVzZSddKTtcbiAgICBpZiAoZnJvbUNvbXB1dGVyVXNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSwgZnJvbUNvbXB1dGVyVXNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21GaWxlU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZVNlYXJjaCddLCBmcm9tRmlsZVNlYXJjaCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvbiddLCBmcm9tQ29kZUV4ZWN1dGlvbik7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VudGVycHJpc2VXZWJTZWFyY2gnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VudGVycHJpc2VXZWJTZWFyY2ggcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZU1hcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVNYXBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlTWFwcyddLCBnb29nbGVNYXBzVG9NbGRldiQzKGZyb21Hb29nbGVNYXBzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddLCBnb29nbGVTZWFyY2hUb01sZGV2JDMoZnJvbUdvb2dsZVNlYXJjaCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJsQ29udGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXJsQ29udGV4dCddKTtcbiAgICBpZiAoZnJvbVVybENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmxDb250ZXh0J10sIGZyb21VcmxDb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbFRvVmVydGV4JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25EZWNsYXJhdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uRGVjbGFyYXRpb25Ub1ZlcnRleCQyKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25EZWNsYXJhdGlvbnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmV0cmlldmFsJ10pO1xuICAgIGlmIChmcm9tUmV0cmlldmFsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmV0cmlldmFsJ10sIGZyb21SZXRyaWV2YWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCddLCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbXB1dGVyVXNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb21wdXRlclVzZSddKTtcbiAgICBpZiAoZnJvbUNvbXB1dGVyVXNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSwgZnJvbUNvbXB1dGVyVXNlKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZVNlYXJjaCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmlsZVNlYXJjaCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvbiddLCBmcm9tQ29kZUV4ZWN1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbnRlcnByaXNlV2ViU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW50ZXJwcmlzZVdlYlNlYXJjaCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbnRlcnByaXNlV2ViU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW50ZXJwcmlzZVdlYlNlYXJjaCddLCBmcm9tRW50ZXJwcmlzZVdlYlNlYXJjaCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVNYXBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVNYXBzJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlTWFwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSwgZnJvbUdvb2dsZU1hcHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2gnXSwgZnJvbUdvb2dsZVNlYXJjaCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmxDb250ZXh0J10pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHQnXSwgZnJvbVVybENvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cGRhdGVDYWNoZWRDb250ZW50Q29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UdGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R0bCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVR0bCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0dGwnXSwgZnJvbVR0bCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeHBpcmVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleHBpcmVUaW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRXhwaXJlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydleHBpcmVUaW1lJ10sIGZyb21FeHBpcmVUaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBkYXRlQ2FjaGVkQ29udGVudENvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVR0bCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHRsJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVHRsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3R0bCddLCBmcm9tVHRsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4cGlyZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FeHBpcmVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSwgZnJvbUV4cGlyZVRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cGRhdGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdENhY2hlZENvbnRlbnROYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgdXBkYXRlQ2FjaGVkQ29udGVudENvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cGRhdGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRDYWNoZWRDb250ZW50TmFtZShhcGlDbGllbnQsIGZyb21OYW1lKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHVwZGF0ZUNhY2hlZENvbnRlbnRDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgQ2FjaGVzIGV4dGVuZHMgQmFzZU1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdHMgY2FjaGVkIGNvbnRlbnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBsaXN0IHJlcXVlc3QuXG4gICAgICAgICAqIEByZXR1cm4gLSBBIHBhZ2VyIG9mIGNhY2hlZCBjb250ZW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgY2FjaGVkQ29udGVudHMgPSBhd2FpdCBhaS5jYWNoZXMubGlzdCh7Y29uZmlnOiB7J3BhZ2VTaXplJzogMn19KTtcbiAgICAgICAgICogZm9yIGF3YWl0IChjb25zdCBjYWNoZWRDb250ZW50IG9mIGNhY2hlZENvbnRlbnRzKSB7XG4gICAgICAgICAqICAgY29uc29sZS5sb2coY2FjaGVkQ29udGVudCk7XG4gICAgICAgICAqIH1cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxpc3QgPSBhc3luYyAocGFyYW1zID0ge30pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGFnZXIoUGFnZWRJdGVtLlBBR0VEX0lURU1fQ0FDSEVEX0NPTlRFTlRTLCAoeCkgPT4gdGhpcy5saXN0SW50ZXJuYWwoeCksIGF3YWl0IHRoaXMubGlzdEludGVybmFsKHBhcmFtcyksIHBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjYWNoZWQgY29udGVudHMgcmVzb3VyY2UuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIENvbnRleHQgY2FjaGluZyBpcyBvbmx5IHN1cHBvcnRlZCBmb3Igc3BlY2lmaWMgbW9kZWxzLiBTZWUgW0dlbWluaVxuICAgICAqIERldmVsb3BlciBBUEkgcmVmZXJlbmNlXShodHRwczovL2FpLmdvb2dsZS5kZXYvZ2VtaW5pLWFwaS9kb2NzL2NhY2hpbmc/bGFuZz1ub2RlL2NvbnRleHQtY2FjKVxuICAgICAqIGFuZCBbVmVydGV4IEFJIHJlZmVyZW5jZV0oaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL3ZlcnRleC1haS9nZW5lcmF0aXZlLWFpL2RvY3MvY29udGV4dC1jYWNoZS9jb250ZXh0LWNhY2hlLW92ZXJ2aWV3I3N1cHBvcnRlZF9tb2RlbHMpXG4gICAgICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBjcmVhdGUgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSBjcmVhdGVkIGNhY2hlZCBjb250ZW50LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGNvbnRlbnRzID0gLi4uOyAvLyBJbml0aWFsaXplIHRoZSBjb250ZW50IHRvIGNhY2hlLlxuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkuY2FjaGVzLmNyZWF0ZSh7XG4gICAgICogICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gtMDAxJyxcbiAgICAgKiAgIGNvbmZpZzoge1xuICAgICAqICAgICdjb250ZW50cyc6IGNvbnRlbnRzLFxuICAgICAqICAgICdkaXNwbGF5TmFtZSc6ICd0ZXN0IGNhY2hlJyxcbiAgICAgKiAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nOiAnV2hhdCBpcyB0aGUgc3VtIG9mIHRoZSB0d28gcGRmcz8nLFxuICAgICAqICAgICd0dGwnOiAnODY0MDBzJyxcbiAgICAgKiAgfVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2NhY2hlZENvbnRlbnRzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChyZXNwKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjcmVhdGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdjYWNoZWRDb250ZW50cycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigocmVzcCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBjYWNoZWQgY29udGVudCBjb25maWd1cmF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGdldCByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIGNhY2hlZCBjb250ZW50LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGF3YWl0IGFpLmNhY2hlcy5nZXQoe25hbWU6ICcuLi4nfSk7IC8vIFRoZSBzZXJ2ZXItZ2VuZXJhdGVkIHJlc291cmNlIG5hbWUuXG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgZ2V0KHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXRDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKHJlc3ApID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldENhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChyZXNwKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGNhY2hlZCBjb250ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZGVsZXRlIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgZW1wdHkgcmVzcG9uc2UgcmV0dXJuZWQgYnkgdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBhd2FpdCBhaS5jYWNoZXMuZGVsZXRlKHtuYW1lOiAnLi4uJ30pOyAvLyBUaGUgc2VydmVyLWdlbmVyYXRlZCByZXNvdXJjZSBuYW1lLlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZGVsZXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IERlbGV0ZUNhY2hlZENvbnRlbnRSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZGVsZXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBkZWxldGVDYWNoZWRDb250ZW50UmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBEZWxldGVDYWNoZWRDb250ZW50UmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgY2FjaGVkIGNvbnRlbnQgY29uZmlndXJhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSB1cGRhdGUgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSB1cGRhdGVkIGNhY2hlZCBjb250ZW50LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkuY2FjaGVzLnVwZGF0ZSh7XG4gICAgICogICBuYW1lOiAnLi4uJywgIC8vIFRoZSBzZXJ2ZXItZ2VuZXJhdGVkIHJlc291cmNlIG5hbWUuXG4gICAgICogICBjb25maWc6IHsndHRsJzogJzc2MDBzJ31cbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IHVwZGF0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQQVRDSCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChyZXNwKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSB1cGRhdGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQQVRDSCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChyZXNwKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBsaXN0SW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGxpc3RDYWNoZWRDb250ZW50c1BhcmFtZXRlcnNUb1ZlcnRleChwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnY2FjaGVkQ29udGVudHMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGxpc3RDYWNoZWRDb250ZW50c1Jlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IExpc3RDYWNoZWRDb250ZW50c1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBsaXN0Q2FjaGVkQ29udGVudHNQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnY2FjaGVkQ29udGVudHMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGxpc3RDYWNoZWRDb250ZW50c1Jlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgTGlzdENhY2hlZENvbnRlbnRzUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UsIFN1cHByZXNzZWRFcnJvciwgU3ltYm9sLCBJdGVyYXRvciAqL1xyXG5cclxuXHJcbmZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IE9iamVjdC5jcmVhdGUoKHR5cGVvZiBBc3luY0l0ZXJhdG9yID09PSBcImZ1bmN0aW9uXCIgPyBBc3luY0l0ZXJhdG9yIDogT2JqZWN0KS5wcm90b3R5cGUpLCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIsIGF3YWl0UmV0dXJuKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gYXdhaXRSZXR1cm4oZikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGYsIHJlamVjdCk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpZiAoZ1tuXSkgeyBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyBpZiAoZikgaVtuXSA9IGYoaVtuXSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbnR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xyXG4gICAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xyXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcmVzcG9uc2UgaXMgdmFsaWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZFJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChyZXNwb25zZS5jYW5kaWRhdGVzID09IHVuZGVmaW5lZCB8fCByZXNwb25zZS5jYW5kaWRhdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRlbnQgPSAoX2EgPSByZXNwb25zZS5jYW5kaWRhdGVzWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGVudDtcbiAgICBpZiAoY29udGVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzVmFsaWRDb250ZW50KGNvbnRlbnQpO1xufVxuZnVuY3Rpb24gaXNWYWxpZENvbnRlbnQoY29udGVudCkge1xuICAgIGlmIChjb250ZW50LnBhcnRzID09PSB1bmRlZmluZWQgfHwgY29udGVudC5wYXJ0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHBhcnQgb2YgY29udGVudC5wYXJ0cykge1xuICAgICAgICBpZiAocGFydCA9PT0gdW5kZWZpbmVkIHx8IE9iamVjdC5rZXlzKHBhcnQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBWYWxpZGF0ZXMgdGhlIGhpc3RvcnkgY29udGFpbnMgdGhlIGNvcnJlY3Qgcm9sZXMuXG4gKlxuICogQHRocm93cyBFcnJvciBpZiB0aGUgaGlzdG9yeSBkb2VzIG5vdCBzdGFydCB3aXRoIGEgdXNlciB0dXJuLlxuICogQHRocm93cyBFcnJvciBpZiB0aGUgaGlzdG9yeSBjb250YWlucyBhbiBpbnZhbGlkIHJvbGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlSGlzdG9yeShoaXN0b3J5KSB7XG4gICAgLy8gRW1wdHkgaGlzdG9yeSBpcyB2YWxpZC5cbiAgICBpZiAoaGlzdG9yeS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGNvbnRlbnQgb2YgaGlzdG9yeSkge1xuICAgICAgICBpZiAoY29udGVudC5yb2xlICE9PSAndXNlcicgJiYgY29udGVudC5yb2xlICE9PSAnbW9kZWwnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJvbGUgbXVzdCBiZSB1c2VyIG9yIG1vZGVsLCBidXQgZ290ICR7Y29udGVudC5yb2xlfS5gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogRXh0cmFjdHMgdGhlIGN1cmF0ZWQgKHZhbGlkKSBoaXN0b3J5IGZyb20gYSBjb21wcmVoZW5zaXZlIGhpc3RvcnkuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoZSBtb2RlbCBtYXkgc29tZXRpbWVzIGdlbmVyYXRlIGludmFsaWQgb3IgZW1wdHkgY29udGVudHMoZS5nLiwgZHVlIHRvIHNhZnR5XG4gKiBmaWx0ZXJzIG9yIHJlY2l0YXRpb24pLiBFeHRyYWN0aW5nIHZhbGlkIHR1cm5zIGZyb20gdGhlIGhpc3RvcnlcbiAqIGVuc3VyZXMgdGhhdCBzdWJzZXF1ZW50IHJlcXVlc3RzIGNvdWxkIGJlIGFjY3BldGVkIGJ5IHRoZSBtb2RlbC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdEN1cmF0ZWRIaXN0b3J5KGNvbXByZWhlbnNpdmVIaXN0b3J5KSB7XG4gICAgaWYgKGNvbXByZWhlbnNpdmVIaXN0b3J5ID09PSB1bmRlZmluZWQgfHwgY29tcHJlaGVuc2l2ZUhpc3RvcnkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgY3VyYXRlZEhpc3RvcnkgPSBbXTtcbiAgICBjb25zdCBsZW5ndGggPSBjb21wcmVoZW5zaXZlSGlzdG9yeS5sZW5ndGg7XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChjb21wcmVoZW5zaXZlSGlzdG9yeVtpXS5yb2xlID09PSAndXNlcicpIHtcbiAgICAgICAgICAgIGN1cmF0ZWRIaXN0b3J5LnB1c2goY29tcHJlaGVuc2l2ZUhpc3RvcnlbaV0pO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbW9kZWxPdXRwdXQgPSBbXTtcbiAgICAgICAgICAgIGxldCBpc1ZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgbGVuZ3RoICYmIGNvbXByZWhlbnNpdmVIaXN0b3J5W2ldLnJvbGUgPT09ICdtb2RlbCcpIHtcbiAgICAgICAgICAgICAgICBtb2RlbE91dHB1dC5wdXNoKGNvbXByZWhlbnNpdmVIaXN0b3J5W2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZCAmJiAhaXNWYWxpZENvbnRlbnQoY29tcHJlaGVuc2l2ZUhpc3RvcnlbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICBjdXJhdGVkSGlzdG9yeS5wdXNoKC4uLm1vZGVsT3V0cHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbGFzdCB1c2VyIGlucHV0IHdoZW4gbW9kZWwgY29udGVudCBpcyBpbnZhbGlkLlxuICAgICAgICAgICAgICAgIGN1cmF0ZWRIaXN0b3J5LnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjdXJhdGVkSGlzdG9yeTtcbn1cbi8qKlxuICogQSB1dGlsaXR5IGNsYXNzIHRvIGNyZWF0ZSBhIGNoYXQgc2Vzc2lvbi5cbiAqL1xuY2xhc3MgQ2hhdHMge1xuICAgIGNvbnN0cnVjdG9yKG1vZGVsc01vZHVsZSwgYXBpQ2xpZW50KSB7XG4gICAgICAgIHRoaXMubW9kZWxzTW9kdWxlID0gbW9kZWxzTW9kdWxlO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBjaGF0IHNlc3Npb24uXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoZSBjb25maWcgaW4gdGhlIHBhcmFtcyB3aWxsIGJlIHVzZWQgZm9yIGFsbCByZXF1ZXN0cyB3aXRoaW4gdGhlIGNoYXRcbiAgICAgKiBzZXNzaW9uIHVubGVzcyBvdmVycmlkZGVuIGJ5IGEgcGVyLXJlcXVlc3QgYGNvbmZpZ2AgaW5cbiAgICAgKiBAc2VlIHtAbGluayB0eXBlcy5TZW5kTWVzc2FnZVBhcmFtZXRlcnMjY29uZmlnfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBQYXJhbWV0ZXJzIGZvciBjcmVhdGluZyBhIGNoYXQgc2Vzc2lvbi5cbiAgICAgKiBAcmV0dXJucyBBIG5ldyBjaGF0IHNlc3Npb24uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgY2hhdCA9IGFpLmNoYXRzLmNyZWF0ZSh7XG4gICAgICogICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnXG4gICAgICogICBjb25maWc6IHtcbiAgICAgKiAgICAgdGVtcGVyYXR1cmU6IDAuNSxcbiAgICAgKiAgICAgbWF4T3V0cHV0VG9rZW5zOiAxMDI0LFxuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGNyZWF0ZShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGF0KHRoaXMuYXBpQ2xpZW50LCB0aGlzLm1vZGVsc01vZHVsZSwgcGFyYW1zLm1vZGVsLCBwYXJhbXMuY29uZmlnLCBcbiAgICAgICAgLy8gRGVlcCBjb3B5IHRoZSBoaXN0b3J5IHRvIGF2b2lkIG11dGF0aW5nIHRoZSBoaXN0b3J5IG91dHNpZGUgb2YgdGhlXG4gICAgICAgIC8vIGNoYXQgc2Vzc2lvbi5cbiAgICAgICAgc3RydWN0dXJlZENsb25lKHBhcmFtcy5oaXN0b3J5KSk7XG4gICAgfVxufVxuLyoqXG4gKiBDaGF0IHNlc3Npb24gdGhhdCBlbmFibGVzIHNlbmRpbmcgbWVzc2FnZXMgdG8gdGhlIG1vZGVsIHdpdGggcHJldmlvdXNcbiAqIGNvbnZlcnNhdGlvbiBjb250ZXh0LlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGUgc2Vzc2lvbiBtYWludGFpbnMgYWxsIHRoZSB0dXJucyBiZXR3ZWVuIHVzZXIgYW5kIG1vZGVsLlxuICovXG5jbGFzcyBDaGF0IHtcbiAgICBjb25zdHJ1Y3RvcihhcGlDbGllbnQsIG1vZGVsc01vZHVsZSwgbW9kZWwsIGNvbmZpZyA9IHt9LCBoaXN0b3J5ID0gW10pIHtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgICAgIHRoaXMubW9kZWxzTW9kdWxlID0gbW9kZWxzTW9kdWxlO1xuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLmhpc3RvcnkgPSBoaXN0b3J5O1xuICAgICAgICAvLyBBIHByb21pc2UgdG8gcmVwcmVzZW50IHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBtZXNzYWdlIGJlaW5nIHNlbnQgdG8gdGhlXG4gICAgICAgIC8vIG1vZGVsLlxuICAgICAgICB0aGlzLnNlbmRQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIHZhbGlkYXRlSGlzdG9yeShoaXN0b3J5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBtZXNzYWdlIHRvIHRoZSBtb2RlbCBhbmQgcmV0dXJucyB0aGUgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgd2FpdCBmb3IgdGhlIHByZXZpb3VzIG1lc3NhZ2UgdG8gYmUgcHJvY2Vzc2VkIGJlZm9yZVxuICAgICAqIHNlbmRpbmcgdGhlIG5leHQgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIENoYXQjc2VuZE1lc3NhZ2VTdHJlYW19IGZvciBzdHJlYW1pbmcgbWV0aG9kLlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBwYXJhbWV0ZXJzIGZvciBzZW5kaW5nIG1lc3NhZ2VzIHdpdGhpbiBhIGNoYXQgc2Vzc2lvbi5cbiAgICAgKiBAcmV0dXJucyBUaGUgbW9kZWwncyByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBjaGF0ID0gYWkuY2hhdHMuY3JlYXRlKHttb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnfSk7XG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjaGF0LnNlbmRNZXNzYWdlKHtcbiAgICAgKiAgIG1lc3NhZ2U6ICdXaHkgaXMgdGhlIHNreSBibHVlPydcbiAgICAgKiB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZS50ZXh0KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBzZW5kTWVzc2FnZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmRQcm9taXNlO1xuICAgICAgICBjb25zdCBpbnB1dENvbnRlbnQgPSB0Q29udGVudChwYXJhbXMubWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlUHJvbWlzZSA9IHRoaXMubW9kZWxzTW9kdWxlLmdlbmVyYXRlQ29udGVudCh7XG4gICAgICAgICAgICBtb2RlbDogdGhpcy5tb2RlbCxcbiAgICAgICAgICAgIGNvbnRlbnRzOiB0aGlzLmdldEhpc3RvcnkodHJ1ZSkuY29uY2F0KGlucHV0Q29udGVudCksXG4gICAgICAgICAgICBjb25maWc6IChfYSA9IHBhcmFtcy5jb25maWcpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuY29uZmlnLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZW5kUHJvbWlzZSA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVzcG9uc2VQcm9taXNlO1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0Q29udGVudCA9IChfYiA9IChfYSA9IHJlc3BvbnNlLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvbnRlbnQ7XG4gICAgICAgICAgICAvLyBCZWNhdXNlIHRoZSBBRkMgaW5wdXQgY29udGFpbnMgdGhlIGVudGlyZSBjdXJhdGVkIGNoYXQgaGlzdG9yeSBpblxuICAgICAgICAgICAgLy8gYWRkaXRpb24gdG8gdGhlIG5ldyB1c2VyIGlucHV0LCB3ZSBuZWVkIHRvIHRydW5jYXRlIHRoZSBBRkMgaGlzdG9yeVxuICAgICAgICAgICAgLy8gdG8gZGVkdXBsaWNhdGUgdGhlIGV4aXN0aW5nIGNoYXQgaGlzdG9yeS5cbiAgICAgICAgICAgIGNvbnN0IGZ1bGxBdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5ID0gcmVzcG9uc2UuYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5nZXRIaXN0b3J5KHRydWUpLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBhdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5ID0gW107XG4gICAgICAgICAgICBpZiAoZnVsbEF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3RvcnkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3RvcnkgPVxuICAgICAgICAgICAgICAgICAgICAoX2MgPSBmdWxsQXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeS5zbGljZShpbmRleCkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbW9kZWxPdXRwdXQgPSBvdXRwdXRDb250ZW50ID8gW291dHB1dENvbnRlbnRdIDogW107XG4gICAgICAgICAgICB0aGlzLnJlY29yZEhpc3RvcnkoaW5wdXRDb250ZW50LCBtb2RlbE91dHB1dCwgYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0pKCk7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZFByb21pc2UuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgLy8gUmVzZXRzIHNlbmRQcm9taXNlIHRvIGF2b2lkIHN1YnNlcXVlbnQgY2FsbHMgZmFpbGluZ1xuICAgICAgICAgICAgdGhpcy5zZW5kUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlUHJvbWlzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBtZXNzYWdlIHRvIHRoZSBtb2RlbCBhbmQgcmV0dXJucyB0aGUgcmVzcG9uc2UgaW4gY2h1bmtzLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHdhaXQgZm9yIHRoZSBwcmV2aW91cyBtZXNzYWdlIHRvIGJlIHByb2Nlc3NlZCBiZWZvcmVcbiAgICAgKiBzZW5kaW5nIHRoZSBuZXh0IG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBDaGF0I3NlbmRNZXNzYWdlfSBmb3Igbm9uLXN0cmVhbWluZyBtZXRob2QuXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIHBhcmFtZXRlcnMgZm9yIHNlbmRpbmcgdGhlIG1lc3NhZ2UuXG4gICAgICogQHJldHVybiBUaGUgbW9kZWwncyByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBjaGF0ID0gYWkuY2hhdHMuY3JlYXRlKHttb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnfSk7XG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjaGF0LnNlbmRNZXNzYWdlU3RyZWFtKHtcbiAgICAgKiAgIG1lc3NhZ2U6ICdXaHkgaXMgdGhlIHNreSBibHVlPydcbiAgICAgKiB9KTtcbiAgICAgKiBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHJlc3BvbnNlKSB7XG4gICAgICogICBjb25zb2xlLmxvZyhjaHVuay50ZXh0KTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgc2VuZE1lc3NhZ2VTdHJlYW0ocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kUHJvbWlzZTtcbiAgICAgICAgY29uc3QgaW5wdXRDb250ZW50ID0gdENvbnRlbnQocGFyYW1zLm1lc3NhZ2UpO1xuICAgICAgICBjb25zdCBzdHJlYW1SZXNwb25zZSA9IHRoaXMubW9kZWxzTW9kdWxlLmdlbmVyYXRlQ29udGVudFN0cmVhbSh7XG4gICAgICAgICAgICBtb2RlbDogdGhpcy5tb2RlbCxcbiAgICAgICAgICAgIGNvbnRlbnRzOiB0aGlzLmdldEhpc3RvcnkodHJ1ZSkuY29uY2F0KGlucHV0Q29udGVudCksXG4gICAgICAgICAgICBjb25maWc6IChfYSA9IHBhcmFtcy5jb25maWcpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuY29uZmlnLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gUmVzb2x2ZSB0aGUgaW50ZXJuYWwgdHJhY2tpbmcgb2Ygc2VuZCBjb21wbGV0aW9uIHByb21pc2UgLSBgc2VuZFByb21pc2VgXG4gICAgICAgIC8vIGZvciBib3RoIHN1Y2Nlc3MgYW5kIGZhaWx1cmUgcmVzcG9uc2UuIFRoZSBhY3R1YWwgZmFpbHVyZSBpcyBzdGlsbFxuICAgICAgICAvLyBwcm9wYWdhdGVkIGJ5IHRoZSBgYXdhaXQgc3RyZWFtUmVzcG9uc2VgLlxuICAgICAgICB0aGlzLnNlbmRQcm9taXNlID0gc3RyZWFtUmVzcG9uc2VcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHVuZGVmaW5lZClcbiAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB1bmRlZmluZWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHN0cmVhbVJlc3BvbnNlO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnByb2Nlc3NTdHJlYW1SZXNwb25zZShyZXNwb25zZSwgaW5wdXRDb250ZW50KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY2hhdCBoaXN0b3J5LlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgaGlzdG9yeSBpcyBhIGxpc3Qgb2YgY29udGVudHMgYWx0ZXJuYXRpbmcgYmV0d2VlbiB1c2VyIGFuZCBtb2RlbC5cbiAgICAgKlxuICAgICAqIFRoZXJlIGFyZSB0d28gdHlwZXMgb2YgaGlzdG9yeTpcbiAgICAgKiAtIFRoZSBgY3VyYXRlZCBoaXN0b3J5YCBjb250YWlucyBvbmx5IHRoZSB2YWxpZCB0dXJucyBiZXR3ZWVuIHVzZXIgYW5kXG4gICAgICogbW9kZWwsIHdoaWNoIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIHN1YnNlcXVlbnQgcmVxdWVzdHMgc2VudCB0byB0aGUgbW9kZWwuXG4gICAgICogLSBUaGUgYGNvbXByZWhlbnNpdmUgaGlzdG9yeWAgY29udGFpbnMgYWxsIHR1cm5zLCBpbmNsdWRpbmcgaW52YWxpZCBvclxuICAgICAqICAgZW1wdHkgbW9kZWwgb3V0cHV0cywgcHJvdmlkaW5nIGEgY29tcGxldGUgcmVjb3JkIG9mIHRoZSBoaXN0b3J5LlxuICAgICAqXG4gICAgICogVGhlIGhpc3RvcnkgaXMgdXBkYXRlZCBhZnRlciByZWNlaXZpbmcgdGhlIHJlc3BvbnNlIGZyb20gdGhlIG1vZGVsLFxuICAgICAqIGZvciBzdHJlYW1pbmcgcmVzcG9uc2UsIGl0IG1lYW5zIHJlY2VpdmluZyB0aGUgbGFzdCBjaHVuayBvZiB0aGUgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBUaGUgYGNvbXByZWhlbnNpdmUgaGlzdG9yeWAgaXMgcmV0dXJuZWQgYnkgZGVmYXVsdC4gVG8gZ2V0IHRoZSBgY3VyYXRlZFxuICAgICAqIGhpc3RvcnlgLCBzZXQgdGhlIGBjdXJhdGVkYCBwYXJhbWV0ZXIgdG8gYHRydWVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGN1cmF0ZWQgLSB3aGV0aGVyIHRvIHJldHVybiB0aGUgY3VyYXRlZCBoaXN0b3J5IG9yIHRoZSBjb21wcmVoZW5zaXZlXG4gICAgICogICAgIGhpc3RvcnkuXG4gICAgICogQHJldHVybiBIaXN0b3J5IGNvbnRlbnRzIGFsdGVybmF0aW5nIGJldHdlZW4gdXNlciBhbmQgbW9kZWwgZm9yIHRoZSBlbnRpcmVcbiAgICAgKiAgICAgY2hhdCBzZXNzaW9uLlxuICAgICAqL1xuICAgIGdldEhpc3RvcnkoY3VyYXRlZCA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGhpc3RvcnkgPSBjdXJhdGVkXG4gICAgICAgICAgICA/IGV4dHJhY3RDdXJhdGVkSGlzdG9yeSh0aGlzLmhpc3RvcnkpXG4gICAgICAgICAgICA6IHRoaXMuaGlzdG9yeTtcbiAgICAgICAgLy8gRGVlcCBjb3B5IHRoZSBoaXN0b3J5IHRvIGF2b2lkIG11dGF0aW5nIHRoZSBoaXN0b3J5IG91dHNpZGUgb2YgdGhlXG4gICAgICAgIC8vIGNoYXQgc2Vzc2lvbi5cbiAgICAgICAgcmV0dXJuIHN0cnVjdHVyZWRDbG9uZShoaXN0b3J5KTtcbiAgICB9XG4gICAgcHJvY2Vzc1N0cmVhbVJlc3BvbnNlKHN0cmVhbVJlc3BvbnNlLCBpbnB1dENvbnRlbnQpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogcHJvY2Vzc1N0cmVhbVJlc3BvbnNlXzEoKSB7XG4gICAgICAgICAgICB2YXIgX2MsIGVfMSwgX2QsIF9lO1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0Q29udGVudCA9IFtdO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfZiA9IHRydWUsIHN0cmVhbVJlc3BvbnNlXzEgPSBfX2FzeW5jVmFsdWVzKHN0cmVhbVJlc3BvbnNlKSwgc3RyZWFtUmVzcG9uc2VfMV8xOyBzdHJlYW1SZXNwb25zZV8xXzEgPSB5aWVsZCBfX2F3YWl0KHN0cmVhbVJlc3BvbnNlXzEubmV4dCgpKSwgX2MgPSBzdHJlYW1SZXNwb25zZV8xXzEuZG9uZSwgIV9jOyBfZiA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgX2UgPSBzdHJlYW1SZXNwb25zZV8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIF9mID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gX2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkUmVzcG9uc2UoY2h1bmspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gKF9iID0gKF9hID0gY2h1bmsuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRDb250ZW50LnB1c2goY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChjaHVuayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2YgJiYgIV9jICYmIChfZCA9IHN0cmVhbVJlc3BvbnNlXzEucmV0dXJuKSkgeWllbGQgX19hd2FpdChfZC5jYWxsKHN0cmVhbVJlc3BvbnNlXzEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWNvcmRIaXN0b3J5KGlucHV0Q29udGVudCwgb3V0cHV0Q29udGVudCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZWNvcmRIaXN0b3J5KHVzZXJJbnB1dCwgbW9kZWxPdXRwdXQsIGF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3RvcnkpIHtcbiAgICAgICAgbGV0IG91dHB1dENvbnRlbnRzID0gW107XG4gICAgICAgIGlmIChtb2RlbE91dHB1dC5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICBtb2RlbE91dHB1dC5ldmVyeSgoY29udGVudCkgPT4gY29udGVudC5yb2xlICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICBvdXRwdXRDb250ZW50cyA9IG1vZGVsT3V0cHV0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQXBwZW5kcyBhbiBlbXB0eSBjb250ZW50IHdoZW4gbW9kZWwgcmV0dXJucyBlbXB0eSByZXNwb25zZSwgc28gdGhhdCB0aGVcbiAgICAgICAgICAgIC8vIGhpc3RvcnkgaXMgYWx3YXlzIGFsdGVybmF0aW5nIGJldHdlZW4gdXNlciBhbmQgbW9kZWwuXG4gICAgICAgICAgICBvdXRwdXRDb250ZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICByb2xlOiAnbW9kZWwnLFxuICAgICAgICAgICAgICAgIHBhcnRzOiBbXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5ICYmXG4gICAgICAgICAgICBhdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuaGlzdG9yeS5wdXNoKC4uLmV4dHJhY3RDdXJhdGVkSGlzdG9yeShhdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhpc3RvcnkucHVzaCh1c2VySW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGlzdG9yeS5wdXNoKC4uLm91dHB1dENvbnRlbnRzKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8qKlxuICogQVBJIGVycm9ycyByYWlzZWQgYnkgdGhlIEdlbkFJIEFQSS5cbiAqL1xuY2xhc3MgQXBpRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zLm1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQXBpRXJyb3InO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IG9wdGlvbnMuc3RhdHVzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgQXBpRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8vIENvZGUgZ2VuZXJhdGVkIGJ5IHRoZSBHb29nbGUgR2VuIEFJIFNESyBnZW5lcmF0b3IgRE8gTk9UIEVESVQuXG5mdW5jdGlvbiBjcmVhdGVGaWxlUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZpbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGUnXSk7XG4gICAgaWYgKGZyb21GaWxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZSddLCBmcm9tRmlsZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpbGVSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlRmlsZVBhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnZmlsZSddLCB0RmlsZU5hbWUoZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlRmlsZVJlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZXRGaWxlUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdmaWxlJ10sIHRGaWxlTmFtZShmcm9tTmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0RmlsZXNDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlU2l6ZSddLCBmcm9tUGFnZVNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlVG9rZW4nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VUb2tlbiddLCBmcm9tUGFnZVRva2VuKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdEZpbGVzUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgbGlzdEZpbGVzQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RGaWxlc1Jlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmV4dFBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25leHRQYWdlVG9rZW4nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTmV4dFBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25leHRQYWdlVG9rZW4nXSwgZnJvbU5leHRQYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVzJ10pO1xuICAgIGlmIChmcm9tRmlsZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUZpbGVzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNsYXNzIEZpbGVzIGV4dGVuZHMgQmFzZU1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdHMgZmlsZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGxpc3QgcmVxdWVzdC5cbiAgICAgICAgICogQHJldHVybiAtIEEgcGFnZXIgb2YgZmlsZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IGZpbGVzID0gYXdhaXQgYWkuZmlsZXMubGlzdCh7Y29uZmlnOiB7J3BhZ2VTaXplJzogMn19KTtcbiAgICAgICAgICogZm9yIGF3YWl0IChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICAgICAqICAgY29uc29sZS5sb2coZmlsZSk7XG4gICAgICAgICAqIH1cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxpc3QgPSBhc3luYyAocGFyYW1zID0ge30pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGFnZXIoUGFnZWRJdGVtLlBBR0VEX0lURU1fRklMRVMsICh4KSA9PiB0aGlzLmxpc3RJbnRlcm5hbCh4KSwgYXdhaXQgdGhpcy5saXN0SW50ZXJuYWwocGFyYW1zKSwgcGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBsb2FkcyBhIGZpbGUgYXN5bmNocm9ub3VzbHkgdG8gdGhlIEdlbWluaSBBUEkuXG4gICAgICogVGhpcyBtZXRob2QgaXMgbm90IGF2YWlsYWJsZSBpbiBWZXJ0ZXggQUkuXG4gICAgICogU3VwcG9ydGVkIHVwbG9hZCBzb3VyY2VzOlxuICAgICAqIC0gTm9kZS5qczogRmlsZSBwYXRoIChzdHJpbmcpIG9yIEJsb2Igb2JqZWN0LlxuICAgICAqIC0gQnJvd3NlcjogQmxvYiBvYmplY3QgKGUuZy4sIEZpbGUpLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgYG1pbWVUeXBlYCBjYW4gYmUgc3BlY2lmaWVkIGluIHRoZSBgY29uZmlnYCBwYXJhbWV0ZXIuIElmIG9taXR0ZWQ6XG4gICAgICogIC0gRm9yIGZpbGUgcGF0aCAoc3RyaW5nKSBpbnB1dHMsIHRoZSBgbWltZVR5cGVgIHdpbGwgYmUgaW5mZXJyZWQgZnJvbSB0aGVcbiAgICAgKiAgICAgZmlsZSBleHRlbnNpb24uXG4gICAgICogIC0gRm9yIEJsb2Igb2JqZWN0IGlucHV0cywgdGhlIGBtaW1lVHlwZWAgd2lsbCBiZSBzZXQgdG8gdGhlIEJsb2IncyBgdHlwZWBcbiAgICAgKiAgICAgcHJvcGVydHkuXG4gICAgICogU29tZXggZWFtcGxlcyBmb3IgZmlsZSBleHRlbnNpb24gdG8gbWltZVR5cGUgbWFwcGluZzpcbiAgICAgKiAudHh0IC0+IHRleHQvcGxhaW5cbiAgICAgKiAuanNvbiAtPiBhcHBsaWNhdGlvbi9qc29uXG4gICAgICogLmpwZyAgLT4gaW1hZ2UvanBlZ1xuICAgICAqIC5wbmcgLT4gaW1hZ2UvcG5nXG4gICAgICogLm1wMyAtPiBhdWRpby9tcGVnXG4gICAgICogLm1wNCAtPiB2aWRlby9tcDRcbiAgICAgKlxuICAgICAqIFRoaXMgc2VjdGlvbiBjYW4gY29udGFpbiBtdWx0aXBsZSBwYXJhZ3JhcGhzIGFuZCBjb2RlIGV4YW1wbGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIE9wdGlvbmFsIHBhcmFtZXRlcnMgc3BlY2lmaWVkIGluIHRoZVxuICAgICAqICAgICAgICBgdHlwZXMuVXBsb2FkRmlsZVBhcmFtZXRlcnNgIGludGVyZmFjZS5cbiAgICAgKiAgICAgICAgIEBzZWUge0BsaW5rIHR5cGVzLlVwbG9hZEZpbGVQYXJhbWV0ZXJzI2NvbmZpZ30gZm9yIHRoZSBvcHRpb25hbFxuICAgICAqICAgICAgICAgY29uZmlnIGluIHRoZSBwYXJhbWV0ZXJzLlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgdHlwZXMuRmlsZWAgb2JqZWN0LlxuICAgICAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgY2FsbGVkIG9uIGEgVmVydGV4IEFJIGNsaWVudC5cbiAgICAgKiBAdGhyb3dzIEFuIGVycm9yIGlmIHRoZSBgbWltZVR5cGVgIGlzIG5vdCBwcm92aWRlZCBhbmQgY2FuIG5vdCBiZSBpbmZlcnJlZCxcbiAgICAgKiB0aGUgYG1pbWVUeXBlYCBjYW4gYmUgcHJvdmlkZWQgaW4gdGhlIGBwYXJhbXMuY29uZmlnYCBwYXJhbWV0ZXIuXG4gICAgICogQHRocm93cyBBbiBlcnJvciBvY2N1cnMgaWYgYSBzdWl0YWJsZSB1cGxvYWQgbG9jYXRpb24gY2Fubm90IGJlIGVzdGFibGlzaGVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBUaGUgZm9sbG93aW5nIGNvZGUgdXBsb2FkcyBhIGZpbGUgdG8gR2VtaW5pIEFQSS5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgZmlsZSA9IGF3YWl0IGFpLmZpbGVzLnVwbG9hZCh7ZmlsZTogJ2ZpbGUudHh0JywgY29uZmlnOiB7XG4gICAgICogICBtaW1lVHlwZTogJ3RleHQvcGxhaW4nLFxuICAgICAqIH19KTtcbiAgICAgKiBjb25zb2xlLmxvZyhmaWxlLm5hbWUpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIHVwbG9hZChwYXJhbXMpIHtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWZXJ0ZXggQUkgZG9lcyBub3Qgc3VwcG9ydCB1cGxvYWRpbmcgZmlsZXMuIFlvdSBjYW4gc2hhcmUgZmlsZXMgdGhyb3VnaCBhIEdDUyBidWNrZXQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAudXBsb2FkRmlsZShwYXJhbXMuZmlsZSwgcGFyYW1zLmNvbmZpZylcbiAgICAgICAgICAgIC50aGVuKChyZXNwKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERvd25sb2FkcyBhIHJlbW90ZWx5IHN0b3JlZCBmaWxlIGFzeW5jaHJvbm91c2x5IHRvIGEgbG9jYXRpb24gc3BlY2lmaWVkIGluXG4gICAgICogdGhlIGBwYXJhbXNgIG9iamVjdC4gVGhpcyBtZXRob2Qgb25seSB3b3JrcyBvbiBOb2RlIGVudmlyb25tZW50LCB0b1xuICAgICAqIGRvd25sb2FkIGZpbGVzIGluIHRoZSBicm93c2VyLCB1c2UgYSBicm93c2VyIGNvbXBsaWFudCBtZXRob2QgbGlrZSBhbiA8YT5cbiAgICAgKiB0YWcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBkb3dubG9hZCByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBUaGUgZm9sbG93aW5nIGNvZGUgZG93bmxvYWRzIGFuIGV4YW1wbGUgZmlsZSBuYW1lZCBcImZpbGVzL21laG96cHhmODc3ZFwiIGFzXG4gICAgICogXCJmaWxlLnR4dFwiLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBhd2FpdCBhaS5maWxlcy5kb3dubG9hZCh7ZmlsZTogZmlsZS5uYW1lLCBkb3dubG9hZFBhdGg6ICdmaWxlLnR4dCd9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBkb3dubG9hZChwYXJhbXMpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5hcGlDbGllbnQuZG93bmxvYWRGaWxlKHBhcmFtcyk7XG4gICAgfVxuICAgIGFzeW5jIGxpc3RJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbGlzdEZpbGVzUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2ZpbGVzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0RmlsZXNSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IExpc3RGaWxlc1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBjcmVhdGVJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlRmlsZVBhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd1cGxvYWQvdjFiZXRhL2ZpbGVzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBjcmVhdGVGaWxlUmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBDcmVhdGVGaWxlUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgZmlsZSBpbmZvcm1hdGlvbiBmcm9tIHRoZSBzZXJ2aWNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZ2V0IHJlcXVlc3RcbiAgICAgKiBAcmV0dXJuIFRoZSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHR5cGVzLkZpbGUgb2JqZWN0IHJlcXVlc3RlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBjb25maWc6IEdldEZpbGVQYXJhbWV0ZXJzID0ge1xuICAgICAqICAgbmFtZTogZmlsZU5hbWUsXG4gICAgICogfTtcbiAgICAgKiBmaWxlID0gYXdhaXQgYWkuZmlsZXMuZ2V0KGNvbmZpZyk7XG4gICAgICogY29uc29sZS5sb2coZmlsZS5uYW1lKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBnZXQocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldEZpbGVQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnZmlsZXMve2ZpbGV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKHJlc3ApID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYSByZW1vdGVseSBzdG9yZWQgZmlsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGRlbGV0ZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIERlbGV0ZUZpbGVSZXNwb25zZSwgdGhlIHJlc3BvbnNlIGZvciB0aGUgZGVsZXRlIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogVGhlIGZvbGxvd2luZyBjb2RlIGRlbGV0ZXMgYW4gZXhhbXBsZSBmaWxlIG5hbWVkIFwiZmlsZXMvbWVob3pweGY4NzdkXCIuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGF3YWl0IGFpLmZpbGVzLmRlbGV0ZSh7bmFtZTogZmlsZS5uYW1lfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBkZWxldGVGaWxlUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2ZpbGVzL3tmaWxlfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZGVsZXRlRmlsZVJlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgRGVsZXRlRmlsZVJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuZnVuY3Rpb24gYmxvYlRvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGF0YSddKTtcbiAgICBpZiAoZnJvbURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkYXRhJ10sIGZyb21EYXRhKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3BsYXlOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhcnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJ0cyddKTtcbiAgICBpZiAoZnJvbVBhcnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21QYXJ0cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0VG9NbGRldiQyKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFydHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJvbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JvbGUnXSk7XG4gICAgaWYgKGZyb21Sb2xlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncm9sZSddLCBmcm9tUm9sZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZpbGVEYXRhVG9NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaXNwbGF5TmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZVVyaSddKTtcbiAgICBpZiAoZnJvbUZpbGVVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlVXJpJ10sIGZyb21GaWxlVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25DYWxsVG9NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaWQnXSk7XG4gICAgaWYgKGZyb21JZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lkJ10sIGZyb21JZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BcmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhcmdzJ10pO1xuICAgIGlmIChmcm9tQXJncyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FyZ3MnXSwgZnJvbUFyZ3MpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFydGlhbEFyZ3MnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcnRpYWxBcmdzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3dpbGxDb250aW51ZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignd2lsbENvbnRpbnVlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uRGVjbGFyYXRpb25Ub1ZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JlaGF2aW9yJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiZWhhdmlvciBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFyYW1ldGVycyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFyYW1ldGVycyddKTtcbiAgICBpZiAoZnJvbVBhcmFtZXRlcnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzJ10sIGZyb21QYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGFyYW1ldGVyc0pzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzSnNvblNjaGVtYSddLCBmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCBmcm9tUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSnNvblNjaGVtYSddLCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGlvbkNvbmZpZ1RvVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsU2VsZWN0aW9uQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbW9kZWxTZWxlY3Rpb25Db25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTW9kZWxTZWxlY3Rpb25Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbENvbmZpZyddLCBmcm9tTW9kZWxTZWxlY3Rpb25Db25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSnNvblNjaGVtYSddLCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF1ZGlvVGltZXN0YW1wID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYXVkaW9UaW1lc3RhbXAnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQXVkaW9UaW1lc3RhbXAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdWRpb1RpbWVzdGFtcCddLCBmcm9tQXVkaW9UaW1lc3RhbXApO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FuZGlkYXRlQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYW5kaWRhdGVDb3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYW5kaWRhdGVDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhbmRpZGF0ZUNvdW50J10sIGZyb21DYW5kaWRhdGVDb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmFibGVBZmZlY3RpdmVEaWFsb2cnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRW5hYmxlQWZmZWN0aXZlRGlhbG9nICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5hYmxlQWZmZWN0aXZlRGlhbG9nJ10sIGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnJlcXVlbmN5UGVuYWx0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2ZyZXF1ZW5jeVBlbmFsdHknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnJlcXVlbmN5UGVuYWx0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZyZXF1ZW5jeVBlbmFsdHknXSwgZnJvbUZyZXF1ZW5jeVBlbmFsdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTG9ncHJvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xvZ3Byb2JzJ10pO1xuICAgIGlmIChmcm9tTG9ncHJvYnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsb2dwcm9icyddLCBmcm9tTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4T3V0cHV0VG9rZW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWF4T3V0cHV0VG9rZW5zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1heE91dHB1dFRva2VucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21heE91dHB1dFRva2VucyddLCBmcm9tTWF4T3V0cHV0VG9rZW5zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1lZGlhUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21lZGlhUmVzb2x1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NZWRpYVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZWRpYVJlc29sdXRpb24nXSwgZnJvbU1lZGlhUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QcmVzZW5jZVBlbmFsdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVzZW5jZVBlbmFsdHknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlc2VuY2VQZW5hbHR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJlc2VuY2VQZW5hbHR5J10sIGZyb21QcmVzZW5jZVBlbmFsdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VMb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTG9ncHJvYnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VMb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTG9ncHJvYnMnXSwgZnJvbVJlc3BvbnNlTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VNaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTWltZVR5cGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VNaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTWltZVR5cGUnXSwgZnJvbVJlc3BvbnNlTWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNb2RhbGl0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTW9kYWxpdGllcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTW9kYWxpdGllcyddLCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VTY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VTY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZVNjaGVtYSddLCBmcm9tUmVzcG9uc2VTY2hlbWEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm91dGluZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JvdXRpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUm91dGluZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JvdXRpbmdDb25maWcnXSwgZnJvbVJvdXRpbmdDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKTtcbiAgICBpZiAoZnJvbVNlZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZWVkJ10sIGZyb21TZWVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNwZWVjaENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3BlZWNoQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tU3BlZWNoQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3BlZWNoQ29uZmlnJ10sIHNwZWVjaENvbmZpZ1RvVmVydGV4JDEoZnJvbVNwZWVjaENvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RvcFNlcXVlbmNlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N0b3BTZXF1ZW5jZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3RvcFNlcXVlbmNlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0b3BTZXF1ZW5jZXMnXSwgZnJvbVN0b3BTZXF1ZW5jZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGVtcGVyYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10pO1xuICAgIGlmIChmcm9tVGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZW1wZXJhdHVyZSddLCBmcm9tVGVtcGVyYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhpbmtpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aGlua2luZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaGlua2luZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RoaW5raW5nQ29uZmlnJ10sIGZyb21UaGlua2luZ0NvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BLID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BLJ10pO1xuICAgIGlmIChmcm9tVG9wSyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvcEsnXSwgZnJvbVRvcEspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wUCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wUCddKTtcbiAgICBpZiAoZnJvbVRvcFAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3BQJ10sIGZyb21Ub3BQKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5hYmxlRW5oYW5jZWRDaXZpY0Fuc3dlcnMnXSkgIT09XG4gICAgICAgIHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuYWJsZUVuaGFuY2VkQ2l2aWNBbnN3ZXJzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlTWFwc1RvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdXRoQ29uZmlnJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdXRoQ29uZmlnIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmFibGVXaWRnZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuYWJsZVdpZGdldCddKTtcbiAgICBpZiAoZnJvbUVuYWJsZVdpZGdldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuYWJsZVdpZGdldCddLCBmcm9tRW5hYmxlV2lkZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlU2VhcmNoVG9NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4Y2x1ZGVEb21haW5zJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleGNsdWRlRG9tYWlucyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydibG9ja2luZ0NvbmZpZGVuY2UnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Jsb2NraW5nQ29uZmlkZW5jZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGltZVJhbmdlRmlsdGVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGltZVJhbmdlRmlsdGVyJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRpbWVSYW5nZUZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RpbWVSYW5nZUZpbHRlciddLCBmcm9tVGltZVJhbmdlRmlsdGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZUNvbm5lY3RDb25maWdUb01sZGV2JDEoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2VuZXJhdGlvbkNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dlbmVyYXRpb25Db25maWcnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tR2VuZXJhdGlvbkNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJ10sIGZyb21HZW5lcmF0aW9uQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTW9kYWxpdGllcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21SZXNwb25zZU1vZGFsaXRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdyZXNwb25zZU1vZGFsaXRpZXMnXSwgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZW1wZXJhdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGVtcGVyYXR1cmUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UZW1wZXJhdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3RlbXBlcmF0dXJlJ10sIGZyb21UZW1wZXJhdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BQID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BQJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9wUCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3RvcFAnXSwgZnJvbVRvcFApO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wSyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wSyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvcEsgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0b3BLJ10sIGZyb21Ub3BLKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heE91dHB1dFRva2VucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21heE91dHB1dFRva2VucycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21NYXhPdXRwdXRUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdtYXhPdXRwdXRUb2tlbnMnXSwgZnJvbU1heE91dHB1dFRva2Vucyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZWRpYVJlc29sdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtZWRpYVJlc29sdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTWVkaWFSZXNvbHV0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnbWVkaWFSZXNvbHV0aW9uJ10sIGZyb21NZWRpYVJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNlZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdzZWVkJ10sIGZyb21TZWVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNwZWVjaENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3BlZWNoQ29uZmlnJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU3BlZWNoQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnc3BlZWNoQ29uZmlnJ10sIHRMaXZlU3BlZWNoQ29uZmlnKGZyb21TcGVlY2hDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRoaW5raW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhpbmtpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGhpbmtpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0aGlua2luZ0NvbmZpZyddLCBmcm9tVGhpbmtpbmdDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5hYmxlQWZmZWN0aXZlRGlhbG9nID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW5hYmxlQWZmZWN0aXZlRGlhbG9nJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ2VuYWJsZUFmZmVjdGl2ZURpYWxvZyddLCBmcm9tRW5hYmxlQWZmZWN0aXZlRGlhbG9nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN5c3RlbUluc3RydWN0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnc3lzdGVtSW5zdHJ1Y3Rpb24nXSwgY29udGVudFRvTWxkZXYkMih0Q29udGVudChmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24pKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29scyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29scyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0VG9vbHMoZnJvbVRvb2xzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b29sVG9NbGRldiQyKHRUb29sKGl0ZW0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICd0b29scyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2Vzc2lvblJlc3VtcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZXNzaW9uUmVzdW1wdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TZXNzaW9uUmVzdW1wdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdzZXNzaW9uUmVzdW1wdGlvbiddLCBzZXNzaW9uUmVzdW1wdGlvbkNvbmZpZ1RvTWxkZXYkMShmcm9tU2Vzc2lvblJlc3VtcHRpb24pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlucHV0QXVkaW9UcmFuc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5wdXRBdWRpb1RyYW5zY3JpcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW5wdXRBdWRpb1RyYW5zY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnaW5wdXRBdWRpb1RyYW5zY3JpcHRpb24nXSwgZnJvbUlucHV0QXVkaW9UcmFuc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnb3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uJ10sIGZyb21PdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVhbHRpbWVJbnB1dENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JlYWx0aW1lSW5wdXRDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUmVhbHRpbWVJbnB1dENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdyZWFsdGltZUlucHV0Q29uZmlnJ10sIGZyb21SZWFsdGltZUlucHV0Q29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRleHRXaW5kb3dDb21wcmVzc2lvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvbnRleHRXaW5kb3dDb21wcmVzc2lvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Db250ZXh0V2luZG93Q29tcHJlc3Npb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnY29udGV4dFdpbmRvd0NvbXByZXNzaW9uJ10sIGZyb21Db250ZXh0V2luZG93Q29tcHJlc3Npb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvYWN0aXZpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb2FjdGl2aXR5J10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUHJvYWN0aXZpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAncHJvYWN0aXZpdHknXSwgZnJvbVByb2FjdGl2aXR5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZUNvbm5lY3RDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21HZW5lcmF0aW9uQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ2VuZXJhdGlvbkNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21HZW5lcmF0aW9uQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnXSwgZ2VuZXJhdGlvbkNvbmZpZ1RvVmVydGV4JDEoZnJvbUdlbmVyYXRpb25Db25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTW9kYWxpdGllcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21SZXNwb25zZU1vZGFsaXRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdyZXNwb25zZU1vZGFsaXRpZXMnXSwgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZW1wZXJhdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGVtcGVyYXR1cmUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UZW1wZXJhdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3RlbXBlcmF0dXJlJ10sIGZyb21UZW1wZXJhdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BQID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BQJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9wUCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3RvcFAnXSwgZnJvbVRvcFApO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wSyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wSyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvcEsgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0b3BLJ10sIGZyb21Ub3BLKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heE91dHB1dFRva2VucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21heE91dHB1dFRva2VucycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21NYXhPdXRwdXRUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdtYXhPdXRwdXRUb2tlbnMnXSwgZnJvbU1heE91dHB1dFRva2Vucyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZWRpYVJlc29sdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtZWRpYVJlc29sdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTWVkaWFSZXNvbHV0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnbWVkaWFSZXNvbHV0aW9uJ10sIGZyb21NZWRpYVJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNlZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdzZWVkJ10sIGZyb21TZWVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNwZWVjaENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3BlZWNoQ29uZmlnJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU3BlZWNoQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnc3BlZWNoQ29uZmlnJ10sIHNwZWVjaENvbmZpZ1RvVmVydGV4JDEodExpdmVTcGVlY2hDb25maWcoZnJvbVNwZWVjaENvbmZpZykpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRoaW5raW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhpbmtpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGhpbmtpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0aGlua2luZ0NvbmZpZyddLCBmcm9tVGhpbmtpbmdDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5hYmxlQWZmZWN0aXZlRGlhbG9nID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW5hYmxlQWZmZWN0aXZlRGlhbG9nJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ2VuYWJsZUFmZmVjdGl2ZURpYWxvZyddLCBmcm9tRW5hYmxlQWZmZWN0aXZlRGlhbG9nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN5c3RlbUluc3RydWN0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnc3lzdGVtSW5zdHJ1Y3Rpb24nXSwgdENvbnRlbnQoZnJvbVN5c3RlbUluc3RydWN0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29scyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29scyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0VG9vbHMoZnJvbVRvb2xzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b29sVG9WZXJ0ZXgkMSh0VG9vbChpdGVtKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAndG9vbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlc3Npb25SZXN1bXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2Vzc2lvblJlc3VtcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2Vzc2lvblJlc3VtcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnc2Vzc2lvblJlc3VtcHRpb24nXSwgZnJvbVNlc3Npb25SZXN1bXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlucHV0QXVkaW9UcmFuc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5wdXRBdWRpb1RyYW5zY3JpcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW5wdXRBdWRpb1RyYW5zY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnaW5wdXRBdWRpb1RyYW5zY3JpcHRpb24nXSwgZnJvbUlucHV0QXVkaW9UcmFuc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnb3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uJ10sIGZyb21PdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVhbHRpbWVJbnB1dENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JlYWx0aW1lSW5wdXRDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUmVhbHRpbWVJbnB1dENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdyZWFsdGltZUlucHV0Q29uZmlnJ10sIGZyb21SZWFsdGltZUlucHV0Q29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRleHRXaW5kb3dDb21wcmVzc2lvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvbnRleHRXaW5kb3dDb21wcmVzc2lvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Db250ZXh0V2luZG93Q29tcHJlc3Npb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnY29udGV4dFdpbmRvd0NvbXByZXNzaW9uJ10sIGZyb21Db250ZXh0V2luZG93Q29tcHJlc3Npb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvYWN0aXZpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb2FjdGl2aXR5J10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUHJvYWN0aXZpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAncHJvYWN0aXZpdHknXSwgZnJvbVByb2FjdGl2aXR5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZUNvbm5lY3RQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NldHVwJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgbGl2ZUNvbm5lY3RDb25maWdUb01sZGV2JDEoZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZUNvbm5lY3RQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZXR1cCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGxpdmVDb25uZWN0Q29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZU11c2ljU2V0Q29uZmlnUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU11c2ljR2VuZXJhdGlvbkNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ211c2ljR2VuZXJhdGlvbkNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NdXNpY0dlbmVyYXRpb25Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtdXNpY0dlbmVyYXRpb25Db25maWcnXSwgZnJvbU11c2ljR2VuZXJhdGlvbkNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVNdXNpY1NldFdlaWdodGVkUHJvbXB0c1BhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21XZWlnaHRlZFByb21wdHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd3ZWlnaHRlZFByb21wdHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tV2VpZ2h0ZWRQcm9tcHRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21XZWlnaHRlZFByb21wdHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3dlaWdodGVkUHJvbXB0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlU2VuZFJlYWx0aW1lSW5wdXRQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTWVkaWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21lZGlhJ10pO1xuICAgIGlmIChmcm9tTWVkaWEgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdEJsb2JzKGZyb21NZWRpYSk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmxvYlRvTWxkZXYkMihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21lZGlhQ2h1bmtzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BdWRpbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXVkaW8nXSk7XG4gICAgaWYgKGZyb21BdWRpbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F1ZGlvJ10sIGJsb2JUb01sZGV2JDIodEF1ZGlvQmxvYihmcm9tQXVkaW8pKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BdWRpb1N0cmVhbUVuZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2F1ZGlvU3RyZWFtRW5kJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUF1ZGlvU3RyZWFtRW5kICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXVkaW9TdHJlYW1FbmQnXSwgZnJvbUF1ZGlvU3RyZWFtRW5kKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2aWRlbyddKTtcbiAgICBpZiAoZnJvbVZpZGVvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW8nXSwgYmxvYlRvTWxkZXYkMih0SW1hZ2VCbG9iKGZyb21WaWRlbykpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BY3Rpdml0eVN0YXJ0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYWN0aXZpdHlTdGFydCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BY3Rpdml0eVN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYWN0aXZpdHlTdGFydCddLCBmcm9tQWN0aXZpdHlTdGFydCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BY3Rpdml0eUVuZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYWN0aXZpdHlFbmQnXSk7XG4gICAgaWYgKGZyb21BY3Rpdml0eUVuZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FjdGl2aXR5RW5kJ10sIGZyb21BY3Rpdml0eUVuZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVTZW5kUmVhbHRpbWVJbnB1dFBhcmFtZXRlcnNUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTWVkaWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21lZGlhJ10pO1xuICAgIGlmIChmcm9tTWVkaWEgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdEJsb2JzKGZyb21NZWRpYSk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21lZGlhQ2h1bmtzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BdWRpbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXVkaW8nXSk7XG4gICAgaWYgKGZyb21BdWRpbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F1ZGlvJ10sIHRBdWRpb0Jsb2IoZnJvbUF1ZGlvKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BdWRpb1N0cmVhbUVuZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2F1ZGlvU3RyZWFtRW5kJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUF1ZGlvU3RyZWFtRW5kICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXVkaW9TdHJlYW1FbmQnXSwgZnJvbUF1ZGlvU3RyZWFtRW5kKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2aWRlbyddKTtcbiAgICBpZiAoZnJvbVZpZGVvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW8nXSwgdEltYWdlQmxvYihmcm9tVmlkZW8pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BY3Rpdml0eVN0YXJ0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYWN0aXZpdHlTdGFydCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BY3Rpdml0eVN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYWN0aXZpdHlTdGFydCddLCBmcm9tQWN0aXZpdHlTdGFydCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BY3Rpdml0eUVuZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYWN0aXZpdHlFbmQnXSk7XG4gICAgaWYgKGZyb21BY3Rpdml0eUVuZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FjdGl2aXR5RW5kJ10sIGZyb21BY3Rpdml0eUVuZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVTZXJ2ZXJNZXNzYWdlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2V0dXBDb21wbGV0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NldHVwQ29tcGxldGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2V0dXBDb21wbGV0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NldHVwQ29tcGxldGUnXSwgZnJvbVNldHVwQ29tcGxldGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VydmVyQ29udGVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NlcnZlckNvbnRlbnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2VydmVyQ29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NlcnZlckNvbnRlbnQnXSwgZnJvbVNlcnZlckNvbnRlbnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbENhbGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xDYWxsJ10pO1xuICAgIGlmIChmcm9tVG9vbENhbGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b29sQ2FsbCddLCBmcm9tVG9vbENhbGwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbENhbGxDYW5jZWxsYXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0b29sQ2FsbENhbmNlbGxhdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Ub29sQ2FsbENhbmNlbGxhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rvb2xDYWxsQ2FuY2VsbGF0aW9uJ10sIGZyb21Ub29sQ2FsbENhbmNlbGxhdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Vc2FnZU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndXNhZ2VNZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Vc2FnZU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXNhZ2VNZXRhZGF0YSddLCB1c2FnZU1ldGFkYXRhRnJvbVZlcnRleChmcm9tVXNhZ2VNZXRhZGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29Bd2F5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb0F3YXknXSk7XG4gICAgaWYgKGZyb21Hb0F3YXkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb0F3YXknXSwgZnJvbUdvQXdheSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZXNzaW9uUmVzdW1wdGlvblVwZGF0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nlc3Npb25SZXN1bXB0aW9uVXBkYXRlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNlc3Npb25SZXN1bXB0aW9uVXBkYXRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2Vzc2lvblJlc3VtcHRpb25VcGRhdGUnXSwgZnJvbVNlc3Npb25SZXN1bXB0aW9uVXBkYXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcGFydFRvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTWVkaWFSZXNvbHV0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWVkaWFSZXNvbHV0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1lZGlhUmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21lZGlhUmVzb2x1dGlvbiddLCBmcm9tTWVkaWFSZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uUmVzdWx0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uUmVzdWx0J10sIGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4ZWN1dGFibGVDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhlY3V0YWJsZUNvZGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhlY3V0YWJsZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGVjdXRhYmxlQ29kZSddLCBmcm9tRXhlY3V0YWJsZUNvZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVEYXRhJ10pO1xuICAgIGlmIChmcm9tRmlsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlRGF0YSddLCBmaWxlRGF0YVRvTWxkZXYkMihmcm9tRmlsZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10sIGZ1bmN0aW9uQ2FsbFRvTWxkZXYkMihmcm9tRnVuY3Rpb25DYWxsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvblJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25SZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvblJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25SZXNwb25zZSddLCBmcm9tRnVuY3Rpb25SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVEYXRhJ10pO1xuICAgIGlmIChmcm9tSW5saW5lRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lubGluZURhdGEnXSwgYmxvYlRvTWxkZXYkMihmcm9tSW5saW5lRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGV4dCddKTtcbiAgICBpZiAoZnJvbVRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZXh0J10sIGZyb21UZXh0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rob3VnaHQnXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodCddLCBmcm9tVGhvdWdodCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0U2lnbmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhvdWdodFNpZ25hdHVyZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0U2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodFNpZ25hdHVyZSddLCBmcm9tVGhvdWdodFNpZ25hdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlb01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmlkZW9NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WaWRlb01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW9NZXRhZGF0YSddLCBmcm9tVmlkZW9NZXRhZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNlc3Npb25SZXN1bXB0aW9uQ29uZmlnVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21IYW5kbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2hhbmRsZSddKTtcbiAgICBpZiAoZnJvbUhhbmRsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2hhbmRsZSddLCBmcm9tSGFuZGxlKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHJhbnNwYXJlbnQnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zcGFyZW50IHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNwZWVjaENvbmZpZ1RvVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUxhbmd1YWdlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFuZ3VhZ2VDb2RlJ10pO1xuICAgIGlmIChmcm9tTGFuZ3VhZ2VDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbGFuZ3VhZ2VDb2RlJ10sIGZyb21MYW5ndWFnZUNvZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVm9pY2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZvaWNlQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tVm9pY2VDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2b2ljZUNvbmZpZyddLCBmcm9tVm9pY2VDb25maWcpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtdWx0aVNwZWFrZXJWb2ljZUNvbmZpZyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbXVsdGlTcGVha2VyVm9pY2VDb25maWcgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0b29sVG9NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25EZWNsYXJhdGlvbnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmV0cmlldmFsJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXRyaWV2YWwgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2hSZXRyaWV2YWwnXSwgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db21wdXRlclVzZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSk7XG4gICAgaWYgKGZyb21Db21wdXRlclVzZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10sIGZyb21Db21wdXRlclVzZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlU2VhcmNoJ10pO1xuICAgIGlmIChmcm9tRmlsZVNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVTZWFyY2gnXSwgZnJvbUZpbGVTZWFyY2gpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb24nXSwgZnJvbUNvZGVFeGVjdXRpb24pO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbnRlcnByaXNlV2ViU2VhcmNoJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbnRlcnByaXNlV2ViU2VhcmNoIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVNYXBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVNYXBzJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlTWFwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSwgZ29vZ2xlTWFwc1RvTWxkZXYkMihmcm9tR29vZ2xlTWFwcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2gnXSwgZ29vZ2xlU2VhcmNoVG9NbGRldiQyKGZyb21Hb29nbGVTZWFyY2gpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVybENvbnRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VybENvbnRleHQnXSk7XG4gICAgaWYgKGZyb21VcmxDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsQ29udGV4dCddLCBmcm9tVXJsQ29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xUb1ZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbkRlY2xhcmF0aW9uVG9WZXJ0ZXgkMShpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXRyaWV2YWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JldHJpZXZhbCddKTtcbiAgICBpZiAoZnJvbVJldHJpZXZhbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JldHJpZXZhbCddLCBmcm9tUmV0cmlldmFsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2hSZXRyaWV2YWwnXSwgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db21wdXRlclVzZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSk7XG4gICAgaWYgKGZyb21Db21wdXRlclVzZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10sIGZyb21Db21wdXRlclVzZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVTZWFyY2gnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpbGVTZWFyY2ggcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb24nXSwgZnJvbUNvZGVFeGVjdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW50ZXJwcmlzZVdlYlNlYXJjaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VudGVycHJpc2VXZWJTZWFyY2gnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRW50ZXJwcmlzZVdlYlNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VudGVycHJpc2VXZWJTZWFyY2gnXSwgZnJvbUVudGVycHJpc2VXZWJTZWFyY2gpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlTWFwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlTWFwcyddKTtcbiAgICBpZiAoZnJvbUdvb2dsZU1hcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVNYXBzJ10sIGZyb21Hb29nbGVNYXBzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10sIGZyb21Hb29nbGVTZWFyY2gpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJsQ29udGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXJsQ29udGV4dCddKTtcbiAgICBpZiAoZnJvbVVybENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmxDb250ZXh0J10sIGZyb21VcmxDb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXNhZ2VNZXRhZGF0YUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVByb21wdFRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcm9tcHRUb2tlbkNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByb21wdFRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9tcHRUb2tlbkNvdW50J10sIGZyb21Qcm9tcHRUb2tlbkNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhY2hlZENvbnRlbnRUb2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FjaGVkQ29udGVudFRva2VuQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2FjaGVkQ29udGVudFRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYWNoZWRDb250ZW50VG9rZW5Db3VudCddLCBmcm9tQ2FjaGVkQ29udGVudFRva2VuQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VUb2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FuZGlkYXRlc1Rva2VuQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VUb2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VUb2tlbkNvdW50J10sIGZyb21SZXNwb25zZVRva2VuQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbFVzZVByb21wdFRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0b29sVXNlUHJvbXB0VG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Ub29sVXNlUHJvbXB0VG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rvb2xVc2VQcm9tcHRUb2tlbkNvdW50J10sIGZyb21Ub29sVXNlUHJvbXB0VG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0c1Rva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aG91Z2h0c1Rva2VuQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhvdWdodHNUb2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodHNUb2tlbkNvdW50J10sIGZyb21UaG91Z2h0c1Rva2VuQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG90YWxUb2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndG90YWxUb2tlbkNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRvdGFsVG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvdGFsVG9rZW5Db3VudCddLCBmcm9tVG90YWxUb2tlbkNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb21wdFRva2Vuc0RldGFpbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcm9tcHRUb2tlbnNEZXRhaWxzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByb21wdFRva2Vuc0RldGFpbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVByb21wdFRva2Vuc0RldGFpbHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Byb21wdFRva2Vuc0RldGFpbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhY2hlVG9rZW5zRGV0YWlscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhY2hlVG9rZW5zRGV0YWlscycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYWNoZVRva2Vuc0RldGFpbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUNhY2hlVG9rZW5zRGV0YWlscztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FjaGVUb2tlbnNEZXRhaWxzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZVRva2Vuc0RldGFpbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYW5kaWRhdGVzVG9rZW5zRGV0YWlscycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZVRva2Vuc0RldGFpbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVJlc3BvbnNlVG9rZW5zRGV0YWlscztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VUb2tlbnNEZXRhaWxzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sVXNlUHJvbXB0VG9rZW5zRGV0YWlscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rvb2xVc2VQcm9tcHRUb2tlbnNEZXRhaWxzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRvb2xVc2VQcm9tcHRUb2tlbnNEZXRhaWxzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21Ub29sVXNlUHJvbXB0VG9rZW5zRGV0YWlscztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9vbFVzZVByb21wdFRva2Vuc0RldGFpbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRyYWZmaWNUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0cmFmZmljVHlwZSddKTtcbiAgICBpZiAoZnJvbVRyYWZmaWNUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHJhZmZpY1R5cGUnXSwgZnJvbVRyYWZmaWNUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5mdW5jdGlvbiBibG9iVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkYXRhJ10pO1xuICAgIGlmIChmcm9tRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RhdGEnXSwgZnJvbURhdGEpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGlzcGxheU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY2FuZGlkYXRlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db250ZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50J10pO1xuICAgIGlmIChmcm9tQ29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRlbnQnXSwgZnJvbUNvbnRlbnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2l0YXRpb25NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NpdGF0aW9uTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2l0YXRpb25NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NpdGF0aW9uTWV0YWRhdGEnXSwgY2l0YXRpb25NZXRhZGF0YUZyb21NbGRldihmcm9tQ2l0YXRpb25NZXRhZGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9rZW5Db3VudCddKTtcbiAgICBpZiAoZnJvbVRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b2tlbkNvdW50J10sIGZyb21Ub2tlbkNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbmlzaFJlYXNvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmluaXNoUmVhc29uJ10pO1xuICAgIGlmIChmcm9tRmluaXNoUmVhc29uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmluaXNoUmVhc29uJ10sIGZyb21GaW5pc2hSZWFzb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXZnTG9ncHJvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F2Z0xvZ3Byb2JzJ10pO1xuICAgIGlmIChmcm9tQXZnTG9ncHJvYnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdmdMb2dwcm9icyddLCBmcm9tQXZnTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR3JvdW5kaW5nTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdncm91bmRpbmdNZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hcm91bmRpbmdNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dyb3VuZGluZ01ldGFkYXRhJ10sIGZyb21Hcm91bmRpbmdNZXRhZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmRleCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5kZXgnXSk7XG4gICAgaWYgKGZyb21JbmRleCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luZGV4J10sIGZyb21JbmRleCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Mb2dwcm9ic1Jlc3VsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2xvZ3Byb2JzUmVzdWx0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUxvZ3Byb2JzUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbG9ncHJvYnNSZXN1bHQnXSwgZnJvbUxvZ3Byb2JzUmVzdWx0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNhZmV0eVJhdGluZ3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlSYXRpbmdzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNhZmV0eVJhdGluZ3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVNhZmV0eVJhdGluZ3M7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NhZmV0eVJhdGluZ3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVybENvbnRleHRNZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3VybENvbnRleHRNZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21VcmxDb250ZXh0TWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmxDb250ZXh0TWV0YWRhdGEnXSwgZnJvbVVybENvbnRleHRNZXRhZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNpdGF0aW9uTWV0YWRhdGFGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNpdGF0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY2l0YXRpb25Tb3VyY2VzJ10pO1xuICAgIGlmIChmcm9tQ2l0YXRpb25zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21DaXRhdGlvbnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NpdGF0aW9ucyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb21wdXRlVG9rZW5zUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50cyddKTtcbiAgICBpZiAoZnJvbUNvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRDb250ZW50cyhmcm9tQ29udGVudHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb250ZW50cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb21wdXRlVG9rZW5zUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9rZW5zSW5mbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9rZW5zSW5mbyddKTtcbiAgICBpZiAoZnJvbVRva2Vuc0luZm8gIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVRva2Vuc0luZm87XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rva2Vuc0luZm8nXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudEVtYmVkZGluZ0Zyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZhbHVlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmFsdWVzJ10pO1xuICAgIGlmIChmcm9tVmFsdWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmFsdWVzJ10sIGZyb21WYWx1ZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhdGlzdGljcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhdGlzdGljcyddKTtcbiAgICBpZiAoZnJvbVN0YXRpc3RpY3MgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGF0aXN0aWNzJ10sIGNvbnRlbnRFbWJlZGRpbmdTdGF0aXN0aWNzRnJvbVZlcnRleChmcm9tU3RhdGlzdGljcykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZW50RW1iZWRkaW5nU3RhdGlzdGljc0Zyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRydW5jYXRlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHJ1bmNhdGVkJ10pO1xuICAgIGlmIChmcm9tVHJ1bmNhdGVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHJ1bmNhdGVkJ10sIGZyb21UcnVuY2F0ZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9rZW5fY291bnQnXSk7XG4gICAgaWYgKGZyb21Ub2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9rZW5Db3VudCddLCBmcm9tVG9rZW5Db3VudCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhcnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJ0cyddKTtcbiAgICBpZiAoZnJvbVBhcnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21QYXJ0cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0VG9NbGRldiQxKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFydHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJvbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JvbGUnXSk7XG4gICAgaWYgKGZyb21Sb2xlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncm9sZSddLCBmcm9tUm9sZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRyb2xSZWZlcmVuY2VDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29udHJvbFR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRyb2xUeXBlJ10pO1xuICAgIGlmIChmcm9tQ29udHJvbFR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb250cm9sVHlwZSddLCBmcm9tQ29udHJvbFR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5hYmxlQ29udHJvbEltYWdlQ29tcHV0YXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmFibGVDb250cm9sSW1hZ2VDb21wdXRhdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbmFibGVDb250cm9sSW1hZ2VDb21wdXRhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbXB1dGVDb250cm9sJ10sIGZyb21FbmFibGVDb250cm9sSW1hZ2VDb21wdXRhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvdW50VG9rZW5zQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzeXN0ZW1JbnN0cnVjdGlvbiddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3lzdGVtSW5zdHJ1Y3Rpb24gcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbHMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Rvb2xzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dlbmVyYXRpb25Db25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dlbmVyYXRpb25Db25maWcgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY291bnRUb2tlbnNDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TeXN0ZW1JbnN0cnVjdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVN5c3RlbUluc3RydWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N5c3RlbUluc3RydWN0aW9uJ10sIHRDb250ZW50KGZyb21TeXN0ZW1JbnN0cnVjdGlvbikpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVRvb2xzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvb2xUb1ZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29scyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR2VuZXJhdGlvbkNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dlbmVyYXRpb25Db25maWcnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tR2VuZXJhdGlvbkNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydnZW5lcmF0aW9uQ29uZmlnJ10sIGdlbmVyYXRpb25Db25maWdUb1ZlcnRleChmcm9tR2VuZXJhdGlvbkNvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb3VudFRva2Vuc1BhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50cyddKTtcbiAgICBpZiAoZnJvbUNvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRDb250ZW50cyhmcm9tQ29udGVudHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRUb01sZGV2JDEoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb250ZW50cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBjb3VudFRva2Vuc0NvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvdW50VG9rZW5zUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50cyddKTtcbiAgICBpZiAoZnJvbUNvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRDb250ZW50cyhmcm9tQ29udGVudHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb250ZW50cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBjb3VudFRva2Vuc0NvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY291bnRUb2tlbnNSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvdGFsVG9rZW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3RhbFRva2VucyddKTtcbiAgICBpZiAoZnJvbVRvdGFsVG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG90YWxUb2tlbnMnXSwgZnJvbVRvdGFsVG9rZW5zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhY2hlZENvbnRlbnRUb2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FjaGVkQ29udGVudFRva2VuQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2FjaGVkQ29udGVudFRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYWNoZWRDb250ZW50VG9rZW5Db3VudCddLCBmcm9tQ2FjaGVkQ29udGVudFRva2VuQ291bnQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb3VudFRva2Vuc1Jlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvdGFsVG9rZW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3RhbFRva2VucyddKTtcbiAgICBpZiAoZnJvbVRvdGFsVG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG90YWxUb2tlbnMnXSwgZnJvbVRvdGFsVG9rZW5zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlTW9kZWxQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlTW9kZWxQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZU1vZGVsUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZU1vZGVsUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlZGl0SW1hZ2VDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21PdXRwdXRHY3NVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ291dHB1dEdjc1VyaSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dEdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3N0b3JhZ2VVcmknXSwgZnJvbU91dHB1dEdjc1VyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZWdhdGl2ZVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25lZ2F0aXZlUHJvbXB0JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU5lZ2F0aXZlUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnbmVnYXRpdmVQcm9tcHQnXSwgZnJvbU5lZ2F0aXZlUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU51bWJlck9mSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbnVtYmVyT2ZJbWFnZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTnVtYmVyT2ZJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzYW1wbGVDb3VudCddLCBmcm9tTnVtYmVyT2ZJbWFnZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXNwZWN0UmF0aW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FzcGVjdFJhdGlvJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQXNwZWN0UmF0aW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdhc3BlY3RSYXRpbyddLCBmcm9tQXNwZWN0UmF0aW8pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR3VpZGFuY2VTY2FsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2d1aWRhbmNlU2NhbGUnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tR3VpZGFuY2VTY2FsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2d1aWRhbmNlU2NhbGUnXSwgZnJvbUd1aWRhbmNlU2NhbGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNlZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzZWVkJ10sIGZyb21TZWVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNhZmV0eUZpbHRlckxldmVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5RmlsdGVyTGV2ZWwnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzYWZldHlTZXR0aW5nJ10sIGZyb21TYWZldHlGaWx0ZXJMZXZlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QZXJzb25HZW5lcmF0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGVyc29uR2VuZXJhdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QZXJzb25HZW5lcmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAncGVyc29uR2VuZXJhdGlvbiddLCBmcm9tUGVyc29uR2VuZXJhdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmNsdWRlU2FmZXR5QXR0cmlidXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2luY2x1ZGVTYWZldHlBdHRyaWJ1dGVzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUluY2x1ZGVTYWZldHlBdHRyaWJ1dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnaW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMnXSwgZnJvbUluY2x1ZGVTYWZldHlBdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUluY2x1ZGVSYWlSZWFzb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbmNsdWRlUmFpUmVhc29uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUluY2x1ZGVSYWlSZWFzb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdpbmNsdWRlUmFpUmVhc29uJ10sIGZyb21JbmNsdWRlUmFpUmVhc29uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhbmd1YWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYW5ndWFnZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUxhbmd1YWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnbGFuZ3VhZ2UnXSwgZnJvbUxhbmd1YWdlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dE1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0TWltZVR5cGUnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0TWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdvdXRwdXRPcHRpb25zJywgJ21pbWVUeXBlJ10sIGZyb21PdXRwdXRNaW1lVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRDb21wcmVzc2lvblF1YWxpdHknLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnb3V0cHV0T3B0aW9ucycsICdjb21wcmVzc2lvblF1YWxpdHknXSwgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BZGRXYXRlcm1hcmsgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FkZFdhdGVybWFyayddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUFkZFdhdGVybWFyayAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2FkZFdhdGVybWFyayddLCBmcm9tQWRkV2F0ZXJtYXJrKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhYmVscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGFiZWxzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2xhYmVscyddLCBmcm9tTGFiZWxzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVkaXRNb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlZGl0TW9kZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUVkaXRNb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZWRpdE1vZGUnXSwgZnJvbUVkaXRNb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJhc2VTdGVwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmFzZVN0ZXBzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQmFzZVN0ZXBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZWRpdENvbmZpZycsICdiYXNlU3RlcHMnXSwgZnJvbUJhc2VTdGVwcyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVkaXRJbWFnZVBhcmFtZXRlcnNJbnRlcm5hbFRvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvbXB0J10pO1xuICAgIGlmIChmcm9tUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3Byb21wdCddLCBmcm9tUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlZmVyZW5jZUltYWdlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JlZmVyZW5jZUltYWdlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZWZlcmVuY2VJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVJlZmVyZW5jZUltYWdlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWZlcmVuY2VJbWFnZUFQSUludGVybmFsVG9WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncmVmZXJlbmNlSW1hZ2VzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGVkaXRJbWFnZUNvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZWRpdEltYWdlUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR2VuZXJhdGVkSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlZGljdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR2VuZXJhdGVkSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21HZW5lcmF0ZWRJbWFnZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVkSW1hZ2VGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGVkSW1hZ2VzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVtYmVkQ29udGVudENvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVGFza1R5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rhc2tUeXBlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGFza1R5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncmVxdWVzdHNbXScsICd0YXNrVHlwZSddLCBmcm9tVGFza1R5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGl0bGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RpdGxlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGl0bGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncmVxdWVzdHNbXScsICd0aXRsZSddLCBmcm9tVGl0bGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0RGltZW5zaW9uYWxpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXREaW1lbnNpb25hbGl0eScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXREaW1lbnNpb25hbGl0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydyZXF1ZXN0c1tdJywgJ291dHB1dERpbWVuc2lvbmFsaXR5J10sIGZyb21PdXRwdXREaW1lbnNpb25hbGl0eSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaW1lVHlwZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdXRvVHJ1bmNhdGUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F1dG9UcnVuY2F0ZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbWJlZENvbnRlbnRDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UYXNrVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGFza1R5cGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UYXNrVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbXScsICd0YXNrX3R5cGUnXSwgZnJvbVRhc2tUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRpdGxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aXRsZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRpdGxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1tdJywgJ3RpdGxlJ10sIGZyb21UaXRsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXREaW1lbnNpb25hbGl0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dERpbWVuc2lvbmFsaXR5JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dERpbWVuc2lvbmFsaXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnb3V0cHV0RGltZW5zaW9uYWxpdHknXSwgZnJvbU91dHB1dERpbWVuc2lvbmFsaXR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1tdJywgJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BdXRvVHJ1bmNhdGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1dG9UcnVuY2F0ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUF1dG9UcnVuY2F0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2F1dG9UcnVuY2F0ZSddLCBmcm9tQXV0b1RydW5jYXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZW1iZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdENvbnRlbnRzRm9yRW1iZWQoYXBpQ2xpZW50LCBmcm9tQ29udGVudHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXF1ZXN0c1tdJywgJ2NvbnRlbnQnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgZW1iZWRDb250ZW50Q29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Nb2RlbEZvckVtYmVkQ29udGVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbEZvckVtYmVkQ29udGVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlcXVlc3RzW10nLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsRm9yRW1iZWRDb250ZW50KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVtYmVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudHMnXSk7XG4gICAgaWYgKGZyb21Db250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0Q29udGVudHNGb3JFbWJlZChhcGlDbGllbnQsIGZyb21Db250ZW50cyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1tdJywgJ2NvbnRlbnQnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgZW1iZWRDb250ZW50Q29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbWJlZENvbnRlbnRSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVtYmVkZGluZ3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VtYmVkZGluZ3MnXSk7XG4gICAgaWYgKGZyb21FbWJlZGRpbmdzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21FbWJlZGRpbmdzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbWJlZGRpbmdzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0YWRhdGEnXSk7XG4gICAgaWYgKGZyb21NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21ldGFkYXRhJ10sIGZyb21NZXRhZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVtYmVkQ29udGVudFJlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVtYmVkZGluZ3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVkaWN0aW9uc1tdJyxcbiAgICAgICAgJ2VtYmVkZGluZ3MnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRW1iZWRkaW5ncyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRW1iZWRkaW5ncztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50RW1iZWRkaW5nRnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VtYmVkZGluZ3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWV0YWRhdGEnXSwgZnJvbU1ldGFkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZW5kcG9pbnRGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmRwb2ludCddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlcGxveWVkTW9kZWxJZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2RlcGxveWVkTW9kZWxJZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21EZXBsb3llZE1vZGVsSWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXBsb3llZE1vZGVsSWQnXSwgZnJvbURlcGxveWVkTW9kZWxJZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZpbGVEYXRhVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaXNwbGF5TmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZVVyaSddKTtcbiAgICBpZiAoZnJvbUZpbGVVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlVXJpJ10sIGZyb21GaWxlVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25DYWxsVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaWQnXSk7XG4gICAgaWYgKGZyb21JZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lkJ10sIGZyb21JZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BcmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhcmdzJ10pO1xuICAgIGlmIChmcm9tQXJncyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FyZ3MnXSwgZnJvbUFyZ3MpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFydGlhbEFyZ3MnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcnRpYWxBcmdzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3dpbGxDb250aW51ZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignd2lsbENvbnRpbnVlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGUnXSk7XG4gICAgaWYgKGZyb21Nb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZSddLCBmcm9tTW9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BbGxvd2VkRnVuY3Rpb25OYW1lcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2FsbG93ZWRGdW5jdGlvbk5hbWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYWxsb3dlZEZ1bmN0aW9uTmFtZXMnXSwgZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RyZWFtRnVuY3Rpb25DYWxsQXJndW1lbnRzJ10pICE9PVxuICAgICAgICB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHJlYW1GdW5jdGlvbkNhbGxBcmd1bWVudHMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25EZWNsYXJhdGlvblRvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JlaGF2aW9yJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiZWhhdmlvciBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFyYW1ldGVycyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFyYW1ldGVycyddKTtcbiAgICBpZiAoZnJvbVBhcmFtZXRlcnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzJ10sIGZyb21QYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGFyYW1ldGVyc0pzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzSnNvblNjaGVtYSddLCBmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCBmcm9tUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSnNvblNjaGVtYSddLCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVDb250ZW50Q29uZmlnVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVN5c3RlbUluc3RydWN0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3lzdGVtSW5zdHJ1Y3Rpb24nXSwgY29udGVudFRvTWxkZXYkMSh0Q29udGVudChmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24pKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZW1wZXJhdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGVtcGVyYXR1cmUnXSk7XG4gICAgaWYgKGZyb21UZW1wZXJhdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10sIGZyb21UZW1wZXJhdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BQID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BQJ10pO1xuICAgIGlmIChmcm9tVG9wUCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvcFAnXSwgZnJvbVRvcFApO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wSyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wSyddKTtcbiAgICBpZiAoZnJvbVRvcEsgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3BLJ10sIGZyb21Ub3BLKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhbmRpZGF0ZUNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FuZGlkYXRlQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2FuZGlkYXRlQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYW5kaWRhdGVDb3VudCddLCBmcm9tQ2FuZGlkYXRlQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4T3V0cHV0VG9rZW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWF4T3V0cHV0VG9rZW5zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1heE91dHB1dFRva2VucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21heE91dHB1dFRva2VucyddLCBmcm9tTWF4T3V0cHV0VG9rZW5zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0b3BTZXF1ZW5jZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzdG9wU2VxdWVuY2VzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVN0b3BTZXF1ZW5jZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdG9wU2VxdWVuY2VzJ10sIGZyb21TdG9wU2VxdWVuY2VzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTG9ncHJvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZUxvZ3Byb2JzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTG9ncHJvYnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUxvZ3Byb2JzJ10sIGZyb21SZXNwb25zZUxvZ3Byb2JzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxvZ3Byb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsb2dwcm9icyddKTtcbiAgICBpZiAoZnJvbUxvZ3Byb2JzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbG9ncHJvYnMnXSwgZnJvbUxvZ3Byb2JzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByZXNlbmNlUGVuYWx0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZXNlbmNlUGVuYWx0eScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QcmVzZW5jZVBlbmFsdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcmVzZW5jZVBlbmFsdHknXSwgZnJvbVByZXNlbmNlUGVuYWx0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GcmVxdWVuY3lQZW5hbHR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnJlcXVlbmN5UGVuYWx0eScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GcmVxdWVuY3lQZW5hbHR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnJlcXVlbmN5UGVuYWx0eSddLCBmcm9tRnJlcXVlbmN5UGVuYWx0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pO1xuICAgIGlmIChmcm9tU2VlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NlZWQnXSwgZnJvbVNlZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VNaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTWltZVR5cGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VNaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTWltZVR5cGUnXSwgZnJvbVJlc3BvbnNlTWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VTY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZVNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZVNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlU2NoZW1hJ10sIHRTY2hlbWEoZnJvbVJlc3BvbnNlU2NoZW1hKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUpzb25TY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZUpzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VKc29uU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VKc29uU2NoZW1hJ10sIGZyb21SZXNwb25zZUpzb25TY2hlbWEpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyb3V0aW5nQ29uZmlnJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyb3V0aW5nQ29uZmlnIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsU2VsZWN0aW9uQ29uZmlnJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtb2RlbFNlbGVjdGlvbkNvbmZpZyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5U2V0dGluZ3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlTZXR0aW5ncycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TYWZldHlTZXR0aW5ncyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tU2FmZXR5U2V0dGluZ3M7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2FmZXR5U2V0dGluZ1RvTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2FmZXR5U2V0dGluZ3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29scyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRUb29scyhmcm9tVG9vbHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvb2xUb01sZGV2JDEodFRvb2woaXRlbSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3Rvb2xzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29sQ29uZmlnJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29sQ29uZmlnJ10sIHRvb2xDb25maWdUb01sZGV2KGZyb21Ub29sQ29uZmlnKSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhYmVscyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbGFiZWxzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYWNoZWRDb250ZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FjaGVkQ29udGVudCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21DYWNoZWRDb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2NhY2hlZENvbnRlbnQnXSwgdENhY2hlZENvbnRlbnROYW1lKGFwaUNsaWVudCwgZnJvbUNhY2hlZENvbnRlbnQpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTW9kYWxpdGllcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZU1vZGFsaXRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZU1vZGFsaXRpZXMnXSwgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZWRpYVJlc29sdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtZWRpYVJlc29sdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWVkaWFSZXNvbHV0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWVkaWFSZXNvbHV0aW9uJ10sIGZyb21NZWRpYVJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3BlZWNoQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzcGVlY2hDb25maWcnXSk7XG4gICAgaWYgKGZyb21TcGVlY2hDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzcGVlY2hDb25maWcnXSwgdFNwZWVjaENvbmZpZyhmcm9tU3BlZWNoQ29uZmlnKSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1ZGlvVGltZXN0YW1wJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdWRpb1RpbWVzdGFtcCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhpbmtpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aGlua2luZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaGlua2luZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RoaW5raW5nQ29uZmlnJ10sIGZyb21UaGlua2luZ0NvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2VDb25maWcnXSk7XG4gICAgaWYgKGZyb21JbWFnZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ltYWdlQ29uZmlnJ10sIGltYWdlQ29uZmlnVG9NbGRldihmcm9tSW1hZ2VDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVDb250ZW50Q29uZmlnVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TeXN0ZW1JbnN0cnVjdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVN5c3RlbUluc3RydWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N5c3RlbUluc3RydWN0aW9uJ10sIHRDb250ZW50KGZyb21TeXN0ZW1JbnN0cnVjdGlvbikpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGVtcGVyYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10pO1xuICAgIGlmIChmcm9tVGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZW1wZXJhdHVyZSddLCBmcm9tVGVtcGVyYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wUCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wUCddKTtcbiAgICBpZiAoZnJvbVRvcFAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3BQJ10sIGZyb21Ub3BQKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcEsgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcEsnXSk7XG4gICAgaWYgKGZyb21Ub3BLICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9wSyddLCBmcm9tVG9wSyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYW5kaWRhdGVDb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhbmRpZGF0ZUNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNhbmRpZGF0ZUNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FuZGlkYXRlQ291bnQnXSwgZnJvbUNhbmRpZGF0ZUNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heE91dHB1dFRva2VucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21heE91dHB1dFRva2VucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NYXhPdXRwdXRUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXhPdXRwdXRUb2tlbnMnXSwgZnJvbU1heE91dHB1dFRva2Vucyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdG9wU2VxdWVuY2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3RvcFNlcXVlbmNlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TdG9wU2VxdWVuY2VzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RvcFNlcXVlbmNlcyddLCBmcm9tU3RvcFNlcXVlbmNlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUxvZ3Byb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VMb2dwcm9icycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUxvZ3Byb2JzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VMb2dwcm9icyddLCBmcm9tUmVzcG9uc2VMb2dwcm9icyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Mb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbG9ncHJvYnMnXSk7XG4gICAgaWYgKGZyb21Mb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xvZ3Byb2JzJ10sIGZyb21Mb2dwcm9icyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QcmVzZW5jZVBlbmFsdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVzZW5jZVBlbmFsdHknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlc2VuY2VQZW5hbHR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJlc2VuY2VQZW5hbHR5J10sIGZyb21QcmVzZW5jZVBlbmFsdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnJlcXVlbmN5UGVuYWx0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2ZyZXF1ZW5jeVBlbmFsdHknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnJlcXVlbmN5UGVuYWx0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZyZXF1ZW5jeVBlbmFsdHknXSwgZnJvbUZyZXF1ZW5jeVBlbmFsdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKTtcbiAgICBpZiAoZnJvbVNlZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZWVkJ10sIGZyb21TZWVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZU1pbWVUeXBlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZU1pbWVUeXBlJ10sIGZyb21SZXNwb25zZU1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VTY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VTY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZVNjaGVtYSddLCB0U2NoZW1hKGZyb21SZXNwb25zZVNjaGVtYSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSnNvblNjaGVtYSddLCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJvdXRpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyb3V0aW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJvdXRpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb3V0aW5nQ29uZmlnJ10sIGZyb21Sb3V0aW5nQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1vZGVsU2VsZWN0aW9uQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbW9kZWxTZWxlY3Rpb25Db25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTW9kZWxTZWxlY3Rpb25Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbENvbmZpZyddLCBmcm9tTW9kZWxTZWxlY3Rpb25Db25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5U2V0dGluZ3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlTZXR0aW5ncycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TYWZldHlTZXR0aW5ncyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tU2FmZXR5U2V0dGluZ3M7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzYWZldHlTZXR0aW5ncyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdFRvb2xzKGZyb21Ub29scyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9vbFRvVmVydGV4KHRUb29sKGl0ZW0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29scyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbENvbmZpZyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndG9vbENvbmZpZyddLCBmcm9tVG9vbENvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYWJlbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhYmVscyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUxhYmVscyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydsYWJlbHMnXSwgZnJvbUxhYmVscyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYWNoZWRDb250ZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FjaGVkQ29udGVudCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21DYWNoZWRDb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2NhY2hlZENvbnRlbnQnXSwgdENhY2hlZENvbnRlbnROYW1lKGFwaUNsaWVudCwgZnJvbUNhY2hlZENvbnRlbnQpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTW9kYWxpdGllcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZU1vZGFsaXRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZU1vZGFsaXRpZXMnXSwgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZWRpYVJlc29sdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtZWRpYVJlc29sdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWVkaWFSZXNvbHV0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWVkaWFSZXNvbHV0aW9uJ10sIGZyb21NZWRpYVJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3BlZWNoQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzcGVlY2hDb25maWcnXSk7XG4gICAgaWYgKGZyb21TcGVlY2hDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzcGVlY2hDb25maWcnXSwgc3BlZWNoQ29uZmlnVG9WZXJ0ZXgodFNwZWVjaENvbmZpZyhmcm9tU3BlZWNoQ29uZmlnKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXVkaW9UaW1lc3RhbXAgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhdWRpb1RpbWVzdGFtcCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BdWRpb1RpbWVzdGFtcCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F1ZGlvVGltZXN0YW1wJ10sIGZyb21BdWRpb1RpbWVzdGFtcCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaGlua2luZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RoaW5raW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRoaW5raW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhpbmtpbmdDb25maWcnXSwgZnJvbVRoaW5raW5nQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZUNvbmZpZyddKTtcbiAgICBpZiAoZnJvbUltYWdlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2VDb25maWcnXSwgaW1hZ2VDb25maWdUb1ZlcnRleChmcm9tSW1hZ2VDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdENvbnRlbnRzKGZyb21Db250ZW50cyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudFRvTWxkZXYkMShpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRlbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRpb25Db25maWcnXSwgZ2VuZXJhdGVDb250ZW50Q29uZmlnVG9NbGRldihhcGlDbGllbnQsIGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudHMnXSk7XG4gICAgaWYgKGZyb21Db250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0Q29udGVudHMoZnJvbUNvbnRlbnRzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29udGVudHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGlvbkNvbmZpZyddLCBnZW5lcmF0ZUNvbnRlbnRDb25maWdUb1ZlcnRleChhcGlDbGllbnQsIGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FuZGlkYXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY2FuZGlkYXRlcyddKTtcbiAgICBpZiAoZnJvbUNhbmRpZGF0ZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUNhbmRpZGF0ZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FuZGlkYXRlRnJvbU1sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FuZGlkYXRlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZWxWZXJzaW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbFZlcnNpb24nXSk7XG4gICAgaWYgKGZyb21Nb2RlbFZlcnNpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbFZlcnNpb24nXSwgZnJvbU1vZGVsVmVyc2lvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9tcHRGZWVkYmFjayA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Byb21wdEZlZWRiYWNrJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByb21wdEZlZWRiYWNrICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJvbXB0RmVlZGJhY2snXSwgZnJvbVByb21wdEZlZWRiYWNrKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlSWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlSWQnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUlkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VJZCddLCBmcm9tUmVzcG9uc2VJZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Vc2FnZU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndXNhZ2VNZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Vc2FnZU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXNhZ2VNZXRhZGF0YSddLCBmcm9tVXNhZ2VNZXRhZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlQ29udGVudFJlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhbmRpZGF0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NhbmRpZGF0ZXMnXSk7XG4gICAgaWYgKGZyb21DYW5kaWRhdGVzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21DYW5kaWRhdGVzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYW5kaWRhdGVzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DcmVhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjcmVhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tQ3JlYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSwgZnJvbUNyZWF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZWxWZXJzaW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbFZlcnNpb24nXSk7XG4gICAgaWYgKGZyb21Nb2RlbFZlcnNpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbFZlcnNpb24nXSwgZnJvbU1vZGVsVmVyc2lvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9tcHRGZWVkYmFjayA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Byb21wdEZlZWRiYWNrJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByb21wdEZlZWRiYWNrICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJvbXB0RmVlZGJhY2snXSwgZnJvbVByb21wdEZlZWRiYWNrKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlSWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlSWQnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUlkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VJZCddLCBmcm9tUmVzcG9uc2VJZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Vc2FnZU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndXNhZ2VNZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Vc2FnZU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXNhZ2VNZXRhZGF0YSddLCBmcm9tVXNhZ2VNZXRhZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlSW1hZ2VzQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ291dHB1dEdjc1VyaSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3V0cHV0R2NzVXJpIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25lZ2F0aXZlUHJvbXB0J10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduZWdhdGl2ZVByb21wdCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTnVtYmVyT2ZJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdudW1iZXJPZkltYWdlcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OdW1iZXJPZkltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhbXBsZUNvdW50J10sIGZyb21OdW1iZXJPZkltYWdlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Bc3BlY3RSYXRpbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXNwZWN0UmF0aW8nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Bc3BlY3RSYXRpbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2FzcGVjdFJhdGlvJ10sIGZyb21Bc3BlY3RSYXRpbyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HdWlkYW5jZVNjYWxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ3VpZGFuY2VTY2FsZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21HdWlkYW5jZVNjYWxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZ3VpZGFuY2VTY2FsZSddLCBmcm9tR3VpZGFuY2VTY2FsZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlZWQgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNhZmV0eUZpbHRlckxldmVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5RmlsdGVyTGV2ZWwnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzYWZldHlTZXR0aW5nJ10sIGZyb21TYWZldHlGaWx0ZXJMZXZlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QZXJzb25HZW5lcmF0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGVyc29uR2VuZXJhdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QZXJzb25HZW5lcmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAncGVyc29uR2VuZXJhdGlvbiddLCBmcm9tUGVyc29uR2VuZXJhdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmNsdWRlU2FmZXR5QXR0cmlidXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2luY2x1ZGVTYWZldHlBdHRyaWJ1dGVzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUluY2x1ZGVTYWZldHlBdHRyaWJ1dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnaW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMnXSwgZnJvbUluY2x1ZGVTYWZldHlBdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUluY2x1ZGVSYWlSZWFzb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbmNsdWRlUmFpUmVhc29uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUluY2x1ZGVSYWlSZWFzb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdpbmNsdWRlUmFpUmVhc29uJ10sIGZyb21JbmNsdWRlUmFpUmVhc29uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhbmd1YWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYW5ndWFnZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUxhbmd1YWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnbGFuZ3VhZ2UnXSwgZnJvbUxhbmd1YWdlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dE1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0TWltZVR5cGUnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0TWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdvdXRwdXRPcHRpb25zJywgJ21pbWVUeXBlJ10sIGZyb21PdXRwdXRNaW1lVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRDb21wcmVzc2lvblF1YWxpdHknLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnb3V0cHV0T3B0aW9ucycsICdjb21wcmVzc2lvblF1YWxpdHknXSwgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FkZFdhdGVybWFyayddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYWRkV2F0ZXJtYXJrIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhYmVscyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbGFiZWxzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZVNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUltYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhbXBsZUltYWdlU2l6ZSddLCBmcm9tSW1hZ2VTaXplKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5oYW5jZVByb21wdCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZW5oYW5jZVByb21wdCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUltYWdlc0NvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU91dHB1dEdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0R2NzVXJpJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0R2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc3RvcmFnZVVyaSddLCBmcm9tT3V0cHV0R2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5lZ2F0aXZlUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmVnYXRpdmVQcm9tcHQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTmVnYXRpdmVQcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICduZWdhdGl2ZVByb21wdCddLCBmcm9tTmVnYXRpdmVQcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTnVtYmVyT2ZJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdudW1iZXJPZkltYWdlcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OdW1iZXJPZkltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhbXBsZUNvdW50J10sIGZyb21OdW1iZXJPZkltYWdlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Bc3BlY3RSYXRpbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXNwZWN0UmF0aW8nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Bc3BlY3RSYXRpbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2FzcGVjdFJhdGlvJ10sIGZyb21Bc3BlY3RSYXRpbyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HdWlkYW5jZVNjYWxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ3VpZGFuY2VTY2FsZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21HdWlkYW5jZVNjYWxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZ3VpZGFuY2VTY2FsZSddLCBmcm9tR3VpZGFuY2VTY2FsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2VlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NlZWQnXSwgZnJvbVNlZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlGaWx0ZXJMZXZlbCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TYWZldHlGaWx0ZXJMZXZlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhZmV0eVNldHRpbmcnXSwgZnJvbVNhZmV0eUZpbHRlckxldmVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBlcnNvbkdlbmVyYXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwZXJzb25HZW5lcmF0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBlcnNvbkdlbmVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdwZXJzb25HZW5lcmF0aW9uJ10sIGZyb21QZXJzb25HZW5lcmF0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUluY2x1ZGVTYWZldHlBdHRyaWJ1dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdpbmNsdWRlU2FmZXR5QXR0cmlidXRlcyddLCBmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5jbHVkZVJhaVJlYXNvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2luY2x1ZGVSYWlSZWFzb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW5jbHVkZVJhaVJlYXNvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2luY2x1ZGVSYWlSZWFzb24nXSwgZnJvbUluY2x1ZGVSYWlSZWFzb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFuZ3VhZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhbmd1YWdlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGFuZ3VhZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdsYW5ndWFnZSddLCBmcm9tTGFuZ3VhZ2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0TWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRNaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dE9wdGlvbnMnLCAnbWltZVR5cGUnXSwgZnJvbU91dHB1dE1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dENvbXByZXNzaW9uUXVhbGl0eScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdvdXRwdXRPcHRpb25zJywgJ2NvbXByZXNzaW9uUXVhbGl0eSddLCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFkZFdhdGVybWFyayA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYWRkV2F0ZXJtYXJrJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQWRkV2F0ZXJtYXJrICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnYWRkV2F0ZXJtYXJrJ10sIGZyb21BZGRXYXRlcm1hcmspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFiZWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MYWJlbHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnbGFiZWxzJ10sIGZyb21MYWJlbHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbWFnZVNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzYW1wbGVJbWFnZVNpemUnXSwgZnJvbUltYWdlU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmhhbmNlUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW5oYW5jZVByb21wdCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FbmhhbmNlUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZW5oYW5jZVByb21wdCddLCBmcm9tRW5oYW5jZVByb21wdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlSW1hZ2VzUGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9tcHQnXSk7XG4gICAgaWYgKGZyb21Qcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncHJvbXB0J10sIGZyb21Qcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBnZW5lcmF0ZUltYWdlc0NvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUltYWdlc1BhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb21wdCddKTtcbiAgICBpZiAoZnJvbVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdwcm9tcHQnXSwgZnJvbVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGdlbmVyYXRlSW1hZ2VzQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUltYWdlc1Jlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR2VuZXJhdGVkSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlZGljdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR2VuZXJhdGVkSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21HZW5lcmF0ZWRJbWFnZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVkSW1hZ2VGcm9tTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0ZWRJbWFnZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Bvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Qb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMnXSwgc2FmZXR5QXR0cmlidXRlc0Zyb21NbGRldihmcm9tUG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlSW1hZ2VzUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR2VuZXJhdGVkSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlZGljdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR2VuZXJhdGVkSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21HZW5lcmF0ZWRJbWFnZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVkSW1hZ2VGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGVkSW1hZ2VzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzJ10sIHNhZmV0eUF0dHJpYnV0ZXNGcm9tVmVydGV4KGZyb21Qb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVWaWRlb3NDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU51bWJlck9mVmlkZW9zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbnVtYmVyT2ZWaWRlb3MnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTnVtYmVyT2ZWaWRlb3MgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzYW1wbGVDb3VudCddLCBmcm9tTnVtYmVyT2ZWaWRlb3MpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRHY3NVcmknXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dHB1dEdjc1VyaSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmcHMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZwcyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRHVyYXRpb25TZWNvbmRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZHVyYXRpb25TZWNvbmRzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUR1cmF0aW9uU2Vjb25kcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2R1cmF0aW9uU2Vjb25kcyddLCBmcm9tRHVyYXRpb25TZWNvbmRzKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2VlZCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXNwZWN0UmF0aW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FzcGVjdFJhdGlvJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQXNwZWN0UmF0aW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdhc3BlY3RSYXRpbyddLCBmcm9tQXNwZWN0UmF0aW8pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzb2x1dGlvbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdyZXNvbHV0aW9uJ10sIGZyb21SZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBlcnNvbkdlbmVyYXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwZXJzb25HZW5lcmF0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBlcnNvbkdlbmVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdwZXJzb25HZW5lcmF0aW9uJ10sIGZyb21QZXJzb25HZW5lcmF0aW9uKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHVic3ViVG9waWMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3B1YnN1YlRvcGljIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZWdhdGl2ZVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25lZ2F0aXZlUHJvbXB0JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU5lZ2F0aXZlUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnbmVnYXRpdmVQcm9tcHQnXSwgZnJvbU5lZ2F0aXZlUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuaGFuY2VQcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmhhbmNlUHJvbXB0JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUVuaGFuY2VQcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdlbmhhbmNlUHJvbXB0J10sIGZyb21FbmhhbmNlUHJvbXB0KTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2VuZXJhdGVBdWRpbyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2VuZXJhdGVBdWRpbyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFzdEZyYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYXN0RnJhbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MYXN0RnJhbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ2xhc3RGcmFtZSddLCBpbWFnZVRvTWxkZXYoZnJvbUxhc3RGcmFtZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVmZXJlbmNlSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVmZXJlbmNlSW1hZ2VzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVJlZmVyZW5jZUltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUmVmZXJlbmNlSW1hZ2VzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZGVvR2VuZXJhdGlvblJlZmVyZW5jZUltYWdlVG9NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncmVmZXJlbmNlSW1hZ2VzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21hc2snXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hc2sgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29tcHJlc3Npb25RdWFsaXR5J10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb21wcmVzc2lvblF1YWxpdHkgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVWaWRlb3NDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OdW1iZXJPZlZpZGVvcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ251bWJlck9mVmlkZW9zJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU51bWJlck9mVmlkZW9zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FtcGxlQ291bnQnXSwgZnJvbU51bWJlck9mVmlkZW9zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dEdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0R2NzVXJpJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0R2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc3RvcmFnZVVyaSddLCBmcm9tT3V0cHV0R2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnBzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRnBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZnBzJ10sIGZyb21GcHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRHVyYXRpb25TZWNvbmRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZHVyYXRpb25TZWNvbmRzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUR1cmF0aW9uU2Vjb25kcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2R1cmF0aW9uU2Vjb25kcyddLCBmcm9tRHVyYXRpb25TZWNvbmRzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Bc3BlY3RSYXRpbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXNwZWN0UmF0aW8nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Bc3BlY3RSYXRpbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2FzcGVjdFJhdGlvJ10sIGZyb21Bc3BlY3RSYXRpbyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNvbHV0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNvbHV0aW9uJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3Jlc29sdXRpb24nXSwgZnJvbVJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGVyc29uR2VuZXJhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BlcnNvbkdlbmVyYXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGVyc29uR2VuZXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3BlcnNvbkdlbmVyYXRpb24nXSwgZnJvbVBlcnNvbkdlbmVyYXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHVic3ViVG9waWMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3B1YnN1YlRvcGljJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUHVic3ViVG9waWMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdwdWJzdWJUb3BpYyddLCBmcm9tUHVic3ViVG9waWMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmVnYXRpdmVQcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZWdhdGl2ZVByb21wdCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OZWdhdGl2ZVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ25lZ2F0aXZlUHJvbXB0J10sIGZyb21OZWdhdGl2ZVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmhhbmNlUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW5oYW5jZVByb21wdCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FbmhhbmNlUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZW5oYW5jZVByb21wdCddLCBmcm9tRW5oYW5jZVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HZW5lcmF0ZUF1ZGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ2VuZXJhdGVBdWRpbycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21HZW5lcmF0ZUF1ZGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZ2VuZXJhdGVBdWRpbyddLCBmcm9tR2VuZXJhdGVBdWRpbyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYXN0RnJhbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhc3RGcmFtZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUxhc3RGcmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAnbGFzdEZyYW1lJ10sIGltYWdlVG9WZXJ0ZXgoZnJvbUxhc3RGcmFtZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVmZXJlbmNlSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVmZXJlbmNlSW1hZ2VzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVJlZmVyZW5jZUltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUmVmZXJlbmNlSW1hZ2VzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZGVvR2VuZXJhdGlvblJlZmVyZW5jZUltYWdlVG9WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3JlZmVyZW5jZUltYWdlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWFzayA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWFzayddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU1hc2sgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ21hc2snXSwgdmlkZW9HZW5lcmF0aW9uTWFza1RvVmVydGV4KGZyb21NYXNrKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db21wcmVzc2lvblF1YWxpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb21wcmVzc2lvblF1YWxpdHknLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ29tcHJlc3Npb25RdWFsaXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnY29tcHJlc3Npb25RdWFsaXR5J10sIGZyb21Db21wcmVzc2lvblF1YWxpdHkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc09wZXJhdGlvbkZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWV0YWRhdGEnXSwgZnJvbU1ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvbmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RvbmUnXSk7XG4gICAgaWYgKGZyb21Eb25lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9uZSddLCBmcm9tRG9uZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZyb21FcnJvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlJyxcbiAgICAgICAgJ2dlbmVyYXRlVmlkZW9SZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlJ10sIGdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tTWxkZXYoZnJvbVJlc3BvbnNlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWV0YWRhdGEnXSwgZnJvbU1ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvbmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RvbmUnXSk7XG4gICAgaWYgKGZyb21Eb25lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9uZSddLCBmcm9tRG9uZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZyb21FcnJvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2UnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlJ10sIGdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tVmVydGV4KGZyb21SZXNwb25zZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc1BhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvbXB0J10pO1xuICAgIGlmIChmcm9tUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3Byb21wdCddLCBmcm9tUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZSddKTtcbiAgICBpZiAoZnJvbUltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ2ltYWdlJ10sIGltYWdlVG9NbGRldihmcm9tSW1hZ2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2aWRlbyddKTtcbiAgICBpZiAoZnJvbVZpZGVvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3ZpZGVvJ10sIHZpZGVvVG9NbGRldihmcm9tVmlkZW8pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNvdXJjZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc291cmNlJ10pO1xuICAgIGlmIChmcm9tU291cmNlICE9IG51bGwpIHtcbiAgICAgICAgZ2VuZXJhdGVWaWRlb3NTb3VyY2VUb01sZGV2KGZyb21Tb3VyY2UsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgZ2VuZXJhdGVWaWRlb3NDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVWaWRlb3NQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9tcHQnXSk7XG4gICAgaWYgKGZyb21Qcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncHJvbXB0J10sIGZyb21Qcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlJ10pO1xuICAgIGlmIChmcm9tSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAnaW1hZ2UnXSwgaW1hZ2VUb1ZlcnRleChmcm9tSW1hZ2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2aWRlbyddKTtcbiAgICBpZiAoZnJvbVZpZGVvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3ZpZGVvJ10sIHZpZGVvVG9WZXJ0ZXgoZnJvbVZpZGVvKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Tb3VyY2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NvdXJjZSddKTtcbiAgICBpZiAoZnJvbVNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgIGdlbmVyYXRlVmlkZW9zU291cmNlVG9WZXJ0ZXgoZnJvbVNvdXJjZSwgdG9PYmplY3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBnZW5lcmF0ZVZpZGVvc0NvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVWaWRlb3NSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2VuZXJhdGVkVmlkZW9zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ2VuZXJhdGVkU2FtcGxlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0ZWRWaWRlb3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUdlbmVyYXRlZFZpZGVvcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRWaWRlb0Zyb21NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRlZFZpZGVvcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmFpTWVkaWFGaWx0ZXJlZENvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JhaU1lZGlhRmlsdGVyZWRDb3VudCddLCBmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyYWlNZWRpYUZpbHRlcmVkUmVhc29ucyddLCBmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2VuZXJhdGVkVmlkZW9zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2aWRlb3MnXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0ZWRWaWRlb3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUdlbmVyYXRlZFZpZGVvcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRWaWRlb0Zyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0ZWRWaWRlb3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JhaU1lZGlhRmlsdGVyZWRDb3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyYWlNZWRpYUZpbHRlcmVkQ291bnQnXSwgZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JhaU1lZGlhRmlsdGVyZWRSZWFzb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMnXSwgZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVWaWRlb3NTb3VyY2VUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvbXB0J10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdwcm9tcHQnXSwgZnJvbVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2UnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAnaW1hZ2UnXSwgaW1hZ2VUb01sZGV2KGZyb21JbWFnZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVmlkZW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3ZpZGVvJ10sIHZpZGVvVG9NbGRldihmcm9tVmlkZW8pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVWaWRlb3NTb3VyY2VUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Qcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb21wdCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncHJvbXB0J10sIGZyb21Qcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ2ltYWdlJ10sIGltYWdlVG9WZXJ0ZXgoZnJvbUltYWdlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmlkZW8nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21WaWRlbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAndmlkZW8nXSwgdmlkZW9Ub1ZlcnRleChmcm9tVmlkZW8pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVkSW1hZ2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydfc2VsZiddKTtcbiAgICBpZiAoZnJvbUltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2UnXSwgaW1hZ2VGcm9tTWxkZXYoZnJvbUltYWdlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SYWlGaWx0ZXJlZFJlYXNvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JhaUZpbHRlcmVkUmVhc29uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJhaUZpbHRlcmVkUmVhc29uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmFpRmlsdGVyZWRSZWFzb24nXSwgZnJvbVJhaUZpbHRlcmVkUmVhc29uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNhZmV0eUF0dHJpYnV0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tU2FmZXR5QXR0cmlidXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NhZmV0eUF0dHJpYnV0ZXMnXSwgc2FmZXR5QXR0cmlidXRlc0Zyb21NbGRldihmcm9tU2FmZXR5QXR0cmlidXRlcykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZWRJbWFnZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydfc2VsZiddKTtcbiAgICBpZiAoZnJvbUltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2UnXSwgaW1hZ2VGcm9tVmVydGV4KGZyb21JbWFnZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmFpRmlsdGVyZWRSZWFzb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyYWlGaWx0ZXJlZFJlYXNvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SYWlGaWx0ZXJlZFJlYXNvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JhaUZpbHRlcmVkUmVhc29uJ10sIGZyb21SYWlGaWx0ZXJlZFJlYXNvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlBdHRyaWJ1dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydfc2VsZiddKTtcbiAgICBpZiAoZnJvbVNhZmV0eUF0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzYWZldHlBdHRyaWJ1dGVzJ10sIHNhZmV0eUF0dHJpYnV0ZXNGcm9tVmVydGV4KGZyb21TYWZldHlBdHRyaWJ1dGVzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmhhbmNlZFByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvbXB0J10pO1xuICAgIGlmIChmcm9tRW5oYW5jZWRQcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmhhbmNlZFByb21wdCddLCBmcm9tRW5oYW5jZWRQcm9tcHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZWRJbWFnZU1hc2tGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21NYXNrID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydfc2VsZiddKTtcbiAgICBpZiAoZnJvbU1hc2sgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXNrJ10sIGltYWdlRnJvbVZlcnRleChmcm9tTWFzaykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFiZWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbHMnXSk7XG4gICAgaWYgKGZyb21MYWJlbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUxhYmVscztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbGFiZWxzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlZFZpZGVvRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21WaWRlbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmlkZW8nXSk7XG4gICAgaWYgKGZyb21WaWRlbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvJ10sIHZpZGVvRnJvbU1sZGV2KGZyb21WaWRlbykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZWRWaWRlb0Zyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZpZGVvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydfc2VsZiddKTtcbiAgICBpZiAoZnJvbVZpZGVvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW8nXSwgdmlkZW9Gcm9tVmVydGV4KGZyb21WaWRlbykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0aW9uQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsU2VsZWN0aW9uQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbW9kZWxTZWxlY3Rpb25Db25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTW9kZWxTZWxlY3Rpb25Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbENvbmZpZyddLCBmcm9tTW9kZWxTZWxlY3Rpb25Db25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSnNvblNjaGVtYSddLCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF1ZGlvVGltZXN0YW1wID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYXVkaW9UaW1lc3RhbXAnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQXVkaW9UaW1lc3RhbXAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdWRpb1RpbWVzdGFtcCddLCBmcm9tQXVkaW9UaW1lc3RhbXApO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FuZGlkYXRlQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYW5kaWRhdGVDb3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYW5kaWRhdGVDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhbmRpZGF0ZUNvdW50J10sIGZyb21DYW5kaWRhdGVDb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmFibGVBZmZlY3RpdmVEaWFsb2cnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRW5hYmxlQWZmZWN0aXZlRGlhbG9nICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5hYmxlQWZmZWN0aXZlRGlhbG9nJ10sIGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnJlcXVlbmN5UGVuYWx0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2ZyZXF1ZW5jeVBlbmFsdHknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnJlcXVlbmN5UGVuYWx0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZyZXF1ZW5jeVBlbmFsdHknXSwgZnJvbUZyZXF1ZW5jeVBlbmFsdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTG9ncHJvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xvZ3Byb2JzJ10pO1xuICAgIGlmIChmcm9tTG9ncHJvYnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsb2dwcm9icyddLCBmcm9tTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4T3V0cHV0VG9rZW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWF4T3V0cHV0VG9rZW5zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1heE91dHB1dFRva2VucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21heE91dHB1dFRva2VucyddLCBmcm9tTWF4T3V0cHV0VG9rZW5zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1lZGlhUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21lZGlhUmVzb2x1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NZWRpYVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZWRpYVJlc29sdXRpb24nXSwgZnJvbU1lZGlhUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QcmVzZW5jZVBlbmFsdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVzZW5jZVBlbmFsdHknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlc2VuY2VQZW5hbHR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJlc2VuY2VQZW5hbHR5J10sIGZyb21QcmVzZW5jZVBlbmFsdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VMb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTG9ncHJvYnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VMb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTG9ncHJvYnMnXSwgZnJvbVJlc3BvbnNlTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VNaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTWltZVR5cGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VNaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTWltZVR5cGUnXSwgZnJvbVJlc3BvbnNlTWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNb2RhbGl0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTW9kYWxpdGllcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTW9kYWxpdGllcyddLCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VTY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VTY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZVNjaGVtYSddLCBmcm9tUmVzcG9uc2VTY2hlbWEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm91dGluZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JvdXRpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUm91dGluZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JvdXRpbmdDb25maWcnXSwgZnJvbVJvdXRpbmdDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKTtcbiAgICBpZiAoZnJvbVNlZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZWVkJ10sIGZyb21TZWVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNwZWVjaENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3BlZWNoQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tU3BlZWNoQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3BlZWNoQ29uZmlnJ10sIHNwZWVjaENvbmZpZ1RvVmVydGV4KGZyb21TcGVlY2hDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0b3BTZXF1ZW5jZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzdG9wU2VxdWVuY2VzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVN0b3BTZXF1ZW5jZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdG9wU2VxdWVuY2VzJ10sIGZyb21TdG9wU2VxdWVuY2VzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRlbXBlcmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZW1wZXJhdHVyZSddKTtcbiAgICBpZiAoZnJvbVRlbXBlcmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGVtcGVyYXR1cmUnXSwgZnJvbVRlbXBlcmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRoaW5raW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhpbmtpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhpbmtpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aGlua2luZ0NvbmZpZyddLCBmcm9tVGhpbmtpbmdDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wSyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wSyddKTtcbiAgICBpZiAoZnJvbVRvcEsgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3BLJ10sIGZyb21Ub3BLKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcFAgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcFAnXSk7XG4gICAgaWYgKGZyb21Ub3BQICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9wUCddLCBmcm9tVG9wUCk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuYWJsZUVuaGFuY2VkQ2l2aWNBbnN3ZXJzJ10pICE9PVxuICAgICAgICB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbmFibGVFbmhhbmNlZENpdmljQW5zd2VycyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdldE1vZGVsUGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdldE1vZGVsUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVNYXBzVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1dGhDb25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F1dGhDb25maWcgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuYWJsZVdpZGdldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5hYmxlV2lkZ2V0J10pO1xuICAgIGlmIChmcm9tRW5hYmxlV2lkZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5hYmxlV2lkZ2V0J10sIGZyb21FbmFibGVXaWRnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVTZWFyY2hUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhjbHVkZURvbWFpbnMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4Y2x1ZGVEb21haW5zIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Jsb2NraW5nQ29uZmlkZW5jZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmxvY2tpbmdDb25maWRlbmNlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaW1lUmFuZ2VGaWx0ZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aW1lUmFuZ2VGaWx0ZXInLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGltZVJhbmdlRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGltZVJhbmdlRmlsdGVyJ10sIGZyb21UaW1lUmFuZ2VGaWx0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbWFnZUNvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUFzcGVjdFJhdGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhc3BlY3RSYXRpbyddKTtcbiAgICBpZiAoZnJvbUFzcGVjdFJhdGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXNwZWN0UmF0aW8nXSwgZnJvbUFzcGVjdFJhdGlvKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2VTaXplJ10pO1xuICAgIGlmIChmcm9tSW1hZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2VTaXplJ10sIGZyb21JbWFnZVNpemUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRNaW1lVHlwZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3V0cHV0TWltZVR5cGUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5J10pICE9PVxuICAgICAgICB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvdXRwdXRDb21wcmVzc2lvblF1YWxpdHkgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW1hZ2VDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQXNwZWN0UmF0aW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FzcGVjdFJhdGlvJ10pO1xuICAgIGlmIChmcm9tQXNwZWN0UmF0aW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhc3BlY3RSYXRpbyddLCBmcm9tQXNwZWN0UmF0aW8pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZVNpemUnXSk7XG4gICAgaWYgKGZyb21JbWFnZVNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbWFnZVNpemUnXSwgZnJvbUltYWdlU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRNaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dE1pbWVUeXBlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU91dHB1dE1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2VPdXRwdXRPcHRpb25zJywgJ21pbWVUeXBlJ10sIGZyb21PdXRwdXRNaW1lVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRDb21wcmVzc2lvblF1YWxpdHknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2VPdXRwdXRPcHRpb25zJywgJ2NvbXByZXNzaW9uUXVhbGl0eSddLCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW1hZ2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUltYWdlQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdieXRlc0Jhc2U2NEVuY29kZWQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tSW1hZ2VCeXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ltYWdlQnl0ZXMnXSwgdEJ5dGVzKGZyb21JbWFnZUJ5dGVzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGltYWdlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NVcmknXSk7XG4gICAgaWYgKGZyb21HY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnY3NVcmknXSwgZnJvbUdjc1VyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZUJ5dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYnl0ZXNCYXNlNjRFbmNvZGVkJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUltYWdlQnl0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbWFnZUJ5dGVzJ10sIHRCeXRlcyhmcm9tSW1hZ2VCeXRlcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbWFnZVRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2NzVXJpJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnY3NVcmkgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlQnl0ZXMnXSk7XG4gICAgaWYgKGZyb21JbWFnZUJ5dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYnl0ZXNCYXNlNjRFbmNvZGVkJ10sIHRCeXRlcyhmcm9tSW1hZ2VCeXRlcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbWFnZVRvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21HY3NVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKTtcbiAgICBpZiAoZnJvbUdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2djc1VyaSddLCBmcm9tR2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlQnl0ZXMnXSk7XG4gICAgaWYgKGZyb21JbWFnZUJ5dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYnl0ZXNCYXNlNjRFbmNvZGVkJ10sIHRCeXRlcyhmcm9tSW1hZ2VCeXRlcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0TW9kZWxzQ29uZmlnVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlU2l6ZSddLCBmcm9tUGFnZVNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlVG9rZW4nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VUb2tlbiddLCBmcm9tUGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsdGVyJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdmaWx0ZXInXSwgZnJvbUZpbHRlcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21RdWVyeUJhc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3F1ZXJ5QmFzZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVF1ZXJ5QmFzZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfdXJsJywgJ21vZGVsc191cmwnXSwgdE1vZGVsc1VybChhcGlDbGllbnQsIGZyb21RdWVyeUJhc2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdE1vZGVsc0NvbmZpZ1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFnZVNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VTaXplJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VTaXplJ10sIGZyb21QYWdlU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VUb2tlbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVRva2VuJ10sIGZyb21QYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsdGVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWx0ZXInXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21GaWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ2ZpbHRlciddLCBmcm9tRmlsdGVyKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVF1ZXJ5QmFzZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncXVlcnlCYXNlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUXVlcnlCYXNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ191cmwnLCAnbW9kZWxzX3VybCddLCB0TW9kZWxzVXJsKGFwaUNsaWVudCwgZnJvbVF1ZXJ5QmFzZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0TW9kZWxzUGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBsaXN0TW9kZWxzQ29uZmlnVG9NbGRldihhcGlDbGllbnQsIGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdE1vZGVsc1BhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGxpc3RNb2RlbHNDb25maWdUb1ZlcnRleChhcGlDbGllbnQsIGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdE1vZGVsc1Jlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmV4dFBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25leHRQYWdlVG9rZW4nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTmV4dFBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25leHRQYWdlVG9rZW4nXSwgZnJvbU5leHRQYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydfc2VsZiddKTtcbiAgICBpZiAoZnJvbU1vZGVscyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0RXh0cmFjdE1vZGVscyhmcm9tTW9kZWxzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2RlbEZyb21NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVscyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0TW9kZWxzUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmV4dFBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25leHRQYWdlVG9rZW4nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTmV4dFBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25leHRQYWdlVG9rZW4nXSwgZnJvbU5leHRQYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydfc2VsZiddKTtcbiAgICBpZiAoZnJvbU1vZGVscyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0RXh0cmFjdE1vZGVscyhmcm9tTW9kZWxzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2RlbEZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbWFza1JlZmVyZW5jZUNvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21NYXNrTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWFza01vZGUnXSk7XG4gICAgaWYgKGZyb21NYXNrTW9kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21hc2tNb2RlJ10sIGZyb21NYXNrTW9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWdtZW50YXRpb25DbGFzc2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2VnbWVudGF0aW9uQ2xhc3NlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZWdtZW50YXRpb25DbGFzc2VzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWFza0NsYXNzZXMnXSwgZnJvbVNlZ21lbnRhdGlvbkNsYXNzZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWFza0RpbGF0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtYXNrRGlsYXRpb24nXSk7XG4gICAgaWYgKGZyb21NYXNrRGlsYXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaWxhdGlvbiddLCBmcm9tTWFza0RpbGF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbW9kZWxGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WZXJzaW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2ZXJzaW9uJ10pO1xuICAgIGlmIChmcm9tVmVyc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZlcnNpb24nXSwgZnJvbVZlcnNpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHVuZWRNb2RlbEluZm8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tVHVuZWRNb2RlbEluZm8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0dW5lZE1vZGVsSW5mbyddLCB0dW5lZE1vZGVsSW5mb0Zyb21NbGRldihmcm9tVHVuZWRNb2RlbEluZm8pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlucHV0VG9rZW5MaW1pdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2lucHV0VG9rZW5MaW1pdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21JbnB1dFRva2VuTGltaXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnB1dFRva2VuTGltaXQnXSwgZnJvbUlucHV0VG9rZW5MaW1pdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRUb2tlbkxpbWl0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0VG9rZW5MaW1pdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21PdXRwdXRUb2tlbkxpbWl0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnb3V0cHV0VG9rZW5MaW1pdCddLCBmcm9tT3V0cHV0VG9rZW5MaW1pdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdXBwb3J0ZWRBY3Rpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3VwcG9ydGVkR2VuZXJhdGlvbk1ldGhvZHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3VwcG9ydGVkQWN0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N1cHBvcnRlZEFjdGlvbnMnXSwgZnJvbVN1cHBvcnRlZEFjdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGVtcGVyYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10pO1xuICAgIGlmIChmcm9tVGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZW1wZXJhdHVyZSddLCBmcm9tVGVtcGVyYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4VGVtcGVyYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXhUZW1wZXJhdHVyZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NYXhUZW1wZXJhdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21heFRlbXBlcmF0dXJlJ10sIGZyb21NYXhUZW1wZXJhdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BQID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BQJ10pO1xuICAgIGlmIChmcm9tVG9wUCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvcFAnXSwgZnJvbVRvcFApO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wSyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wSyddKTtcbiAgICBpZiAoZnJvbVRvcEsgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3BLJ10sIGZyb21Ub3BLKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRoaW5raW5nID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aGlua2luZyddKTtcbiAgICBpZiAoZnJvbVRoaW5raW5nICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhpbmtpbmcnXSwgZnJvbVRoaW5raW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbW9kZWxGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmVyc2lvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmVyc2lvbklkJ10pO1xuICAgIGlmIChmcm9tVmVyc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZlcnNpb24nXSwgZnJvbVZlcnNpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kcG9pbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXBsb3llZE1vZGVscyddKTtcbiAgICBpZiAoZnJvbUVuZHBvaW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRW5kcG9pbnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZHBvaW50RnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZHBvaW50cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFiZWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbHMnXSk7XG4gICAgaWYgKGZyb21MYWJlbHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYWJlbHMnXSwgZnJvbUxhYmVscyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdW5lZE1vZGVsSW5mbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21UdW5lZE1vZGVsSW5mbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1bmVkTW9kZWxJbmZvJ10sIHR1bmVkTW9kZWxJbmZvRnJvbVZlcnRleChmcm9tVHVuZWRNb2RlbEluZm8pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlZmF1bHRDaGVja3BvaW50SWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkZWZhdWx0Q2hlY2twb2ludElkJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbURlZmF1bHRDaGVja3BvaW50SWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZWZhdWx0Q2hlY2twb2ludElkJ10sIGZyb21EZWZhdWx0Q2hlY2twb2ludElkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNoZWNrcG9pbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjaGVja3BvaW50cyddKTtcbiAgICBpZiAoZnJvbUNoZWNrcG9pbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21DaGVja3BvaW50cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2hlY2twb2ludHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcGFydFRvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTWVkaWFSZXNvbHV0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWVkaWFSZXNvbHV0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1lZGlhUmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21lZGlhUmVzb2x1dGlvbiddLCBmcm9tTWVkaWFSZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uUmVzdWx0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uUmVzdWx0J10sIGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4ZWN1dGFibGVDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhlY3V0YWJsZUNvZGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhlY3V0YWJsZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGVjdXRhYmxlQ29kZSddLCBmcm9tRXhlY3V0YWJsZUNvZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVEYXRhJ10pO1xuICAgIGlmIChmcm9tRmlsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlRGF0YSddLCBmaWxlRGF0YVRvTWxkZXYkMShmcm9tRmlsZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10sIGZ1bmN0aW9uQ2FsbFRvTWxkZXYkMShmcm9tRnVuY3Rpb25DYWxsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvblJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25SZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvblJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25SZXNwb25zZSddLCBmcm9tRnVuY3Rpb25SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVEYXRhJ10pO1xuICAgIGlmIChmcm9tSW5saW5lRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lubGluZURhdGEnXSwgYmxvYlRvTWxkZXYkMShmcm9tSW5saW5lRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGV4dCddKTtcbiAgICBpZiAoZnJvbVRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZXh0J10sIGZyb21UZXh0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rob3VnaHQnXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodCddLCBmcm9tVGhvdWdodCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0U2lnbmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhvdWdodFNpZ25hdHVyZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0U2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodFNpZ25hdHVyZSddLCBmcm9tVGhvdWdodFNpZ25hdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlb01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmlkZW9NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WaWRlb01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW9NZXRhZGF0YSddLCBmcm9tVmlkZW9NZXRhZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHByb2R1Y3RJbWFnZVRvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Qcm9kdWN0SW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb2R1Y3RJbWFnZSddKTtcbiAgICBpZiAoZnJvbVByb2R1Y3RJbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ltYWdlJ10sIGltYWdlVG9WZXJ0ZXgoZnJvbVByb2R1Y3RJbWFnZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiByZWNvbnRleHRJbWFnZUNvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU51bWJlck9mSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbnVtYmVyT2ZJbWFnZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTnVtYmVyT2ZJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzYW1wbGVDb3VudCddLCBmcm9tTnVtYmVyT2ZJbWFnZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmFzZVN0ZXBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiYXNlU3RlcHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21CYXNlU3RlcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdiYXNlU3RlcHMnXSwgZnJvbUJhc2VTdGVwcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRHY3NVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ291dHB1dEdjc1VyaSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dEdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3N0b3JhZ2VVcmknXSwgZnJvbU91dHB1dEdjc1VyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2VlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NlZWQnXSwgZnJvbVNlZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlGaWx0ZXJMZXZlbCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TYWZldHlGaWx0ZXJMZXZlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhZmV0eVNldHRpbmcnXSwgZnJvbVNhZmV0eUZpbHRlckxldmVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBlcnNvbkdlbmVyYXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwZXJzb25HZW5lcmF0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBlcnNvbkdlbmVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdwZXJzb25HZW5lcmF0aW9uJ10sIGZyb21QZXJzb25HZW5lcmF0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFkZFdhdGVybWFyayA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYWRkV2F0ZXJtYXJrJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQWRkV2F0ZXJtYXJrICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnYWRkV2F0ZXJtYXJrJ10sIGZyb21BZGRXYXRlcm1hcmspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0TWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRNaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dE9wdGlvbnMnLCAnbWltZVR5cGUnXSwgZnJvbU91dHB1dE1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dENvbXByZXNzaW9uUXVhbGl0eScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdvdXRwdXRPcHRpb25zJywgJ2NvbXByZXNzaW9uUXVhbGl0eSddLCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuaGFuY2VQcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmhhbmNlUHJvbXB0JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUVuaGFuY2VQcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdlbmhhbmNlUHJvbXB0J10sIGZyb21FbmhhbmNlUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhYmVscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGFiZWxzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2xhYmVscyddLCBmcm9tTGFiZWxzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcmVjb250ZXh0SW1hZ2VQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU291cmNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzb3VyY2UnXSk7XG4gICAgaWYgKGZyb21Tb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICByZWNvbnRleHRJbWFnZVNvdXJjZVRvVmVydGV4KGZyb21Tb3VyY2UsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgcmVjb250ZXh0SW1hZ2VDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHJlY29udGV4dEltYWdlUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21HZW5lcmF0ZWRJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVkaWN0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0ZWRJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUdlbmVyYXRlZEltYWdlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRJbWFnZUZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0ZWRJbWFnZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcmVjb250ZXh0SW1hZ2VTb3VyY2VUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Qcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb21wdCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncHJvbXB0J10sIGZyb21Qcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGVyc29uSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BlcnNvbkltYWdlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGVyc29uSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3BlcnNvbkltYWdlJywgJ2ltYWdlJ10sIGltYWdlVG9WZXJ0ZXgoZnJvbVBlcnNvbkltYWdlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9kdWN0SW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJvZHVjdEltYWdlcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Qcm9kdWN0SW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21Qcm9kdWN0SW1hZ2VzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb2R1Y3RJbWFnZVRvVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdwcm9kdWN0SW1hZ2VzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWxUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUmVmZXJlbmNlSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZWZlcmVuY2VJbWFnZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZWZlcmVuY2VJbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlZmVyZW5jZUltYWdlJ10sIGltYWdlVG9WZXJ0ZXgoZnJvbVJlZmVyZW5jZUltYWdlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZWZlcmVuY2VJZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVmZXJlbmNlSWQnXSk7XG4gICAgaWYgKGZyb21SZWZlcmVuY2VJZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlZmVyZW5jZUlkJ10sIGZyb21SZWZlcmVuY2VJZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZWZlcmVuY2VUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVmZXJlbmNlVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZWZlcmVuY2VUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVmZXJlbmNlVHlwZSddLCBmcm9tUmVmZXJlbmNlVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXNrSW1hZ2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXNrSW1hZ2VDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWFza0ltYWdlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWFza0ltYWdlQ29uZmlnJ10sIG1hc2tSZWZlcmVuY2VDb25maWdUb1ZlcnRleChmcm9tTWFza0ltYWdlQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250cm9sSW1hZ2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb250cm9sSW1hZ2VDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29udHJvbEltYWdlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29udHJvbEltYWdlQ29uZmlnJ10sIGNvbnRyb2xSZWZlcmVuY2VDb25maWdUb1ZlcnRleChmcm9tQ29udHJvbEltYWdlQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdHlsZUltYWdlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3R5bGVJbWFnZUNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TdHlsZUltYWdlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3R5bGVJbWFnZUNvbmZpZyddLCBmcm9tU3R5bGVJbWFnZUNvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdWJqZWN0SW1hZ2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzdWJqZWN0SW1hZ2VDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3ViamVjdEltYWdlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3ViamVjdEltYWdlQ29uZmlnJ10sIGZyb21TdWJqZWN0SW1hZ2VDb25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzYWZldHlBdHRyaWJ1dGVzRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21DYXRlZ29yaWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5QXR0cmlidXRlcycsXG4gICAgICAgICdjYXRlZ29yaWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNhdGVnb3JpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYXRlZ29yaWVzJ10sIGZyb21DYXRlZ29yaWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNjb3JlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eUF0dHJpYnV0ZXMnLFxuICAgICAgICAnc2NvcmVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNjb3JlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Njb3JlcyddLCBmcm9tU2NvcmVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRlbnRUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50VHlwZSddKTtcbiAgICBpZiAoZnJvbUNvbnRlbnRUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29udGVudFR5cGUnXSwgZnJvbUNvbnRlbnRUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2FmZXR5QXR0cmlidXRlc0Zyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNhdGVnb3JpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlBdHRyaWJ1dGVzJyxcbiAgICAgICAgJ2NhdGVnb3JpZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2F0ZWdvcmllcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhdGVnb3JpZXMnXSwgZnJvbUNhdGVnb3JpZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2NvcmVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5QXR0cmlidXRlcycsXG4gICAgICAgICdzY29yZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2NvcmVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2NvcmVzJ10sIGZyb21TY29yZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudFR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRUeXBlJ10pO1xuICAgIGlmIChmcm9tQ29udGVudFR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb250ZW50VHlwZSddLCBmcm9tQ29udGVudFR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzYWZldHlTZXR0aW5nVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ2F0ZWdvcnkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NhdGVnb3J5J10pO1xuICAgIGlmIChmcm9tQ2F0ZWdvcnkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYXRlZ29yeSddLCBmcm9tQ2F0ZWdvcnkpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRob2QnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21ldGhvZCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhyZXNob2xkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aHJlc2hvbGQnXSk7XG4gICAgaWYgKGZyb21UaHJlc2hvbGQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aHJlc2hvbGQnXSwgZnJvbVRocmVzaG9sZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNjcmliYmxlSW1hZ2VUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlJ10pO1xuICAgIGlmIChmcm9tSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbWFnZSddLCBpbWFnZVRvVmVydGV4KGZyb21JbWFnZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzZWdtZW50SW1hZ2VDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTW9kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ21vZGUnXSwgZnJvbU1vZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4UHJlZGljdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXhQcmVkaWN0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21NYXhQcmVkaWN0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ21heFByZWRpY3Rpb25zJ10sIGZyb21NYXhQcmVkaWN0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWRlbmNlVGhyZXNob2xkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29uZmlkZW5jZVRocmVzaG9sZCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Db25maWRlbmNlVGhyZXNob2xkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnY29uZmlkZW5jZVRocmVzaG9sZCddLCBmcm9tQ29uZmlkZW5jZVRocmVzaG9sZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXNrRGlsYXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21hc2tEaWxhdGlvbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU1hc2tEaWxhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ21hc2tEaWxhdGlvbiddLCBmcm9tTWFza0RpbGF0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJpbmFyeUNvbG9yVGhyZXNob2xkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYmluYXJ5Q29sb3JUaHJlc2hvbGQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQmluYXJ5Q29sb3JUaHJlc2hvbGQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdiaW5hcnlDb2xvclRocmVzaG9sZCddLCBmcm9tQmluYXJ5Q29sb3JUaHJlc2hvbGQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFiZWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MYWJlbHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnbGFiZWxzJ10sIGZyb21MYWJlbHMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzZWdtZW50SW1hZ2VQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU291cmNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzb3VyY2UnXSk7XG4gICAgaWYgKGZyb21Tb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICBzZWdtZW50SW1hZ2VTb3VyY2VUb1ZlcnRleChmcm9tU291cmNlLCB0b09iamVjdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNlZ21lbnRJbWFnZUNvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2VnbWVudEltYWdlUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21HZW5lcmF0ZWRNYXNrcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJlZGljdGlvbnMnXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0ZWRNYXNrcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tR2VuZXJhdGVkTWFza3M7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVkSW1hZ2VNYXNrRnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRlZE1hc2tzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNlZ21lbnRJbWFnZVNvdXJjZVRvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvbXB0J10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdwcm9tcHQnXSwgZnJvbVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2UnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAnaW1hZ2UnXSwgaW1hZ2VUb1ZlcnRleChmcm9tSW1hZ2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNjcmliYmxlSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzY3JpYmJsZUltYWdlJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNjcmliYmxlSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3NjcmliYmxlJ10sIHNjcmliYmxlSW1hZ2VUb1ZlcnRleChmcm9tU2NyaWJibGVJbWFnZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzcGVlY2hDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTGFuZ3VhZ2VDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYW5ndWFnZUNvZGUnXSk7XG4gICAgaWYgKGZyb21MYW5ndWFnZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYW5ndWFnZUNvZGUnXSwgZnJvbUxhbmd1YWdlQ29kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Wb2ljZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndm9pY2VDb25maWcnXSk7XG4gICAgaWYgKGZyb21Wb2ljZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZvaWNlQ29uZmlnJ10sIGZyb21Wb2ljZUNvbmZpZyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ211bHRpU3BlYWtlclZvaWNlQ29uZmlnJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdWx0aVNwZWFrZXJWb2ljZUNvbmZpZyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xDb25maWdUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkNhbGxpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxsaW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxsaW5nQ29uZmlnJ10sIGZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ1RvTWxkZXYoZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmV0cmlldmFsQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmV0cmlldmFsQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJldHJpZXZhbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JldHJpZXZhbENvbmZpZyddLCBmcm9tUmV0cmlldmFsQ29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbFRvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkRlY2xhcmF0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JldHJpZXZhbCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmV0cmlldmFsIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnb29nbGVTZWFyY2hSZXRyaWV2YWwnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJ10sIGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29tcHV0ZXJVc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10pO1xuICAgIGlmIChmcm9tQ29tcHV0ZXJVc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb21wdXRlclVzZSddLCBmcm9tQ29tcHV0ZXJVc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZVNlYXJjaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZVNlYXJjaCddKTtcbiAgICBpZiAoZnJvbUZpbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlU2VhcmNoJ10sIGZyb21GaWxlU2VhcmNoKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uJ10sIGZyb21Db2RlRXhlY3V0aW9uKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW50ZXJwcmlzZVdlYlNlYXJjaCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZW50ZXJwcmlzZVdlYlNlYXJjaCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlTWFwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlTWFwcyddKTtcbiAgICBpZiAoZnJvbUdvb2dsZU1hcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVNYXBzJ10sIGdvb2dsZU1hcHNUb01sZGV2JDEoZnJvbUdvb2dsZU1hcHMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10sIGdvb2dsZVNlYXJjaFRvTWxkZXYkMShmcm9tR29vZ2xlU2VhcmNoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmxDb250ZXh0J10pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHQnXSwgZnJvbVVybENvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0b29sVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25EZWNsYXJhdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uRGVjbGFyYXRpb25Ub1ZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXRyaWV2YWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JldHJpZXZhbCddKTtcbiAgICBpZiAoZnJvbVJldHJpZXZhbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JldHJpZXZhbCddLCBmcm9tUmV0cmlldmFsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2hSZXRyaWV2YWwnXSwgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db21wdXRlclVzZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSk7XG4gICAgaWYgKGZyb21Db21wdXRlclVzZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10sIGZyb21Db21wdXRlclVzZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVTZWFyY2gnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpbGVTZWFyY2ggcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb24nXSwgZnJvbUNvZGVFeGVjdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW50ZXJwcmlzZVdlYlNlYXJjaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VudGVycHJpc2VXZWJTZWFyY2gnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRW50ZXJwcmlzZVdlYlNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VudGVycHJpc2VXZWJTZWFyY2gnXSwgZnJvbUVudGVycHJpc2VXZWJTZWFyY2gpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlTWFwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlTWFwcyddKTtcbiAgICBpZiAoZnJvbUdvb2dsZU1hcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVNYXBzJ10sIGZyb21Hb29nbGVNYXBzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10sIGZyb21Hb29nbGVTZWFyY2gpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJsQ29udGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXJsQ29udGV4dCddKTtcbiAgICBpZiAoZnJvbVVybENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmxDb250ZXh0J10sIGZyb21VcmxDb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdHVuZWRNb2RlbEluZm9Gcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUJhc2VNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmFzZU1vZGVsJ10pO1xuICAgIGlmIChmcm9tQmFzZU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmFzZU1vZGVsJ10sIGZyb21CYXNlTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ3JlYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY3JlYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbUNyZWF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjcmVhdGVUaW1lJ10sIGZyb21DcmVhdGVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVwZGF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21VcGRhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXBkYXRlVGltZSddLCBmcm9tVXBkYXRlVGltZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHR1bmVkTW9kZWxJbmZvRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQmFzZU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbGFiZWxzJyxcbiAgICAgICAgJ2dvb2dsZS12ZXJ0ZXgtbGxtLXR1bmluZy1iYXNlLW1vZGVsLWlkJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUJhc2VNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Jhc2VNb2RlbCddLCBmcm9tQmFzZU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNyZWF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21DcmVhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY3JlYXRlVGltZSddLCBmcm9tQ3JlYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcGRhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cGRhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tVXBkYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSwgZnJvbVVwZGF0ZVRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cGRhdGVNb2RlbENvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZWZhdWx0Q2hlY2twb2ludElkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZGVmYXVsdENoZWNrcG9pbnRJZCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EZWZhdWx0Q2hlY2twb2ludElkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2RlZmF1bHRDaGVja3BvaW50SWQnXSwgZnJvbURlZmF1bHRDaGVja3BvaW50SWQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cGRhdGVNb2RlbENvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVmYXVsdENoZWNrcG9pbnRJZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2RlZmF1bHRDaGVja3BvaW50SWQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGVmYXVsdENoZWNrcG9pbnRJZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkZWZhdWx0Q2hlY2twb2ludElkJ10sIGZyb21EZWZhdWx0Q2hlY2twb2ludElkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBkYXRlTW9kZWxQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgdXBkYXRlTW9kZWxDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBkYXRlTW9kZWxQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVNb2RlbENvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBzY2FsZUltYWdlQVBJQ29uZmlnSW50ZXJuYWxUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21PdXRwdXRHY3NVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ291dHB1dEdjc1VyaSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dEdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3N0b3JhZ2VVcmknXSwgZnJvbU91dHB1dEdjc1VyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlGaWx0ZXJMZXZlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eUZpbHRlckxldmVsJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNhZmV0eUZpbHRlckxldmVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FmZXR5U2V0dGluZyddLCBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGVyc29uR2VuZXJhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BlcnNvbkdlbmVyYXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGVyc29uR2VuZXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3BlcnNvbkdlbmVyYXRpb24nXSwgZnJvbVBlcnNvbkdlbmVyYXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5jbHVkZVJhaVJlYXNvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2luY2x1ZGVSYWlSZWFzb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW5jbHVkZVJhaVJlYXNvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2luY2x1ZGVSYWlSZWFzb24nXSwgZnJvbUluY2x1ZGVSYWlSZWFzb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0TWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRNaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dE9wdGlvbnMnLCAnbWltZVR5cGUnXSwgZnJvbU91dHB1dE1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dENvbXByZXNzaW9uUXVhbGl0eScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdvdXRwdXRPcHRpb25zJywgJ2NvbXByZXNzaW9uUXVhbGl0eSddLCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuaGFuY2VJbnB1dEltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW5oYW5jZUlucHV0SW1hZ2UnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRW5oYW5jZUlucHV0SW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICd1cHNjYWxlQ29uZmlnJywgJ2VuaGFuY2VJbnB1dEltYWdlJ10sIGZyb21FbmhhbmNlSW5wdXRJbWFnZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZVByZXNlcnZhdGlvbkZhY3RvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2ltYWdlUHJlc2VydmF0aW9uRmFjdG9yJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUltYWdlUHJlc2VydmF0aW9uRmFjdG9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAndXBzY2FsZUNvbmZpZycsICdpbWFnZVByZXNlcnZhdGlvbkZhY3RvciddLCBmcm9tSW1hZ2VQcmVzZXJ2YXRpb25GYWN0b3IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFiZWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MYWJlbHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnbGFiZWxzJ10sIGZyb21MYWJlbHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTnVtYmVyT2ZJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdudW1iZXJPZkltYWdlcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OdW1iZXJPZkltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhbXBsZUNvdW50J10sIGZyb21OdW1iZXJPZkltYWdlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Nb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTW9kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ21vZGUnXSwgZnJvbU1vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cHNjYWxlSW1hZ2VBUElQYXJhbWV0ZXJzSW50ZXJuYWxUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2UnXSk7XG4gICAgaWYgKGZyb21JbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdpbWFnZSddLCBpbWFnZVRvVmVydGV4KGZyb21JbWFnZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXBzY2FsZUZhY3RvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Vwc2NhbGVGYWN0b3InLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVXBzY2FsZUZhY3RvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAndXBzY2FsZUNvbmZpZycsICd1cHNjYWxlRmFjdG9yJ10sIGZyb21VcHNjYWxlRmFjdG9yKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgdXBzY2FsZUltYWdlQVBJQ29uZmlnSW50ZXJuYWxUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwc2NhbGVJbWFnZVJlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdlbmVyYXRlZEltYWdlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZWRpY3Rpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdlbmVyYXRlZEltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tR2VuZXJhdGVkSW1hZ2VzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlZEltYWdlRnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRlZEltYWdlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb0Zyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmknXSk7XG4gICAgaWYgKGZyb21VcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmknXSwgZnJvbVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlb0J5dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmNvZGVkVmlkZW8nXSk7XG4gICAgaWYgKGZyb21WaWRlb0J5dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW9CeXRlcyddLCB0Qnl0ZXMoZnJvbVZpZGVvQnl0ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmNvZGluZyddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdmlkZW9Gcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21VcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKTtcbiAgICBpZiAoZnJvbVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VyaSddLCBmcm9tVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdieXRlc0Jhc2U2NEVuY29kZWQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9CeXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvQnl0ZXMnXSwgdEJ5dGVzKGZyb21WaWRlb0J5dGVzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvR2VuZXJhdGlvbk1hc2tUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlJ10pO1xuICAgIGlmIChmcm9tSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfc2VsZiddLCBpbWFnZVRvVmVydGV4KGZyb21JbWFnZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWFza01vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21hc2tNb2RlJ10pO1xuICAgIGlmIChmcm9tTWFza01vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXNrTW9kZSddLCBmcm9tTWFza01vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb0dlbmVyYXRpb25SZWZlcmVuY2VJbWFnZVRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZSddKTtcbiAgICBpZiAoZnJvbUltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2UnXSwgaW1hZ2VUb01sZGV2KGZyb21JbWFnZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVmZXJlbmNlVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JlZmVyZW5jZVR5cGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVmZXJlbmNlVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlZmVyZW5jZVR5cGUnXSwgZnJvbVJlZmVyZW5jZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb0dlbmVyYXRpb25SZWZlcmVuY2VJbWFnZVRvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2UnXSk7XG4gICAgaWYgKGZyb21JbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ltYWdlJ10sIGltYWdlVG9WZXJ0ZXgoZnJvbUltYWdlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZWZlcmVuY2VUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVmZXJlbmNlVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZWZlcmVuY2VUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVmZXJlbmNlVHlwZSddLCBmcm9tUmVmZXJlbmNlVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmknXSk7XG4gICAgaWYgKGZyb21VcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmknXSwgZnJvbVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlb0J5dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2aWRlb0J5dGVzJ10pO1xuICAgIGlmIChmcm9tVmlkZW9CeXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuY29kZWRWaWRlbyddLCB0Qnl0ZXMoZnJvbVZpZGVvQnl0ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5jb2RpbmcnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdmlkZW9Ub1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmknXSk7XG4gICAgaWYgKGZyb21VcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnY3NVcmknXSwgZnJvbVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlb0J5dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2aWRlb0J5dGVzJ10pO1xuICAgIGlmIChmcm9tVmlkZW9CeXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2J5dGVzQmFzZTY0RW5jb2RlZCddLCB0Qnl0ZXMoZnJvbVZpZGVvQnl0ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vLyBDb2RlIGdlbmVyYXRlZCBieSB0aGUgR29vZ2xlIEdlbiBBSSBTREsgZ2VuZXJhdG9yIERPIE5PVCBFRElULlxuZnVuY3Rpb24gY3JlYXRlRmlsZVNlYXJjaFN0b3JlQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWxlU2VhcmNoU3RvcmVQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBjcmVhdGVGaWxlU2VhcmNoU3RvcmVDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlRmlsZVNlYXJjaFN0b3JlQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Gb3JjZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZm9yY2UnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Gb3JjZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAnZm9yY2UnXSwgZnJvbUZvcmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlRmlsZVNlYXJjaFN0b3JlUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgZGVsZXRlRmlsZVNlYXJjaFN0b3JlQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdldEZpbGVTZWFyY2hTdG9yZVBhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGltcG9ydEZpbGVDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUN1c3RvbU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY3VzdG9tTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ3VzdG9tTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUN1c3RvbU1ldGFkYXRhO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnY3VzdG9tTWV0YWRhdGEnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNodW5raW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2h1bmtpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ2h1bmtpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnY2h1bmtpbmdDb25maWcnXSwgZnJvbUNodW5raW5nQ29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW1wb3J0RmlsZU9wZXJhdGlvbkZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWV0YWRhdGEnXSwgZnJvbU1ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvbmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RvbmUnXSk7XG4gICAgaWYgKGZyb21Eb25lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9uZSddLCBmcm9tRG9uZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZyb21FcnJvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2UnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlJ10sIGltcG9ydEZpbGVSZXNwb25zZUZyb21NbGRldihmcm9tUmVzcG9uc2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW1wb3J0RmlsZVBhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GaWxlU2VhcmNoU3RvcmVOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZmlsZVNlYXJjaFN0b3JlTmFtZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GaWxlU2VhcmNoU3RvcmVOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdmaWxlX3NlYXJjaF9zdG9yZV9uYW1lJ10sIGZyb21GaWxlU2VhcmNoU3RvcmVOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlTmFtZSddKTtcbiAgICBpZiAoZnJvbUZpbGVOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZU5hbWUnXSwgZnJvbUZpbGVOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgaW1wb3J0RmlsZUNvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbXBvcnRGaWxlUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcmVudCddKTtcbiAgICBpZiAoZnJvbVBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmVudCddLCBmcm9tUGFyZW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvY3VtZW50TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZG9jdW1lbnROYW1lJ10pO1xuICAgIGlmIChmcm9tRG9jdW1lbnROYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9jdW1lbnROYW1lJ10sIGZyb21Eb2N1bWVudE5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0RmlsZVNlYXJjaFN0b3Jlc0NvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFnZVNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VTaXplJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VTaXplJ10sIGZyb21QYWdlU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VUb2tlbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVRva2VuJ10sIGZyb21QYWdlVG9rZW4pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0RmlsZVNlYXJjaFN0b3Jlc1BhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGxpc3RGaWxlU2VhcmNoU3RvcmVzQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RGaWxlU2VhcmNoU3RvcmVzUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZXh0UGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmV4dFBhZ2VUb2tlbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21OZXh0UGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmV4dFBhZ2VUb2tlbiddLCBmcm9tTmV4dFBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlU2VhcmNoU3RvcmVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZmlsZVNlYXJjaFN0b3JlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GaWxlU2VhcmNoU3RvcmVzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21GaWxlU2VhcmNoU3RvcmVzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlU2VhcmNoU3RvcmVzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUN1c3RvbU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY3VzdG9tTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ3VzdG9tTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUN1c3RvbU1ldGFkYXRhO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnY3VzdG9tTWV0YWRhdGEnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNodW5raW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2h1bmtpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ2h1bmtpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnY2h1bmtpbmdDb25maWcnXSwgZnJvbUNodW5raW5nQ29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRmlsZVNlYXJjaFN0b3JlTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2ZpbGVTZWFyY2hTdG9yZU5hbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRmlsZVNlYXJjaFN0b3JlTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnZmlsZV9zZWFyY2hfc3RvcmVfbmFtZSddLCBmcm9tRmlsZVNlYXJjaFN0b3JlTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlUmVzdW1hYmxlUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY29uc3QgQ09OVEVOVF9UWVBFX0hFQURFUiA9ICdDb250ZW50LVR5cGUnO1xuY29uc3QgU0VSVkVSX1RJTUVPVVRfSEVBREVSID0gJ1gtU2VydmVyLVRpbWVvdXQnO1xuY29uc3QgVVNFUl9BR0VOVF9IRUFERVIgPSAnVXNlci1BZ2VudCc7XG5jb25zdCBHT09HTEVfQVBJX0NMSUVOVF9IRUFERVIgPSAneC1nb29nLWFwaS1jbGllbnQnO1xuY29uc3QgU0RLX1ZFUlNJT04gPSAnMS4zMS4wJzsgLy8geC1yZWxlYXNlLXBsZWFzZS12ZXJzaW9uXG5jb25zdCBMSUJSQVJZX0xBQkVMID0gYGdvb2dsZS1nZW5haS1zZGsvJHtTREtfVkVSU0lPTn1gO1xuY29uc3QgVkVSVEVYX0FJX0FQSV9ERUZBVUxUX1ZFUlNJT04gPSAndjFiZXRhMSc7XG5jb25zdCBHT09HTEVfQUlfQVBJX0RFRkFVTFRfVkVSU0lPTiA9ICd2MWJldGEnO1xuY29uc3QgcmVzcG9uc2VMaW5lUkUgPSAvXlxccypkYXRhOiAoLiopKD86XFxuXFxufFxcclxccnxcXHJcXG5cXHJcXG4pLztcbi8qKlxuICogVGhlIEFwaUNsaWVudCBjbGFzcyBpcyB1c2VkIHRvIHNlbmQgcmVxdWVzdHMgdG8gdGhlIEdlbWluaSBBUEkgb3IgVmVydGV4IEFJXG4gKiBlbmRwb2ludHMuXG4gKi9cbmNsYXNzIEFwaUNsaWVudCB7XG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdHMpLCB7IHByb2plY3Q6IG9wdHMucHJvamVjdCwgbG9jYXRpb246IG9wdHMubG9jYXRpb24sIGFwaUtleTogb3B0cy5hcGlLZXksIHZlcnRleGFpOiBvcHRzLnZlcnRleGFpIH0pO1xuICAgICAgICBjb25zdCBpbml0SHR0cE9wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50T3B0aW9ucy52ZXJ0ZXhhaSkge1xuICAgICAgICAgICAgaW5pdEh0dHBPcHRpb25zLmFwaVZlcnNpb24gPVxuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuY2xpZW50T3B0aW9ucy5hcGlWZXJzaW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBWRVJURVhfQUlfQVBJX0RFRkFVTFRfVkVSU0lPTjtcbiAgICAgICAgICAgIGluaXRIdHRwT3B0aW9ucy5iYXNlVXJsID0gdGhpcy5iYXNlVXJsRnJvbVByb2plY3RMb2NhdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5ub3JtYWxpemVBdXRoUGFyYW1ldGVycygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gR2VtaW5pIEFQSVxuICAgICAgICAgICAgaW5pdEh0dHBPcHRpb25zLmFwaVZlcnNpb24gPVxuICAgICAgICAgICAgICAgIChfYiA9IHRoaXMuY2xpZW50T3B0aW9ucy5hcGlWZXJzaW9uKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBHT09HTEVfQUlfQVBJX0RFRkFVTFRfVkVSU0lPTjtcbiAgICAgICAgICAgIGluaXRIdHRwT3B0aW9ucy5iYXNlVXJsID0gYGh0dHBzOi8vZ2VuZXJhdGl2ZWxhbmd1YWdlLmdvb2dsZWFwaXMuY29tL2A7XG4gICAgICAgIH1cbiAgICAgICAgaW5pdEh0dHBPcHRpb25zLmhlYWRlcnMgPSB0aGlzLmdldERlZmF1bHRIZWFkZXJzKCk7XG4gICAgICAgIHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucyA9IGluaXRIdHRwT3B0aW9ucztcbiAgICAgICAgaWYgKG9wdHMuaHR0cE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucyA9IHRoaXMucGF0Y2hIdHRwT3B0aW9ucyhpbml0SHR0cE9wdGlvbnMsIG9wdHMuaHR0cE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgdGhlIGJhc2UgVVJMIGZvciBWZXJ0ZXggQUkgYmFzZWQgb24gcHJvamVjdCBhbmQgbG9jYXRpb24uXG4gICAgICogVXNlcyB0aGUgZ2xvYmFsIGVuZHBvaW50IGlmIGxvY2F0aW9uIGlzICdnbG9iYWwnIG9yIGlmIHByb2plY3QvbG9jYXRpb25cbiAgICAgKiBhcmUgbm90IHNwZWNpZmllZCAoaW1wbHlpbmcgQVBJIGtleSB1c2FnZSkuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBiYXNlVXJsRnJvbVByb2plY3RMb2NhdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50T3B0aW9ucy5wcm9qZWN0ICYmXG4gICAgICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMubG9jYXRpb24gJiZcbiAgICAgICAgICAgIHRoaXMuY2xpZW50T3B0aW9ucy5sb2NhdGlvbiAhPT0gJ2dsb2JhbCcpIHtcbiAgICAgICAgICAgIC8vIFJlZ2lvbmFsIGVuZHBvaW50XG4gICAgICAgICAgICByZXR1cm4gYGh0dHBzOi8vJHt0aGlzLmNsaWVudE9wdGlvbnMubG9jYXRpb259LWFpcGxhdGZvcm0uZ29vZ2xlYXBpcy5jb20vYDtcbiAgICAgICAgfVxuICAgICAgICAvLyBHbG9iYWwgZW5kcG9pbnQgKGNvdmVycyAnZ2xvYmFsJyBsb2NhdGlvbiBhbmQgQVBJIGtleSB1c2FnZSlcbiAgICAgICAgcmV0dXJuIGBodHRwczovL2FpcGxhdGZvcm0uZ29vZ2xlYXBpcy5jb20vYDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplcyBhdXRoZW50aWNhdGlvbiBwYXJhbWV0ZXJzIGZvciBWZXJ0ZXggQUkuXG4gICAgICogSWYgcHJvamVjdCBhbmQgbG9jYXRpb24gYXJlIHByb3ZpZGVkLCBBUEkga2V5IGlzIGNsZWFyZWQuXG4gICAgICogSWYgcHJvamVjdCBhbmQgbG9jYXRpb24gYXJlIG5vdCBwcm92aWRlZCAoaW1wbHlpbmcgQVBJIGtleSB1c2FnZSksXG4gICAgICogcHJvamVjdCBhbmQgbG9jYXRpb24gYXJlIGNsZWFyZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBub3JtYWxpemVBdXRoUGFyYW1ldGVycygpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50T3B0aW9ucy5wcm9qZWN0ICYmIHRoaXMuY2xpZW50T3B0aW9ucy5sb2NhdGlvbikge1xuICAgICAgICAgICAgLy8gVXNpbmcgcHJvamVjdC9sb2NhdGlvbiBmb3IgYXV0aCwgY2xlYXIgcG90ZW50aWFsIEFQSSBrZXlcbiAgICAgICAgICAgIHRoaXMuY2xpZW50T3B0aW9ucy5hcGlLZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNpbmcgQVBJIGtleSBmb3IgYXV0aCAob3Igbm8gYXV0aCBwcm92aWRlZCB5ZXQpLCBjbGVhciBwcm9qZWN0L2xvY2F0aW9uXG4gICAgICAgIHRoaXMuY2xpZW50T3B0aW9ucy5wcm9qZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMubG9jYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlzVmVydGV4QUkoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuY2xpZW50T3B0aW9ucy52ZXJ0ZXhhaSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2U7XG4gICAgfVxuICAgIGdldFByb2plY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudE9wdGlvbnMucHJvamVjdDtcbiAgICB9XG4gICAgZ2V0TG9jYXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudE9wdGlvbnMubG9jYXRpb247XG4gICAgfVxuICAgIGdldEFwaVZlcnNpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMgJiZcbiAgICAgICAgICAgIHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucy5hcGlWZXJzaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMuYXBpVmVyc2lvbjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FQSSB2ZXJzaW9uIGlzIG5vdCBzZXQuJyk7XG4gICAgfVxuICAgIGdldEJhc2VVcmwoKSB7XG4gICAgICAgIGlmICh0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMgJiZcbiAgICAgICAgICAgIHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucy5iYXNlVXJsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMuYmFzZVVybDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jhc2UgVVJMIGlzIG5vdCBzZXQuJyk7XG4gICAgfVxuICAgIGdldFJlcXVlc3RVcmwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJlcXVlc3RVcmxJbnRlcm5hbCh0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMpO1xuICAgIH1cbiAgICBnZXRIZWFkZXJzKCkge1xuICAgICAgICBpZiAodGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zICYmXG4gICAgICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMuaGVhZGVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zLmhlYWRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hlYWRlcnMgYXJlIG5vdCBzZXQuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UmVxdWVzdFVybEludGVybmFsKGh0dHBPcHRpb25zKSB7XG4gICAgICAgIGlmICghaHR0cE9wdGlvbnMgfHxcbiAgICAgICAgICAgIGh0dHBPcHRpb25zLmJhc2VVcmwgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgaHR0cE9wdGlvbnMuYXBpVmVyc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hUVFAgb3B0aW9ucyBhcmUgbm90IGNvcnJlY3RseSBzZXQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmFzZVVybCA9IGh0dHBPcHRpb25zLmJhc2VVcmwuZW5kc1dpdGgoJy8nKVxuICAgICAgICAgICAgPyBodHRwT3B0aW9ucy5iYXNlVXJsLnNsaWNlKDAsIC0xKVxuICAgICAgICAgICAgOiBodHRwT3B0aW9ucy5iYXNlVXJsO1xuICAgICAgICBjb25zdCB1cmxFbGVtZW50ID0gW2Jhc2VVcmxdO1xuICAgICAgICBpZiAoaHR0cE9wdGlvbnMuYXBpVmVyc2lvbiAmJiBodHRwT3B0aW9ucy5hcGlWZXJzaW9uICE9PSAnJykge1xuICAgICAgICAgICAgdXJsRWxlbWVudC5wdXNoKGh0dHBPcHRpb25zLmFwaVZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmxFbGVtZW50LmpvaW4oJy8nKTtcbiAgICB9XG4gICAgZ2V0QmFzZVJlc291cmNlUGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIGBwcm9qZWN0cy8ke3RoaXMuY2xpZW50T3B0aW9ucy5wcm9qZWN0fS9sb2NhdGlvbnMvJHt0aGlzLmNsaWVudE9wdGlvbnMubG9jYXRpb259YDtcbiAgICB9XG4gICAgZ2V0QXBpS2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRPcHRpb25zLmFwaUtleTtcbiAgICB9XG4gICAgZ2V0V2Vic29ja2V0QmFzZVVybCgpIHtcbiAgICAgICAgY29uc3QgYmFzZVVybCA9IHRoaXMuZ2V0QmFzZVVybCgpO1xuICAgICAgICBjb25zdCB1cmxQYXJ0cyA9IG5ldyBVUkwoYmFzZVVybCk7XG4gICAgICAgIHVybFBhcnRzLnByb3RvY29sID0gdXJsUGFydHMucHJvdG9jb2wgPT0gJ2h0dHA6JyA/ICd3cycgOiAnd3NzJztcbiAgICAgICAgcmV0dXJuIHVybFBhcnRzLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHNldEJhc2VVcmwodXJsKSB7XG4gICAgICAgIGlmICh0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucy5iYXNlVXJsID0gdXJsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIVFRQIG9wdGlvbnMgYXJlIG5vdCBjb3JyZWN0bHkgc2V0LicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0cnVjdFVybChwYXRoLCBodHRwT3B0aW9ucywgcHJlcGVuZFByb2plY3RMb2NhdGlvbikge1xuICAgICAgICBjb25zdCB1cmxFbGVtZW50ID0gW3RoaXMuZ2V0UmVxdWVzdFVybEludGVybmFsKGh0dHBPcHRpb25zKV07XG4gICAgICAgIGlmIChwcmVwZW5kUHJvamVjdExvY2F0aW9uKSB7XG4gICAgICAgICAgICB1cmxFbGVtZW50LnB1c2godGhpcy5nZXRCYXNlUmVzb3VyY2VQYXRoKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoICE9PSAnJykge1xuICAgICAgICAgICAgdXJsRWxlbWVudC5wdXNoKHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYCR7dXJsRWxlbWVudC5qb2luKCcvJyl9YCk7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICAgIHNob3VsZFByZXBlbmRWZXJ0ZXhQcm9qZWN0UGF0aChyZXF1ZXN0KSB7XG4gICAgICAgIGlmICh0aGlzLmNsaWVudE9wdGlvbnMuYXBpS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmNsaWVudE9wdGlvbnMudmVydGV4YWkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxdWVzdC5wYXRoLnN0YXJ0c1dpdGgoJ3Byb2plY3RzLycpKSB7XG4gICAgICAgICAgICAvLyBBc3N1bWUgdGhlIHBhdGggYWxyZWFkeSBzdGFydHMgd2l0aFxuICAgICAgICAgICAgLy8gYHByb2plY3RzLzxwcm9qZWN0Pi9sb2NhdGlvbi88bG9jYXRpb24+YC5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxdWVzdC5odHRwTWV0aG9kID09PSAnR0VUJyAmJlxuICAgICAgICAgICAgcmVxdWVzdC5wYXRoLnN0YXJ0c1dpdGgoJ3B1Ymxpc2hlcnMvZ29vZ2xlL21vZGVscycpKSB7XG4gICAgICAgICAgICAvLyBUaGVzZSBwYXRocyBhcmUgdXNlZCBieSBWZXJ0ZXgncyBtb2RlbHMuZ2V0IGFuZCBtb2RlbHMubGlzdFxuICAgICAgICAgICAgLy8gY2FsbHMuIEZvciBiYXNlIG1vZGVscyBWZXJ0ZXggZG9lcyBub3QgYWNjZXB0IGEgcHJvamVjdC9sb2NhdGlvblxuICAgICAgICAgICAgLy8gcHJlZml4IChmb3IgdHVuZWQgbW9kZWwgdGhlIHByZWZpeCBpcyByZXF1aXJlZCkuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGFzeW5jIHJlcXVlc3QocmVxdWVzdCkge1xuICAgICAgICBsZXQgcGF0Y2hlZEh0dHBPcHRpb25zID0gdGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zO1xuICAgICAgICBpZiAocmVxdWVzdC5odHRwT3B0aW9ucykge1xuICAgICAgICAgICAgcGF0Y2hlZEh0dHBPcHRpb25zID0gdGhpcy5wYXRjaEh0dHBPcHRpb25zKHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucywgcmVxdWVzdC5odHRwT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJlcGVuZFByb2plY3RMb2NhdGlvbiA9IHRoaXMuc2hvdWxkUHJlcGVuZFZlcnRleFByb2plY3RQYXRoKHJlcXVlc3QpO1xuICAgICAgICBjb25zdCB1cmwgPSB0aGlzLmNvbnN0cnVjdFVybChyZXF1ZXN0LnBhdGgsIHBhdGNoZWRIdHRwT3B0aW9ucywgcHJlcGVuZFByb2plY3RMb2NhdGlvbik7XG4gICAgICAgIGlmIChyZXF1ZXN0LnF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhyZXF1ZXN0LnF1ZXJ5UGFyYW1zKSkge1xuICAgICAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlcXVlc3RJbml0ID0ge307XG4gICAgICAgIGlmIChyZXF1ZXN0Lmh0dHBNZXRob2QgPT09ICdHRVQnKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdC5ib2R5ICYmIHJlcXVlc3QuYm9keSAhPT0gJ3t9Jykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVxdWVzdCBib2R5IHNob3VsZCBiZSBlbXB0eSBmb3IgR0VUIHJlcXVlc3QsIGJ1dCBnb3Qgbm9uIGVtcHR5IHJlcXVlc3QgYm9keScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVxdWVzdEluaXQuYm9keSA9IHJlcXVlc3QuYm9keTtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0SW5pdCA9IGF3YWl0IHRoaXMuaW5jbHVkZUV4dHJhSHR0cE9wdGlvbnNUb1JlcXVlc3RJbml0KHJlcXVlc3RJbml0LCBwYXRjaGVkSHR0cE9wdGlvbnMsIHVybC50b1N0cmluZygpLCByZXF1ZXN0LmFib3J0U2lnbmFsKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5hcnlBcGlDYWxsKHVybCwgcmVxdWVzdEluaXQsIHJlcXVlc3QuaHR0cE1ldGhvZCk7XG4gICAgfVxuICAgIHBhdGNoSHR0cE9wdGlvbnMoYmFzZUh0dHBPcHRpb25zLCByZXF1ZXN0SHR0cE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcGF0Y2hlZEh0dHBPcHRpb25zID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShiYXNlSHR0cE9wdGlvbnMpKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocmVxdWVzdEh0dHBPcHRpb25zKSkge1xuICAgICAgICAgICAgLy8gUmVjb3JkcyBjb21waWxlIHRvIG9iamVjdHMuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVFMyMzQ1VFM3MDUzOiBFbGVtZW50IGltcGxpY2l0bHkgaGFzIGFuICdhbnknIHR5cGVcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIGV4cHJlc3Npb24gb2YgdHlwZSAnc3RyaW5nJyBjYW4ndCBiZSB1c2VkIHRvIGluZGV4IHR5cGVcbiAgICAgICAgICAgICAgICAvLyAnSHR0cE9wdGlvbnMnLlxuICAgICAgICAgICAgICAgIHBhdGNoZWRIdHRwT3B0aW9uc1trZXldID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXRjaGVkSHR0cE9wdGlvbnNba2V5XSksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRTMjM0NVRTNzA1MzogRWxlbWVudCBpbXBsaWNpdGx5IGhhcyBhbiAnYW55JyB0eXBlXG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBleHByZXNzaW9uIG9mIHR5cGUgJ3N0cmluZycgY2FuJ3QgYmUgdXNlZCB0byBpbmRleCB0eXBlXG4gICAgICAgICAgICAgICAgLy8gJ0h0dHBPcHRpb25zJy5cbiAgICAgICAgICAgICAgICBwYXRjaGVkSHR0cE9wdGlvbnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRjaGVkSHR0cE9wdGlvbnM7XG4gICAgfVxuICAgIGFzeW5jIHJlcXVlc3RTdHJlYW0ocmVxdWVzdCkge1xuICAgICAgICBsZXQgcGF0Y2hlZEh0dHBPcHRpb25zID0gdGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zO1xuICAgICAgICBpZiAocmVxdWVzdC5odHRwT3B0aW9ucykge1xuICAgICAgICAgICAgcGF0Y2hlZEh0dHBPcHRpb25zID0gdGhpcy5wYXRjaEh0dHBPcHRpb25zKHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucywgcmVxdWVzdC5odHRwT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJlcGVuZFByb2plY3RMb2NhdGlvbiA9IHRoaXMuc2hvdWxkUHJlcGVuZFZlcnRleFByb2plY3RQYXRoKHJlcXVlc3QpO1xuICAgICAgICBjb25zdCB1cmwgPSB0aGlzLmNvbnN0cnVjdFVybChyZXF1ZXN0LnBhdGgsIHBhdGNoZWRIdHRwT3B0aW9ucywgcHJlcGVuZFByb2plY3RMb2NhdGlvbik7XG4gICAgICAgIGlmICghdXJsLnNlYXJjaFBhcmFtcy5oYXMoJ2FsdCcpIHx8IHVybC5zZWFyY2hQYXJhbXMuZ2V0KCdhbHQnKSAhPT0gJ3NzZScpIHtcbiAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdhbHQnLCAnc3NlJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlcXVlc3RJbml0ID0ge307XG4gICAgICAgIHJlcXVlc3RJbml0LmJvZHkgPSByZXF1ZXN0LmJvZHk7XG4gICAgICAgIHJlcXVlc3RJbml0ID0gYXdhaXQgdGhpcy5pbmNsdWRlRXh0cmFIdHRwT3B0aW9uc1RvUmVxdWVzdEluaXQocmVxdWVzdEluaXQsIHBhdGNoZWRIdHRwT3B0aW9ucywgdXJsLnRvU3RyaW5nKCksIHJlcXVlc3QuYWJvcnRTaWduYWwpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1BcGlDYWxsKHVybCwgcmVxdWVzdEluaXQsIHJlcXVlc3QuaHR0cE1ldGhvZCk7XG4gICAgfVxuICAgIGFzeW5jIGluY2x1ZGVFeHRyYUh0dHBPcHRpb25zVG9SZXF1ZXN0SW5pdChyZXF1ZXN0SW5pdCwgaHR0cE9wdGlvbnMsIHVybCwgYWJvcnRTaWduYWwpIHtcbiAgICAgICAgaWYgKChodHRwT3B0aW9ucyAmJiBodHRwT3B0aW9ucy50aW1lb3V0KSB8fCBhYm9ydFNpZ25hbCkge1xuICAgICAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbmFsID0gYWJvcnRDb250cm9sbGVyLnNpZ25hbDtcbiAgICAgICAgICAgIGlmIChodHRwT3B0aW9ucy50aW1lb3V0ICYmIChodHRwT3B0aW9ucyA9PT0gbnVsbCB8fCBodHRwT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaHR0cE9wdGlvbnMudGltZW91dCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZW91dEhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4gYWJvcnRDb250cm9sbGVyLmFib3J0KCksIGh0dHBPcHRpb25zLnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0SGFuZGxlICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiB0aW1lb3V0SGFuZGxlLnVucmVmID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBjYWxsIHVucmVmIHRvIHByZXZlbnQgbm9kZWpzIHByb2Nlc3MgZnJvbSBoYW5naW5nLCBzZWVcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS90aW1lcnMuaHRtbCN0aW1lb3V0dW5yZWZcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dEhhbmRsZS51bnJlZigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhYm9ydFNpZ25hbCkge1xuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcXVlc3RJbml0LnNpZ25hbCA9IHNpZ25hbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaHR0cE9wdGlvbnMgJiYgaHR0cE9wdGlvbnMuZXh0cmFCb2R5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbmNsdWRlRXh0cmFCb2R5VG9SZXF1ZXN0SW5pdChyZXF1ZXN0SW5pdCwgaHR0cE9wdGlvbnMuZXh0cmFCb2R5KTtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0SW5pdC5oZWFkZXJzID0gYXdhaXQgdGhpcy5nZXRIZWFkZXJzSW50ZXJuYWwoaHR0cE9wdGlvbnMsIHVybCk7XG4gICAgICAgIHJldHVybiByZXF1ZXN0SW5pdDtcbiAgICB9XG4gICAgYXN5bmMgdW5hcnlBcGlDYWxsKHVybCwgcmVxdWVzdEluaXQsIGh0dHBNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2FsbCh1cmwudG9TdHJpbmcoKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0SW5pdCksIHsgbWV0aG9kOiBodHRwTWV0aG9kIH0pKVxuICAgICAgICAgICAgLnRoZW4oYXN5bmMgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aHJvd0Vycm9ySWZOb3RPSyhyZXNwb25zZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEh0dHBSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHN0cmVhbUFwaUNhbGwodXJsLCByZXF1ZXN0SW5pdCwgaHR0cE1ldGhvZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcGlDYWxsKHVybC50b1N0cmluZygpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlcXVlc3RJbml0KSwgeyBtZXRob2Q6IGh0dHBNZXRob2QgfSkpXG4gICAgICAgICAgICAudGhlbihhc3luYyAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRocm93RXJyb3JJZk5vdE9LKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NTdHJlYW1SZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHByb2Nlc3NTdHJlYW1SZXNwb25zZShyZXNwb25zZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qIHByb2Nlc3NTdHJlYW1SZXNwb25zZV8xKCkge1xuICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gKF9hID0gcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLmJvZHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRSZWFkZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi04Jyk7XG4gICAgICAgICAgICBpZiAoIXJlYWRlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVzcG9uc2UgYm9keSBpcyBlbXB0eScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgYnVmZmVyID0gJyc7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0geWllbGQgX19hd2FpdChyZWFkZXIucmVhZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXIudHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29tcGxldGUgSlNPTiBzZWdtZW50IGF0IHRoZSBlbmQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rU3RyaW5nID0gZGVjb2Rlci5kZWNvZGUodmFsdWUsIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSBhbmQgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGNodW5rIGNvbnRhaW5zIGFuIGVycm9yLlxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmtKc29uID0gSlNPTi5wYXJzZShjaHVua1N0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJ2Vycm9yJyBpbiBjaHVua0pzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvckpzb24gPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNodW5rSnNvblsnZXJyb3InXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IGVycm9ySnNvblsnc3RhdHVzJ107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IGVycm9ySnNvblsnY29kZSddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGBnb3Qgc3RhdHVzOiAke3N0YXR1c30uICR7SlNPTi5zdHJpbmdpZnkoY2h1bmtKc29uKX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlID49IDQwMCAmJiBjb2RlIDwgNjAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFwaUVycm9yID0gbmV3IEFwaUVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yTWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGFwaUVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdBcGlFcnJvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlciArPSBjaHVua1N0cmluZztcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hdGNoID0gYnVmZmVyLm1hdGNoKHJlc3BvbnNlTGluZVJFKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9jZXNzZWRDaHVua1N0cmluZyA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJ0aWFsUmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UocHJvY2Vzc2VkQ2h1bmtTdHJpbmcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChuZXcgSHR0cFJlc3BvbnNlKHBhcnRpYWxSZXNwb25zZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShtYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gYnVmZmVyLm1hdGNoKHJlc3BvbnNlTGluZVJFKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleGNlcHRpb24gcGFyc2luZyBzdHJlYW0gY2h1bmsgJHtwcm9jZXNzZWRDaHVua1N0cmluZ30uICR7ZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgYXBpQ2FsbCh1cmwsIHJlcXVlc3RJbml0KSB7XG4gICAgICAgIHJldHVybiBmZXRjaCh1cmwsIHJlcXVlc3RJbml0KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleGNlcHRpb24gJHtlfSBzZW5kaW5nIHJlcXVlc3RgKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldERlZmF1bHRIZWFkZXJzKCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgICAgIGNvbnN0IHZlcnNpb25IZWFkZXJWYWx1ZSA9IExJQlJBUllfTEFCRUwgKyAnICcgKyB0aGlzLmNsaWVudE9wdGlvbnMudXNlckFnZW50RXh0cmE7XG4gICAgICAgIGhlYWRlcnNbVVNFUl9BR0VOVF9IRUFERVJdID0gdmVyc2lvbkhlYWRlclZhbHVlO1xuICAgICAgICBoZWFkZXJzW0dPT0dMRV9BUElfQ0xJRU5UX0hFQURFUl0gPSB2ZXJzaW9uSGVhZGVyVmFsdWU7XG4gICAgICAgIGhlYWRlcnNbQ09OVEVOVF9UWVBFX0hFQURFUl0gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH1cbiAgICBhc3luYyBnZXRIZWFkZXJzSW50ZXJuYWwoaHR0cE9wdGlvbnMsIHVybCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICAgICAgaWYgKGh0dHBPcHRpb25zICYmIGh0dHBPcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGh0dHBPcHRpb25zLmhlYWRlcnMpKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBcHBlbmQgYSB0aW1lb3V0IGhlYWRlciBpZiBpdCBpcyBzZXQsIG5vdGUgdGhhdCB0aGUgdGltZW91dCBvcHRpb24gaXNcbiAgICAgICAgICAgIC8vIGluIG1pbGxpc2Vjb25kcyBidXQgdGhlIGhlYWRlciBpcyBpbiBzZWNvbmRzLlxuICAgICAgICAgICAgaWYgKGh0dHBPcHRpb25zLnRpbWVvdXQgJiYgaHR0cE9wdGlvbnMudGltZW91dCA+IDApIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLmFwcGVuZChTRVJWRVJfVElNRU9VVF9IRUFERVIsIFN0cmluZyhNYXRoLmNlaWwoaHR0cE9wdGlvbnMudGltZW91dCAvIDEwMDApKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5jbGllbnRPcHRpb25zLmF1dGguYWRkQXV0aEhlYWRlcnMoaGVhZGVycywgdXJsKTtcbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuICAgIGdldEZpbGVOYW1lKGZpbGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgZmlsZU5hbWUgPSAnJztcbiAgICAgICAgaWYgKHR5cGVvZiBmaWxlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZmlsZU5hbWUgPSBmaWxlLnJlcGxhY2UoL1svXFxcXF0rJC8sICcnKTtcbiAgICAgICAgICAgIGZpbGVOYW1lID0gKF9hID0gZmlsZU5hbWUuc3BsaXQoL1svXFxcXF0vKS5wb3AoKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbGVOYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIGEgZmlsZSBhc3luY2hyb25vdXNseSB1c2luZyBHZW1pbmkgQVBJIG9ubHksIHRoaXMgaXMgbm90IHN1cHBvcnRlZFxuICAgICAqIGluIFZlcnRleCBBSS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWxlIFRoZSBzdHJpbmcgcGF0aCB0byB0aGUgZmlsZSB0byBiZSB1cGxvYWRlZCBvciBhIEJsb2Igb2JqZWN0LlxuICAgICAqIEBwYXJhbSBjb25maWcgT3B0aW9uYWwgcGFyYW1ldGVycyBzcGVjaWZpZWQgaW4gdGhlIGBVcGxvYWRGaWxlQ29uZmlnYFxuICAgICAqICAgICBpbnRlcmZhY2UuIEBzZWUge0BsaW5rIHR5cGVzLlVwbG9hZEZpbGVDb25maWd9XG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGaWxlYCBvYmplY3QuXG4gICAgICogQHRocm93cyBBbiBlcnJvciBpZiBjYWxsZWQgb24gYSBWZXJ0ZXggQUkgY2xpZW50LlxuICAgICAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgdGhlIGBtaW1lVHlwZWAgaXMgbm90IHByb3ZpZGVkIGFuZCBjYW4gbm90IGJlIGluZmVycmVkLFxuICAgICAqL1xuICAgIGFzeW5jIHVwbG9hZEZpbGUoZmlsZSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgZmlsZVRvVXBsb2FkID0ge307XG4gICAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgZmlsZVRvVXBsb2FkLm1pbWVUeXBlID0gY29uZmlnLm1pbWVUeXBlO1xuICAgICAgICAgICAgZmlsZVRvVXBsb2FkLm5hbWUgPSBjb25maWcubmFtZTtcbiAgICAgICAgICAgIGZpbGVUb1VwbG9hZC5kaXNwbGF5TmFtZSA9IGNvbmZpZy5kaXNwbGF5TmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlsZVRvVXBsb2FkLm5hbWUgJiYgIWZpbGVUb1VwbG9hZC5uYW1lLnN0YXJ0c1dpdGgoJ2ZpbGVzLycpKSB7XG4gICAgICAgICAgICBmaWxlVG9VcGxvYWQubmFtZSA9IGBmaWxlcy8ke2ZpbGVUb1VwbG9hZC5uYW1lfWA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXBsb2FkZXIgPSB0aGlzLmNsaWVudE9wdGlvbnMudXBsb2FkZXI7XG4gICAgICAgIGNvbnN0IGZpbGVTdGF0ID0gYXdhaXQgdXBsb2FkZXIuc3RhdChmaWxlKTtcbiAgICAgICAgZmlsZVRvVXBsb2FkLnNpemVCeXRlcyA9IFN0cmluZyhmaWxlU3RhdC5zaXplKTtcbiAgICAgICAgY29uc3QgbWltZVR5cGUgPSAoX2EgPSBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcubWltZVR5cGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZpbGVTdGF0LnR5cGU7XG4gICAgICAgIGlmIChtaW1lVHlwZSA9PT0gdW5kZWZpbmVkIHx8IG1pbWVUeXBlID09PSAnJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGRldGVybWluZSBtaW1lVHlwZS4gUGxlYXNlIHByb3ZpZGUgbWltZVR5cGUgaW4gdGhlIGNvbmZpZy4nKTtcbiAgICAgICAgfVxuICAgICAgICBmaWxlVG9VcGxvYWQubWltZVR5cGUgPSBtaW1lVHlwZTtcbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIGZpbGU6IGZpbGVUb1VwbG9hZCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZmlsZU5hbWUgPSB0aGlzLmdldEZpbGVOYW1lKGZpbGUpO1xuICAgICAgICBjb25zdCBwYXRoID0gZm9ybWF0TWFwKCd1cGxvYWQvdjFiZXRhL2ZpbGVzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgY29uc3QgdXBsb2FkVXJsID0gYXdhaXQgdGhpcy5mZXRjaFVwbG9hZFVybChwYXRoLCBmaWxlVG9VcGxvYWQuc2l6ZUJ5dGVzLCBmaWxlVG9VcGxvYWQubWltZVR5cGUsIGZpbGVOYW1lLCBib2R5LCBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcuaHR0cE9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdXBsb2FkZXIudXBsb2FkKGZpbGUsIHVwbG9hZFVybCwgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwbG9hZHMgYSBmaWxlIHRvIGEgZ2l2ZW4gZmlsZSBzZWFyY2ggc3RvcmUgYXN5bmNocm9ub3VzbHkgdXNpbmcgR2VtaW5pIEFQSSBvbmx5LCB0aGlzIGlzIG5vdCBzdXBwb3J0ZWRcbiAgICAgKiBpbiBWZXJ0ZXggQUkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlsZVNlYXJjaFN0b3JlTmFtZSBUaGUgbmFtZSBvZiB0aGUgZmlsZSBzZWFyY2ggc3RvcmUgdG8gdXBsb2FkIHRoZSBmaWxlIHRvLlxuICAgICAqIEBwYXJhbSBmaWxlIFRoZSBzdHJpbmcgcGF0aCB0byB0aGUgZmlsZSB0byBiZSB1cGxvYWRlZCBvciBhIEJsb2Igb2JqZWN0LlxuICAgICAqIEBwYXJhbSBjb25maWcgT3B0aW9uYWwgcGFyYW1ldGVycyBzcGVjaWZpZWQgaW4gdGhlIGBVcGxvYWRGaWxlQ29uZmlnYFxuICAgICAqICAgICBpbnRlcmZhY2UuIEBzZWUge0BsaW5rIFVwbG9hZEZpbGVDb25maWd9XG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGaWxlYCBvYmplY3QuXG4gICAgICogQHRocm93cyBBbiBlcnJvciBpZiBjYWxsZWQgb24gYSBWZXJ0ZXggQUkgY2xpZW50LlxuICAgICAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgdGhlIGBtaW1lVHlwZWAgaXMgbm90IHByb3ZpZGVkIGFuZCBjYW4gbm90IGJlIGluZmVycmVkLFxuICAgICAqL1xuICAgIGFzeW5jIHVwbG9hZEZpbGVUb0ZpbGVTZWFyY2hTdG9yZShmaWxlU2VhcmNoU3RvcmVOYW1lLCBmaWxlLCBjb25maWcpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB1cGxvYWRlciA9IHRoaXMuY2xpZW50T3B0aW9ucy51cGxvYWRlcjtcbiAgICAgICAgY29uc3QgZmlsZVN0YXQgPSBhd2FpdCB1cGxvYWRlci5zdGF0KGZpbGUpO1xuICAgICAgICBjb25zdCBzaXplQnl0ZXMgPSBTdHJpbmcoZmlsZVN0YXQuc2l6ZSk7XG4gICAgICAgIGNvbnN0IG1pbWVUeXBlID0gKF9hID0gY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLm1pbWVUeXBlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmaWxlU3RhdC50eXBlO1xuICAgICAgICBpZiAobWltZVR5cGUgPT09IHVuZGVmaW5lZCB8fCBtaW1lVHlwZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBkZXRlcm1pbmUgbWltZVR5cGUuIFBsZWFzZSBwcm92aWRlIG1pbWVUeXBlIGluIHRoZSBjb25maWcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGF0aCA9IGB1cGxvYWQvdjFiZXRhLyR7ZmlsZVNlYXJjaFN0b3JlTmFtZX06dXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVgO1xuICAgICAgICBjb25zdCBmaWxlTmFtZSA9IHRoaXMuZ2V0RmlsZU5hbWUoZmlsZSk7XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7fTtcbiAgICAgICAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgICAgICB1cGxvYWRUb0ZpbGVTZWFyY2hTdG9yZUNvbmZpZ1RvTWxkZXYoY29uZmlnLCBib2R5KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cGxvYWRVcmwgPSBhd2FpdCB0aGlzLmZldGNoVXBsb2FkVXJsKHBhdGgsIHNpemVCeXRlcywgbWltZVR5cGUsIGZpbGVOYW1lLCBib2R5LCBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcuaHR0cE9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdXBsb2FkZXIudXBsb2FkVG9GaWxlU2VhcmNoU3RvcmUoZmlsZSwgdXBsb2FkVXJsLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRG93bmxvYWRzIGEgZmlsZSBhc3luY2hyb25vdXNseSB0byB0aGUgc3BlY2lmaWVkIHBhdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW1zIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZG93bmxvYWQgcmVxdWVzdCwgc2VlIHtAbGlua1xuICAgICAqIHR5cGVzLkRvd25sb2FkRmlsZVBhcmFtZXRlcnN9XG4gICAgICovXG4gICAgYXN5bmMgZG93bmxvYWRGaWxlKHBhcmFtcykge1xuICAgICAgICBjb25zdCBkb3dubG9hZGVyID0gdGhpcy5jbGllbnRPcHRpb25zLmRvd25sb2FkZXI7XG4gICAgICAgIGF3YWl0IGRvd25sb2FkZXIuZG93bmxvYWQocGFyYW1zLCB0aGlzKTtcbiAgICB9XG4gICAgYXN5bmMgZmV0Y2hVcGxvYWRVcmwocGF0aCwgc2l6ZUJ5dGVzLCBtaW1lVHlwZSwgZmlsZU5hbWUsIGJvZHksIGNvbmZpZ0h0dHBPcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGh0dHBPcHRpb25zID0ge307XG4gICAgICAgIGlmIChjb25maWdIdHRwT3B0aW9ucykge1xuICAgICAgICAgICAgaHR0cE9wdGlvbnMgPSBjb25maWdIdHRwT3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGh0dHBPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIGFwaVZlcnNpb246ICcnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLCAnWC1Hb29nLVVwbG9hZC1Qcm90b2NvbCc6ICdyZXN1bWFibGUnLCAnWC1Hb29nLVVwbG9hZC1Db21tYW5kJzogJ3N0YXJ0JywgJ1gtR29vZy1VcGxvYWQtSGVhZGVyLUNvbnRlbnQtTGVuZ3RoJzogYCR7c2l6ZUJ5dGVzfWAsICdYLUdvb2ctVXBsb2FkLUhlYWRlci1Db250ZW50LVR5cGUnOiBgJHttaW1lVHlwZX1gIH0sIChmaWxlTmFtZSA/IHsgJ1gtR29vZy1VcGxvYWQtRmlsZS1OYW1lJzogZmlsZU5hbWUgfSA6IHt9KSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGh0dHBSZXNwb25zZSA9IGF3YWl0IHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBodHRwT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaHR0cFJlc3BvbnNlIHx8ICEoaHR0cFJlc3BvbnNlID09PSBudWxsIHx8IGh0dHBSZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaHR0cFJlc3BvbnNlLmhlYWRlcnMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlcnZlciBkaWQgbm90IHJldHVybiBhbiBIdHRwUmVzcG9uc2Ugb3IgdGhlIHJldHVybmVkIEh0dHBSZXNwb25zZSBkaWQgbm90IGhhdmUgaGVhZGVycy4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cGxvYWRVcmwgPSAoX2EgPSBodHRwUmVzcG9uc2UgPT09IG51bGwgfHwgaHR0cFJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBodHRwUmVzcG9uc2UuaGVhZGVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWyd4LWdvb2ctdXBsb2FkLXVybCddO1xuICAgICAgICBpZiAodXBsb2FkVXJsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCB1cGxvYWQgdXJsLiBTZXJ2ZXIgZGlkIG5vdCByZXR1cm4gdGhlIHgtZ29vZ2xlLXVwbG9hZC11cmwgaW4gdGhlIGhlYWRlcnMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXBsb2FkVXJsO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHRocm93RXJyb3JJZk5vdE9LKHJlc3BvbnNlKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChyZXNwb25zZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmVzcG9uc2UgaXMgdW5kZWZpbmVkJyk7XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzO1xuICAgICAgICBsZXQgZXJyb3JCb2R5O1xuICAgICAgICBpZiAoKF9hID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL2pzb24nKSkge1xuICAgICAgICAgICAgZXJyb3JCb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXJyb3JCb2R5ID0ge1xuICAgICAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGF3YWl0IHJlc3BvbnNlLnRleHQoKSxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkoZXJyb3JCb2R5KTtcbiAgICAgICAgaWYgKHN0YXR1cyA+PSA0MDAgJiYgc3RhdHVzIDwgNjAwKSB7XG4gICAgICAgICAgICBjb25zdCBhcGlFcnJvciA9IG5ldyBBcGlFcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JNZXNzYWdlLFxuICAgICAgICAgICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aHJvdyBhcGlFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICB9XG59XG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHVwZGF0ZXMgdGhlIGByZXF1ZXN0SW5pdC5ib2R5YCB3aXRoIHZhbHVlcyBmcm9tIGFuIGBleHRyYUJvZHlgIG9iamVjdC5cbiAqXG4gKiBJZiBgcmVxdWVzdEluaXQuYm9keWAgaXMgYSBzdHJpbmcsIGl0J3MgYXNzdW1lZCB0byBiZSBKU09OIGFuZCB3aWxsIGJlIHBhcnNlZC5cbiAqIFRoZSBgZXh0cmFCb2R5YCBpcyB0aGVuIGRlZXBseSBtZXJnZWQgaW50byB0aGlzIHBhcnNlZCBvYmplY3QuXG4gKiBJZiBgcmVxdWVzdEluaXQuYm9keWAgaXMgYSBCbG9iLCBgZXh0cmFCb2R5YCB3aWxsIGJlIGlnbm9yZWQsIGFuZCBhIHdhcm5pbmcgbG9nZ2VkLFxuICogYXMgbWVyZ2luZyBzdHJ1Y3R1cmVkIGRhdGEgaW50byBhbiBvcGFxdWUgQmxvYiBpcyBub3Qgc3VwcG9ydGVkLlxuICpcbiAqIFRoZSBmdW5jdGlvbiBkb2VzIG5vdCBlbmZvcmNlIHRoYXQgdXBkYXRlZCB2YWx1ZXMgZnJvbSBgZXh0cmFCb2R5YCBoYXZlIHRoZVxuICogc2FtZSB0eXBlIGFzIGV4aXN0aW5nIHZhbHVlcyBpbiBgcmVxdWVzdEluaXQuYm9keWAuIFR5cGUgbWlzbWF0Y2hlcyBkdXJpbmdcbiAqIHRoZSBtZXJnZSB3aWxsIHJlc3VsdCBpbiBhIHdhcm5pbmcsIGJ1dCB0aGUgdmFsdWUgZnJvbSBgZXh0cmFCb2R5YCB3aWxsIG92ZXJ3cml0ZVxuICogdGhlIG9yaWdpbmFsLiBgZXh0cmFCb2R5YCB1c2VycyBhcmUgcmVzcG9uc2libGUgZm9yIGVuc3VyaW5nIGBleHRyYUJvZHlgIGhhcyB0aGUgY29ycmVjdCBzdHJ1Y3R1cmUuXG4gKlxuICogQHBhcmFtIHJlcXVlc3RJbml0IFRoZSBSZXF1ZXN0SW5pdCBvYmplY3Qgd2hvc2UgYm9keSB3aWxsIGJlIHVwZGF0ZWQuXG4gKiBAcGFyYW0gZXh0cmFCb2R5IFRoZSBvYmplY3QgY29udGFpbmluZyB1cGRhdGVzIHRvIGJlIG1lcmdlZCBpbnRvIGByZXF1ZXN0SW5pdC5ib2R5YC5cbiAqL1xuZnVuY3Rpb24gaW5jbHVkZUV4dHJhQm9keVRvUmVxdWVzdEluaXQocmVxdWVzdEluaXQsIGV4dHJhQm9keSkge1xuICAgIGlmICghZXh0cmFCb2R5IHx8IE9iamVjdC5rZXlzKGV4dHJhQm9keSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHJlcXVlc3RJbml0LmJvZHkgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignaW5jbHVkZUV4dHJhQm9keVRvUmVxdWVzdEluaXQ6IGV4dHJhQm9keSBwcm92aWRlZCBidXQgY3VycmVudCByZXF1ZXN0IGJvZHkgaXMgYSBCbG9iLiBleHRyYUJvZHkgd2lsbCBiZSBpZ25vcmVkIGFzIG1lcmdpbmcgaXMgbm90IHN1cHBvcnRlZCBmb3IgQmxvYiBib2RpZXMuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRCb2R5T2JqZWN0ID0ge307XG4gICAgLy8gSWYgYWRkaW5nIG5ldyB0eXBlIHRvIEh0dHBSZXF1ZXN0LmJvZHksIHBsZWFzZSBjaGVjayB0aGUgY29kZSBiZWxvdyB0b1xuICAgIC8vIHNlZSBpZiB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgbG9naWMuXG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0SW5pdC5ib2R5ID09PSAnc3RyaW5nJyAmJiByZXF1ZXN0SW5pdC5ib2R5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEJvZHkgPSBKU09OLnBhcnNlKHJlcXVlc3RJbml0LmJvZHkpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJzZWRCb2R5ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIHBhcnNlZEJvZHkgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAhQXJyYXkuaXNBcnJheShwYXJzZWRCb2R5KSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCb2R5T2JqZWN0ID0gcGFyc2VkQm9keTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignaW5jbHVkZUV4dHJhQm9keVRvUmVxdWVzdEluaXQ6IE9yaWdpbmFsIHJlcXVlc3QgYm9keSBpcyB2YWxpZCBKU09OIGJ1dCBub3QgYSBub24tYXJyYXkgb2JqZWN0LiBTa2lwIGFwcGx5aW5nIGV4dHJhQm9keSB0byB0aGUgcmVxdWVzdCBib2R5LicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qICBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignaW5jbHVkZUV4dHJhQm9keVRvUmVxdWVzdEluaXQ6IE9yaWdpbmFsIHJlcXVlc3QgYm9keSBpcyBub3QgdmFsaWQgSlNPTi4gU2tpcCBhcHBseWluZyBleHRyYUJvZHkgdG8gdGhlIHJlcXVlc3QgYm9keS4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkZWVwTWVyZ2UodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gT2JqZWN0LmFzc2lnbih7fSwgdGFyZ2V0KTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZVZhbHVlID0gc291cmNlW2tleV07XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0VmFsdWUgPSBvdXRwdXRba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlVmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHNvdXJjZVZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICAgICAhQXJyYXkuaXNBcnJheShzb3VyY2VWYWx1ZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHRhcmdldFZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICAgICAhQXJyYXkuaXNBcnJheSh0YXJnZXRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBkZWVwTWVyZ2UodGFyZ2V0VmFsdWUsIHNvdXJjZVZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRWYWx1ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlVmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB0YXJnZXRWYWx1ZSAhPT0gdHlwZW9mIHNvdXJjZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYGluY2x1ZGVFeHRyYUJvZHlUb1JlcXVlc3RJbml0OmRlZXBNZXJnZTogVHlwZSBtaXNtYXRjaCBmb3Iga2V5IFwiJHtrZXl9XCIuIE9yaWdpbmFsIHR5cGU6ICR7dHlwZW9mIHRhcmdldFZhbHVlfSwgTmV3IHR5cGU6ICR7dHlwZW9mIHNvdXJjZVZhbHVlfS4gT3ZlcndyaXRpbmcuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBzb3VyY2VWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgY29uc3QgbWVyZ2VkQm9keSA9IGRlZXBNZXJnZShjdXJyZW50Qm9keU9iamVjdCwgZXh0cmFCb2R5KTtcbiAgICByZXF1ZXN0SW5pdC5ib2R5ID0gSlNPTi5zdHJpbmdpZnkobWVyZ2VkQm9keSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8vIFRPRE86IGIvNDE2MDQxMjI5IC0gRGV0ZXJtaW5lIGhvdyB0byByZXRyaWV2ZSB0aGUgTUNQIHBhY2thZ2UgdmVyc2lvbi5cbmNvbnN0IE1DUF9MQUJFTCA9ICdtY3BfdXNlZC91bmtub3duJztcbi8vIFdoZXRoZXIgTUNQIHRvb2wgdXNhZ2UgaXMgZGV0ZWN0ZWQgZnJvbSBtY3BUb1Rvb2wuIFRoaXMgaXMgdXNlZCBmb3Jcbi8vIHRlbGVtZXRyeS5cbmxldCBoYXNNY3BUb29sVXNhZ2VGcm9tTWNwVG9Ub29sID0gZmFsc2U7XG4vLyBDaGVja3Mgd2hldGhlciB0aGUgbGlzdCBvZiB0b29scyBjb250YWlucyBhbnkgTUNQIHRvb2xzLlxuZnVuY3Rpb24gaGFzTWNwVG9vbFVzYWdlKHRvb2xzKSB7XG4gICAgZm9yIChjb25zdCB0b29sIG9mIHRvb2xzKSB7XG4gICAgICAgIGlmIChpc01jcENhbGxhYmxlVG9vbCh0b29sKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0b29sID09PSAnb2JqZWN0JyAmJiAnaW5wdXRTY2hlbWEnIGluIHRvb2wpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoYXNNY3BUb29sVXNhZ2VGcm9tTWNwVG9Ub29sO1xufVxuLy8gU2V0cyB0aGUgTUNQIHZlcnNpb24gbGFiZWwgaW4gdGhlIEdvb2dsZSBBUEkgY2xpZW50IGhlYWRlci5cbmZ1bmN0aW9uIHNldE1jcFVzYWdlSGVhZGVyKGhlYWRlcnMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZXhpc3RpbmdIZWFkZXIgPSAoX2EgPSBoZWFkZXJzW0dPT0dMRV9BUElfQ0xJRU5UX0hFQURFUl0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xuICAgIGhlYWRlcnNbR09PR0xFX0FQSV9DTElFTlRfSEVBREVSXSA9IChleGlzdGluZ0hlYWRlciArIGAgJHtNQ1BfTEFCRUx9YCkudHJpbVN0YXJ0KCk7XG59XG4vLyBSZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBpcyBhIE1DUCBDYWxsYWJsZVRvb2wsIG90aGVyd2lzZSBmYWxzZS5cbmZ1bmN0aW9uIGlzTWNwQ2FsbGFibGVUb29sKG9iamVjdCkge1xuICAgIHJldHVybiAob2JqZWN0ICE9PSBudWxsICYmXG4gICAgICAgIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICAgIG9iamVjdCBpbnN0YW5jZW9mIE1jcENhbGxhYmxlVG9vbCk7XG59XG4vLyBMaXN0IGFsbCB0b29scyBmcm9tIHRoZSBNQ1AgY2xpZW50LlxuZnVuY3Rpb24gbGlzdEFsbFRvb2xzKG1jcENsaWVudCwgbWF4VG9vbHMgPSAxMDApIHtcbiAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiBsaXN0QWxsVG9vbHNfMSgpIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IG51bVRvb2xzID0gMDtcbiAgICAgICAgd2hpbGUgKG51bVRvb2xzIDwgbWF4VG9vbHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHQgPSB5aWVsZCBfX2F3YWl0KG1jcENsaWVudC5saXN0VG9vbHMoeyBjdXJzb3IgfSkpO1xuICAgICAgICAgICAgZm9yIChjb25zdCB0b29sIG9mIHQudG9vbHMpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHRvb2wpO1xuICAgICAgICAgICAgICAgIG51bVRvb2xzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXQubmV4dEN1cnNvcikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3Vyc29yID0gdC5uZXh0Q3Vyc29yO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIE1jcENhbGxhYmxlVG9vbCBjYW4gYmUgdXNlZCBmb3IgbW9kZWwgaW5mZXJlbmNlIGFuZCBpbnZva2luZyBNQ1AgY2xpZW50cyB3aXRoXG4gKiBnaXZlbiBmdW5jdGlvbiBjYWxsIGFyZ3VtZW50cy5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIEJ1aWx0LWluIE1DUCBzdXBwb3J0IGlzIGFuIGV4cGVyaW1lbnRhbCBmZWF0dXJlLCBtYXkgY2hhbmdlIGluIGZ1dHVyZVxuICogdmVyc2lvbnMuXG4gKi9cbmNsYXNzIE1jcENhbGxhYmxlVG9vbCB7XG4gICAgY29uc3RydWN0b3IobWNwQ2xpZW50cyA9IFtdLCBjb25maWcpIHtcbiAgICAgICAgdGhpcy5tY3BUb29scyA9IFtdO1xuICAgICAgICB0aGlzLmZ1bmN0aW9uTmFtZVRvTWNwQ2xpZW50ID0ge307XG4gICAgICAgIHRoaXMubWNwQ2xpZW50cyA9IG1jcENsaWVudHM7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgTWNwQ2FsbGFibGVUb29sLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUobWNwQ2xpZW50cywgY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWNwQ2FsbGFibGVUb29sKG1jcENsaWVudHMsIGNvbmZpZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyB0aGUgZnVuY3Rpb24gbmFtZXMgYXJlIG5vdCBkdXBsaWNhdGUgYW5kIGluaXRpYWxpemUgdGhlIGZ1bmN0aW9uXG4gICAgICogbmFtZSB0byBNQ1AgY2xpZW50IG1hcHBpbmcuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIE1DUCB0b29scyBmcm9tIHRoZSBNQ1AgY2xpZW50cyBoYXZlIGR1cGxpY2F0ZSB0b29sXG4gICAgICogICAgIG5hbWVzLlxuICAgICAqL1xuICAgIGFzeW5jIGluaXRpYWxpemUoKSB7XG4gICAgICAgIHZhciBfYSwgZV8xLCBfYiwgX2M7XG4gICAgICAgIGlmICh0aGlzLm1jcFRvb2xzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmdW5jdGlvbk1hcCA9IHt9O1xuICAgICAgICBjb25zdCBtY3BUb29scyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG1jcENsaWVudCBvZiB0aGlzLm1jcENsaWVudHMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBfZSA9IChlXzEgPSB2b2lkIDAsIF9fYXN5bmNWYWx1ZXMobGlzdEFsbFRvb2xzKG1jcENsaWVudCkpKSwgX2Y7IF9mID0gYXdhaXQgX2UubmV4dCgpLCBfYSA9IF9mLmRvbmUsICFfYTsgX2QgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jID0gX2YudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIF9kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1jcFRvb2wgPSBfYztcbiAgICAgICAgICAgICAgICAgICAgbWNwVG9vbHMucHVzaChtY3BUb29sKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWNwVG9vbE5hbWUgPSBtY3BUb29sLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmdW5jdGlvbk1hcFttY3BUb29sTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGZ1bmN0aW9uIG5hbWUgJHttY3BUb29sTmFtZX0gZm91bmQgaW4gTUNQIHRvb2xzLiBQbGVhc2UgZW5zdXJlIGZ1bmN0aW9uIG5hbWVzIGFyZSB1bmlxdWUuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25NYXBbbWNwVG9vbE5hbWVdID0gbWNwQ2xpZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBfZS5yZXR1cm4pKSBhd2FpdCBfYi5jYWxsKF9lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubWNwVG9vbHMgPSBtY3BUb29scztcbiAgICAgICAgdGhpcy5mdW5jdGlvbk5hbWVUb01jcENsaWVudCA9IGZ1bmN0aW9uTWFwO1xuICAgIH1cbiAgICBhc3luYyB0b29sKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgcmV0dXJuIG1jcFRvb2xzVG9HZW1pbmlUb29sKHRoaXMubWNwVG9vbHMsIHRoaXMuY29uZmlnKTtcbiAgICB9XG4gICAgYXN5bmMgY2FsbFRvb2woZnVuY3Rpb25DYWxscykge1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgY29uc3QgZnVuY3Rpb25DYWxsUmVzcG9uc2VQYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGZ1bmN0aW9uQ2FsbCBvZiBmdW5jdGlvbkNhbGxzKSB7XG4gICAgICAgICAgICBpZiAoZnVuY3Rpb25DYWxsLm5hbWUgaW4gdGhpcy5mdW5jdGlvbk5hbWVUb01jcENsaWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1jcENsaWVudCA9IHRoaXMuZnVuY3Rpb25OYW1lVG9NY3BDbGllbnRbZnVuY3Rpb25DYWxsLm5hbWVdO1xuICAgICAgICAgICAgICAgIGxldCByZXF1ZXN0T3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBiLzQyNDIzODY1NCAtIEFkZCBzdXBwb3J0IGZvciBmaW5lciBncmFpbmVkIHRpbWVvdXQgY29udHJvbC5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcudGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IHRoaXMuY29uZmlnLnRpbWVvdXQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxUb29sUmVzcG9uc2UgPSBhd2FpdCBtY3BDbGllbnQuY2FsbFRvb2woe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBmdW5jdGlvbkNhbGwubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBmdW5jdGlvbkNhbGwuYXJncyxcbiAgICAgICAgICAgICAgICB9LCBcbiAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIHJlc3VsdCBzY2hlbWEgdG8gdW5kZWZpbmVkIHRvIGFsbG93IE1DUCB0byByZWx5IG9uIHRoZVxuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgc2NoZW1hLlxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgcmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uQ2FsbFJlc3BvbnNlUGFydHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGZ1bmN0aW9uQ2FsbC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IGNhbGxUb29sUmVzcG9uc2UuaXNFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8geyBlcnJvcjogY2FsbFRvb2xSZXNwb25zZSB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjYWxsVG9vbFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbkNhbGxSZXNwb25zZVBhcnRzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzTWNwQ2xpZW50KGNsaWVudCkge1xuICAgIHJldHVybiAoY2xpZW50ICE9PSBudWxsICYmXG4gICAgICAgIHR5cGVvZiBjbGllbnQgPT09ICdvYmplY3QnICYmXG4gICAgICAgICdsaXN0VG9vbHMnIGluIGNsaWVudCAmJlxuICAgICAgICB0eXBlb2YgY2xpZW50Lmxpc3RUb29scyA9PT0gJ2Z1bmN0aW9uJyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBNY3BDYWxsYWJsZVRvb2wgZnJvbSBNQ1AgY2xpZW50cyBhbmQgYW4gb3B0aW9uYWwgY29uZmlnLlxuICpcbiAqIFRoZSBjYWxsYWJsZSB0b29sIGNhbiBpbnZva2UgdGhlIE1DUCBjbGllbnRzIHdpdGggZ2l2ZW4gZnVuY3Rpb24gY2FsbFxuICogYXJndW1lbnRzLiAob2Z0ZW4gZm9yIGF1dG9tYXRpYyBmdW5jdGlvbiBjYWxsaW5nKS5cbiAqIFVzZSB0aGUgY29uZmlnIHRvIG1vZGlmeSB0b29sIHBhcmFtZXRlcnMgc3VjaCBhcyBiZWhhdmlvci5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIEJ1aWx0LWluIE1DUCBzdXBwb3J0IGlzIGFuIGV4cGVyaW1lbnRhbCBmZWF0dXJlLCBtYXkgY2hhbmdlIGluIGZ1dHVyZVxuICogdmVyc2lvbnMuXG4gKi9cbmZ1bmN0aW9uIG1jcFRvVG9vbCguLi5hcmdzKSB7XG4gICAgLy8gU2V0IE1DUCB1c2FnZSBmb3IgdGVsZW1ldHJ5LlxuICAgIGhhc01jcFRvb2xVc2FnZUZyb21NY3BUb1Rvb2wgPSB0cnVlO1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIE1DUCBjbGllbnRzIHByb3ZpZGVkJyk7XG4gICAgfVxuICAgIGNvbnN0IG1heWJlQ29uZmlnID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChpc01jcENsaWVudChtYXliZUNvbmZpZykpIHtcbiAgICAgICAgcmV0dXJuIE1jcENhbGxhYmxlVG9vbC5jcmVhdGUoYXJncywge30pO1xuICAgIH1cbiAgICByZXR1cm4gTWNwQ2FsbGFibGVUb29sLmNyZWF0ZShhcmdzLnNsaWNlKDAsIGFyZ3MubGVuZ3RoIC0gMSksIG1heWJlQ29uZmlnKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuLyoqXG4gKiBIYW5kbGVzIGluY29taW5nIG1lc3NhZ2VzIGZyb20gdGhlIFdlYlNvY2tldC5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhpcyBmdW5jdGlvbiBpcyByZXNwb25zaWJsZSBmb3IgcGFyc2luZyBpbmNvbWluZyBtZXNzYWdlcywgdHJhbnNmb3JtaW5nIHRoZW1cbiAqIGludG8gTGl2ZU11c2ljU2VydmVyTWVzc2FnZSwgYW5kIHRoZW4gY2FsbGluZyB0aGUgb25tZXNzYWdlIGNhbGxiYWNrLlxuICogTm90ZSB0aGF0IHRoZSBmaXJzdCBtZXNzYWdlIHdoaWNoIGlzIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlciBpcyBhXG4gKiBzZXR1cENvbXBsZXRlIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIGFwaUNsaWVudCBUaGUgQXBpQ2xpZW50IGluc3RhbmNlLlxuICogQHBhcmFtIG9ubWVzc2FnZSBUaGUgdXNlci1wcm92aWRlZCBvbm1lc3NhZ2UgY2FsbGJhY2sgKGlmIGFueSkuXG4gKiBAcGFyYW0gZXZlbnQgVGhlIE1lc3NhZ2VFdmVudCBmcm9tIHRoZSBXZWJTb2NrZXQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVdlYlNvY2tldE1lc3NhZ2UkMShhcGlDbGllbnQsIG9ubWVzc2FnZSwgZXZlbnQpIHtcbiAgICBjb25zdCBzZXJ2ZXJNZXNzYWdlID0gbmV3IExpdmVNdXNpY1NlcnZlck1lc3NhZ2UoKTtcbiAgICBsZXQgZGF0YTtcbiAgICBpZiAoZXZlbnQuZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoYXdhaXQgZXZlbnQuZGF0YS50ZXh0KCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24oc2VydmVyTWVzc2FnZSwgZGF0YSk7XG4gICAgb25tZXNzYWdlKHNlcnZlck1lc3NhZ2UpO1xufVxuLyoqXG4gICBMaXZlTXVzaWMgY2xhc3MgZW5jYXBzdWxhdGVzIHRoZSBjb25maWd1cmF0aW9uIGZvciBsaXZlIG11c2ljXG4gICBnZW5lcmF0aW9uIHZpYSBMeXJpYSBMaXZlIG1vZGVscy5cblxuICAgQGV4cGVyaW1lbnRhbFxuICAqL1xuY2xhc3MgTGl2ZU11c2ljIHtcbiAgICBjb25zdHJ1Y3RvcihhcGlDbGllbnQsIGF1dGgsIHdlYlNvY2tldEZhY3RvcnkpIHtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgICAgIHRoaXMuYXV0aCA9IGF1dGg7XG4gICAgICAgIHRoaXMud2ViU29ja2V0RmFjdG9yeSA9IHdlYlNvY2tldEZhY3Rvcnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAgIEVzdGFibGlzaGVzIGEgY29ubmVjdGlvbiB0byB0aGUgc3BlY2lmaWVkIG1vZGVsIGFuZCByZXR1cm5zIGFcbiAgICAgICBMaXZlTXVzaWNTZXNzaW9uIG9iamVjdCByZXByZXNlbnRpbmcgdGhhdCBjb25uZWN0aW9uLlxuICBcbiAgICAgICBAZXhwZXJpbWVudGFsXG4gIFxuICAgICAgIEByZW1hcmtzXG4gIFxuICAgICAgIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZXN0YWJsaXNoaW5nIGEgY29ubmVjdGlvbiB0byB0aGUgbW9kZWwuXG4gICAgICAgQHJldHVybiBBIGxpdmUgc2Vzc2lvbi5cbiAgXG4gICAgICAgQGV4YW1wbGVcbiAgICAgICBgYGB0c1xuICAgICAgIGxldCBtb2RlbCA9ICdtb2RlbHMvbHlyaWEtcmVhbHRpbWUtZXhwJztcbiAgICAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgYWkubGl2ZS5tdXNpYy5jb25uZWN0KHtcbiAgICAgICAgIG1vZGVsOiBtb2RlbCxcbiAgICAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICAgICBvbm1lc3NhZ2U6IChlOiBNZXNzYWdlRXZlbnQpID0+IHtcbiAgICAgICAgICAgICBjb25zb2xlLmxvZygnUmVjZWl2ZWQgbWVzc2FnZSBmcm9tIHRoZSBzZXJ2ZXI6ICVzXFxuJywgZGVidWcoZS5kYXRhKSk7XG4gICAgICAgICAgIH0sXG4gICAgICAgICAgIG9uZXJyb3I6IChlOiBFcnJvckV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgY29uc29sZS5sb2coJ0Vycm9yIG9jY3VycmVkOiAlc1xcbicsIGRlYnVnKGUuZXJyb3IpKTtcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgb25jbG9zZTogKGU6IENsb3NlRXZlbnQpID0+IHtcbiAgICAgICAgICAgICBjb25zb2xlLmxvZygnQ29ubmVjdGlvbiBjbG9zZWQuJyk7XG4gICAgICAgICAgIH0sXG4gICAgICAgICB9LFxuICAgICAgIH0pO1xuICAgICAgIGBgYFxuICAgICAgKi9cbiAgICBhc3luYyBjb25uZWN0KHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xpdmUgbXVzaWMgaXMgbm90IHN1cHBvcnRlZCBmb3IgVmVydGV4IEFJLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUud2FybignTGl2ZSBtdXNpYyBnZW5lcmF0aW9uIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZSBpbiBmdXR1cmUgdmVyc2lvbnMuJyk7XG4gICAgICAgIGNvbnN0IHdlYnNvY2tldEJhc2VVcmwgPSB0aGlzLmFwaUNsaWVudC5nZXRXZWJzb2NrZXRCYXNlVXJsKCk7XG4gICAgICAgIGNvbnN0IGFwaVZlcnNpb24gPSB0aGlzLmFwaUNsaWVudC5nZXRBcGlWZXJzaW9uKCk7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBtYXBUb0hlYWRlcnMkMSh0aGlzLmFwaUNsaWVudC5nZXREZWZhdWx0SGVhZGVycygpKTtcbiAgICAgICAgY29uc3QgYXBpS2V5ID0gdGhpcy5hcGlDbGllbnQuZ2V0QXBpS2V5KCk7XG4gICAgICAgIGNvbnN0IHVybCA9IGAke3dlYnNvY2tldEJhc2VVcmx9L3dzL2dvb2dsZS5haS5nZW5lcmF0aXZlbGFuZ3VhZ2UuJHthcGlWZXJzaW9ufS5HZW5lcmF0aXZlU2VydmljZS5CaWRpR2VuZXJhdGVNdXNpYz9rZXk9JHthcGlLZXl9YDtcbiAgICAgICAgbGV0IG9ub3BlblJlc29sdmUgPSAoKSA9PiB7IH07XG4gICAgICAgIGNvbnN0IG9ub3BlblByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgb25vcGVuUmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSBwYXJhbXMuY2FsbGJhY2tzO1xuICAgICAgICBjb25zdCBvbm9wZW5Bd2FpdGVkQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvbm9wZW5SZXNvbHZlKHt9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYXBpQ2xpZW50ID0gdGhpcy5hcGlDbGllbnQ7XG4gICAgICAgIGNvbnN0IHdlYnNvY2tldENhbGxiYWNrcyA9IHtcbiAgICAgICAgICAgIG9ub3Blbjogb25vcGVuQXdhaXRlZENhbGxiYWNrLFxuICAgICAgICAgICAgb25tZXNzYWdlOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB2b2lkIGhhbmRsZVdlYlNvY2tldE1lc3NhZ2UkMShhcGlDbGllbnQsIGNhbGxiYWNrcy5vbm1lc3NhZ2UsIGV2ZW50KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbmVycm9yOiAoX2EgPSBjYWxsYmFja3MgPT09IG51bGwgfHwgY2FsbGJhY2tzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25lcnJvcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbmNsb3NlOiAoX2IgPSBjYWxsYmFja3MgPT09IG51bGwgfHwgY2FsbGJhY2tzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25jbG9zZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbm4gPSB0aGlzLndlYlNvY2tldEZhY3RvcnkuY3JlYXRlKHVybCwgaGVhZGVyc1RvTWFwJDEoaGVhZGVycyksIHdlYnNvY2tldENhbGxiYWNrcyk7XG4gICAgICAgIGNvbm4uY29ubmVjdCgpO1xuICAgICAgICAvLyBXYWl0IGZvciB0aGUgd2Vic29ja2V0IHRvIG9wZW4gYmVmb3JlIHNlbmRpbmcgcmVxdWVzdHMuXG4gICAgICAgIGF3YWl0IG9ub3BlblByb21pc2U7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdE1vZGVsKHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMubW9kZWwpO1xuICAgICAgICBjb25zdCBzZXR1cCA9IHsgbW9kZWwgfTtcbiAgICAgICAgY29uc3QgY2xpZW50TWVzc2FnZSA9IHsgc2V0dXAgfTtcbiAgICAgICAgY29ubi5zZW5kKEpTT04uc3RyaW5naWZ5KGNsaWVudE1lc3NhZ2UpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBMaXZlTXVzaWNTZXNzaW9uKGNvbm4sIHRoaXMuYXBpQ2xpZW50KTtcbiAgICB9XG59XG4vKipcbiAgIFJlcHJlc2VudHMgYSBjb25uZWN0aW9uIHRvIHRoZSBBUEkuXG5cbiAgIEBleHBlcmltZW50YWxcbiAgKi9cbmNsYXNzIExpdmVNdXNpY1Nlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKGNvbm4sIGFwaUNsaWVudCkge1xuICAgICAgICB0aGlzLmNvbm4gPSBjb25uO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICBTZXRzIGlucHV0cyB0byBzdGVlciBtdXNpYyBnZW5lcmF0aW9uLiBVcGRhdGVzIHRoZSBzZXNzaW9uJ3MgY3VycmVudFxuICAgICAgd2VpZ2h0ZWQgcHJvbXB0cy5cbiAgXG4gICAgICBAcGFyYW0gcGFyYW1zIC0gQ29udGFpbnMgb25lIHByb3BlcnR5LCBgd2VpZ2h0ZWRQcm9tcHRzYC5cbiAgXG4gICAgICAgIC0gYHdlaWdodGVkUHJvbXB0c2AgdG8gc2VuZCB0byB0aGUgbW9kZWw7IHdlaWdodHMgYXJlIG5vcm1hbGl6ZWQgdG9cbiAgICAgICAgICBzdW0gdG8gMS4wLlxuICBcbiAgICAgIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBhc3luYyBzZXRXZWlnaHRlZFByb21wdHMocGFyYW1zKSB7XG4gICAgICAgIGlmICghcGFyYW1zLndlaWdodGVkUHJvbXB0cyB8fFxuICAgICAgICAgICAgT2JqZWN0LmtleXMocGFyYW1zLndlaWdodGVkUHJvbXB0cykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlaWdodGVkIHByb21wdHMgbXVzdCBiZSBzZXQgYW5kIGNvbnRhaW4gYXQgbGVhc3Qgb25lIGVudHJ5LicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsaWVudENvbnRlbnQgPSBsaXZlTXVzaWNTZXRXZWlnaHRlZFByb21wdHNQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICB0aGlzLmNvbm4uc2VuZChKU09OLnN0cmluZ2lmeSh7IGNsaWVudENvbnRlbnQgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgIFNldHMgYSBjb25maWd1cmF0aW9uIHRvIHRoZSBtb2RlbC4gVXBkYXRlcyB0aGUgc2Vzc2lvbidzIGN1cnJlbnRcbiAgICAgIG11c2ljIGdlbmVyYXRpb24gY29uZmlnLlxuICBcbiAgICAgIEBwYXJhbSBwYXJhbXMgLSBDb250YWlucyBvbmUgcHJvcGVydHksIGBtdXNpY0dlbmVyYXRpb25Db25maWdgLlxuICBcbiAgICAgICAgLSBgbXVzaWNHZW5lcmF0aW9uQ29uZmlnYCB0byBzZXQgaW4gdGhlIG1vZGVsLiBQYXNzaW5nIGFuIGVtcHR5IG9yXG4gICAgICB1bmRlZmluZWQgY29uZmlnIHRvIHRoZSBtb2RlbCB3aWxsIHJlc2V0IHRoZSBjb25maWcgdG8gZGVmYXVsdHMuXG4gIFxuICAgICAgQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIGFzeW5jIHNldE11c2ljR2VuZXJhdGlvbkNvbmZpZyhwYXJhbXMpIHtcbiAgICAgICAgaWYgKCFwYXJhbXMubXVzaWNHZW5lcmF0aW9uQ29uZmlnKSB7XG4gICAgICAgICAgICBwYXJhbXMubXVzaWNHZW5lcmF0aW9uQ29uZmlnID0ge307XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2V0Q29uZmlnUGFyYW1ldGVycyA9IGxpdmVNdXNpY1NldENvbmZpZ1BhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgIHRoaXMuY29ubi5zZW5kKEpTT04uc3RyaW5naWZ5KHNldENvbmZpZ1BhcmFtZXRlcnMpKTtcbiAgICB9XG4gICAgc2VuZFBsYXliYWNrQ29udHJvbChwbGF5YmFja0NvbnRyb2wpIHtcbiAgICAgICAgY29uc3QgY2xpZW50TWVzc2FnZSA9IHsgcGxheWJhY2tDb250cm9sIH07XG4gICAgICAgIHRoaXMuY29ubi5zZW5kKEpTT04uc3RyaW5naWZ5KGNsaWVudE1lc3NhZ2UpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnQgdGhlIG11c2ljIHN0cmVhbS5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBwbGF5KCkge1xuICAgICAgICB0aGlzLnNlbmRQbGF5YmFja0NvbnRyb2woTGl2ZU11c2ljUGxheWJhY2tDb250cm9sLlBMQVkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZW1wb3JhcmlseSBoYWx0IHRoZSBtdXNpYyBzdHJlYW0uIFVzZSBgcGxheWAgdG8gcmVzdW1lIGZyb20gdGhlIGN1cnJlbnRcbiAgICAgKiBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBwYXVzZSgpIHtcbiAgICAgICAgdGhpcy5zZW5kUGxheWJhY2tDb250cm9sKExpdmVNdXNpY1BsYXliYWNrQ29udHJvbC5QQVVTRSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3AgdGhlIG11c2ljIHN0cmVhbSBhbmQgcmVzZXQgdGhlIHN0YXRlLiBSZXRhaW5zIHRoZSBjdXJyZW50IHByb21wdHNcbiAgICAgKiBhbmQgY29uZmlnLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMuc2VuZFBsYXliYWNrQ29udHJvbChMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2wuU1RPUCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgY29udGV4dCBvZiB0aGUgbXVzaWMgZ2VuZXJhdGlvbiB3aXRob3V0IHN0b3BwaW5nIGl0LlxuICAgICAqIFJldGFpbnMgdGhlIGN1cnJlbnQgcHJvbXB0cyBhbmQgY29uZmlnLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHJlc2V0Q29udGV4dCgpIHtcbiAgICAgICAgdGhpcy5zZW5kUGxheWJhY2tDb250cm9sKExpdmVNdXNpY1BsYXliYWNrQ29udHJvbC5SRVNFVF9DT05URVhUKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICAgVGVybWluYXRlcyB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24uXG4gIFxuICAgICAgIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5jb25uLmNsb3NlKCk7XG4gICAgfVxufVxuLy8gQ29udmVydHMgYW4gaGVhZGVycyBvYmplY3QgdG8gYSBcIm1hcFwiIG9iamVjdCBhcyBleHBlY3RlZCBieSB0aGUgV2ViU29ja2V0XG4vLyBjb25zdHJ1Y3Rvci4gV2UgdXNlIHRoaXMgYXMgdGhlIEF1dGggaW50ZXJmYWNlIHdvcmtzIHdpdGggSGVhZGVycyBvYmplY3RzXG4vLyB3aGlsZSB0aGUgV2ViU29ja2V0IGNvbnN0cnVjdG9yIHRha2VzIGEgbWFwLlxuZnVuY3Rpb24gaGVhZGVyc1RvTWFwJDEoaGVhZGVycykge1xuICAgIGNvbnN0IGhlYWRlck1hcCA9IHt9O1xuICAgIGhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICBoZWFkZXJNYXBba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiBoZWFkZXJNYXA7XG59XG4vLyBDb252ZXJ0cyBhIFwibWFwXCIgb2JqZWN0IHRvIGEgaGVhZGVycyBvYmplY3QuIFdlIHVzZSB0aGlzIGFzIHRoZSBBdXRoXG4vLyBpbnRlcmZhY2Ugd29ya3Mgd2l0aCBIZWFkZXJzIG9iamVjdHMgd2hpbGUgdGhlIEFQSSBjbGllbnQgZGVmYXVsdCBoZWFkZXJzXG4vLyByZXR1cm5zIGEgbWFwLlxuZnVuY3Rpb24gbWFwVG9IZWFkZXJzJDEobWFwKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobWFwKSkge1xuICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGhlYWRlcnM7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNvbnN0IEZVTkNUSU9OX1JFU1BPTlNFX1JFUVVJUkVTX0lEID0gJ0Z1bmN0aW9uUmVzcG9uc2UgcmVxdWVzdCBtdXN0IGhhdmUgYW4gYGlkYCBmaWVsZCBmcm9tIHRoZSByZXNwb25zZSBvZiBhIFRvb2xDYWxsLkZ1bmN0aW9uYWxDYWxscyBpbiBHb29nbGUgQUkuJztcbi8qKlxuICogSGFuZGxlcyBpbmNvbWluZyBtZXNzYWdlcyBmcm9tIHRoZSBXZWJTb2NrZXQuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgZnVuY3Rpb24gaXMgcmVzcG9uc2libGUgZm9yIHBhcnNpbmcgaW5jb21pbmcgbWVzc2FnZXMsIHRyYW5zZm9ybWluZyB0aGVtXG4gKiBpbnRvIExpdmVTZXJ2ZXJNZXNzYWdlcywgYW5kIHRoZW4gY2FsbGluZyB0aGUgb25tZXNzYWdlIGNhbGxiYWNrLiBOb3RlIHRoYXRcbiAqIHRoZSBmaXJzdCBtZXNzYWdlIHdoaWNoIGlzIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlciBpcyBhIHNldHVwQ29tcGxldGVcbiAqIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIGFwaUNsaWVudCBUaGUgQXBpQ2xpZW50IGluc3RhbmNlLlxuICogQHBhcmFtIG9ubWVzc2FnZSBUaGUgdXNlci1wcm92aWRlZCBvbm1lc3NhZ2UgY2FsbGJhY2sgKGlmIGFueSkuXG4gKiBAcGFyYW0gZXZlbnQgVGhlIE1lc3NhZ2VFdmVudCBmcm9tIHRoZSBXZWJTb2NrZXQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVdlYlNvY2tldE1lc3NhZ2UoYXBpQ2xpZW50LCBvbm1lc3NhZ2UsIGV2ZW50KSB7XG4gICAgY29uc3Qgc2VydmVyTWVzc2FnZSA9IG5ldyBMaXZlU2VydmVyTWVzc2FnZSgpO1xuICAgIGxldCBqc29uRGF0YTtcbiAgICBpZiAoZXZlbnQuZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAganNvbkRhdGEgPSBhd2FpdCBldmVudC5kYXRhLnRleHQoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXZlbnQuZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIGpzb25EYXRhID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGV2ZW50LmRhdGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAganNvbkRhdGEgPSBldmVudC5kYXRhO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShqc29uRGF0YSk7XG4gICAgaWYgKGFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgY29uc3QgcmVzcCA9IGxpdmVTZXJ2ZXJNZXNzYWdlRnJvbVZlcnRleChkYXRhKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihzZXJ2ZXJNZXNzYWdlLCByZXNwKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlc3AgPSBkYXRhO1xuICAgICAgICBPYmplY3QuYXNzaWduKHNlcnZlck1lc3NhZ2UsIHJlc3ApO1xuICAgIH1cbiAgICBvbm1lc3NhZ2Uoc2VydmVyTWVzc2FnZSk7XG59XG4vKipcbiAgIExpdmUgY2xhc3MgZW5jYXBzdWxhdGVzIHRoZSBjb25maWd1cmF0aW9uIGZvciBsaXZlIGludGVyYWN0aW9uIHdpdGggdGhlXG4gICBHZW5lcmF0aXZlIExhbmd1YWdlIEFQSS4gSXQgZW1iZWRzIEFwaUNsaWVudCBmb3IgZ2VuZXJhbCBBUEkgc2V0dGluZ3MuXG5cbiAgIEBleHBlcmltZW50YWxcbiAgKi9cbmNsYXNzIExpdmUge1xuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCwgYXV0aCwgd2ViU29ja2V0RmFjdG9yeSkge1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICAgICAgdGhpcy5hdXRoID0gYXV0aDtcbiAgICAgICAgdGhpcy53ZWJTb2NrZXRGYWN0b3J5ID0gd2ViU29ja2V0RmFjdG9yeTtcbiAgICAgICAgdGhpcy5tdXNpYyA9IG5ldyBMaXZlTXVzaWModGhpcy5hcGlDbGllbnQsIHRoaXMuYXV0aCwgdGhpcy53ZWJTb2NrZXRGYWN0b3J5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICAgRXN0YWJsaXNoZXMgYSBjb25uZWN0aW9uIHRvIHRoZSBzcGVjaWZpZWQgbW9kZWwgd2l0aCB0aGUgZ2l2ZW5cbiAgICAgICBjb25maWd1cmF0aW9uIGFuZCByZXR1cm5zIGEgU2Vzc2lvbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoYXQgY29ubmVjdGlvbi5cbiAgXG4gICAgICAgQGV4cGVyaW1lbnRhbCBCdWlsdC1pbiBNQ1Agc3VwcG9ydCBpcyBhbiBleHBlcmltZW50YWwgZmVhdHVyZSwgbWF5IGNoYW5nZSBpblxuICAgICAgIGZ1dHVyZSB2ZXJzaW9ucy5cbiAgXG4gICAgICAgQHJlbWFya3NcbiAgXG4gICAgICAgQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBlc3RhYmxpc2hpbmcgYSBjb25uZWN0aW9uIHRvIHRoZSBtb2RlbC5cbiAgICAgICBAcmV0dXJuIEEgbGl2ZSBzZXNzaW9uLlxuICBcbiAgICAgICBAZXhhbXBsZVxuICAgICAgIGBgYHRzXG4gICAgICAgbGV0IG1vZGVsOiBzdHJpbmc7XG4gICAgICAgaWYgKEdPT0dMRV9HRU5BSV9VU0VfVkVSVEVYQUkpIHtcbiAgICAgICAgIG1vZGVsID0gJ2dlbWluaS0yLjAtZmxhc2gtbGl2ZS1wcmV2aWV3LTA0LTA5JztcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgbW9kZWwgPSAnZ2VtaW5pLWxpdmUtMi41LWZsYXNoLXByZXZpZXcnO1xuICAgICAgIH1cbiAgICAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgYWkubGl2ZS5jb25uZWN0KHtcbiAgICAgICAgIG1vZGVsOiBtb2RlbCxcbiAgICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgICByZXNwb25zZU1vZGFsaXRpZXM6IFtNb2RhbGl0eS5BVURJT10sXG4gICAgICAgICB9LFxuICAgICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgICAgIG9ub3BlbjogKCkgPT4ge1xuICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDb25uZWN0ZWQgdG8gdGhlIHNvY2tldC4nKTtcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgb25tZXNzYWdlOiAoZTogTWVzc2FnZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgY29uc29sZS5sb2coJ1JlY2VpdmVkIG1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyOiAlc1xcbicsIGRlYnVnKGUuZGF0YSkpO1xuICAgICAgICAgICB9LFxuICAgICAgICAgICBvbmVycm9yOiAoZTogRXJyb3JFdmVudCkgPT4ge1xuICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFcnJvciBvY2N1cnJlZDogJXNcXG4nLCBkZWJ1ZyhlLmVycm9yKSk7XG4gICAgICAgICAgIH0sXG4gICAgICAgICAgIG9uY2xvc2U6IChlOiBDbG9zZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgY29uc29sZS5sb2coJ0Nvbm5lY3Rpb24gY2xvc2VkLicpO1xuICAgICAgICAgICB9LFxuICAgICAgICAgfSxcbiAgICAgICB9KTtcbiAgICAgICBgYGBcbiAgICAgICovXG4gICAgYXN5bmMgY29ubmVjdChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIC8vIFRPRE86IGIvNDA0OTQ2NzQ2IC0gU3VwcG9ydCBwZXIgcmVxdWVzdCBIVFRQIG9wdGlvbnMuXG4gICAgICAgIGlmIChwYXJhbXMuY29uZmlnICYmIHBhcmFtcy5jb25maWcuaHR0cE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIExpdmUgbW9kdWxlIGRvZXMgbm90IHN1cHBvcnQgaHR0cE9wdGlvbnMgYXQgcmVxdWVzdC1sZXZlbCBpbicgK1xuICAgICAgICAgICAgICAgICcgTGl2ZUNvbm5lY3RDb25maWcgeWV0LiBQbGVhc2UgdXNlIHRoZSBjbGllbnQtbGV2ZWwgaHR0cE9wdGlvbnMnICtcbiAgICAgICAgICAgICAgICAnIGNvbmZpZ3VyYXRpb24gaW5zdGVhZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3ZWJzb2NrZXRCYXNlVXJsID0gdGhpcy5hcGlDbGllbnQuZ2V0V2Vic29ja2V0QmFzZVVybCgpO1xuICAgICAgICBjb25zdCBhcGlWZXJzaW9uID0gdGhpcy5hcGlDbGllbnQuZ2V0QXBpVmVyc2lvbigpO1xuICAgICAgICBsZXQgdXJsO1xuICAgICAgICBjb25zdCBjbGllbnRIZWFkZXJzID0gdGhpcy5hcGlDbGllbnQuZ2V0SGVhZGVycygpO1xuICAgICAgICBpZiAocGFyYW1zLmNvbmZpZyAmJlxuICAgICAgICAgICAgcGFyYW1zLmNvbmZpZy50b29scyAmJlxuICAgICAgICAgICAgaGFzTWNwVG9vbFVzYWdlKHBhcmFtcy5jb25maWcudG9vbHMpKSB7XG4gICAgICAgICAgICBzZXRNY3BVc2FnZUhlYWRlcihjbGllbnRIZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXJzID0gbWFwVG9IZWFkZXJzKGNsaWVudEhlYWRlcnMpO1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB1cmwgPSBgJHt3ZWJzb2NrZXRCYXNlVXJsfS93cy9nb29nbGUuY2xvdWQuYWlwbGF0Zm9ybS4ke2FwaVZlcnNpb259LkxsbUJpZGlTZXJ2aWNlL0JpZGlHZW5lcmF0ZUNvbnRlbnRgO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hdXRoLmFkZEF1dGhIZWFkZXJzKGhlYWRlcnMsIHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBhcGlLZXkgPSB0aGlzLmFwaUNsaWVudC5nZXRBcGlLZXkoKTtcbiAgICAgICAgICAgIGxldCBtZXRob2QgPSAnQmlkaUdlbmVyYXRlQ29udGVudCc7XG4gICAgICAgICAgICBsZXQga2V5TmFtZSA9ICdrZXknO1xuICAgICAgICAgICAgaWYgKGFwaUtleSA9PT0gbnVsbCB8fCBhcGlLZXkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFwaUtleS5zdGFydHNXaXRoKCdhdXRoX3Rva2Vucy8nKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignV2FybmluZzogRXBoZW1lcmFsIHRva2VuIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlIGluIGZ1dHVyZSB2ZXJzaW9ucy4nKTtcbiAgICAgICAgICAgICAgICBpZiAoYXBpVmVyc2lvbiAhPT0gJ3YxYWxwaGEnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIldhcm5pbmc6IFRoZSBTREsncyBlcGhlbWVyYWwgdG9rZW4gc3VwcG9ydCBpcyBpbiB2MWFscGhhIG9ubHkuIFBsZWFzZSB1c2UgY29uc3QgYWkgPSBuZXcgR29vZ2xlR2VuQUkoe2FwaUtleTogdG9rZW4ubmFtZSwgaHR0cE9wdGlvbnM6IHsgYXBpVmVyc2lvbjogJ3YxYWxwaGEnIH19KTsgYmVmb3JlIHNlc3Npb24gY29ubmVjdGlvbi5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1ldGhvZCA9ICdCaWRpR2VuZXJhdGVDb250ZW50Q29uc3RyYWluZWQnO1xuICAgICAgICAgICAgICAgIGtleU5hbWUgPSAnYWNjZXNzX3Rva2VuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVybCA9IGAke3dlYnNvY2tldEJhc2VVcmx9L3dzL2dvb2dsZS5haS5nZW5lcmF0aXZlbGFuZ3VhZ2UuJHthcGlWZXJzaW9ufS5HZW5lcmF0aXZlU2VydmljZS4ke21ldGhvZH0/JHtrZXlOYW1lfT0ke2FwaUtleX1gO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvbm9wZW5SZXNvbHZlID0gKCkgPT4geyB9O1xuICAgICAgICBjb25zdCBvbm9wZW5Qcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIG9ub3BlblJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gcGFyYW1zLmNhbGxiYWNrcztcbiAgICAgICAgY29uc3Qgb25vcGVuQXdhaXRlZENhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgKF9hID0gY2FsbGJhY2tzID09PSBudWxsIHx8IGNhbGxiYWNrcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2tzLm9ub3BlbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoY2FsbGJhY2tzKTtcbiAgICAgICAgICAgIG9ub3BlblJlc29sdmUoe30pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhcGlDbGllbnQgPSB0aGlzLmFwaUNsaWVudDtcbiAgICAgICAgY29uc3Qgd2Vic29ja2V0Q2FsbGJhY2tzID0ge1xuICAgICAgICAgICAgb25vcGVuOiBvbm9wZW5Bd2FpdGVkQ2FsbGJhY2ssXG4gICAgICAgICAgICBvbm1lc3NhZ2U6IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHZvaWQgaGFuZGxlV2ViU29ja2V0TWVzc2FnZShhcGlDbGllbnQsIGNhbGxiYWNrcy5vbm1lc3NhZ2UsIGV2ZW50KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbmVycm9yOiAoX2EgPSBjYWxsYmFja3MgPT09IG51bGwgfHwgY2FsbGJhY2tzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25lcnJvcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbmNsb3NlOiAoX2IgPSBjYWxsYmFja3MgPT09IG51bGwgfHwgY2FsbGJhY2tzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25jbG9zZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbm4gPSB0aGlzLndlYlNvY2tldEZhY3RvcnkuY3JlYXRlKHVybCwgaGVhZGVyc1RvTWFwKGhlYWRlcnMpLCB3ZWJzb2NrZXRDYWxsYmFja3MpO1xuICAgICAgICBjb25uLmNvbm5lY3QoKTtcbiAgICAgICAgLy8gV2FpdCBmb3IgdGhlIHdlYnNvY2tldCB0byBvcGVuIGJlZm9yZSBzZW5kaW5nIHJlcXVlc3RzLlxuICAgICAgICBhd2FpdCBvbm9wZW5Qcm9taXNlO1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRNb2RlbCA9IHRNb2RlbCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zLm1vZGVsKTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSAmJlxuICAgICAgICAgICAgdHJhbnNmb3JtZWRNb2RlbC5zdGFydHNXaXRoKCdwdWJsaXNoZXJzLycpKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9qZWN0ID0gdGhpcy5hcGlDbGllbnQuZ2V0UHJvamVjdCgpO1xuICAgICAgICAgICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLmFwaUNsaWVudC5nZXRMb2NhdGlvbigpO1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRNb2RlbCA9XG4gICAgICAgICAgICAgICAgYHByb2plY3RzLyR7cHJvamVjdH0vbG9jYXRpb25zLyR7bG9jYXRpb259L2AgKyB0cmFuc2Zvcm1lZE1vZGVsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjbGllbnRNZXNzYWdlID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkgJiZcbiAgICAgICAgICAgICgoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucmVzcG9uc2VNb2RhbGl0aWVzKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBTZXQgZGVmYXVsdCB0byBBVURJTyB0byBhbGlnbiB3aXRoIE1MRGV2IEFQSS5cbiAgICAgICAgICAgIGlmIChwYXJhbXMuY29uZmlnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuY29uZmlnID0geyByZXNwb25zZU1vZGFsaXRpZXM6IFtNb2RhbGl0eS5BVURJT10gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5jb25maWcucmVzcG9uc2VNb2RhbGl0aWVzID0gW01vZGFsaXR5LkFVRElPXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmdlbmVyYXRpb25Db25maWcpIHtcbiAgICAgICAgICAgIC8vIFJhaXNlIGRlcHJlY2F0aW9uIHdhcm5pbmcgZm9yIGdlbmVyYXRpb25Db25maWcuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1NldHRpbmcgYExpdmVDb25uZWN0Q29uZmlnLmdlbmVyYXRpb25fY29uZmlnYCBpcyBkZXByZWNhdGVkLCBwbGVhc2Ugc2V0IHRoZSBmaWVsZHMgb24gYExpdmVDb25uZWN0Q29uZmlnYCBkaXJlY3RseS4gVGhpcyB3aWxsIGJlY29tZSBhbiBlcnJvciBpbiBhIGZ1dHVyZSB2ZXJzaW9uIChub3QgYmVmb3JlIFEzIDIwMjUpLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlucHV0VG9vbHMgPSAoX2YgPSAoX2UgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UudG9vbHMpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IFtdO1xuICAgICAgICBjb25zdCBjb252ZXJ0ZWRUb29scyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHRvb2wgb2YgaW5wdXRUb29scykge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNDYWxsYWJsZVRvb2wodG9vbCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsYWJsZVRvb2wgPSB0b29sO1xuICAgICAgICAgICAgICAgIGNvbnZlcnRlZFRvb2xzLnB1c2goYXdhaXQgY2FsbGFibGVUb29sLnRvb2woKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb252ZXJ0ZWRUb29scy5wdXNoKHRvb2wpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb252ZXJ0ZWRUb29scy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBwYXJhbXMuY29uZmlnLnRvb2xzID0gY29udmVydGVkVG9vbHM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGl2ZUNvbm5lY3RQYXJhbWV0ZXJzID0ge1xuICAgICAgICAgICAgbW9kZWw6IHRyYW5zZm9ybWVkTW9kZWwsXG4gICAgICAgICAgICBjb25maWc6IHBhcmFtcy5jb25maWcsXG4gICAgICAgICAgICBjYWxsYmFja3M6IHBhcmFtcy5jYWxsYmFja3MsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNsaWVudE1lc3NhZ2UgPSBsaXZlQ29ubmVjdFBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgbGl2ZUNvbm5lY3RQYXJhbWV0ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsaWVudE1lc3NhZ2UgPSBsaXZlQ29ubmVjdFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBsaXZlQ29ubmVjdFBhcmFtZXRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBjbGllbnRNZXNzYWdlWydjb25maWcnXTtcbiAgICAgICAgY29ubi5zZW5kKEpTT04uc3RyaW5naWZ5KGNsaWVudE1lc3NhZ2UpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXNzaW9uKGNvbm4sIHRoaXMuYXBpQ2xpZW50KTtcbiAgICB9XG4gICAgLy8gVE9ETzogYi80MTYwNDEyMjkgLSBBYnN0cmFjdCB0aGlzIG1ldGhvZCB0byBhIGNvbW1vbiBwbGFjZS5cbiAgICBpc0NhbGxhYmxlVG9vbCh0b29sKSB7XG4gICAgICAgIHJldHVybiAnY2FsbFRvb2wnIGluIHRvb2wgJiYgdHlwZW9mIHRvb2wuY2FsbFRvb2wgPT09ICdmdW5jdGlvbic7XG4gICAgfVxufVxuY29uc3QgZGVmYXVsdExpdmVTZW5kQ2xpZW50Q29udGVudFBhcmFtZXJ0ZXJzID0ge1xuICAgIHR1cm5Db21wbGV0ZTogdHJ1ZSxcbn07XG4vKipcbiAgIFJlcHJlc2VudHMgYSBjb25uZWN0aW9uIHRvIHRoZSBBUEkuXG5cbiAgIEBleHBlcmltZW50YWxcbiAgKi9cbmNsYXNzIFNlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKGNvbm4sIGFwaUNsaWVudCkge1xuICAgICAgICB0aGlzLmNvbm4gPSBjb25uO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICB9XG4gICAgdExpdmVDbGllbnRDb250ZW50KGFwaUNsaWVudCwgcGFyYW1zKSB7XG4gICAgICAgIGlmIChwYXJhbXMudHVybnMgIT09IG51bGwgJiYgcGFyYW1zLnR1cm5zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBjb250ZW50cyA9IFtdO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb250ZW50cyA9IHRDb250ZW50cyhwYXJhbXMudHVybnMpO1xuICAgICAgICAgICAgICAgIGlmICghYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50cyA9IGNvbnRlbnRzLm1hcCgoaXRlbSkgPT4gY29udGVudFRvTWxkZXYkMShpdGVtKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2UgY2xpZW50IGNvbnRlbnQgXCJ0dXJuc1wiLCB0eXBlOiAnJHt0eXBlb2YgcGFyYW1zLnR1cm5zfSdgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY2xpZW50Q29udGVudDogeyB0dXJuczogY29udGVudHMsIHR1cm5Db21wbGV0ZTogcGFyYW1zLnR1cm5Db21wbGV0ZSB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2xpZW50Q29udGVudDogeyB0dXJuQ29tcGxldGU6IHBhcmFtcy50dXJuQ29tcGxldGUgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdExpdmVDbGllbnR0VG9vbFJlc3BvbnNlKGFwaUNsaWVudCwgcGFyYW1zKSB7XG4gICAgICAgIGxldCBmdW5jdGlvblJlc3BvbnNlcyA9IFtdO1xuICAgICAgICBpZiAocGFyYW1zLmZ1bmN0aW9uUmVzcG9uc2VzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZnVuY3Rpb25SZXNwb25zZXMgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBhcmFtcy5mdW5jdGlvblJlc3BvbnNlcykpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2VzID0gW3BhcmFtcy5mdW5jdGlvblJlc3BvbnNlc107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlcyA9IHBhcmFtcy5mdW5jdGlvblJlc3BvbnNlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnVuY3Rpb25SZXNwb25zZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Z1bmN0aW9uUmVzcG9uc2VzIGlzIHJlcXVpcmVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZnVuY3Rpb25SZXNwb25zZSBvZiBmdW5jdGlvblJlc3BvbnNlcykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmdW5jdGlvblJlc3BvbnNlICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2UgPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAhKCduYW1lJyBpbiBmdW5jdGlvblJlc3BvbnNlKSB8fFxuICAgICAgICAgICAgICAgICEoJ3Jlc3BvbnNlJyBpbiBmdW5jdGlvblJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHBhcnNlIGZ1bmN0aW9uIHJlc3BvbnNlLCB0eXBlICcke3R5cGVvZiBmdW5jdGlvblJlc3BvbnNlfScuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFwaUNsaWVudC5pc1ZlcnRleEFJKCkgJiYgISgnaWQnIGluIGZ1bmN0aW9uUmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEZVTkNUSU9OX1JFU1BPTlNFX1JFUVVJUkVTX0lEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbGllbnRNZXNzYWdlID0ge1xuICAgICAgICAgICAgdG9vbFJlc3BvbnNlOiB7IGZ1bmN0aW9uUmVzcG9uc2VzOiBmdW5jdGlvblJlc3BvbnNlcyB9LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY2xpZW50TWVzc2FnZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICBTZW5kIGEgbWVzc2FnZSBvdmVyIHRoZSBlc3RhYmxpc2hlZCBjb25uZWN0aW9uLlxuICBcbiAgICAgIEBwYXJhbSBwYXJhbXMgLSBDb250YWlucyB0d28gKipvcHRpb25hbCoqIHByb3BlcnRpZXMsIGB0dXJuc2AgYW5kXG4gICAgICAgICAgYHR1cm5Db21wbGV0ZWAuXG4gIFxuICAgICAgICAtIGB0dXJuc2Agd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSBgQ29udGVudFtdYFxuICAgICAgICAtIGB0dXJuQ29tcGxldGU6IHRydWVgIFtkZWZhdWx0XSBpbmRpY2F0ZXMgdGhhdCB5b3UgYXJlIGRvbmUgc2VuZGluZ1xuICAgICAgICAgIGNvbnRlbnQgYW5kIGV4cGVjdCBhIHJlc3BvbnNlLiBJZiBgdHVybkNvbXBsZXRlOiBmYWxzZWAsIHRoZSBzZXJ2ZXJcbiAgICAgICAgICB3aWxsIHdhaXQgZm9yIGFkZGl0aW9uYWwgbWVzc2FnZXMgYmVmb3JlIHN0YXJ0aW5nIGdlbmVyYXRpb24uXG4gIFxuICAgICAgQGV4cGVyaW1lbnRhbFxuICBcbiAgICAgIEByZW1hcmtzXG4gICAgICBUaGVyZSBhcmUgdHdvIHdheXMgdG8gc2VuZCBtZXNzYWdlcyB0byB0aGUgbGl2ZSBBUEk6XG4gICAgICBgc2VuZENsaWVudENvbnRlbnRgIGFuZCBgc2VuZFJlYWx0aW1lSW5wdXRgLlxuICBcbiAgICAgIGBzZW5kQ2xpZW50Q29udGVudGAgbWVzc2FnZXMgYXJlIGFkZGVkIHRvIHRoZSBtb2RlbCBjb250ZXh0ICoqaW4gb3JkZXIqKi5cbiAgICAgIEhhdmluZyBhIGNvbnZlcnNhdGlvbiB1c2luZyBgc2VuZENsaWVudENvbnRlbnRgIG1lc3NhZ2VzIGlzIHJvdWdobHlcbiAgICAgIGVxdWl2YWxlbnQgdG8gdXNpbmcgdGhlIGBDaGF0LnNlbmRNZXNzYWdlU3RyZWFtYCwgZXhjZXB0IHRoYXQgdGhlIHN0YXRlIG9mXG4gICAgICB0aGUgYGNoYXRgIGhpc3RvcnkgaXMgc3RvcmVkIG9uIHRoZSBBUEkgc2VydmVyIGluc3RlYWQgb2YgbG9jYWxseS5cbiAgXG4gICAgICBCZWNhdXNlIG9mIGBzZW5kQ2xpZW50Q29udGVudGAncyBvcmRlciBndWFyYW50ZWUsIHRoZSBtb2RlbCBjYW5ub3QgcmVzcG9uc1xuICAgICAgYXMgcXVpY2tseSB0byBgc2VuZENsaWVudENvbnRlbnRgIG1lc3NhZ2VzIGFzIHRvIGBzZW5kUmVhbHRpbWVJbnB1dGBcbiAgICAgIG1lc3NhZ2VzLiBUaGlzIG1ha2VzIHRoZSBiaWdnZXN0IGRpZmZlcmVuY2Ugd2hlbiBzZW5kaW5nIG9iamVjdHMgdGhhdCBoYXZlXG4gICAgICBzaWduaWZpY2FudCBwcmVwcm9jZXNzaW5nIHRpbWUgKHR5cGljYWxseSBpbWFnZXMpLlxuICBcbiAgICAgIFRoZSBgc2VuZENsaWVudENvbnRlbnRgIG1lc3NhZ2Ugc2VuZHMgYSBgQ29udGVudFtdYFxuICAgICAgd2hpY2ggaGFzIG1vcmUgb3B0aW9ucyB0aGFuIHRoZSBgQmxvYmAgc2VudCBieSBgc2VuZFJlYWx0aW1lSW5wdXRgLlxuICBcbiAgICAgIFNvIHRoZSBtYWluIHVzZS1jYXNlcyBmb3IgYHNlbmRDbGllbnRDb250ZW50YCBvdmVyIGBzZW5kUmVhbHRpbWVJbnB1dGAgYXJlOlxuICBcbiAgICAgIC0gU2VuZGluZyBhbnl0aGluZyB0aGF0IGNhbid0IGJlIHJlcHJlc2VudGVkIGFzIGEgYEJsb2JgICh0ZXh0LFxuICAgICAgYHNlbmRDbGllbnRDb250ZW50KHt0dXJucz1cIkhlbGxvP1wifWApKS5cbiAgICAgIC0gTWFuYWdpbmcgdHVybnMgd2hlbiBub3QgdXNpbmcgYXVkaW8gaW5wdXQgYW5kIHZvaWNlIGFjdGl2aXR5IGRldGVjdGlvbi5cbiAgICAgICAgKGBzZW5kQ2xpZW50Q29udGVudCh7dHVybkNvbXBsZXRlOnRydWV9KWAgb3IgdGhlIHNob3J0IGZvcm1cbiAgICAgIGBzZW5kQ2xpZW50Q29udGVudCgpYClcbiAgICAgIC0gUHJlZmlsbGluZyBhIGNvbnZlcnNhdGlvbiBjb250ZXh0XG4gICAgICAgIGBgYFxuICAgICAgICBzZW5kQ2xpZW50Q29udGVudCh7XG4gICAgICAgICAgICB0dXJuczogW1xuICAgICAgICAgICAgICBDb250ZW50KHtyb2xlOnVzZXIsIHBhcnRzOi4uLn0pLFxuICAgICAgICAgICAgICBDb250ZW50KHtyb2xlOnVzZXIsIHBhcnRzOi4uLn0pLFxuICAgICAgICAgICAgICAuLi5cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSlcbiAgICAgICAgYGBgXG4gICAgICBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgc2VuZENsaWVudENvbnRlbnQocGFyYW1zKSB7XG4gICAgICAgIHBhcmFtcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdExpdmVTZW5kQ2xpZW50Q29udGVudFBhcmFtZXJ0ZXJzKSwgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgY2xpZW50TWVzc2FnZSA9IHRoaXMudExpdmVDbGllbnRDb250ZW50KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICB0aGlzLmNvbm4uc2VuZChKU09OLnN0cmluZ2lmeShjbGllbnRNZXNzYWdlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAgU2VuZCBhIHJlYWx0aW1lIG1lc3NhZ2Ugb3ZlciB0aGUgZXN0YWJsaXNoZWQgY29ubmVjdGlvbi5cbiAgXG4gICAgICBAcGFyYW0gcGFyYW1zIC0gQ29udGFpbnMgb25lIHByb3BlcnR5LCBgbWVkaWFgLlxuICBcbiAgICAgICAgLSBgbWVkaWFgIHdpbGwgYmUgY29udmVydGVkIHRvIGEgYEJsb2JgXG4gIFxuICAgICAgQGV4cGVyaW1lbnRhbFxuICBcbiAgICAgIEByZW1hcmtzXG4gICAgICBVc2UgYHNlbmRSZWFsdGltZUlucHV0YCBmb3IgcmVhbHRpbWUgYXVkaW8gY2h1bmtzIGFuZCB2aWRlbyBmcmFtZXMgKGltYWdlcykuXG4gIFxuICAgICAgV2l0aCBgc2VuZFJlYWx0aW1lSW5wdXRgIHRoZSBhcGkgd2lsbCByZXNwb25kIHRvIGF1ZGlvIGF1dG9tYXRpY2FsbHlcbiAgICAgIGJhc2VkIG9uIHZvaWNlIGFjdGl2aXR5IGRldGVjdGlvbiAoVkFEKS5cbiAgXG4gICAgICBgc2VuZFJlYWx0aW1lSW5wdXRgIGlzIG9wdGltaXplZCBmb3IgcmVzcG9uc2l2bmVzcyBhdCB0aGUgZXhwZW5zZSBvZlxuICAgICAgZGV0ZXJtaW5pc3RpYyBvcmRlcmluZyBndWFyYW50ZWVzLiBBdWRpbyBhbmQgdmlkZW8gdG9rZW5zIGFyZSB0byB0aGVcbiAgICAgIGNvbnRleHQgd2hlbiB0aGV5IGJlY29tZSBhdmFpbGFibGUuXG4gIFxuICAgICAgTm90ZTogVGhlIENhbGwgc2lnbmF0dXJlIGV4cGVjdHMgYSBgQmxvYmAgb2JqZWN0LCBidXQgb25seSBhIHN1YnNldFxuICAgICAgb2YgYXVkaW8gYW5kIGltYWdlIG1pbWV0eXBlcyBhcmUgYWxsb3dlZC5cbiAgICAgKi9cbiAgICBzZW5kUmVhbHRpbWVJbnB1dChwYXJhbXMpIHtcbiAgICAgICAgbGV0IGNsaWVudE1lc3NhZ2UgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY2xpZW50TWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICAncmVhbHRpbWVJbnB1dCc6IGxpdmVTZW5kUmVhbHRpbWVJbnB1dFBhcmFtZXRlcnNUb1ZlcnRleChwYXJhbXMpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsaWVudE1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgJ3JlYWx0aW1lSW5wdXQnOiBsaXZlU2VuZFJlYWx0aW1lSW5wdXRQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbm4uc2VuZChKU09OLnN0cmluZ2lmeShjbGllbnRNZXNzYWdlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAgU2VuZCBhIGZ1bmN0aW9uIHJlc3BvbnNlIG1lc3NhZ2Ugb3ZlciB0aGUgZXN0YWJsaXNoZWQgY29ubmVjdGlvbi5cbiAgXG4gICAgICBAcGFyYW0gcGFyYW1zIC0gQ29udGFpbnMgcHJvcGVydHkgYGZ1bmN0aW9uUmVzcG9uc2VzYC5cbiAgXG4gICAgICAgIC0gYGZ1bmN0aW9uUmVzcG9uc2VzYCB3aWxsIGJlIGNvbnZlcnRlZCB0byBhIGBmdW5jdGlvblJlc3BvbnNlc1tdYFxuICBcbiAgICAgIEByZW1hcmtzXG4gICAgICBVc2UgYHNlbmRGdW5jdGlvblJlc3BvbnNlYCB0byByZXBseSB0byBgTGl2ZVNlcnZlclRvb2xDYWxsYCBmcm9tIHRoZSBzZXJ2ZXIuXG4gIFxuICAgICAgVXNlIHtAbGluayB0eXBlcy5MaXZlQ29ubmVjdENvbmZpZyN0b29sc30gdG8gY29uZmlndXJlIHRoZSBjYWxsYWJsZSBmdW5jdGlvbnMuXG4gIFxuICAgICAgQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHNlbmRUb29sUmVzcG9uc2UocGFyYW1zKSB7XG4gICAgICAgIGlmIChwYXJhbXMuZnVuY3Rpb25SZXNwb25zZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb29sIHJlc3BvbnNlIHBhcmFtZXRlcnMgYXJlIHJlcXVpcmVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsaWVudE1lc3NhZ2UgPSB0aGlzLnRMaXZlQ2xpZW50dFRvb2xSZXNwb25zZSh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgdGhpcy5jb25uLnNlbmQoSlNPTi5zdHJpbmdpZnkoY2xpZW50TWVzc2FnZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgICBUZXJtaW5hdGVzIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbi5cbiAgXG4gICAgICAgQGV4cGVyaW1lbnRhbFxuICBcbiAgICAgICBAZXhhbXBsZVxuICAgICAgIGBgYHRzXG4gICAgICAgbGV0IG1vZGVsOiBzdHJpbmc7XG4gICAgICAgaWYgKEdPT0dMRV9HRU5BSV9VU0VfVkVSVEVYQUkpIHtcbiAgICAgICAgIG1vZGVsID0gJ2dlbWluaS0yLjAtZmxhc2gtbGl2ZS1wcmV2aWV3LTA0LTA5JztcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgbW9kZWwgPSAnZ2VtaW5pLWxpdmUtMi41LWZsYXNoLXByZXZpZXcnO1xuICAgICAgIH1cbiAgICAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgYWkubGl2ZS5jb25uZWN0KHtcbiAgICAgICAgIG1vZGVsOiBtb2RlbCxcbiAgICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgICByZXNwb25zZU1vZGFsaXRpZXM6IFtNb2RhbGl0eS5BVURJT10sXG4gICAgICAgICB9XG4gICAgICAgfSk7XG4gIFxuICAgICAgIHNlc3Npb24uY2xvc2UoKTtcbiAgICAgICBgYGBcbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5jb25uLmNsb3NlKCk7XG4gICAgfVxufVxuLy8gQ29udmVydHMgYW4gaGVhZGVycyBvYmplY3QgdG8gYSBcIm1hcFwiIG9iamVjdCBhcyBleHBlY3RlZCBieSB0aGUgV2ViU29ja2V0XG4vLyBjb25zdHJ1Y3Rvci4gV2UgdXNlIHRoaXMgYXMgdGhlIEF1dGggaW50ZXJmYWNlIHdvcmtzIHdpdGggSGVhZGVycyBvYmplY3RzXG4vLyB3aGlsZSB0aGUgV2ViU29ja2V0IGNvbnN0cnVjdG9yIHRha2VzIGEgbWFwLlxuZnVuY3Rpb24gaGVhZGVyc1RvTWFwKGhlYWRlcnMpIHtcbiAgICBjb25zdCBoZWFkZXJNYXAgPSB7fTtcbiAgICBoZWFkZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgaGVhZGVyTWFwW2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gaGVhZGVyTWFwO1xufVxuLy8gQ29udmVydHMgYSBcIm1hcFwiIG9iamVjdCB0byBhIGhlYWRlcnMgb2JqZWN0LiBXZSB1c2UgdGhpcyBhcyB0aGUgQXV0aFxuLy8gaW50ZXJmYWNlIHdvcmtzIHdpdGggSGVhZGVycyBvYmplY3RzIHdoaWxlIHRoZSBBUEkgY2xpZW50IGRlZmF1bHQgaGVhZGVyc1xuLy8gcmV0dXJucyBhIG1hcC5cbmZ1bmN0aW9uIG1hcFRvSGVhZGVycyhtYXApIHtcbiAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhtYXApKSB7XG4gICAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gaGVhZGVycztcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY29uc3QgREVGQVVMVF9NQVhfUkVNT1RFX0NBTExTID0gMTA7XG4vKiogUmV0dXJucyB3aGV0aGVyIGF1dG9tYXRpYyBmdW5jdGlvbiBjYWxsaW5nIGlzIGRpc2FibGVkLiAqL1xuZnVuY3Rpb24gc2hvdWxkRGlzYWJsZUFmYyhjb25maWcpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBpZiAoKF9hID0gY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc2FibGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBjYWxsYWJsZVRvb2xzUHJlc2VudCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgdG9vbCBvZiAoX2IgPSBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcudG9vbHMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdKSB7XG4gICAgICAgIGlmIChpc0NhbGxhYmxlVG9vbCh0b29sKSkge1xuICAgICAgICAgICAgY2FsbGFibGVUb29sc1ByZXNlbnQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFjYWxsYWJsZVRvb2xzUHJlc2VudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgbWF4Q2FsbHMgPSAoX2MgPSBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcuYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubWF4aW11bVJlbW90ZUNhbGxzO1xuICAgIGlmICgobWF4Q2FsbHMgJiYgKG1heENhbGxzIDwgMCB8fCAhTnVtYmVyLmlzSW50ZWdlcihtYXhDYWxscykpKSB8fFxuICAgICAgICBtYXhDYWxscyA9PSAwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignSW52YWxpZCBtYXhpbXVtUmVtb3RlQ2FsbHMgdmFsdWUgcHJvdmlkZWQgZm9yIGF1dG9tYXRpYyBmdW5jdGlvbiBjYWxsaW5nLiBEaXNhYmxlZCBhdXRvbWF0aWMgZnVuY3Rpb24gY2FsbGluZy4gUGxlYXNlIHByb3ZpZGUgYSB2YWxpZCBpbnRlZ2VyIHZhbHVlIGdyZWF0ZXIgdGhhbiAwLiBtYXhpbXVtUmVtb3RlQ2FsbHMgcHJvdmlkZWQ6JywgbWF4Q2FsbHMpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNDYWxsYWJsZVRvb2wodG9vbCkge1xuICAgIHJldHVybiAnY2FsbFRvb2wnIGluIHRvb2wgJiYgdHlwZW9mIHRvb2wuY2FsbFRvb2wgPT09ICdmdW5jdGlvbic7XG59XG4vLyBDaGVja3Mgd2hldGhlciB0aGUgbGlzdCBvZiB0b29scyBjb250YWlucyBhbnkgQ2FsbGFibGVUb29scy4gV2lsbCByZXR1cm4gdHJ1ZVxuLy8gaWYgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIENhbGxhYmxlVG9vbC5cbmZ1bmN0aW9uIGhhc0NhbGxhYmxlVG9vbHMocGFyYW1zKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgcmV0dXJuIChfYyA9IChfYiA9IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b29scykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNvbWUoKHRvb2wpID0+IGlzQ2FsbGFibGVUb29sKHRvb2wpKSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZmFsc2U7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGluZGV4ZXMgb2YgdGhlIHRvb2xzIHRoYXQgYXJlIG5vdCBjb21wYXRpYmxlIHdpdGggQUZDLlxuICovXG5mdW5jdGlvbiBmaW5kQWZjSW5jb21wYXRpYmxlVG9vbEluZGV4ZXMocGFyYW1zKSB7XG4gICAgdmFyIF9hO1xuICAgIC8vIFVzZSBudW1iZXJbXSBmb3IgYW4gYXJyYXkgb2YgbnVtYmVycyBpbiBUeXBlU2NyaXB0XG4gICAgY29uc3QgYWZjSW5jb21wYXRpYmxlVG9vbEluZGV4ZXMgPSBbXTtcbiAgICBpZiAoISgoX2EgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9vbHMpKSB7XG4gICAgICAgIHJldHVybiBhZmNJbmNvbXBhdGlibGVUb29sSW5kZXhlcztcbiAgICB9XG4gICAgcGFyYW1zLmNvbmZpZy50b29scy5mb3JFYWNoKCh0b29sLCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAoaXNDYWxsYWJsZVRvb2wodG9vbCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBnZW1pbmlUb29sID0gdG9vbDtcbiAgICAgICAgaWYgKGdlbWluaVRvb2wuZnVuY3Rpb25EZWNsYXJhdGlvbnMgJiZcbiAgICAgICAgICAgIGdlbWluaVRvb2wuZnVuY3Rpb25EZWNsYXJhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgYWZjSW5jb21wYXRpYmxlVG9vbEluZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYWZjSW5jb21wYXRpYmxlVG9vbEluZGV4ZXM7XG59XG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0byBhcHBlbmQgYXV0b21hdGljIGZ1bmN0aW9uIGNhbGxpbmcgaGlzdG9yeSB0byB0aGVcbiAqIHJlc3BvbnNlLlxuICovXG5mdW5jdGlvbiBzaG91bGRBcHBlbmRBZmNIaXN0b3J5KGNvbmZpZykge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gISgoX2EgPSBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcuYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaWdub3JlQ2FsbEhpc3RvcnkpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBNb2RlbHMgZXh0ZW5kcyBCYXNlTW9kdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcGlDbGllbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYWtlcyBhbiBBUEkgcmVxdWVzdCB0byBnZW5lcmF0ZSBjb250ZW50IHdpdGggYSBnaXZlbiBtb2RlbC5cbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIHRoZSBgbW9kZWxgIHBhcmFtZXRlciwgc3VwcG9ydGVkIGZvcm1hdHMgZm9yIFZlcnRleCBBSSBBUEkgaW5jbHVkZTpcbiAgICAgICAgICogLSBUaGUgR2VtaW5pIG1vZGVsIElELCBmb3IgZXhhbXBsZTogJ2dlbWluaS0yLjAtZmxhc2gnXG4gICAgICAgICAqIC0gVGhlIGZ1bGwgcmVzb3VyY2UgbmFtZSBzdGFydHMgd2l0aCAncHJvamVjdHMvJywgZm9yIGV4YW1wbGU6XG4gICAgICAgICAqICAncHJvamVjdHMvbXktcHJvamVjdC1pZC9sb2NhdGlvbnMvdXMtY2VudHJhbDEvcHVibGlzaGVycy9nb29nbGUvbW9kZWxzL2dlbWluaS0yLjAtZmxhc2gnXG4gICAgICAgICAqIC0gVGhlIHBhcnRpYWwgcmVzb3VyY2UgbmFtZSB3aXRoICdwdWJsaXNoZXJzLycsIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAgJ3B1Ymxpc2hlcnMvZ29vZ2xlL21vZGVscy9nZW1pbmktMi4wLWZsYXNoJyBvclxuICAgICAgICAgKiAgJ3B1Ymxpc2hlcnMvbWV0YS9tb2RlbHMvbGxhbWEtMy4xLTQwNWItaW5zdHJ1Y3QtbWFhcydcbiAgICAgICAgICogLSBgL2Agc2VwYXJhdGVkIHB1Ymxpc2hlciBhbmQgbW9kZWwgbmFtZSwgZm9yIGV4YW1wbGU6XG4gICAgICAgICAqICdnb29nbGUvZ2VtaW5pLTIuMC1mbGFzaCcgb3IgJ21ldGEvbGxhbWEtMy4xLTQwNWItaW5zdHJ1Y3QtbWFhcydcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIHRoZSBgbW9kZWxgIHBhcmFtZXRlciwgc3VwcG9ydGVkIGZvcm1hdHMgZm9yIEdlbWluaSBBUEkgaW5jbHVkZTpcbiAgICAgICAgICogLSBUaGUgR2VtaW5pIG1vZGVsIElELCBmb3IgZXhhbXBsZTogJ2dlbWluaS0yLjAtZmxhc2gnXG4gICAgICAgICAqIC0gVGhlIG1vZGVsIG5hbWUgc3RhcnRzIHdpdGggJ21vZGVscy8nLCBmb3IgZXhhbXBsZTpcbiAgICAgICAgICogICdtb2RlbHMvZ2VtaW5pLTIuMC1mbGFzaCdcbiAgICAgICAgICogLSBGb3IgdHVuZWQgbW9kZWxzLCB0aGUgbW9kZWwgbmFtZSBzdGFydHMgd2l0aCAndHVuZWRNb2RlbHMvJyxcbiAgICAgICAgICogZm9yIGV4YW1wbGU6XG4gICAgICAgICAqICd0dW5lZE1vZGVscy8xMjM0NTY3ODkwMTIzNDU2Nzg5J1xuICAgICAgICAgKlxuICAgICAgICAgKiBTb21lIG1vZGVscyBzdXBwb3J0IG11bHRpbW9kYWwgaW5wdXQgYW5kIG91dHB1dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBnZW5lcmF0aW5nIGNvbnRlbnQuXG4gICAgICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gZ2VuZXJhdGluZyBjb250ZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy5nZW5lcmF0ZUNvbnRlbnQoe1xuICAgICAgICAgKiAgIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaCcsXG4gICAgICAgICAqICAgY29udGVudHM6ICd3aHkgaXMgdGhlIHNreSBibHVlPycsXG4gICAgICAgICAqICAgY29uZmlnOiB7XG4gICAgICAgICAqICAgICBjYW5kaWRhdGVDb3VudDogMixcbiAgICAgICAgICogICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZW5lcmF0ZUNvbnRlbnQgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRQYXJhbXMgPSBhd2FpdCB0aGlzLnByb2Nlc3NQYXJhbXNNYXliZUFkZE1jcFVzYWdlKHBhcmFtcyk7XG4gICAgICAgICAgICB0aGlzLm1heWJlTW92ZVRvUmVzcG9uc2VKc29uU2NoZW0ocGFyYW1zKTtcbiAgICAgICAgICAgIGlmICghaGFzQ2FsbGFibGVUb29scyhwYXJhbXMpIHx8IHNob3VsZERpc2FibGVBZmMocGFyYW1zLmNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZW5lcmF0ZUNvbnRlbnRJbnRlcm5hbCh0cmFuc2Zvcm1lZFBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpbmNvbXBhdGlibGVUb29sSW5kZXhlcyA9IGZpbmRBZmNJbmNvbXBhdGlibGVUb29sSW5kZXhlcyhwYXJhbXMpO1xuICAgICAgICAgICAgaWYgKGluY29tcGF0aWJsZVRvb2xJbmRleGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmb3JtYXR0ZWRJbmRleGVzID0gaW5jb21wYXRpYmxlVG9vbEluZGV4ZXNcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoaW5kZXgpID0+IGB0b29sc1ske2luZGV4fV1gKVxuICAgICAgICAgICAgICAgICAgICAuam9pbignLCAnKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEF1dG9tYXRpYyBmdW5jdGlvbiBjYWxsaW5nIHdpdGggQ2FsbGFibGVUb29scyAob3IgTUNQIG9iamVjdHMpIGFuZCBiYXNpYyBGdW5jdGlvbkRlY2xhcmF0aW9ucyBpcyBub3QgeWV0IHN1cHBvcnRlZC4gSW5jb21wYXRpYmxlIHRvb2xzIGZvdW5kIGF0ICR7Zm9ybWF0dGVkSW5kZXhlc30uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgICAgICBsZXQgZnVuY3Rpb25SZXNwb25zZUNvbnRlbnQ7XG4gICAgICAgICAgICBjb25zdCBhdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5ID0gdENvbnRlbnRzKHRyYW5zZm9ybWVkUGFyYW1zLmNvbnRlbnRzKTtcbiAgICAgICAgICAgIGNvbnN0IG1heFJlbW90ZUNhbGxzID0gKF9jID0gKF9iID0gKF9hID0gdHJhbnNmb3JtZWRQYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubWF4aW11bVJlbW90ZUNhbGxzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBERUZBVUxUX01BWF9SRU1PVEVfQ0FMTFM7XG4gICAgICAgICAgICBsZXQgcmVtb3RlQ2FsbHMgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKHJlbW90ZUNhbGxzIDwgbWF4UmVtb3RlQ2FsbHMpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2VuZXJhdGVDb250ZW50SW50ZXJuYWwodHJhbnNmb3JtZWRQYXJhbXMpO1xuICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2UuZnVuY3Rpb25DYWxscyB8fCByZXNwb25zZS5mdW5jdGlvbkNhbGxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VDb250ZW50ID0gcmVzcG9uc2UuY2FuZGlkYXRlc1swXS5jb250ZW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uUmVzcG9uc2VQYXJ0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdG9vbCBvZiAoX2UgPSAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QudG9vbHMpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IFtdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0NhbGxhYmxlVG9vbCh0b29sKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbGFibGVUb29sID0gdG9vbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gYXdhaXQgY2FsbGFibGVUb29sLmNhbGxUb29sKHJlc3BvbnNlLmZ1bmN0aW9uQ2FsbHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25SZXNwb25zZVBhcnRzLnB1c2goLi4ucGFydHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlbW90ZUNhbGxzKys7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25SZXNwb25zZUNvbnRlbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICAgICAgcGFydHM6IGZ1bmN0aW9uUmVzcG9uc2VQYXJ0cyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkUGFyYW1zLmNvbnRlbnRzID0gdENvbnRlbnRzKHRyYW5zZm9ybWVkUGFyYW1zLmNvbnRlbnRzKTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFBhcmFtcy5jb250ZW50cy5wdXNoKHJlc3BvbnNlQ29udGVudCk7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRQYXJhbXMuY29udGVudHMucHVzaChmdW5jdGlvblJlc3BvbnNlQ29udGVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZEFwcGVuZEFmY0hpc3RvcnkodHJhbnNmb3JtZWRQYXJhbXMuY29uZmlnKSkge1xuICAgICAgICAgICAgICAgICAgICBhdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5LnB1c2gocmVzcG9uc2VDb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeS5wdXNoKGZ1bmN0aW9uUmVzcG9uc2VDb250ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2hvdWxkQXBwZW5kQWZjSGlzdG9yeSh0cmFuc2Zvcm1lZFBhcmFtcy5jb25maWcpKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSA9XG4gICAgICAgICAgICAgICAgICAgIGF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3Rvcnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYWtlcyBhbiBBUEkgcmVxdWVzdCB0byBnZW5lcmF0ZSBjb250ZW50IHdpdGggYSBnaXZlbiBtb2RlbCBhbmQgeWllbGRzIHRoZVxuICAgICAgICAgKiByZXNwb25zZSBpbiBjaHVua3MuXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciB0aGUgYG1vZGVsYCBwYXJhbWV0ZXIsIHN1cHBvcnRlZCBmb3JtYXRzIGZvciBWZXJ0ZXggQUkgQVBJIGluY2x1ZGU6XG4gICAgICAgICAqIC0gVGhlIEdlbWluaSBtb2RlbCBJRCwgZm9yIGV4YW1wbGU6ICdnZW1pbmktMi4wLWZsYXNoJ1xuICAgICAgICAgKiAtIFRoZSBmdWxsIHJlc291cmNlIG5hbWUgc3RhcnRzIHdpdGggJ3Byb2plY3RzLycsIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAgJ3Byb2plY3RzL215LXByb2plY3QtaWQvbG9jYXRpb25zL3VzLWNlbnRyYWwxL3B1Ymxpc2hlcnMvZ29vZ2xlL21vZGVscy9nZW1pbmktMi4wLWZsYXNoJ1xuICAgICAgICAgKiAtIFRoZSBwYXJ0aWFsIHJlc291cmNlIG5hbWUgd2l0aCAncHVibGlzaGVycy8nLCBmb3IgZXhhbXBsZTpcbiAgICAgICAgICogICdwdWJsaXNoZXJzL2dvb2dsZS9tb2RlbHMvZ2VtaW5pLTIuMC1mbGFzaCcgb3JcbiAgICAgICAgICogICdwdWJsaXNoZXJzL21ldGEvbW9kZWxzL2xsYW1hLTMuMS00MDViLWluc3RydWN0LW1hYXMnXG4gICAgICAgICAqIC0gYC9gIHNlcGFyYXRlZCBwdWJsaXNoZXIgYW5kIG1vZGVsIG5hbWUsIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAnZ29vZ2xlL2dlbWluaS0yLjAtZmxhc2gnIG9yICdtZXRhL2xsYW1hLTMuMS00MDViLWluc3RydWN0LW1hYXMnXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciB0aGUgYG1vZGVsYCBwYXJhbWV0ZXIsIHN1cHBvcnRlZCBmb3JtYXRzIGZvciBHZW1pbmkgQVBJIGluY2x1ZGU6XG4gICAgICAgICAqIC0gVGhlIEdlbWluaSBtb2RlbCBJRCwgZm9yIGV4YW1wbGU6ICdnZW1pbmktMi4wLWZsYXNoJ1xuICAgICAgICAgKiAtIFRoZSBtb2RlbCBuYW1lIHN0YXJ0cyB3aXRoICdtb2RlbHMvJywgZm9yIGV4YW1wbGU6XG4gICAgICAgICAqICAnbW9kZWxzL2dlbWluaS0yLjAtZmxhc2gnXG4gICAgICAgICAqIC0gRm9yIHR1bmVkIG1vZGVscywgdGhlIG1vZGVsIG5hbWUgc3RhcnRzIHdpdGggJ3R1bmVkTW9kZWxzLycsXG4gICAgICAgICAqIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAgJ3R1bmVkTW9kZWxzLzEyMzQ1Njc4OTAxMjM0NTY3ODknXG4gICAgICAgICAqXG4gICAgICAgICAqIFNvbWUgbW9kZWxzIHN1cHBvcnQgbXVsdGltb2RhbCBpbnB1dCBhbmQgb3V0cHV0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGdlbmVyYXRpbmcgY29udGVudCB3aXRoIHN0cmVhbWluZyByZXNwb25zZS5cbiAgICAgICAgICogQHJldHVybiBUaGUgcmVzcG9uc2UgZnJvbSBnZW5lcmF0aW5nIGNvbnRlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmdlbmVyYXRlQ29udGVudFN0cmVhbSh7XG4gICAgICAgICAqICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJyxcbiAgICAgICAgICogICBjb250ZW50czogJ3doeSBpcyB0aGUgc2t5IGJsdWU/JyxcbiAgICAgICAgICogICBjb25maWc6IHtcbiAgICAgICAgICogICAgIG1heE91dHB1dFRva2VuczogMjAwLFxuICAgICAgICAgKiAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgcmVzcG9uc2UpIHtcbiAgICAgICAgICogICBjb25zb2xlLmxvZyhjaHVuayk7XG4gICAgICAgICAqIH1cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdlbmVyYXRlQ29udGVudFN0cmVhbSA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAgICAgICB0aGlzLm1heWJlTW92ZVRvUmVzcG9uc2VKc29uU2NoZW0ocGFyYW1zKTtcbiAgICAgICAgICAgIGlmIChzaG91bGREaXNhYmxlQWZjKHBhcmFtcy5jb25maWcpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRQYXJhbXMgPSBhd2FpdCB0aGlzLnByb2Nlc3NQYXJhbXNNYXliZUFkZE1jcFVzYWdlKHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2VuZXJhdGVDb250ZW50U3RyZWFtSW50ZXJuYWwodHJhbnNmb3JtZWRQYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW5jb21wYXRpYmxlVG9vbEluZGV4ZXMgPSBmaW5kQWZjSW5jb21wYXRpYmxlVG9vbEluZGV4ZXMocGFyYW1zKTtcbiAgICAgICAgICAgIGlmIChpbmNvbXBhdGlibGVUb29sSW5kZXhlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVkSW5kZXhlcyA9IGluY29tcGF0aWJsZVRvb2xJbmRleGVzXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKGluZGV4KSA9PiBgdG9vbHNbJHtpbmRleH1dYClcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJywgJyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbmNvbXBhdGlibGUgdG9vbHMgZm91bmQgYXQgJHtmb3JtYXR0ZWRJbmRleGVzfS4gQXV0b21hdGljIGZ1bmN0aW9uIGNhbGxpbmcgd2l0aCBDYWxsYWJsZVRvb2xzIChvciBNQ1Agb2JqZWN0cykgYW5kIGJhc2ljIEZ1bmN0aW9uRGVjbGFyYXRpb25zXCIgaXMgbm90IHlldCBzdXBwb3J0ZWQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXaXRoIHRvb2wgY29tcGF0aWJpbGl0eSBjb25maXJtZWQsIHZhbGlkYXRlIHRoYXQgdGhlIGNvbmZpZ3VyYXRpb24gYXJlXG4gICAgICAgICAgICAvLyBjb21wYXRpYmxlIHdpdGggZWFjaCBvdGhlciBhbmQgcmFpc2UgYW4gZXJyb3IgaWYgaW52YWxpZC5cbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbUZ1bmN0aW9uQ2FsbCA9IChfYyA9IChfYiA9IChfYSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b29sQ29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZnVuY3Rpb25DYWxsaW5nQ29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Muc3RyZWFtRnVuY3Rpb25DYWxsQXJndW1lbnRzO1xuICAgICAgICAgICAgY29uc3QgZGlzYWJsZUFmYyA9IChfZSA9IChfZCA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmcpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5kaXNhYmxlO1xuICAgICAgICAgICAgaWYgKHN0cmVhbUZ1bmN0aW9uQ2FsbCAmJiAhZGlzYWJsZUFmYykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJ1bm5pbmcgaW4gc3RyZWFtaW5nIG1vZGUgd2l0aCAnc3RyZWFtRnVuY3Rpb25DYWxsQXJndW1lbnRzJyBlbmFibGVkLCBcIiArXG4gICAgICAgICAgICAgICAgICAgICd0aGlzIGZlYXR1cmUgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBhdXRvbWF0aWMgZnVuY3Rpb24gY2FsbGluZyAoQUZDKS4gJyArXG4gICAgICAgICAgICAgICAgICAgIFwiUGxlYXNlIHNldCAnY29uZmlnLmF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZy5kaXNhYmxlJyB0byB0cnVlIHRvIGRpc2FibGUgQUZDIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJvciBsZWF2ZSAnY29uZmlnLnRvb2xDb25maWcuZnVuY3Rpb25DYWxsaW5nQ29uZmlnLnN0cmVhbUZ1bmN0aW9uQ2FsbEFyZ3VtZW50cycgXCIgK1xuICAgICAgICAgICAgICAgICAgICAndG8gYmUgdW5kZWZpbmVkIG9yIHNldCB0byBmYWxzZSB0byBkaXNhYmxlIHN0cmVhbWluZyBmdW5jdGlvbiBjYWxsIGFyZ3VtZW50cyBmZWF0dXJlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJvY2Vzc0FmY1N0cmVhbShwYXJhbXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2VuZXJhdGVzIGFuIGltYWdlIGJhc2VkIG9uIGEgdGV4dCBkZXNjcmlwdGlvbiBhbmQgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBnZW5lcmF0aW5nIGltYWdlcy5cbiAgICAgICAgICogQHJldHVybiBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNsaWVudC5tb2RlbHMuZ2VuZXJhdGVJbWFnZXMoe1xuICAgICAgICAgKiAgbW9kZWw6ICdpbWFnZW4tMy4wLWdlbmVyYXRlLTAwMicsXG4gICAgICAgICAqICBwcm9tcHQ6ICdSb2JvdCBob2xkaW5nIGEgcmVkIHNrYXRlYm9hcmQnLFxuICAgICAgICAgKiAgY29uZmlnOiB7XG4gICAgICAgICAqICAgIG51bWJlck9mSW1hZ2VzOiAxLFxuICAgICAgICAgKiAgICBpbmNsdWRlUmFpUmVhc29uOiB0cnVlLFxuICAgICAgICAgKiAgfSxcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlPy5nZW5lcmF0ZWRJbWFnZXM/LlswXT8uaW1hZ2U/LmltYWdlQnl0ZXMpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2VuZXJhdGVJbWFnZXMgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZW5lcmF0ZUltYWdlc0ludGVybmFsKHBhcmFtcykudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgbGV0IHBvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcztcbiAgICAgICAgICAgICAgICBjb25zdCBnZW5lcmF0ZWRJbWFnZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAoYXBpUmVzcG9uc2UgPT09IG51bGwgfHwgYXBpUmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFwaVJlc3BvbnNlLmdlbmVyYXRlZEltYWdlcykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGdlbmVyYXRlZEltYWdlIG9mIGFwaVJlc3BvbnNlLmdlbmVyYXRlZEltYWdlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdlbmVyYXRlZEltYWdlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGdlbmVyYXRlZEltYWdlID09PSBudWxsIHx8IGdlbmVyYXRlZEltYWdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnZW5lcmF0ZWRJbWFnZS5zYWZldHlBdHRyaWJ1dGVzKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoX2EgPSBnZW5lcmF0ZWRJbWFnZSA9PT0gbnVsbCB8fCBnZW5lcmF0ZWRJbWFnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2VuZXJhdGVkSW1hZ2Uuc2FmZXR5QXR0cmlidXRlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRlbnRUeXBlKSA9PT0gJ1Bvc2l0aXZlIFByb21wdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMgPSBnZW5lcmF0ZWRJbWFnZSA9PT0gbnVsbCB8fCBnZW5lcmF0ZWRJbWFnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2VuZXJhdGVkSW1hZ2Uuc2FmZXR5QXR0cmlidXRlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlZEltYWdlcy5wdXNoKGdlbmVyYXRlZEltYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlZEltYWdlczogZ2VuZXJhdGVkSW1hZ2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzOiBwb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZGtIdHRwUmVzcG9uc2U6IGFwaVJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVkSW1hZ2VzOiBnZW5lcmF0ZWRJbWFnZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZGtIdHRwUmVzcG9uc2U6IGFwaVJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubGlzdCA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgcXVlcnlCYXNlOiB0cnVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGFjdHVhbENvbmZpZyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdENvbmZpZyksIHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb25maWcpO1xuICAgICAgICAgICAgY29uc3QgYWN0dWFsUGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGNvbmZpZzogYWN0dWFsQ29uZmlnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFjdHVhbFBhcmFtcy5jb25maWcucXVlcnlCYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoX2EgPSBhY3R1YWxQYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpbHRlcmluZyB0dW5lZCBtb2RlbHMgbGlzdCBmb3IgVmVydGV4IEFJIGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWxQYXJhbXMuY29uZmlnLmZpbHRlciA9ICdsYWJlbHMudHVuZS10eXBlOionO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYWdlcihQYWdlZEl0ZW0uUEFHRURfSVRFTV9NT0RFTFMsICh4KSA9PiB0aGlzLmxpc3RJbnRlcm5hbCh4KSwgYXdhaXQgdGhpcy5saXN0SW50ZXJuYWwoYWN0dWFsUGFyYW1zKSwgYWN0dWFsUGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVkaXRzIGFuIGltYWdlIGJhc2VkIG9uIGEgcHJvbXB0LCBsaXN0IG9mIHJlZmVyZW5jZSBpbWFnZXMsIGFuZCBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGVkaXRpbmcgYW4gaW1hZ2UuXG4gICAgICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjbGllbnQubW9kZWxzLmVkaXRJbWFnZSh7XG4gICAgICAgICAqICBtb2RlbDogJ2ltYWdlbi0zLjAtY2FwYWJpbGl0eS0wMDEnLFxuICAgICAgICAgKiAgcHJvbXB0OiAnR2VuZXJhdGUgYW4gaW1hZ2UgY29udGFpbmluZyBhIG11ZyB3aXRoIHRoZSBwcm9kdWN0IGxvZ28gWzFdIHZpc2libGUgb24gdGhlIHNpZGUgb2YgdGhlIG11Zy4nLFxuICAgICAgICAgKiAgcmVmZXJlbmNlSW1hZ2VzOiBbc3ViamVjdFJlZmVyZW5jZUltYWdlXVxuICAgICAgICAgKiAgY29uZmlnOiB7XG4gICAgICAgICAqICAgIG51bWJlck9mSW1hZ2VzOiAxLFxuICAgICAgICAgKiAgICBpbmNsdWRlUmFpUmVhc29uOiB0cnVlLFxuICAgICAgICAgKiAgfSxcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlPy5nZW5lcmF0ZWRJbWFnZXM/LlswXT8uaW1hZ2U/LmltYWdlQnl0ZXMpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZWRpdEltYWdlID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zSW50ZXJuYWwgPSB7XG4gICAgICAgICAgICAgICAgbW9kZWw6IHBhcmFtcy5tb2RlbCxcbiAgICAgICAgICAgICAgICBwcm9tcHQ6IHBhcmFtcy5wcm9tcHQsXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlSW1hZ2VzOiBbXSxcbiAgICAgICAgICAgICAgICBjb25maWc6IHBhcmFtcy5jb25maWcsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5yZWZlcmVuY2VJbWFnZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLnJlZmVyZW5jZUltYWdlcykge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXNJbnRlcm5hbC5yZWZlcmVuY2VJbWFnZXMgPSBwYXJhbXMucmVmZXJlbmNlSW1hZ2VzLm1hcCgoaW1nKSA9PiBpbWcudG9SZWZlcmVuY2VJbWFnZUFQSSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5lZGl0SW1hZ2VJbnRlcm5hbChwYXJhbXNJbnRlcm5hbCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcHNjYWxlcyBhbiBpbWFnZSBiYXNlZCBvbiBhbiBpbWFnZSwgdXBzY2FsZSBmYWN0b3IsIGFuZCBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKiBPbmx5IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkgY3VycmVudGx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHVwc2NhbGluZyBhbiBpbWFnZS5cbiAgICAgICAgICogQHJldHVybiBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNsaWVudC5tb2RlbHMudXBzY2FsZUltYWdlKHtcbiAgICAgICAgICogIG1vZGVsOiAnaW1hZ2VuLTMuMC1nZW5lcmF0ZS0wMDInLFxuICAgICAgICAgKiAgaW1hZ2U6IGltYWdlLFxuICAgICAgICAgKiAgdXBzY2FsZUZhY3RvcjogJ3gyJyxcbiAgICAgICAgICogIGNvbmZpZzoge1xuICAgICAgICAgKiAgICBpbmNsdWRlUmFpUmVhc29uOiB0cnVlLFxuICAgICAgICAgKiAgfSxcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlPy5nZW5lcmF0ZWRJbWFnZXM/LlswXT8uaW1hZ2U/LmltYWdlQnl0ZXMpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXBzY2FsZUltYWdlID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgbGV0IGFwaUNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICBudW1iZXJPZkltYWdlczogMSxcbiAgICAgICAgICAgICAgICBtb2RlOiAndXBzY2FsZScsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5jb25maWcpIHtcbiAgICAgICAgICAgICAgICBhcGlDb25maWcgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFwaUNvbmZpZyksIHBhcmFtcy5jb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXBpUGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIG1vZGVsOiBwYXJhbXMubW9kZWwsXG4gICAgICAgICAgICAgICAgaW1hZ2U6IHBhcmFtcy5pbWFnZSxcbiAgICAgICAgICAgICAgICB1cHNjYWxlRmFjdG9yOiBwYXJhbXMudXBzY2FsZUZhY3RvcixcbiAgICAgICAgICAgICAgICBjb25maWc6IGFwaUNvbmZpZyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy51cHNjYWxlSW1hZ2VJbnRlcm5hbChhcGlQYXJhbXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogIEdlbmVyYXRlcyB2aWRlb3MgYmFzZWQgb24gYSB0ZXh0IGRlc2NyaXB0aW9uIGFuZCBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGdlbmVyYXRpbmcgdmlkZW9zLlxuICAgICAgICAgKiBAcmV0dXJuIEEgUHJvbWlzZTxHZW5lcmF0ZVZpZGVvc09wZXJhdGlvbj4gd2hpY2ggYWxsb3dzIHlvdSB0byB0cmFjayB0aGUgcHJvZ3Jlc3MgYW5kIGV2ZW50dWFsbHkgcmV0cmlldmUgdGhlIGdlbmVyYXRlZCB2aWRlb3MgdXNpbmcgdGhlIG9wZXJhdGlvbnMuZ2V0IG1ldGhvZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3Qgb3BlcmF0aW9uID0gYXdhaXQgYWkubW9kZWxzLmdlbmVyYXRlVmlkZW9zKHtcbiAgICAgICAgICogIG1vZGVsOiAndmVvLTIuMC1nZW5lcmF0ZS0wMDEnLFxuICAgICAgICAgKiAgc291cmNlOiB7XG4gICAgICAgICAqICAgIHByb21wdDogJ0EgbmVvbiBob2xvZ3JhbSBvZiBhIGNhdCBkcml2aW5nIGF0IHRvcCBzcGVlZCcsXG4gICAgICAgICAqICB9LFxuICAgICAgICAgKiAgY29uZmlnOiB7XG4gICAgICAgICAqICAgIG51bWJlck9mVmlkZW9zOiAxXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiB3aGlsZSAoIW9wZXJhdGlvbi5kb25lKSB7XG4gICAgICAgICAqICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDAwKSk7XG4gICAgICAgICAqICAgb3BlcmF0aW9uID0gYXdhaXQgYWkub3BlcmF0aW9ucy5nZXRWaWRlb3NPcGVyYXRpb24oe29wZXJhdGlvbjogb3BlcmF0aW9ufSk7XG4gICAgICAgICAqIH1cbiAgICAgICAgICpcbiAgICAgICAgICogY29uc29sZS5sb2cob3BlcmF0aW9uLnJlc3BvbnNlPy5nZW5lcmF0ZWRWaWRlb3M/LlswXT8udmlkZW8/LnVyaSk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZW5lcmF0ZVZpZGVvcyA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICAgICAgaWYgKChwYXJhbXMucHJvbXB0IHx8IHBhcmFtcy5pbWFnZSB8fCBwYXJhbXMudmlkZW8pICYmIHBhcmFtcy5zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NvdXJjZSBhbmQgcHJvbXB0L2ltYWdlL3ZpZGVvIGFyZSBtdXR1YWxseSBleGNsdXNpdmUuIFBsZWFzZSBvbmx5IHVzZSBzb3VyY2UuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZW1pbmkgQVBJIGRvZXMgbm90IHN1cHBvcnQgdmlkZW8gYnl0ZXMuXG4gICAgICAgICAgICBpZiAoIXRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgICAgIGlmICgoKF9hID0gcGFyYW1zLnZpZGVvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudXJpKSAmJiAoKF9iID0gcGFyYW1zLnZpZGVvKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudmlkZW9CeXRlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnZpZGVvID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJpOiBwYXJhbXMudmlkZW8udXJpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWltZVR5cGU6IHBhcmFtcy52aWRlby5taW1lVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKChfZCA9IChfYyA9IHBhcmFtcy5zb3VyY2UpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy52aWRlbykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnVyaSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKChfZiA9IChfZSA9IHBhcmFtcy5zb3VyY2UpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS52aWRlbykgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLnZpZGVvQnl0ZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5zb3VyY2UudmlkZW8gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmk6IHBhcmFtcy5zb3VyY2UudmlkZW8udXJpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWltZVR5cGU6IHBhcmFtcy5zb3VyY2UudmlkZW8ubWltZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2VuZXJhdGVWaWRlb3NJbnRlcm5hbChwYXJhbXMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGxvZ2ljIGlzIG5lZWRlZCBmb3IgR2VuZXJhdGVDb250ZW50Q29uZmlnIG9ubHkuXG4gICAgICogUHJldmlvdXNseSB3ZSBtYWRlIEdlbmVyYXRlQ29udGVudENvbmZpZy5yZXNwb25zZVNjaGVtYSBmaWVsZCB0byBhY2NlcHRcbiAgICAgKiB1bmtub3duLiBTaW5jZSB2MS45LjAsIHdlIHN3aXRjaCB0byB1c2UgYmFja2VuZCBKU09OIHNjaGVtYSBzdXBwb3J0LlxuICAgICAqIFRvIG1haW50YWluIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHdlIG1vdmUgdGhlIGRhdGEgdGhhdCB3YXMgdHJlYXRlZCBhc1xuICAgICAqIEpTT04gc2NoZW1hIGZyb20gdGhlIHJlc3BvbnNlU2NoZW1hIGZpZWxkIHRvIHRoZSByZXNwb25zZUpzb25TY2hlbWEgZmllbGQuXG4gICAgICovXG4gICAgbWF5YmVNb3ZlVG9SZXNwb25zZUpzb25TY2hlbShwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5jb25maWcgJiYgcGFyYW1zLmNvbmZpZy5yZXNwb25zZVNjaGVtYSkge1xuICAgICAgICAgICAgaWYgKCFwYXJhbXMuY29uZmlnLnJlc3BvbnNlSnNvblNjaGVtYSkge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhwYXJhbXMuY29uZmlnLnJlc3BvbnNlU2NoZW1hKS5pbmNsdWRlcygnJHNjaGVtYScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5jb25maWcucmVzcG9uc2VKc29uU2NoZW1hID0gcGFyYW1zLmNvbmZpZy5yZXNwb25zZVNjaGVtYTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhcmFtcy5jb25maWcucmVzcG9uc2VTY2hlbWE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyB0aGUgQ2FsbGFibGVUb29scyBpbiB0aGUgcGFyYW1ldGVycyB0byBiZSBzaW1wbHkgVG9vbHMsIGl0XG4gICAgICogY29waWVzIHRoZSBwYXJhbXMgaW50byBhIG5ldyBvYmplY3QgYW5kIHJlcGxhY2VzIHRoZSB0b29scywgaXQgZG9lcyBub3RcbiAgICAgKiBtb2RpZnkgdGhlIG9yaWdpbmFsIHBhcmFtcy4gQWxzbyBzZXRzIHRoZSBNQ1AgdXNhZ2UgaGVhZGVyIGlmIHRoZXJlIGFyZVxuICAgICAqIE1DUCB0b29scyBpbiB0aGUgcGFyYW1ldGVycy5cbiAgICAgKi9cbiAgICBhc3luYyBwcm9jZXNzUGFyYW1zTWF5YmVBZGRNY3BVc2FnZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IHRvb2xzID0gKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvb2xzO1xuICAgICAgICBpZiAoIXRvb2xzKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkVG9vbHMgPSBhd2FpdCBQcm9taXNlLmFsbCh0b29scy5tYXAoYXN5bmMgKHRvb2wpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0NhbGxhYmxlVG9vbCh0b29sKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxhYmxlVG9vbCA9IHRvb2w7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGNhbGxhYmxlVG9vbC50b29sKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9vbDtcbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCBuZXdQYXJhbXMgPSB7XG4gICAgICAgICAgICBtb2RlbDogcGFyYW1zLm1vZGVsLFxuICAgICAgICAgICAgY29udGVudHM6IHBhcmFtcy5jb250ZW50cyxcbiAgICAgICAgICAgIGNvbmZpZzogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMuY29uZmlnKSwgeyB0b29sczogdHJhbnNmb3JtZWRUb29scyB9KSxcbiAgICAgICAgfTtcbiAgICAgICAgbmV3UGFyYW1zLmNvbmZpZy50b29scyA9IHRyYW5zZm9ybWVkVG9vbHM7XG4gICAgICAgIGlmIChwYXJhbXMuY29uZmlnICYmXG4gICAgICAgICAgICBwYXJhbXMuY29uZmlnLnRvb2xzICYmXG4gICAgICAgICAgICBoYXNNY3BUb29sVXNhZ2UocGFyYW1zLmNvbmZpZy50b29scykpIHtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSAoX2MgPSAoX2IgPSBwYXJhbXMuY29uZmlnLmh0dHBPcHRpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaGVhZGVycykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDoge307XG4gICAgICAgICAgICBsZXQgbmV3SGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIGhlYWRlcnMpO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG5ld0hlYWRlcnMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG5ld0hlYWRlcnMgPSB0aGlzLmFwaUNsaWVudC5nZXREZWZhdWx0SGVhZGVycygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0TWNwVXNhZ2VIZWFkZXIobmV3SGVhZGVycyk7XG4gICAgICAgICAgICBuZXdQYXJhbXMuY29uZmlnLmh0dHBPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMuY29uZmlnLmh0dHBPcHRpb25zKSwgeyBoZWFkZXJzOiBuZXdIZWFkZXJzIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdQYXJhbXM7XG4gICAgfVxuICAgIGFzeW5jIGluaXRBZmNUb29sc01hcChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IGFmY1Rvb2xzID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IHRvb2wgb2YgKF9iID0gKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvb2xzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSkge1xuICAgICAgICAgICAgaWYgKGlzQ2FsbGFibGVUb29sKHRvb2wpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbGFibGVUb29sID0gdG9vbDtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29sRGVjbGFyYXRpb24gPSBhd2FpdCBjYWxsYWJsZVRvb2wudG9vbCgpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZGVjbGFyYXRpb24gb2YgKF9jID0gdG9vbERlY2xhcmF0aW9uLmZ1bmN0aW9uRGVjbGFyYXRpb25zKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBbXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRlY2xhcmF0aW9uLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gZGVjbGFyYXRpb24gbmFtZSBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWZjVG9vbHMuaGFzKGRlY2xhcmF0aW9uLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSB0b29sIGRlY2xhcmF0aW9uIG5hbWU6ICR7ZGVjbGFyYXRpb24ubmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhZmNUb29scy5zZXQoZGVjbGFyYXRpb24ubmFtZSwgY2FsbGFibGVUb29sKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFmY1Rvb2xzO1xuICAgIH1cbiAgICBhc3luYyBwcm9jZXNzQWZjU3RyZWFtKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3QgbWF4UmVtb3RlQ2FsbHMgPSAoX2MgPSAoX2IgPSAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubWF4aW11bVJlbW90ZUNhbGxzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBERUZBVUxUX01BWF9SRU1PVEVfQ0FMTFM7XG4gICAgICAgIGxldCB3ZXJlRnVuY3Rpb25zQ2FsbGVkID0gZmFsc2U7XG4gICAgICAgIGxldCByZW1vdGVDYWxsQ291bnQgPSAwO1xuICAgICAgICBjb25zdCBhZmNUb29sc01hcCA9IGF3YWl0IHRoaXMuaW5pdEFmY1Rvb2xzTWFwKHBhcmFtcyk7XG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKG1vZGVscywgYWZjVG9vbHMsIHBhcmFtcykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2MsIGVfMSwgX2QsIF9lO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyZW1vdGVDYWxsQ291bnQgPCBtYXhSZW1vdGVDYWxscykge1xuICAgICAgICAgICAgICAgICAgICBpZiAod2VyZUZ1bmN0aW9uc0NhbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3RlQ2FsbENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ZXJlRnVuY3Rpb25zQ2FsbGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRQYXJhbXMgPSB5aWVsZCBfX2F3YWl0KG1vZGVscy5wcm9jZXNzUGFyYW1zTWF5YmVBZGRNY3BVc2FnZShwYXJhbXMpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBfX2F3YWl0KG1vZGVscy5nZW5lcmF0ZUNvbnRlbnRTdHJlYW1JbnRlcm5hbCh0cmFuc2Zvcm1lZFBhcmFtcykpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmdW5jdGlvblJlc3BvbnNlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZUNvbnRlbnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfZiA9IHRydWUsIHJlc3BvbnNlXzEgPSAoZV8xID0gdm9pZCAwLCBfX2FzeW5jVmFsdWVzKHJlc3BvbnNlKSksIHJlc3BvbnNlXzFfMTsgcmVzcG9uc2VfMV8xID0geWllbGQgX19hd2FpdChyZXNwb25zZV8xLm5leHQoKSksIF9jID0gcmVzcG9uc2VfMV8xLmRvbmUsICFfYzsgX2YgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2UgPSByZXNwb25zZV8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2YgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IF9lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaHVuay5jYW5kaWRhdGVzICYmICgoX2EgPSBjaHVuay5jYW5kaWRhdGVzWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VDb250ZW50cy5wdXNoKGNodW5rLmNhbmRpZGF0ZXNbMF0uY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFydCBvZiAoX2IgPSBjaHVuay5jYW5kaWRhdGVzWzBdLmNvbnRlbnQucGFydHMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVtb3RlQ2FsbENvdW50IDwgbWF4UmVtb3RlQ2FsbHMgJiYgcGFydC5mdW5jdGlvbkNhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnQuZnVuY3Rpb25DYWxsLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiBjYWxsIG5hbWUgd2FzIG5vdCByZXR1cm5lZCBieSB0aGUgbW9kZWwuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYWZjVG9vbHMuaGFzKHBhcnQuZnVuY3Rpb25DYWxsLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXV0b21hdGljIGZ1bmN0aW9uIGNhbGxpbmcgd2FzIHJlcXVlc3RlZCwgYnV0IG5vdCBhbGwgdGhlIHRvb2xzIHRoZSBtb2RlbCB1c2VkIGltcGxlbWVudCB0aGUgQ2FsbGFibGVUb29sIGludGVyZmFjZS4gQXZhaWxhYmxlIHRvb2xzOiAke2FmY1Rvb2xzLmtleXMoKX0sIG1pc2luZyB0b29sOiAke3BhcnQuZnVuY3Rpb25DYWxsLm5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZVBhcnRzID0geWllbGQgX19hd2FpdChhZmNUb29sc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmdldChwYXJ0LmZ1bmN0aW9uQ2FsbC5uYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNhbGxUb29sKFtwYXJ0LmZ1bmN0aW9uQ2FsbF0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25SZXNwb25zZXMucHVzaCguLi5yZXNwb25zZVBhcnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2YgJiYgIV9jICYmIChfZCA9IHJlc3BvbnNlXzEucmV0dXJuKSkgeWllbGQgX19hd2FpdChfZC5jYWxsKHJlc3BvbnNlXzEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZnVuY3Rpb25SZXNwb25zZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2VyZUZ1bmN0aW9uc0NhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3BvbnNlQ2h1bmsgPSBuZXcgR2VuZXJhdGVDb250ZW50UmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVkUmVzcG9uc2VDaHVuay5jYW5kaWRhdGVzID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydHM6IGZ1bmN0aW9uUmVzcG9uc2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdCh0eXBlZFJlc3BvbnNlQ2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3Q29udGVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NvbnRlbnRzLnB1c2goLi4ucmVzcG9uc2VDb250ZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDb250ZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydHM6IGZ1bmN0aW9uUmVzcG9uc2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkQ29udGVudHMgPSB0Q29udGVudHMocGFyYW1zLmNvbnRlbnRzKS5jb25jYXQobmV3Q29udGVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmNvbnRlbnRzID0gdXBkYXRlZENvbnRlbnRzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkodGhpcywgYWZjVG9vbHNNYXAsIHBhcmFtcyk7XG4gICAgfVxuICAgIGFzeW5jIGdlbmVyYXRlQ29udGVudEludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZW5lcmF0ZUNvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OmdlbmVyYXRlQ29udGVudCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGdlbmVyYXRlQ29udGVudFJlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEdlbmVyYXRlQ29udGVudFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZW5lcmF0ZUNvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06Z2VuZXJhdGVDb250ZW50JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZ2VuZXJhdGVDb250ZW50UmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2VuZXJhdGVDb250ZW50U3RyZWFtSW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdlbmVyYXRlQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06c3RyZWFtR2VuZXJhdGVDb250ZW50P2FsdD1zc2UnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBjb25zdCBhcGlDbGllbnQgPSB0aGlzLmFwaUNsaWVudDtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXBpQ2xpZW50LnJlcXVlc3RTdHJlYW0oe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKGZ1bmN0aW9uIChhcGlSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBlXzIsIF9iLCBfYztcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9kID0gdHJ1ZSwgYXBpUmVzcG9uc2VfMSA9IF9fYXN5bmNWYWx1ZXMoYXBpUmVzcG9uc2UpLCBhcGlSZXNwb25zZV8xXzE7IGFwaVJlc3BvbnNlXzFfMSA9IHlpZWxkIF9fYXdhaXQoYXBpUmVzcG9uc2VfMS5uZXh0KCkpLCBfYSA9IGFwaVJlc3BvbnNlXzFfMS5kb25lLCAhX2E7IF9kID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jID0gYXBpUmVzcG9uc2VfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBfYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZ2VuZXJhdGVDb250ZW50UmVzcG9uc2VGcm9tVmVydGV4KCh5aWVsZCBfX2F3YWl0KGNodW5rLmpzb24oKSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwWydzZGtIdHRwUmVzcG9uc2UnXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogY2h1bmsuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHR5cGVkUmVzcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2QgJiYgIV9hICYmIChfYiA9IGFwaVJlc3BvbnNlXzEucmV0dXJuKSkgeWllbGQgX19hd2FpdChfYi5jYWxsKGFwaVJlc3BvbnNlXzEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2VuZXJhdGVDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnN0cmVhbUdlbmVyYXRlQ29udGVudD9hbHQ9c3NlJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgY29uc3QgYXBpQ2xpZW50ID0gdGhpcy5hcGlDbGllbnQ7XG4gICAgICAgICAgICByZXNwb25zZSA9IGFwaUNsaWVudC5yZXF1ZXN0U3RyZWFtKHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbihmdW5jdGlvbiAoYXBpUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSwgZV8zLCBfYiwgX2M7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfZCA9IHRydWUsIGFwaVJlc3BvbnNlXzIgPSBfX2FzeW5jVmFsdWVzKGFwaVJlc3BvbnNlKSwgYXBpUmVzcG9uc2VfMl8xOyBhcGlSZXNwb25zZV8yXzEgPSB5aWVsZCBfX2F3YWl0KGFwaVJlc3BvbnNlXzIubmV4dCgpKSwgX2EgPSBhcGlSZXNwb25zZV8yXzEuZG9uZSwgIV9hOyBfZCA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYyA9IGFwaVJlc3BvbnNlXzJfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gX2M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGdlbmVyYXRlQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2KCh5aWVsZCBfX2F3YWl0KGNodW5rLmpzb24oKSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwWydzZGtIdHRwUmVzcG9uc2UnXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogY2h1bmsuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHR5cGVkUmVzcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVfM18xKSB7IGVfMyA9IHsgZXJyb3I6IGVfM18xIH07IH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2QgJiYgIV9hICYmIChfYiA9IGFwaVJlc3BvbnNlXzIucmV0dXJuKSkgeWllbGQgX19hd2FpdChfYi5jYWxsKGFwaVJlc3BvbnNlXzIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyBlbWJlZGRpbmdzIGZvciB0aGUgZ2l2ZW4gY29udGVudHMuIE9ubHkgdGV4dCBpcyBzdXBwb3J0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGVtYmVkZGluZyBjb250ZW50cy5cbiAgICAgKiBAcmV0dXJuIFRoZSByZXNwb25zZSBmcm9tIHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5tb2RlbHMuZW1iZWRDb250ZW50KHtcbiAgICAgKiAgbW9kZWw6ICd0ZXh0LWVtYmVkZGluZy0wMDQnLFxuICAgICAqICBjb250ZW50czogW1xuICAgICAqICAgICdXaGF0IGlzIHlvdXIgbmFtZT8nLFxuICAgICAqICAgICdXaGF0IGlzIHlvdXIgZmF2b3JpdGUgY29sb3I/JyxcbiAgICAgKiAgXSxcbiAgICAgKiAgY29uZmlnOiB7XG4gICAgICogICAgb3V0cHV0RGltZW5zaW9uYWxpdHk6IDY0LFxuICAgICAqICB9LFxuICAgICAqIH0pO1xuICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBlbWJlZENvbnRlbnQocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGVtYmVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06cHJlZGljdCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGVtYmVkQ29udGVudFJlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEVtYmVkQ29udGVudFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBlbWJlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06YmF0Y2hFbWJlZENvbnRlbnRzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZW1iZWRDb250ZW50UmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBFbWJlZENvbnRlbnRSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBtZXRob2QgZm9yIGdlbmVyYXRpbmcgaW1hZ2VzLlxuICAgICAqL1xuICAgIGFzeW5jIGdlbmVyYXRlSW1hZ2VzSW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdlbmVyYXRlSW1hZ2VzUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpwcmVkaWN0JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZ2VuZXJhdGVJbWFnZXNSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBHZW5lcmF0ZUltYWdlc1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZW5lcmF0ZUltYWdlc1BhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpwcmVkaWN0JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZ2VuZXJhdGVJbWFnZXNSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEdlbmVyYXRlSW1hZ2VzUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByaXZhdGUgbWV0aG9kIGZvciBlZGl0aW5nIGFuIGltYWdlLlxuICAgICAqL1xuICAgIGFzeW5jIGVkaXRJbWFnZUludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZWRpdEltYWdlUGFyYW1ldGVyc0ludGVybmFsVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnByZWRpY3QnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBlZGl0SW1hZ2VSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBFZGl0SW1hZ2VSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBWZXJ0ZXggQUkuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBtZXRob2QgZm9yIHVwc2NhbGluZyBhbiBpbWFnZS5cbiAgICAgKi9cbiAgICBhc3luYyB1cHNjYWxlSW1hZ2VJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IHVwc2NhbGVJbWFnZUFQSVBhcmFtZXRlcnNJbnRlcm5hbFRvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpwcmVkaWN0JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gdXBzY2FsZUltYWdlUmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgVXBzY2FsZUltYWdlUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgVmVydGV4IEFJLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlY29udGV4dHVhbGl6ZXMgYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBUaGVyZSBhcmUgdHdvIHR5cGVzIG9mIHJlY29udGV4dHVhbGl6YXRpb24gY3VycmVudGx5IHN1cHBvcnRlZDpcbiAgICAgKiAxKSBJbWFnZW4gUHJvZHVjdCBSZWNvbnRleHQgLSBHZW5lcmF0ZSBpbWFnZXMgb2YgcHJvZHVjdHMgaW4gbmV3IHNjZW5lc1xuICAgICAqICAgIGFuZCBjb250ZXh0cy5cbiAgICAgKiAyKSBWaXJ0dWFsIFRyeS1PbjogR2VuZXJhdGUgaW1hZ2VzIG9mIHBlcnNvbnMgbW9kZWxpbmcgZmFzaGlvbiBwcm9kdWN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgcmVjb250ZXh0dWFsaXppbmcgYW4gaW1hZ2UuXG4gICAgICogQHJldHVybiBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlMSA9IGF3YWl0IGFpLm1vZGVscy5yZWNvbnRleHRJbWFnZSh7XG4gICAgICogIG1vZGVsOiAnaW1hZ2VuLXByb2R1Y3QtcmVjb250ZXh0LXByZXZpZXctMDYtMzAnLFxuICAgICAqICBzb3VyY2U6IHtcbiAgICAgKiAgICBwcm9tcHQ6ICdJbiBhIG1vZGVybiBraXRjaGVuIHNldHRpbmcuJyxcbiAgICAgKiAgICBwcm9kdWN0SW1hZ2VzOiBbcHJvZHVjdEltYWdlXSxcbiAgICAgKiAgfSxcbiAgICAgKiAgY29uZmlnOiB7XG4gICAgICogICAgbnVtYmVyT2ZJbWFnZXM6IDEsXG4gICAgICogIH0sXG4gICAgICogfSk7XG4gICAgICogY29uc29sZS5sb2cocmVzcG9uc2UxPy5nZW5lcmF0ZWRJbWFnZXM/LlswXT8uaW1hZ2U/LmltYWdlQnl0ZXMpO1xuICAgICAqXG4gICAgICogY29uc3QgcmVzcG9uc2UyID0gYXdhaXQgYWkubW9kZWxzLnJlY29udGV4dEltYWdlKHtcbiAgICAgKiAgbW9kZWw6ICd2aXJ0dWFsLXRyeS1vbi1wcmV2aWV3LTA4LTA0JyxcbiAgICAgKiAgc291cmNlOiB7XG4gICAgICogICAgcGVyc29uSW1hZ2U6IHBlcnNvbkltYWdlLFxuICAgICAqICAgIHByb2R1Y3RJbWFnZXM6IFtwcm9kdWN0SW1hZ2VdLFxuICAgICAqICB9LFxuICAgICAqICBjb25maWc6IHtcbiAgICAgKiAgICBudW1iZXJPZkltYWdlczogMSxcbiAgICAgKiAgfSxcbiAgICAgKiB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZTI/LmdlbmVyYXRlZEltYWdlcz8uWzBdPy5pbWFnZT8uaW1hZ2VCeXRlcyk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgcmVjb250ZXh0SW1hZ2UocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSByZWNvbnRleHRJbWFnZVBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06cHJlZGljdCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gcmVjb250ZXh0SW1hZ2VSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBSZWNvbnRleHRJbWFnZVJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIFZlcnRleCBBSS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWdtZW50cyBhbiBpbWFnZSwgY3JlYXRpbmcgYSBtYXNrIG9mIGEgc3BlY2lmaWVkIGFyZWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHNlZ21lbnRpbmcgYW4gaW1hZ2UuXG4gICAgICogQHJldHVybiBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLnNlZ21lbnRJbWFnZSh7XG4gICAgICogIG1vZGVsOiAnaW1hZ2Utc2VnbWVudGF0aW9uLTAwMScsXG4gICAgICogIHNvdXJjZToge1xuICAgICAqICAgIGltYWdlOiBpbWFnZSxcbiAgICAgKiAgfSxcbiAgICAgKiAgY29uZmlnOiB7XG4gICAgICogICAgbW9kZTogJ2ZvcmVncm91bmQnLFxuICAgICAqICB9LFxuICAgICAqIH0pO1xuICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlPy5nZW5lcmF0ZWRNYXNrcz8uWzBdPy5tYXNrPy5pbWFnZUJ5dGVzKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBzZWdtZW50SW1hZ2UocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBzZWdtZW50SW1hZ2VQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnByZWRpY3QnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IHNlZ21lbnRJbWFnZVJlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IFNlZ21lbnRJbWFnZVJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIFZlcnRleCBBSS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIGluZm9ybWF0aW9uIGFib3V0IGEgbW9kZWwgYnkgbmFtZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBtb2RlbEluZm8gPSBhd2FpdCBhaS5tb2RlbHMuZ2V0KHttb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgZ2V0KHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXRNb2RlbFBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBtb2RlbEZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2V0TW9kZWxQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBtb2RlbEZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBsaXN0SW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGxpc3RNb2RlbHNQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWxzX3VybH0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGxpc3RNb2RlbHNSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBMaXN0TW9kZWxzUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGxpc3RNb2RlbHNQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbHNfdXJsfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gbGlzdE1vZGVsc1Jlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgTGlzdE1vZGVsc1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGEgdHVuZWQgbW9kZWwgYnkgaXRzIG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHVwZGF0aW5nIHRoZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJuIFRoZSByZXNwb25zZSBmcm9tIHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5tb2RlbHMudXBkYXRlKHtcbiAgICAgKiAgIG1vZGVsOiAndHVuZWQtbW9kZWwtbmFtZScsXG4gICAgICogICBjb25maWc6IHtcbiAgICAgKiAgICAgZGlzcGxheU5hbWU6ICdOZXcgZGlzcGxheSBuYW1lJyxcbiAgICAgKiAgICAgZGVzY3JpcHRpb246ICdOZXcgZGVzY3JpcHRpb24nLFxuICAgICAqICAgfSxcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IHVwZGF0ZU1vZGVsUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BBVENIJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IG1vZGVsRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSB1cGRhdGVNb2RlbFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUEFUQ0gnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gbW9kZWxGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhIHR1bmVkIG1vZGVsIGJ5IGl0cyBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBkZWxldGluZyB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybiBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmRlbGV0ZSh7bW9kZWw6ICd0dW5lZC1tb2RlbC1uYW1lJ30pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZGVsZXRlTW9kZWxQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGRlbGV0ZU1vZGVsUmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgRGVsZXRlTW9kZWxSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZGVsZXRlTW9kZWxQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZGVsZXRlTW9kZWxSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IERlbGV0ZU1vZGVsUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvdW50cyB0aGUgbnVtYmVyIG9mIHRva2VucyBpbiB0aGUgZ2l2ZW4gY29udGVudHMuIE11bHRpbW9kYWwgaW5wdXQgaXNcbiAgICAgKiBzdXBwb3J0ZWQgZm9yIEdlbWluaSBtb2RlbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGNvdW50aW5nIHRva2Vucy5cbiAgICAgKiBAcmV0dXJuIFRoZSByZXNwb25zZSBmcm9tIHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5tb2RlbHMuY291bnRUb2tlbnMoe1xuICAgICAqICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnLFxuICAgICAqICBjb250ZW50czogJ1RoZSBxdWljayBicm93biBmb3gganVtcHMgb3ZlciB0aGUgbGF6eSBkb2cuJ1xuICAgICAqIH0pO1xuICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBjb3VudFRva2VucyhwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY291bnRUb2tlbnNQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OmNvdW50VG9rZW5zJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gY291bnRUb2tlbnNSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBDb3VudFRva2Vuc1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjb3VudFRva2Vuc1BhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpjb3VudFRva2VucycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGNvdW50VG9rZW5zUmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBDb3VudFRva2Vuc1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIGxpc3Qgb2YgY29udGVudHMsIHJldHVybnMgYSBjb3JyZXNwb25kaW5nIFRva2Vuc0luZm8gY29udGFpbmluZ1xuICAgICAqIHRoZSBsaXN0IG9mIHRva2VucyBhbmQgbGlzdCBvZiB0b2tlbiBpZHMuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgY29tcHV0aW5nIHRva2Vucy5cbiAgICAgKiBAcmV0dXJuIFRoZSByZXNwb25zZSBmcm9tIHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5tb2RlbHMuY29tcHV0ZVRva2Vucyh7XG4gICAgICogIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaCcsXG4gICAgICogIGNvbnRlbnRzOiAnV2hhdCBpcyB5b3VyIG5hbWU/J1xuICAgICAqIH0pO1xuICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBjb21wdXRlVG9rZW5zKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY29tcHV0ZVRva2Vuc1BhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06Y29tcHV0ZVRva2VucycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGNvbXB1dGVUb2tlbnNSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBDb21wdXRlVG9rZW5zUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgVmVydGV4IEFJLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByaXZhdGUgbWV0aG9kIGZvciBnZW5lcmF0aW5nIHZpZGVvcy5cbiAgICAgKi9cbiAgICBhc3luYyBnZW5lcmF0ZVZpZGVvc0ludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZW5lcmF0ZVZpZGVvc1BhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06cHJlZGljdExvbmdSdW5uaW5nJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBnZW5lcmF0ZVZpZGVvc09wZXJhdGlvbkZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBHZW5lcmF0ZVZpZGVvc09wZXJhdGlvbigpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2VuZXJhdGVWaWRlb3NQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06cHJlZGljdExvbmdSdW5uaW5nJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBnZW5lcmF0ZVZpZGVvc09wZXJhdGlvbkZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgT3BlcmF0aW9ucyBleHRlbmRzIEJhc2VNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc3RhdHVzIG9mIGEgbG9uZy1ydW5uaW5nIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbWV0ZXJzIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZ2V0IG9wZXJhdGlvbiByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIHVwZGF0ZWQgT3BlcmF0aW9uIG9iamVjdCwgd2l0aCB0aGUgbGF0ZXN0IHN0YXR1cyBvciByZXN1bHQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VmlkZW9zT3BlcmF0aW9uKHBhcmFtZXRlcnMpIHtcbiAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gcGFyYW1ldGVycy5vcGVyYXRpb247XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHBhcmFtZXRlcnMuY29uZmlnO1xuICAgICAgICBpZiAob3BlcmF0aW9uLm5hbWUgPT09IHVuZGVmaW5lZCB8fCBvcGVyYXRpb24ubmFtZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3BlcmF0aW9uIG5hbWUgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgcmVzb3VyY2VOYW1lID0gb3BlcmF0aW9uLm5hbWUuc3BsaXQoJy9vcGVyYXRpb25zLycpWzBdO1xuICAgICAgICAgICAgbGV0IGh0dHBPcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGNvbmZpZyAmJiAnaHR0cE9wdGlvbnMnIGluIGNvbmZpZykge1xuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zID0gY29uZmlnLmh0dHBPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmF3T3BlcmF0aW9uID0gYXdhaXQgdGhpcy5mZXRjaFByZWRpY3RWaWRlb3NPcGVyYXRpb25JbnRlcm5hbCh7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uTmFtZTogb3BlcmF0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgcmVzb3VyY2VOYW1lOiByZXNvdXJjZU5hbWUsXG4gICAgICAgICAgICAgICAgY29uZmlnOiB7IGh0dHBPcHRpb25zOiBodHRwT3B0aW9ucyB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gb3BlcmF0aW9uLl9mcm9tQVBJUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgIGFwaVJlc3BvbnNlOiByYXdPcGVyYXRpb24sXG4gICAgICAgICAgICAgICAgX2lzVmVydGV4QUk6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHJhd09wZXJhdGlvbiA9IGF3YWl0IHRoaXMuZ2V0VmlkZW9zT3BlcmF0aW9uSW50ZXJuYWwoe1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbk5hbWU6IG9wZXJhdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gb3BlcmF0aW9uLl9mcm9tQVBJUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgIGFwaVJlc3BvbnNlOiByYXdPcGVyYXRpb24sXG4gICAgICAgICAgICAgICAgX2lzVmVydGV4QUk6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc3RhdHVzIG9mIGEgbG9uZy1ydW5uaW5nIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbWV0ZXJzIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZ2V0IG9wZXJhdGlvbiByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIHVwZGF0ZWQgT3BlcmF0aW9uIG9iamVjdCwgd2l0aCB0aGUgbGF0ZXN0IHN0YXR1cyBvciByZXN1bHQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0KHBhcmFtZXRlcnMpIHtcbiAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gcGFyYW1ldGVycy5vcGVyYXRpb247XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHBhcmFtZXRlcnMuY29uZmlnO1xuICAgICAgICBpZiAob3BlcmF0aW9uLm5hbWUgPT09IHVuZGVmaW5lZCB8fCBvcGVyYXRpb24ubmFtZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3BlcmF0aW9uIG5hbWUgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgcmVzb3VyY2VOYW1lID0gb3BlcmF0aW9uLm5hbWUuc3BsaXQoJy9vcGVyYXRpb25zLycpWzBdO1xuICAgICAgICAgICAgbGV0IGh0dHBPcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGNvbmZpZyAmJiAnaHR0cE9wdGlvbnMnIGluIGNvbmZpZykge1xuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zID0gY29uZmlnLmh0dHBPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmF3T3BlcmF0aW9uID0gYXdhaXQgdGhpcy5mZXRjaFByZWRpY3RWaWRlb3NPcGVyYXRpb25JbnRlcm5hbCh7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uTmFtZTogb3BlcmF0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgcmVzb3VyY2VOYW1lOiByZXNvdXJjZU5hbWUsXG4gICAgICAgICAgICAgICAgY29uZmlnOiB7IGh0dHBPcHRpb25zOiBodHRwT3B0aW9ucyB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gb3BlcmF0aW9uLl9mcm9tQVBJUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgIGFwaVJlc3BvbnNlOiByYXdPcGVyYXRpb24sXG4gICAgICAgICAgICAgICAgX2lzVmVydGV4QUk6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHJhd09wZXJhdGlvbiA9IGF3YWl0IHRoaXMuZ2V0VmlkZW9zT3BlcmF0aW9uSW50ZXJuYWwoe1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbk5hbWU6IG9wZXJhdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gb3BlcmF0aW9uLl9mcm9tQVBJUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgIGFwaVJlc3BvbnNlOiByYXdPcGVyYXRpb24sXG4gICAgICAgICAgICAgICAgX2lzVmVydGV4QUk6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0VmlkZW9zT3BlcmF0aW9uSW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldE9wZXJhdGlvblBhcmFtZXRlcnNUb1ZlcnRleChwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne29wZXJhdGlvbk5hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldE9wZXJhdGlvblBhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7b3BlcmF0aW9uTmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZmV0Y2hQcmVkaWN0VmlkZW9zT3BlcmF0aW9uSW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBmZXRjaFByZWRpY3RPcGVyYXRpb25QYXJhbWV0ZXJzVG9WZXJ0ZXgocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tyZXNvdXJjZU5hbWV9OmZldGNoUHJlZGljdE9wZXJhdGlvbicsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBWZXJ0ZXggQUkuJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmZ1bmN0aW9uIGJsb2JUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkYXRhJ10pO1xuICAgIGlmIChmcm9tRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RhdGEnXSwgZnJvbURhdGEpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGlzcGxheU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudFRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhcnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJ0cyddKTtcbiAgICBpZiAoZnJvbVBhcnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21QYXJ0cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0VG9NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Sb2xlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyb2xlJ10pO1xuICAgIGlmIChmcm9tUm9sZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JvbGUnXSwgZnJvbVJvbGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVBdXRoVG9rZW5Db25maWdUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRXhwaXJlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhwaXJlVGltZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUV4cGlyZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZXhwaXJlVGltZSddLCBmcm9tRXhwaXJlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZXdTZXNzaW9uRXhwaXJlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25ld1Nlc3Npb25FeHBpcmVUaW1lJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU5ld1Nlc3Npb25FeHBpcmVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ25ld1Nlc3Npb25FeHBpcmVUaW1lJ10sIGZyb21OZXdTZXNzaW9uRXhwaXJlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Vc2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1c2VzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVXNlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd1c2VzJ10sIGZyb21Vc2VzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxpdmVDb25uZWN0Q29uc3RyYWludHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdsaXZlQ29ubmVjdENvbnN0cmFpbnRzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUxpdmVDb25uZWN0Q29uc3RyYWludHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnYmlkaUdlbmVyYXRlQ29udGVudFNldHVwJ10sIGxpdmVDb25uZWN0Q29uc3RyYWludHNUb01sZGV2KGFwaUNsaWVudCwgZnJvbUxpdmVDb25uZWN0Q29uc3RyYWludHMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxvY2tBZGRpdGlvbmFsRmllbGRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbG9ja0FkZGl0aW9uYWxGaWVsZHMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTG9ja0FkZGl0aW9uYWxGaWVsZHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZmllbGRNYXNrJ10sIGZyb21Mb2NrQWRkaXRpb25hbEZpZWxkcyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUF1dGhUb2tlblBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGNyZWF0ZUF1dGhUb2tlbkNvbmZpZ1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tQ29uZmlnLCB0b09iamVjdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmaWxlRGF0YVRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3BsYXlOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlVXJpJ10pO1xuICAgIGlmIChmcm9tRmlsZVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVVcmknXSwgZnJvbUZpbGVVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkNhbGxUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaWQnXSk7XG4gICAgaWYgKGZyb21JZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lkJ10sIGZyb21JZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BcmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhcmdzJ10pO1xuICAgIGlmIChmcm9tQXJncyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FyZ3MnXSwgZnJvbUFyZ3MpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFydGlhbEFyZ3MnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcnRpYWxBcmdzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3dpbGxDb250aW51ZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignd2lsbENvbnRpbnVlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZU1hcHNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1dGhDb25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F1dGhDb25maWcgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuYWJsZVdpZGdldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5hYmxlV2lkZ2V0J10pO1xuICAgIGlmIChmcm9tRW5hYmxlV2lkZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5hYmxlV2lkZ2V0J10sIGZyb21FbmFibGVXaWRnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVTZWFyY2hUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4Y2x1ZGVEb21haW5zJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleGNsdWRlRG9tYWlucyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydibG9ja2luZ0NvbmZpZGVuY2UnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Jsb2NraW5nQ29uZmlkZW5jZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGltZVJhbmdlRmlsdGVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGltZVJhbmdlRmlsdGVyJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRpbWVSYW5nZUZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RpbWVSYW5nZUZpbHRlciddLCBmcm9tVGltZVJhbmdlRmlsdGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZUNvbm5lY3RDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUdlbmVyYXRpb25Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnZW5lcmF0aW9uQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUdlbmVyYXRpb25Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZyddLCBmcm9tR2VuZXJhdGlvbkNvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1vZGFsaXRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZU1vZGFsaXRpZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAncmVzcG9uc2VNb2RhbGl0aWVzJ10sIGZyb21SZXNwb25zZU1vZGFsaXRpZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGVtcGVyYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0ZW1wZXJhdHVyZSddLCBmcm9tVGVtcGVyYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wUCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wUCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvcFAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0b3BQJ10sIGZyb21Ub3BQKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcEsgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcEsnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub3BLICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAndG9wSyddLCBmcm9tVG9wSyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhPdXRwdXRUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXhPdXRwdXRUb2tlbnMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTWF4T3V0cHV0VG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnbWF4T3V0cHV0VG9rZW5zJ10sIGZyb21NYXhPdXRwdXRUb2tlbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWVkaWFSZXNvbHV0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWVkaWFSZXNvbHV0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU1lZGlhUmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ21lZGlhUmVzb2x1dGlvbiddLCBmcm9tTWVkaWFSZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcGVlY2hDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNwZWVjaENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3NwZWVjaENvbmZpZyddLCB0TGl2ZVNwZWVjaENvbmZpZyhmcm9tU3BlZWNoQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaGlua2luZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RoaW5raW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRoaW5raW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAndGhpbmtpbmdDb25maWcnXSwgZnJvbVRoaW5raW5nQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VuYWJsZUFmZmVjdGl2ZURpYWxvZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdlbmFibGVBZmZlY3RpdmVEaWFsb2cnXSwgZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TeXN0ZW1JbnN0cnVjdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVN5c3RlbUluc3RydWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3N5c3RlbUluc3RydWN0aW9uJ10sIGNvbnRlbnRUb01sZGV2KHRDb250ZW50KGZyb21TeXN0ZW1JbnN0cnVjdGlvbikpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29scyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRUb29scyhmcm9tVG9vbHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvb2xUb01sZGV2KHRUb29sKGl0ZW0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICd0b29scyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2Vzc2lvblJlc3VtcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZXNzaW9uUmVzdW1wdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TZXNzaW9uUmVzdW1wdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdzZXNzaW9uUmVzdW1wdGlvbiddLCBzZXNzaW9uUmVzdW1wdGlvbkNvbmZpZ1RvTWxkZXYoZnJvbVNlc3Npb25SZXN1bXB0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2lucHV0QXVkaW9UcmFuc2NyaXB0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUlucHV0QXVkaW9UcmFuc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2lucHV0QXVkaW9UcmFuc2NyaXB0aW9uJ10sIGZyb21JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ291dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbiddLCBmcm9tT3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlYWx0aW1lSW5wdXRDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZWFsdGltZUlucHV0Q29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVJlYWx0aW1lSW5wdXRDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAncmVhbHRpbWVJbnB1dENvbmZpZyddLCBmcm9tUmVhbHRpbWVJbnB1dENvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZXh0V2luZG93Q29tcHJlc3Npb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb250ZXh0V2luZG93Q29tcHJlc3Npb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ29udGV4dFdpbmRvd0NvbXByZXNzaW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2NvbnRleHRXaW5kb3dDb21wcmVzc2lvbiddLCBmcm9tQ29udGV4dFdpbmRvd0NvbXByZXNzaW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb2FjdGl2aXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9hY3Rpdml0eSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVByb2FjdGl2aXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3Byb2FjdGl2aXR5J10sIGZyb21Qcm9hY3Rpdml0eSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVDb25uZWN0Q29uc3RyYWludHNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2V0dXAnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBsaXZlQ29ubmVjdENvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcGFydFRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1lZGlhUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21lZGlhUmVzb2x1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NZWRpYVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZWRpYVJlc29sdXRpb24nXSwgZnJvbU1lZGlhUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvblJlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvblJlc3VsdCddLCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGVjdXRhYmxlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4ZWN1dGFibGVDb2RlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4ZWN1dGFibGVDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhlY3V0YWJsZUNvZGUnXSwgZnJvbUV4ZWN1dGFibGVDb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlRGF0YSddKTtcbiAgICBpZiAoZnJvbUZpbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZURhdGEnXSwgZmlsZURhdGFUb01sZGV2KGZyb21GaWxlRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmdW5jdGlvbkNhbGwnXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGwnXSwgZnVuY3Rpb25DYWxsVG9NbGRldihmcm9tRnVuY3Rpb25DYWxsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvblJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25SZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvblJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25SZXNwb25zZSddLCBmcm9tRnVuY3Rpb25SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVEYXRhJ10pO1xuICAgIGlmIChmcm9tSW5saW5lRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lubGluZURhdGEnXSwgYmxvYlRvTWxkZXYoZnJvbUlubGluZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aG91Z2h0J10pO1xuICAgIGlmIChmcm9tVGhvdWdodCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHQnXSwgZnJvbVRob3VnaHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodFNpZ25hdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rob3VnaHRTaWduYXR1cmUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhvdWdodFNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHRTaWduYXR1cmUnXSwgZnJvbVRob3VnaHRTaWduYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW9NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ZpZGVvTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvTWV0YWRhdGEnXSwgZnJvbVZpZGVvTWV0YWRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzZXNzaW9uUmVzdW1wdGlvbkNvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUhhbmRsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaGFuZGxlJ10pO1xuICAgIGlmIChmcm9tSGFuZGxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaGFuZGxlJ10sIGZyb21IYW5kbGUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0cmFuc3BhcmVudCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNwYXJlbnQgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbFRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25EZWNsYXJhdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkRlY2xhcmF0aW9ucyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXRyaWV2YWwnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JldHJpZXZhbCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCddLCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbXB1dGVyVXNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb21wdXRlclVzZSddKTtcbiAgICBpZiAoZnJvbUNvbXB1dGVyVXNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSwgZnJvbUNvbXB1dGVyVXNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21GaWxlU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZVNlYXJjaCddLCBmcm9tRmlsZVNlYXJjaCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvbiddLCBmcm9tQ29kZUV4ZWN1dGlvbik7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VudGVycHJpc2VXZWJTZWFyY2gnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VudGVycHJpc2VXZWJTZWFyY2ggcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZU1hcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVNYXBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlTWFwcyddLCBnb29nbGVNYXBzVG9NbGRldihmcm9tR29vZ2xlTWFwcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2gnXSwgZ29vZ2xlU2VhcmNoVG9NbGRldihmcm9tR29vZ2xlU2VhcmNoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmxDb250ZXh0J10pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHQnXSwgZnJvbVVybENvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8qKlxuICogUmV0dXJucyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGZpZWxkIG1hc2tzIGZyb20gYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHNldHVwIFRoZSBvYmplY3QgdG8gZXh0cmFjdCBmaWVsZCBtYXNrcyBmcm9tLlxuICogQHJldHVybiBBIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGZpZWxkIG1hc2tzLlxuICovXG5mdW5jdGlvbiBnZXRGaWVsZE1hc2tzKHNldHVwKSB7XG4gICAgY29uc3QgZmllbGRzID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2V0dXApIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR1cCwga2V5KSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBzZXR1cFtrZXldO1xuICAgICAgICAgICAgLy8gMm5kIGxheWVyLCByZWN1cnNpdmVseSBnZXQgZmllbGQgbWFza3Mgc2VlIFRPRE8oYi80MTgyOTAxMDApXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIHZhbHVlICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gT2JqZWN0LmtleXModmFsdWUpLm1hcCgoa2spID0+IGAke2tleX0uJHtra31gKTtcbiAgICAgICAgICAgICAgICBmaWVsZHMucHVzaCguLi5maWVsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWVsZHMucHVzaChrZXkpOyAvLyAxc3QgbGF5ZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmllbGRzLmpvaW4oJywnKTtcbn1cbi8qKlxuICogQ29udmVydHMgYmlkaUdlbmVyYXRlQ29udGVudFNldHVwLlxuICogQHBhcmFtIHJlcXVlc3REaWN0IC0gVGhlIHJlcXVlc3QgZGljdGlvbmFyeS5cbiAqIEBwYXJhbSBjb25maWcgLSBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gKiBAcmV0dXJuIC0gVGhlIG1vZGlmaWVkIHJlcXVlc3QgZGljdGlvbmFyeS5cbiAqL1xuZnVuY3Rpb24gY29udmVydEJpZGlTZXR1cFRvVG9rZW5TZXR1cChyZXF1ZXN0RGljdCwgY29uZmlnKSB7XG4gICAgLy8gQ29udmVydCBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXAgZnJvbSBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXAuc2V0dXAuXG4gICAgbGV0IHNldHVwRm9yTWFza0dlbmVyYXRpb24gPSBudWxsO1xuICAgIGNvbnN0IGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cFZhbHVlID0gcmVxdWVzdERpY3RbJ2JpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cCddO1xuICAgIGlmICh0eXBlb2YgYmlkaUdlbmVyYXRlQ29udGVudFNldHVwVmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgIGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cFZhbHVlICE9PSBudWxsICYmXG4gICAgICAgICdzZXR1cCcgaW4gYmlkaUdlbmVyYXRlQ29udGVudFNldHVwVmFsdWUpIHtcbiAgICAgICAgLy8gTm93IHdlIGtub3cgYmlkaUdlbmVyYXRlQ29udGVudFNldHVwVmFsdWUgaXMgYW4gb2JqZWN0IGFuZCBoYXMgYSAnc2V0dXAnXG4gICAgICAgIC8vIHByb3BlcnR5LlxuICAgICAgICBjb25zdCBpbm5lclNldHVwID0gYmlkaUdlbmVyYXRlQ29udGVudFNldHVwVmFsdWVcbiAgICAgICAgICAgIC5zZXR1cDtcbiAgICAgICAgaWYgKHR5cGVvZiBpbm5lclNldHVwID09PSAnb2JqZWN0JyAmJiBpbm5lclNldHVwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBWYWxpZCBpbm5lciBzZXR1cCBmb3VuZC5cbiAgICAgICAgICAgIHJlcXVlc3REaWN0WydiaWRpR2VuZXJhdGVDb250ZW50U2V0dXAnXSA9IGlubmVyU2V0dXA7XG4gICAgICAgICAgICBzZXR1cEZvck1hc2tHZW5lcmF0aW9uID0gaW5uZXJTZXR1cDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXBWYWx1ZS5zZXR1cGAgaXMgbm90IGEgdmFsaWQgb2JqZWN0OyB0cmVhdCBhc1xuICAgICAgICAgICAgLy8gaWYgYmlkaUdlbmVyYXRlQ29udGVudFNldHVwIGlzIGludmFsaWQuXG4gICAgICAgICAgICBkZWxldGUgcmVxdWVzdERpY3RbJ2JpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cCddO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gYGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cGAgZXhpc3RzIGJ1dCBub3QgaW4gdGhlIGV4cGVjdGVkXG4gICAgICAgIC8vIHNoYXBlIHtzZXR1cDogey4uLn19OyB0cmVhdCBhcyBpbnZhbGlkLlxuICAgICAgICBkZWxldGUgcmVxdWVzdERpY3RbJ2JpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cCddO1xuICAgIH1cbiAgICBjb25zdCBwcmVFeGlzdGluZ0ZpZWxkTWFzayA9IHJlcXVlc3REaWN0WydmaWVsZE1hc2snXTtcbiAgICAvLyBIYW5kbGUgbWFzayBnZW5lcmF0aW9uIHNldHVwLlxuICAgIGlmIChzZXR1cEZvck1hc2tHZW5lcmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRlZE1hc2tGcm9tQmlkaSA9IGdldEZpZWxkTWFza3Moc2V0dXBGb3JNYXNrR2VuZXJhdGlvbik7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5sb2NrQWRkaXRpb25hbEZpZWxkcykgJiZcbiAgICAgICAgICAgIChjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcubG9ja0FkZGl0aW9uYWxGaWVsZHMubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gQ2FzZSAxOiBsb2NrQWRkaXRpb25hbEZpZWxkcyBpcyBhbiBlbXB0eSBhcnJheS4gTG9jayBvbmx5IGZpZWxkcyBmcm9tXG4gICAgICAgICAgICAvLyBiaWRpIHNldHVwLlxuICAgICAgICAgICAgaWYgKGdlbmVyYXRlZE1hc2tGcm9tQmlkaSkge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgYXNzaWduIGlmIG1hc2sgaXMgbm90IGVtcHR5XG4gICAgICAgICAgICAgICAgcmVxdWVzdERpY3RbJ2ZpZWxkTWFzayddID0gZ2VuZXJhdGVkTWFza0Zyb21CaWRpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHJlcXVlc3REaWN0WydmaWVsZE1hc2snXTsgLy8gSWYgbWFzayBpcyBlbXB0eSwgZWZmZWN0aXZlbHkgbm9cbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpYyBmaWVsZHMgbG9ja2VkIGJ5IGJpZGlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmxvY2tBZGRpdGlvbmFsRmllbGRzKSAmJlxuICAgICAgICAgICAgY29uZmlnLmxvY2tBZGRpdGlvbmFsRmllbGRzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIHByZUV4aXN0aW5nRmllbGRNYXNrICE9PSBudWxsICYmXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHByZUV4aXN0aW5nRmllbGRNYXNrKSAmJlxuICAgICAgICAgICAgcHJlRXhpc3RpbmdGaWVsZE1hc2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gQ2FzZSAyOiBMb2NrIGZpZWxkcyBmcm9tIGJpZGkgc2V0dXAgKyBhZGRpdGlvbmFsIGZpZWxkc1xuICAgICAgICAgICAgLy8gKHByZUV4aXN0aW5nRmllbGRNYXNrKS5cbiAgICAgICAgICAgIGNvbnN0IGdlbmVyYXRpb25Db25maWdGaWVsZHMgPSBbXG4gICAgICAgICAgICAgICAgJ3RlbXBlcmF0dXJlJyxcbiAgICAgICAgICAgICAgICAndG9wSycsXG4gICAgICAgICAgICAgICAgJ3RvcFAnLFxuICAgICAgICAgICAgICAgICdtYXhPdXRwdXRUb2tlbnMnLFxuICAgICAgICAgICAgICAgICdyZXNwb25zZU1vZGFsaXRpZXMnLFxuICAgICAgICAgICAgICAgICdzZWVkJyxcbiAgICAgICAgICAgICAgICAnc3BlZWNoQ29uZmlnJyxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBsZXQgbWFwcGVkRmllbGRzRnJvbVByZUV4aXN0aW5nID0gW107XG4gICAgICAgICAgICBpZiAocHJlRXhpc3RpbmdGaWVsZE1hc2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG1hcHBlZEZpZWxkc0Zyb21QcmVFeGlzdGluZyA9IHByZUV4aXN0aW5nRmllbGRNYXNrLm1hcCgoZmllbGQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdlbmVyYXRpb25Db25maWdGaWVsZHMuaW5jbHVkZXMoZmllbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYGdlbmVyYXRpb25Db25maWcuJHtmaWVsZH1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZDsgLy8gS2VlcCBvcmlnaW5hbCBmaWVsZCBuYW1lIGlmIG5vdCBpblxuICAgICAgICAgICAgICAgICAgICAvLyBnZW5lcmF0aW9uQ29uZmlnRmllbGRzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmaW5hbE1hc2tQYXJ0cyA9IFtdO1xuICAgICAgICAgICAgaWYgKGdlbmVyYXRlZE1hc2tGcm9tQmlkaSkge1xuICAgICAgICAgICAgICAgIGZpbmFsTWFza1BhcnRzLnB1c2goZ2VuZXJhdGVkTWFza0Zyb21CaWRpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXBwZWRGaWVsZHNGcm9tUHJlRXhpc3RpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZpbmFsTWFza1BhcnRzLnB1c2goLi4ubWFwcGVkRmllbGRzRnJvbVByZUV4aXN0aW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaW5hbE1hc2tQYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdERpY3RbJ2ZpZWxkTWFzayddID0gZmluYWxNYXNrUGFydHMuam9pbignLCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgbm8gZmllbGRzIGZyb20gYmlkaSBhbmQgbm8gdmFsaWQgYWRkaXRpb25hbCBmaWVsZHMgZnJvbVxuICAgICAgICAgICAgICAgIC8vIHByZS1leGlzdGluZyBtYXNrLlxuICAgICAgICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0RGljdFsnZmllbGRNYXNrJ107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBDYXNlIDM6IFwiTG9jayBhbGwgZmllbGRzXCIgKG1lYW5pbmcsIGRvbid0IHNlbmQgYSBmaWVsZF9tYXNrLCBsZXQgc2VydmVyXG4gICAgICAgICAgICAvLyBkZWZhdWx0cyBhcHBseSBvciBhbGwgYXJlIG11dGFibGUpLiBUaGlzIGlzIGhpdCBpZjpcbiAgICAgICAgICAgIC8vICAtIGBjb25maWcubG9ja0FkZGl0aW9uYWxGaWVsZHNgIGlzIHVuZGVmaW5lZC5cbiAgICAgICAgICAgIC8vICAtIGBjb25maWcubG9ja0FkZGl0aW9uYWxGaWVsZHNgIGlzIG5vbi1lbXB0eSwgQlVUXG4gICAgICAgICAgICAvLyAgYHByZUV4aXN0aW5nRmllbGRNYXNrYCBpcyBudWxsLCBub3QgYSBzdHJpbmcsIG9yIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0RGljdFsnZmllbGRNYXNrJ107XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE5vIHZhbGlkIGBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXBgIHdhcyBmb3VuZCBvciBleHRyYWN0ZWQuXG4gICAgICAgIC8vIFwiTG9jayBhZGRpdGlvbmFsIG51bGwgZmllbGRzIGlmIGFueVwiLlxuICAgICAgICBpZiAocHJlRXhpc3RpbmdGaWVsZE1hc2sgIT09IG51bGwgJiZcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkocHJlRXhpc3RpbmdGaWVsZE1hc2spICYmXG4gICAgICAgICAgICBwcmVFeGlzdGluZ0ZpZWxkTWFzay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGEgcHJlLWV4aXN0aW5nIGZpZWxkIG1hc2ssIGl0J3MgYSBzdHJpbmcsIGFuZCBpdCdzIG5vdFxuICAgICAgICAgICAgLy8gZW1wdHksIHRoZW4gd2Ugc2hvdWxkIGxvY2sgYWxsIGZpZWxkcy5cbiAgICAgICAgICAgIHJlcXVlc3REaWN0WydmaWVsZE1hc2snXSA9IHByZUV4aXN0aW5nRmllbGRNYXNrLmpvaW4oJywnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0RGljdFsnZmllbGRNYXNrJ107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcXVlc3REaWN0O1xufVxuY2xhc3MgVG9rZW5zIGV4dGVuZHMgQmFzZU1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGVwaGVtZXJhbCBhdXRoIHRva2VuIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBFcGhlbWVyYWwgYXV0aCB0b2tlbnMgaXMgb25seSBzdXBwb3J0ZWQgaW4gdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLlxuICAgICAqIEl0IGNhbiBiZSB1c2VkIGZvciB0aGUgc2Vzc2lvbiBjb25uZWN0aW9uIHRvIHRoZSBMaXZlIGNvbnN0cmFpbmVkIEFQSS5cbiAgICAgKiBTdXBwb3J0IGluIHYxYWxwaGEgb25seS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGNyZWF0ZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIGNyZWF0ZWQgYXV0aCB0b2tlbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBhaSA9IG5ldyBHb29nbGVHZW5BSSh7XG4gICAgICogICAgIGFwaUtleTogdG9rZW4ubmFtZSxcbiAgICAgKiAgICAgaHR0cE9wdGlvbnM6IHsgYXBpVmVyc2lvbjogJ3YxYWxwaGEnIH0gIC8vIFN1cHBvcnQgaW4gdjFhbHBoYSBvbmx5LlxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gQ2FzZSAxOiBJZiBMaXZlRXBoZW1lcmFsUGFyYW1ldGVycyBpcyB1bnNldCwgdW5sb2NrIExpdmVDb25uZWN0Q29uZmlnXG4gICAgICogLy8gd2hlbiB1c2luZyB0aGUgdG9rZW4gaW4gTGl2ZSBBUEkgc2Vzc2lvbnMuIEVhY2ggc2Vzc2lvbiBjb25uZWN0aW9uIGNhblxuICAgICAqIC8vIHVzZSBhIGRpZmZlcmVudCBjb25maWd1cmF0aW9uLlxuICAgICAqIGNvbnN0IGNvbmZpZzogQ3JlYXRlQXV0aFRva2VuQ29uZmlnID0ge1xuICAgICAqICAgICB1c2VzOiAzLFxuICAgICAqICAgICBleHBpcmVUaW1lOiAnMjAyNS0wNS0wMVQwMDowMDowMFonLFxuICAgICAqIH1cbiAgICAgKiBjb25zdCB0b2tlbiA9IGF3YWl0IGFpLnRva2Vucy5jcmVhdGUoY29uZmlnKTtcbiAgICAgKlxuICAgICAqIC8vIENhc2UgMjogSWYgTGl2ZUVwaGVtZXJhbFBhcmFtZXRlcnMgaXMgc2V0LCBsb2NrIGFsbCBmaWVsZHMgaW5cbiAgICAgKiAvLyBMaXZlQ29ubmVjdENvbmZpZyB3aGVuIHVzaW5nIHRoZSB0b2tlbiBpbiBMaXZlIEFQSSBzZXNzaW9ucy4gRm9yXG4gICAgICogLy8gZXhhbXBsZSwgY2hhbmdpbmcgYG91dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbmAgaW4gdGhlIExpdmUgQVBJXG4gICAgICogLy8gY29ubmVjdGlvbiB3aWxsIGJlIGlnbm9yZWQgYnkgdGhlIEFQSS5cbiAgICAgKiBjb25zdCBjb25maWc6IENyZWF0ZUF1dGhUb2tlbkNvbmZpZyA9XG4gICAgICogICAgIHVzZXM6IDMsXG4gICAgICogICAgIGV4cGlyZVRpbWU6ICcyMDI1LTA1LTAxVDAwOjAwOjAwWicsXG4gICAgICogICAgIExpdmVFcGhlbWVyYWxQYXJhbWV0ZXJzOiB7XG4gICAgICogICAgICAgIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaC0wMDEnLFxuICAgICAqICAgICAgICBjb25maWc6IHtcbiAgICAgKiAgICAgICAgICAgJ3Jlc3BvbnNlTW9kYWxpdGllcyc6IFsnQVVESU8nXSxcbiAgICAgKiAgICAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJzogJ0Fsd2F5cyBhbnN3ZXIgaW4gRW5nbGlzaC4nLFxuICAgICAqICAgICAgICB9XG4gICAgICogICAgIH1cbiAgICAgKiB9XG4gICAgICogY29uc3QgdG9rZW4gPSBhd2FpdCBhaS50b2tlbnMuY3JlYXRlKGNvbmZpZyk7XG4gICAgICpcbiAgICAgKiAvLyBDYXNlIDM6IElmIExpdmVFcGhlbWVyYWxQYXJhbWV0ZXJzIGlzIHNldCBhbmQgbG9ja0FkZGl0aW9uYWxGaWVsZHMgaXNcbiAgICAgKiAvLyBzZXQsIGxvY2sgTGl2ZUNvbm5lY3RDb25maWcgd2l0aCBzZXQgYW5kIGFkZGl0aW9uYWwgZmllbGRzIChlLmcuXG4gICAgICogLy8gcmVzcG9uc2VNb2RhbGl0aWVzLCBzeXN0ZW1JbnN0cnVjdGlvbiwgdGVtcGVyYXR1cmUgaW4gdGhpcyBleGFtcGxlKSB3aGVuXG4gICAgICogLy8gdXNpbmcgdGhlIHRva2VuIGluIExpdmUgQVBJIHNlc3Npb25zLlxuICAgICAqIGNvbnN0IGNvbmZpZzogQ3JlYXRlQXV0aFRva2VuQ29uZmlnID1cbiAgICAgKiAgICAgdXNlczogMyxcbiAgICAgKiAgICAgZXhwaXJlVGltZTogJzIwMjUtMDUtMDFUMDA6MDA6MDBaJyxcbiAgICAgKiAgICAgTGl2ZUVwaGVtZXJhbFBhcmFtZXRlcnM6IHtcbiAgICAgKiAgICAgICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoLTAwMScsXG4gICAgICogICAgICAgIGNvbmZpZzoge1xuICAgICAqICAgICAgICAgICAncmVzcG9uc2VNb2RhbGl0aWVzJzogWydBVURJTyddLFxuICAgICAqICAgICAgICAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nOiAnQWx3YXlzIGFuc3dlciBpbiBFbmdsaXNoLicsXG4gICAgICogICAgICAgIH1cbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgbG9ja0FkZGl0aW9uYWxGaWVsZHM6IFsndGVtcGVyYXR1cmUnXSxcbiAgICAgKiB9XG4gICAgICogY29uc3QgdG9rZW4gPSBhd2FpdCBhaS50b2tlbnMuY3JlYXRlKGNvbmZpZyk7XG4gICAgICpcbiAgICAgKiAvLyBDYXNlIDQ6IElmIExpdmVFcGhlbWVyYWxQYXJhbWV0ZXJzIGlzIHNldCBhbmQgbG9ja0FkZGl0aW9uYWxGaWVsZHMgaXNcbiAgICAgKiAvLyBlbXB0eSBhcnJheSwgbG9jayBMaXZlQ29ubmVjdENvbmZpZyB3aXRoIHNldCBmaWVsZHMgKGUuZy5cbiAgICAgKiAvLyByZXNwb25zZU1vZGFsaXRpZXMsIHN5c3RlbUluc3RydWN0aW9uIGluIHRoaXMgZXhhbXBsZSkgd2hlbiB1c2luZyB0aGVcbiAgICAgKiAvLyB0b2tlbiBpbiBMaXZlIEFQSSBzZXNzaW9ucy5cbiAgICAgKiBjb25zdCBjb25maWc6IENyZWF0ZUF1dGhUb2tlbkNvbmZpZyA9XG4gICAgICogICAgIHVzZXM6IDMsXG4gICAgICogICAgIGV4cGlyZVRpbWU6ICcyMDI1LTA1LTAxVDAwOjAwOjAwWicsXG4gICAgICogICAgIExpdmVFcGhlbWVyYWxQYXJhbWV0ZXJzOiB7XG4gICAgICogICAgICAgIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaC0wMDEnLFxuICAgICAqICAgICAgICBjb25maWc6IHtcbiAgICAgKiAgICAgICAgICAgJ3Jlc3BvbnNlTW9kYWxpdGllcyc6IFsnQVVESU8nXSxcbiAgICAgKiAgICAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJzogJ0Fsd2F5cyBhbnN3ZXIgaW4gRW5nbGlzaC4nLFxuICAgICAqICAgICAgICB9XG4gICAgICogICAgIH0sXG4gICAgICogICAgIGxvY2tBZGRpdGlvbmFsRmllbGRzOiBbXSxcbiAgICAgKiB9XG4gICAgICogY29uc3QgdG9rZW4gPSBhd2FpdCBhaS50b2tlbnMuY3JlYXRlKGNvbmZpZyk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjbGllbnQudG9rZW5zLmNyZWF0ZSBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNyZWF0ZUF1dGhUb2tlblBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnYXV0aF90b2tlbnMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZEJvZHkgPSBjb252ZXJ0QmlkaVNldHVwVG9Ub2tlblNldHVwKGJvZHksIHBhcmFtcy5jb25maWcpO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh0cmFuc2Zvcm1lZEJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKHJlc3ApID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vLyBDb2RlIGdlbmVyYXRlZCBieSB0aGUgR29vZ2xlIEdlbiBBSSBTREsgZ2VuZXJhdG9yIERPIE5PVCBFRElULlxuZnVuY3Rpb24gZGVsZXRlRG9jdW1lbnRDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZvcmNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmb3JjZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUZvcmNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdmb3JjZSddLCBmcm9tRm9yY2UpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVEb2N1bWVudFBhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZURvY3VtZW50Q29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdldERvY3VtZW50UGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdERvY3VtZW50c0NvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFnZVNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VTaXplJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VTaXplJ10sIGZyb21QYWdlU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VUb2tlbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVRva2VuJ10sIGZyb21QYWdlVG9rZW4pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0RG9jdW1lbnRzUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhcmVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFyZW50J10pO1xuICAgIGlmIChmcm9tUGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdwYXJlbnQnXSwgZnJvbVBhcmVudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGxpc3REb2N1bWVudHNDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdERvY3VtZW50c1Jlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmV4dFBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25leHRQYWdlVG9rZW4nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTmV4dFBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25leHRQYWdlVG9rZW4nXSwgZnJvbU5leHRQYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRG9jdW1lbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkb2N1bWVudHMnXSk7XG4gICAgaWYgKGZyb21Eb2N1bWVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbURvY3VtZW50cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9jdW1lbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgRG9jdW1lbnRzIGV4dGVuZHMgQmFzZU1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdHMgZG9jdW1lbnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBsaXN0IHJlcXVlc3QuXG4gICAgICAgICAqIEByZXR1cm4gLSBBIHBhZ2VyIG9mIGRvY3VtZW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgZG9jdW1lbnRzID0gYXdhaXQgYWkuZG9jdW1lbnRzLmxpc3Qoe3BhcmVudDoncmFnX3N0b3JlX25hbWUnLCBjb25maWc6IHsncGFnZVNpemUnOiAyfX0pO1xuICAgICAgICAgKiBmb3IgYXdhaXQgKGNvbnN0IGRvY3VtZW50IG9mIGRvY3VtZW50cykge1xuICAgICAgICAgKiAgIGNvbnNvbGUubG9nKGRvY3VtZW50KTtcbiAgICAgICAgICogfVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGlzdCA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGFnZXIoUGFnZWRJdGVtLlBBR0VEX0lURU1fRE9DVU1FTlRTLCAoeCkgPT4gdGhpcy5saXN0SW50ZXJuYWwoeyBwYXJlbnQ6IHBhcmFtcy5wYXJlbnQsIGNvbmZpZzogeC5jb25maWcgfSksIGF3YWl0IHRoaXMubGlzdEludGVybmFsKHBhcmFtcyksIHBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBEb2N1bWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZ2V0dGluZyBhIGRvY3VtZW50LlxuICAgICAqIEByZXR1cm4gRG9jdW1lbnQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0KHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXREb2N1bWVudFBhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigocmVzcCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhIERvY3VtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBkZWxldGluZyBhIGRvY3VtZW50LlxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGRlbGV0ZURvY3VtZW50UGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBpQ2xpZW50LnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGxpc3RJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbGlzdERvY3VtZW50c1BhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7cGFyZW50fS9kb2N1bWVudHMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gbGlzdERvY3VtZW50c1Jlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgTGlzdERvY3VtZW50c1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgRmlsZVNlYXJjaFN0b3JlcyBleHRlbmRzIEJhc2VNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCwgZG9jdW1lbnRzID0gbmV3IERvY3VtZW50cyhhcGlDbGllbnQpKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgICAgICB0aGlzLmRvY3VtZW50cyA9IGRvY3VtZW50cztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3RzIGZpbGUgc2VhcmNoIHN0b3Jlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgbGlzdCByZXF1ZXN0LlxuICAgICAgICAgKiBAcmV0dXJuIC0gQSBwYWdlciBvZiBmaWxlIHNlYXJjaCBzdG9yZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IGZpbGVTZWFyY2hTdG9yZXMgPSBhd2FpdCBhaS5maWxlU2VhcmNoU3RvcmVzLmxpc3Qoe2NvbmZpZzogeydwYWdlU2l6ZSc6IDJ9fSk7XG4gICAgICAgICAqIGZvciBhd2FpdCAoY29uc3QgZmlsZVNlYXJjaFN0b3JlIG9mIGZpbGVTZWFyY2hTdG9yZXMpIHtcbiAgICAgICAgICogICBjb25zb2xlLmxvZyhmaWxlU2VhcmNoU3RvcmUpO1xuICAgICAgICAgKiB9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saXN0ID0gYXN5bmMgKHBhcmFtcyA9IHt9KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhZ2VyKFBhZ2VkSXRlbS5QQUdFRF9JVEVNX0ZJTEVfU0VBUkNIX1NUT1JFUywgKHgpID0+IHRoaXMubGlzdEludGVybmFsKHgpLCBhd2FpdCB0aGlzLmxpc3RJbnRlcm5hbChwYXJhbXMpLCBwYXJhbXMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIGEgZmlsZSBhc3luY2hyb25vdXNseSB0byBhIGdpdmVuIEZpbGUgU2VhcmNoIFN0b3JlLlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIG5vdCBhdmFpbGFibGUgaW4gVmVydGV4IEFJLlxuICAgICAqIFN1cHBvcnRlZCB1cGxvYWQgc291cmNlczpcbiAgICAgKiAtIE5vZGUuanM6IEZpbGUgcGF0aCAoc3RyaW5nKSBvciBCbG9iIG9iamVjdC5cbiAgICAgKiAtIEJyb3dzZXI6IEJsb2Igb2JqZWN0IChlLmcuLCBGaWxlKS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhlIGBtaW1lVHlwZWAgY2FuIGJlIHNwZWNpZmllZCBpbiB0aGUgYGNvbmZpZ2AgcGFyYW1ldGVyLiBJZiBvbWl0dGVkOlxuICAgICAqICAtIEZvciBmaWxlIHBhdGggKHN0cmluZykgaW5wdXRzLCB0aGUgYG1pbWVUeXBlYCB3aWxsIGJlIGluZmVycmVkIGZyb20gdGhlXG4gICAgICogICAgIGZpbGUgZXh0ZW5zaW9uLlxuICAgICAqICAtIEZvciBCbG9iIG9iamVjdCBpbnB1dHMsIHRoZSBgbWltZVR5cGVgIHdpbGwgYmUgc2V0IHRvIHRoZSBCbG9iJ3MgYHR5cGVgXG4gICAgICogICAgIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogVGhpcyBzZWN0aW9uIGNhbiBjb250YWluIG11bHRpcGxlIHBhcmFncmFwaHMgYW5kIGNvZGUgZXhhbXBsZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gT3B0aW9uYWwgcGFyYW1ldGVycyBzcGVjaWZpZWQgaW4gdGhlXG4gICAgICogICAgICAgIGB0eXBlcy5VcGxvYWRUb0ZpbGVTZWFyY2hTdG9yZVBhcmFtZXRlcnNgIGludGVyZmFjZS5cbiAgICAgKiAgICAgICAgIEBzZWUge0BsaW5rIHR5cGVzLlVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlUGFyYW1ldGVycyNjb25maWd9IGZvciB0aGUgb3B0aW9uYWxcbiAgICAgKiAgICAgICAgIGNvbmZpZyBpbiB0aGUgcGFyYW1ldGVycy5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgbG9uZyBydW5uaW5nIG9wZXJhdGlvbi5cbiAgICAgKiBAdGhyb3dzIEFuIGVycm9yIGlmIGNhbGxlZCBvbiBhIFZlcnRleCBBSSBjbGllbnQuXG4gICAgICogQHRocm93cyBBbiBlcnJvciBpZiB0aGUgYG1pbWVUeXBlYCBpcyBub3QgcHJvdmlkZWQgYW5kIGNhbiBub3QgYmUgaW5mZXJyZWQsXG4gICAgICogdGhlIGBtaW1lVHlwZWAgY2FuIGJlIHByb3ZpZGVkIGluIHRoZSBgcGFyYW1zLmNvbmZpZ2AgcGFyYW1ldGVyLlxuICAgICAqIEB0aHJvd3MgQW4gZXJyb3Igb2NjdXJzIGlmIGEgc3VpdGFibGUgdXBsb2FkIGxvY2F0aW9uIGNhbm5vdCBiZSBlc3RhYmxpc2hlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogVGhlIGZvbGxvd2luZyBjb2RlIHVwbG9hZHMgYSBmaWxlIHRvIGEgZ2l2ZW4gZmlsZSBzZWFyY2ggc3RvcmUuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IG9wZXJhdGlvbiA9IGF3YWl0IGFpLmZpbGVTZWFyY2hTdG9yZXMudXBsb2FkKHtmaWxlU2VhcmNoU3RvcmVOYW1lOiAnZmlsZVNlYXJjaFN0b3Jlcy9mb28tYmFyJywgZmlsZTogJ2ZpbGUudHh0JywgY29uZmlnOiB7XG4gICAgICogICBtaW1lVHlwZTogJ3RleHQvcGxhaW4nLFxuICAgICAqIH19KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvcGVyYXRpb24ubmFtZSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgdXBsb2FkVG9GaWxlU2VhcmNoU3RvcmUocGFyYW1zKSB7XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmVydGV4IEFJIGRvZXMgbm90IHN1cHBvcnQgdXBsb2FkaW5nIGZpbGVzIHRvIGEgZmlsZSBzZWFyY2ggc3RvcmUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50LnVwbG9hZEZpbGVUb0ZpbGVTZWFyY2hTdG9yZShwYXJhbXMuZmlsZVNlYXJjaFN0b3JlTmFtZSwgcGFyYW1zLmZpbGUsIHBhcmFtcy5jb25maWcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgRmlsZSBTZWFyY2ggU3RvcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGNyZWF0aW5nIGEgRmlsZSBTZWFyY2ggU3RvcmUuXG4gICAgICogQHJldHVybiBGaWxlU2VhcmNoU3RvcmUuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjcmVhdGVGaWxlU2VhcmNoU3RvcmVQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnZmlsZVNlYXJjaFN0b3JlcycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigocmVzcCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIEZpbGUgU2VhcmNoIFN0b3JlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBnZXR0aW5nIGEgRmlsZSBTZWFyY2ggU3RvcmUuXG4gICAgICogQHJldHVybiBGaWxlU2VhcmNoU3RvcmUuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0KHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXRGaWxlU2VhcmNoU3RvcmVQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKHJlc3ApID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYSBGaWxlIFNlYXJjaCBTdG9yZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZGVsZXRpbmcgYSBGaWxlIFNlYXJjaCBTdG9yZS5cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBkZWxldGVGaWxlU2VhcmNoU3RvcmVQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hcGlDbGllbnQucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbGlzdEludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBsaXN0RmlsZVNlYXJjaFN0b3Jlc1BhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdmaWxlU2VhcmNoU3RvcmVzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGxpc3RGaWxlU2VhcmNoU3RvcmVzUmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBMaXN0RmlsZVNlYXJjaFN0b3Jlc1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB1cGxvYWRUb0ZpbGVTZWFyY2hTdG9yZUludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSB1cGxvYWRUb0ZpbGVTZWFyY2hTdG9yZVBhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd1cGxvYWQvdjFiZXRhL3tmaWxlX3NlYXJjaF9zdG9yZV9uYW1lfTp1cGxvYWRUb0ZpbGVTZWFyY2hTdG9yZScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gdXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVSZXN1bWFibGVSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IFVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlUmVzdW1hYmxlUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEltcG9ydHMgYSBGaWxlIGZyb20gRmlsZSBTZXJ2aWNlIHRvIGEgRmlsZVNlYXJjaFN0b3JlLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBhIGxvbmctcnVubmluZyBvcGVyYXRpb24sIHNlZSBhaXAuZGV2LzE1MVxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBpbXBvcnRpbmcgYSBmaWxlIHRvIGEgZmlsZSBzZWFyY2ggc3RvcmUuXG4gICAgICogQHJldHVybiBJbXBvcnRGaWxlT3BlcmF0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIGltcG9ydEZpbGUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGltcG9ydEZpbGVQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne2ZpbGVfc2VhcmNoX3N0b3JlX25hbWV9OmltcG9ydEZpbGUnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGltcG9ydEZpbGVPcGVyYXRpb25Gcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBJbXBvcnRGaWxlT3BlcmF0aW9uKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY29uc3QgR09PR0xFX0FQSV9LRVlfSEVBREVSID0gJ3gtZ29vZy1hcGkta2V5JztcbmNvbnN0IFJFUVVJUkVEX1ZFUlRFWF9BSV9TQ09QRSA9ICdodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL2Nsb3VkLXBsYXRmb3JtJztcbmNsYXNzIE5vZGVBdXRoIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzLmFwaUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmFwaUtleSA9IG9wdHMuYXBpS2V5O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZlcnRleEF1dGhPcHRpb25zID0gYnVpbGRHb29nbGVBdXRoT3B0aW9ucyhvcHRzLmdvb2dsZUF1dGhPcHRpb25zKTtcbiAgICAgICAgdGhpcy5nb29nbGVBdXRoID0gbmV3IEdvb2dsZUF1dGgodmVydGV4QXV0aE9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBhZGRBdXRoSGVhZGVycyhoZWFkZXJzLCB1cmwpIHtcbiAgICAgICAgaWYgKHRoaXMuYXBpS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFwaUtleS5zdGFydHNXaXRoKCdhdXRoX3Rva2Vucy8nKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXBoZW1lcmFsIHRva2VucyBhcmUgb25seSBzdXBwb3J0ZWQgYnkgdGhlIGxpdmUgQVBJLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hZGRLZXlIZWFkZXIoaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkR29vZ2xlQXV0aEhlYWRlcnMoaGVhZGVycywgdXJsKTtcbiAgICB9XG4gICAgYWRkS2V5SGVhZGVyKGhlYWRlcnMpIHtcbiAgICAgICAgaWYgKGhlYWRlcnMuZ2V0KEdPT0dMRV9BUElfS0VZX0hFQURFUikgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hcGlLZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLCB0aGlzIG1ldGhvZCBpcyBvbmx5IGNhbGxlZFxuICAgICAgICAgICAgLy8gd2hlbiBhcGlLZXkgaXMgc2V0LlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcnlpbmcgdG8gc2V0IEFQSSBrZXkgaGVhZGVyIGJ1dCBhcGlLZXkgaXMgbm90IHNldCcpO1xuICAgICAgICB9XG4gICAgICAgIGhlYWRlcnMuYXBwZW5kKEdPT0dMRV9BUElfS0VZX0hFQURFUiwgdGhpcy5hcGlLZXkpO1xuICAgIH1cbiAgICBhc3luYyBhZGRHb29nbGVBdXRoSGVhZGVycyhoZWFkZXJzLCB1cmwpIHtcbiAgICAgICAgaWYgKHRoaXMuZ29vZ2xlQXV0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4sIGFkZEdvb2dsZUF1dGhIZWFkZXJzIHNob3VsZCBvbmx5IGJlXG4gICAgICAgICAgICAvLyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhcGlLZXkgc2V0IGFuZCBpbiB0aGVzZSBjYXNlcyBnb29nbGVBdXRoXG4gICAgICAgICAgICAvLyBpcyBzZXQuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyeWluZyB0byBzZXQgZ29vZ2xlLWF1dGggaGVhZGVycyBidXQgZ29vZ2xlQXV0aCBpcyB1bnNldCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF1dGhIZWFkZXJzID0gYXdhaXQgdGhpcy5nb29nbGVBdXRoLmdldFJlcXVlc3RIZWFkZXJzKHVybCk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGF1dGhIZWFkZXJzKSB7XG4gICAgICAgICAgICBpZiAoaGVhZGVycy5nZXQoa2V5KSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBidWlsZEdvb2dsZUF1dGhPcHRpb25zKGdvb2dsZUF1dGhPcHRpb25zKSB7XG4gICAgbGV0IGF1dGhPcHRpb25zO1xuICAgIGlmICghZ29vZ2xlQXV0aE9wdGlvbnMpIHtcbiAgICAgICAgYXV0aE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBzY29wZXM6IFtSRVFVSVJFRF9WRVJURVhfQUlfU0NPUEVdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXV0aE9wdGlvbnM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhdXRoT3B0aW9ucyA9IGdvb2dsZUF1dGhPcHRpb25zO1xuICAgICAgICBpZiAoIWF1dGhPcHRpb25zLnNjb3Blcykge1xuICAgICAgICAgICAgYXV0aE9wdGlvbnMuc2NvcGVzID0gW1JFUVVJUkVEX1ZFUlRFWF9BSV9TQ09QRV07XG4gICAgICAgICAgICByZXR1cm4gYXV0aE9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHR5cGVvZiBhdXRoT3B0aW9ucy5zY29wZXMgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICBhdXRoT3B0aW9ucy5zY29wZXMgIT09IFJFUVVJUkVEX1ZFUlRFWF9BSV9TQ09QRSkgfHxcbiAgICAgICAgICAgIChBcnJheS5pc0FycmF5KGF1dGhPcHRpb25zLnNjb3BlcykgJiZcbiAgICAgICAgICAgICAgICBhdXRoT3B0aW9ucy5zY29wZXMuaW5kZXhPZihSRVFVSVJFRF9WRVJURVhfQUlfU0NPUEUpIDwgMCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhdXRoIHNjb3Blcy4gU2NvcGVzIG11c3QgaW5jbHVkZTogJHtSRVFVSVJFRF9WRVJURVhfQUlfU0NPUEV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF1dGhPcHRpb25zO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgTm9kZURvd25sb2FkZXIge1xuICAgIGFzeW5jIGRvd25sb2FkKHBhcmFtcywgYXBpQ2xpZW50KSB7XG4gICAgICAgIGlmIChwYXJhbXMuZG93bmxvYWRQYXRoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGRvd25sb2FkRmlsZShwYXJhbXMsIGFwaUNsaWVudCk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UgaW5zdGFuY2VvZiBIdHRwUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3cml0ZXIgPSBjcmVhdGVXcml0ZVN0cmVhbShwYXJhbXMuZG93bmxvYWRQYXRoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBib2R5ID0gUmVhZGFibGUuZnJvbVdlYihyZXNwb25zZS5yZXNwb25zZUludGVybmFsLmJvZHkpO1xuICAgICAgICAgICAgICAgIGJvZHkucGlwZSh3cml0ZXIpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGZpbmlzaGVkKHdyaXRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB3cml0ZUZpbGUocGFyYW1zLmRvd25sb2FkUGF0aCwgcmVzcG9uc2UsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kaW5nOiAnYmFzZTY0JyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byB3cml0ZSBmaWxlIHRvICR7cGFyYW1zLmRvd25sb2FkUGF0aH06ICR7ZXJyb3J9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZG93bmxvYWRGaWxlKHBhcmFtcywgYXBpQ2xpZW50KSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgbmFtZSA9IHRGaWxlTmFtZShwYXJhbXMuZmlsZSk7XG4gICAgaWYgKG5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgYXBpQ2xpZW50LnJlcXVlc3Qoe1xuICAgICAgICAgICAgcGF0aDogYGZpbGVzLyR7bmFtZX06ZG93bmxvYWRgLFxuICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBxdWVyeVBhcmFtczoge1xuICAgICAgICAgICAgICAgICdhbHQnOiAnbWVkaWEnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNHZW5lcmF0ZWRWaWRlbyhwYXJhbXMuZmlsZSkpIHtcbiAgICAgICAgY29uc3QgdmlkZW9CeXRlcyA9IChfYyA9IHBhcmFtcy5maWxlLnZpZGVvKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudmlkZW9CeXRlcztcbiAgICAgICAgaWYgKHR5cGVvZiB2aWRlb0J5dGVzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHZpZGVvQnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBkb3dubG9hZCBnZW5lcmF0ZWQgdmlkZW8sIFVyaSBvciB2aWRlb0J5dGVzIG5vdCBmb3VuZC4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc1ZpZGVvKHBhcmFtcy5maWxlKSkge1xuICAgICAgICBjb25zdCB2aWRlb0J5dGVzID0gcGFyYW1zLmZpbGUudmlkZW9CeXRlcztcbiAgICAgICAgaWYgKHR5cGVvZiB2aWRlb0J5dGVzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHZpZGVvQnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBkb3dubG9hZCB2aWRlbywgVXJpIG9yIHZpZGVvQnl0ZXMgbm90IGZvdW5kLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGZpbGUgdHlwZScpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgTm9kZVdlYlNvY2tldEZhY3Rvcnkge1xuICAgIGNyZWF0ZSh1cmwsIGhlYWRlcnMsIGNhbGxiYWNrcykge1xuICAgICAgICByZXR1cm4gbmV3IE5vZGVXZWJTb2NrZXQodXJsLCBoZWFkZXJzLCBjYWxsYmFja3MpO1xuICAgIH1cbn1cbmNsYXNzIE5vZGVXZWJTb2NrZXQge1xuICAgIGNvbnN0cnVjdG9yKHVybCwgaGVhZGVycywgY2FsbGJhY2tzKSB7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcbiAgICB9XG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy53cyA9IG5ldyBOb2RlV3MuV2ViU29ja2V0KHRoaXMudXJsLCB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9KTtcbiAgICAgICAgdGhpcy53cy5vbm9wZW4gPSB0aGlzLmNhbGxiYWNrcy5vbm9wZW47XG4gICAgICAgIHRoaXMud3Mub25lcnJvciA9IHRoaXMuY2FsbGJhY2tzLm9uZXJyb3I7XG4gICAgICAgIHRoaXMud3Mub25jbG9zZSA9IHRoaXMuY2FsbGJhY2tzLm9uY2xvc2U7XG4gICAgICAgIHRoaXMud3Mub25tZXNzYWdlID0gdGhpcy5jYWxsYmFja3Mub25tZXNzYWdlO1xuICAgIH1cbiAgICBzZW5kKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRoaXMud3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXQgaXMgbm90IGNvbm5lY3RlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3Muc2VuZChtZXNzYWdlKTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLndzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBjb25uZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndzLmNsb3NlKCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vLyBDb2RlIGdlbmVyYXRlZCBieSB0aGUgR29vZ2xlIEdlbiBBSSBTREsgZ2VuZXJhdG9yIERPIE5PVCBFRElULlxuZnVuY3Rpb24gY2FuY2VsVHVuaW5nSm9iUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCwgX3Jvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNhbmNlbFR1bmluZ0pvYlBhcmFtZXRlcnNUb1ZlcnRleChmcm9tT2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY2FuY2VsVHVuaW5nSm9iUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCwgX3Jvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjYW5jZWxUdW5pbmdKb2JSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCwgX3Jvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVUdW5pbmdKb2JDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCwgX3Jvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZhbGlkYXRpb25EYXRhc2V0J10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2YWxpZGF0aW9uRGF0YXNldCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHVuZWRNb2RlbERpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndHVuZWRNb2RlbERpc3BsYXlOYW1lJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVR1bmVkTW9kZWxEaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tVHVuZWRNb2RlbERpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rlc2NyaXB0aW9uIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcG9jaENvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcG9jaENvdW50J10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRXBvY2hDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0dW5pbmdUYXNrJywgJ2h5cGVycGFyYW1ldGVycycsICdlcG9jaENvdW50J10sIGZyb21FcG9jaENvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxlYXJuaW5nUmF0ZU11bHRpcGxpZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdsZWFybmluZ1JhdGVNdWx0aXBsaWVyJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUxlYXJuaW5nUmF0ZU11bHRpcGxpZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0dW5pbmdUYXNrJywgJ2h5cGVycGFyYW1ldGVycycsICdsZWFybmluZ1JhdGVNdWx0aXBsaWVyJ10sIGZyb21MZWFybmluZ1JhdGVNdWx0aXBsaWVyKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5J10pICE9PVxuICAgICAgICB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBvcnRMYXN0Q2hlY2twb2ludE9ubHkgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJlVHVuZWRNb2RlbENoZWNrcG9pbnRJZCddKSAhPT1cbiAgICAgICAgdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncHJlVHVuZWRNb2RlbENoZWNrcG9pbnRJZCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhZGFwdGVyU2l6ZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYWRhcHRlclNpemUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJhdGNoU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmF0Y2hTaXplJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQmF0Y2hTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3R1bmluZ1Rhc2snLCAnaHlwZXJwYXJhbWV0ZXJzJywgJ2JhdGNoU2l6ZSddLCBmcm9tQmF0Y2hTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxlYXJuaW5nUmF0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGVhcm5pbmdSYXRlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGVhcm5pbmdSYXRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3R1bmluZ1Rhc2snLCAnaHlwZXJwYXJhbWV0ZXJzJywgJ2xlYXJuaW5nUmF0ZSddLCBmcm9tTGVhcm5pbmdSYXRlKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsYWJlbHMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmV0YSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmV0YSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVUdW5pbmdKb2JDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QsIHJvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGxldCBkaXNjcmltaW5hdG9yVmFsaWRhdGlvbkRhdGFzZXQgPSBnZXRWYWx1ZUJ5UGF0aChyb290T2JqZWN0LCBbXG4gICAgICAgICdjb25maWcnLFxuICAgICAgICAnbWV0aG9kJyxcbiAgICBdKTtcbiAgICBpZiAoZGlzY3JpbWluYXRvclZhbGlkYXRpb25EYXRhc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGlzY3JpbWluYXRvclZhbGlkYXRpb25EYXRhc2V0ID0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnO1xuICAgIH1cbiAgICBpZiAoZGlzY3JpbWluYXRvclZhbGlkYXRpb25EYXRhc2V0ID09PSAnU1VQRVJWSVNFRF9GSU5FX1RVTklORycpIHtcbiAgICAgICAgY29uc3QgZnJvbVZhbGlkYXRpb25EYXRhc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAgICAgJ3ZhbGlkYXRpb25EYXRhc2V0JyxcbiAgICAgICAgXSk7XG4gICAgICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVmFsaWRhdGlvbkRhdGFzZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N1cGVydmlzZWRUdW5pbmdTcGVjJ10sIHR1bmluZ1ZhbGlkYXRpb25EYXRhc2V0VG9WZXJ0ZXgoZnJvbVZhbGlkYXRpb25EYXRhc2V0KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZGlzY3JpbWluYXRvclZhbGlkYXRpb25EYXRhc2V0ID09PSAnUFJFRkVSRU5DRV9UVU5JTkcnKSB7XG4gICAgICAgIGNvbnN0IGZyb21WYWxpZGF0aW9uRGF0YXNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgICAgICd2YWxpZGF0aW9uRGF0YXNldCcsXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVZhbGlkYXRpb25EYXRhc2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwcmVmZXJlbmNlT3B0aW1pemF0aW9uU3BlYyddLCB0dW5pbmdWYWxpZGF0aW9uRGF0YXNldFRvVmVydGV4KGZyb21WYWxpZGF0aW9uRGF0YXNldCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0dW5lZE1vZGVsRGlzcGxheU5hbWUnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVHVuZWRNb2RlbERpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3R1bmVkTW9kZWxEaXNwbGF5TmFtZSddLCBmcm9tVHVuZWRNb2RlbERpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGxldCBkaXNjcmltaW5hdG9yRXBvY2hDb3VudCA9IGdldFZhbHVlQnlQYXRoKHJvb3RPYmplY3QsIFtcbiAgICAgICAgJ2NvbmZpZycsXG4gICAgICAgICdtZXRob2QnLFxuICAgIF0pO1xuICAgIGlmIChkaXNjcmltaW5hdG9yRXBvY2hDb3VudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRpc2NyaW1pbmF0b3JFcG9jaENvdW50ID0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnO1xuICAgIH1cbiAgICBpZiAoZGlzY3JpbWluYXRvckVwb2NoQ291bnQgPT09ICdTVVBFUlZJU0VEX0ZJTkVfVFVOSU5HJykge1xuICAgICAgICBjb25zdCBmcm9tRXBvY2hDb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXBvY2hDb3VudCddKTtcbiAgICAgICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FcG9jaENvdW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzdXBlcnZpc2VkVHVuaW5nU3BlYycsICdoeXBlclBhcmFtZXRlcnMnLCAnZXBvY2hDb3VudCddLCBmcm9tRXBvY2hDb3VudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZGlzY3JpbWluYXRvckVwb2NoQ291bnQgPT09ICdQUkVGRVJFTkNFX1RVTklORycpIHtcbiAgICAgICAgY29uc3QgZnJvbUVwb2NoQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vwb2NoQ291bnQnXSk7XG4gICAgICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRXBvY2hDb3VudCAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncHJlZmVyZW5jZU9wdGltaXphdGlvblNwZWMnLCAnaHlwZXJQYXJhbWV0ZXJzJywgJ2Vwb2NoQ291bnQnXSwgZnJvbUVwb2NoQ291bnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBkaXNjcmltaW5hdG9yTGVhcm5pbmdSYXRlTXVsdGlwbGllciA9IGdldFZhbHVlQnlQYXRoKHJvb3RPYmplY3QsIFtcbiAgICAgICAgJ2NvbmZpZycsXG4gICAgICAgICdtZXRob2QnLFxuICAgIF0pO1xuICAgIGlmIChkaXNjcmltaW5hdG9yTGVhcm5pbmdSYXRlTXVsdGlwbGllciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRpc2NyaW1pbmF0b3JMZWFybmluZ1JhdGVNdWx0aXBsaWVyID0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnO1xuICAgIH1cbiAgICBpZiAoZGlzY3JpbWluYXRvckxlYXJuaW5nUmF0ZU11bHRpcGxpZXIgPT09ICdTVVBFUlZJU0VEX0ZJTkVfVFVOSU5HJykge1xuICAgICAgICBjb25zdCBmcm9tTGVhcm5pbmdSYXRlTXVsdGlwbGllciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgICAgICdsZWFybmluZ1JhdGVNdWx0aXBsaWVyJyxcbiAgICAgICAgXSk7XG4gICAgICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGVhcm5pbmdSYXRlTXVsdGlwbGllciAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3VwZXJ2aXNlZFR1bmluZ1NwZWMnLCAnaHlwZXJQYXJhbWV0ZXJzJywgJ2xlYXJuaW5nUmF0ZU11bHRpcGxpZXInXSwgZnJvbUxlYXJuaW5nUmF0ZU11bHRpcGxpZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGRpc2NyaW1pbmF0b3JMZWFybmluZ1JhdGVNdWx0aXBsaWVyID09PSAnUFJFRkVSRU5DRV9UVU5JTkcnKSB7XG4gICAgICAgIGNvbnN0IGZyb21MZWFybmluZ1JhdGVNdWx0aXBsaWVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAgICAgJ2xlYXJuaW5nUmF0ZU11bHRpcGxpZXInLFxuICAgICAgICBdKTtcbiAgICAgICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MZWFybmluZ1JhdGVNdWx0aXBsaWVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgW1xuICAgICAgICAgICAgICAgICdwcmVmZXJlbmNlT3B0aW1pemF0aW9uU3BlYycsXG4gICAgICAgICAgICAgICAgJ2h5cGVyUGFyYW1ldGVycycsXG4gICAgICAgICAgICAgICAgJ2xlYXJuaW5nUmF0ZU11bHRpcGxpZXInLFxuICAgICAgICAgICAgXSwgZnJvbUxlYXJuaW5nUmF0ZU11bHRpcGxpZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBkaXNjcmltaW5hdG9yRXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5ID0gZ2V0VmFsdWVCeVBhdGgocm9vdE9iamVjdCwgWydjb25maWcnLCAnbWV0aG9kJ10pO1xuICAgIGlmIChkaXNjcmltaW5hdG9yRXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGlzY3JpbWluYXRvckV4cG9ydExhc3RDaGVja3BvaW50T25seSA9ICdTVVBFUlZJU0VEX0ZJTkVfVFVOSU5HJztcbiAgICB9XG4gICAgaWYgKGRpc2NyaW1pbmF0b3JFeHBvcnRMYXN0Q2hlY2twb2ludE9ubHkgPT09ICdTVVBFUlZJU0VEX0ZJTkVfVFVOSU5HJykge1xuICAgICAgICBjb25zdCBmcm9tRXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAgICAgJ2V4cG9ydExhc3RDaGVja3BvaW50T25seScsXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUV4cG9ydExhc3RDaGVja3BvaW50T25seSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3VwZXJ2aXNlZFR1bmluZ1NwZWMnLCAnZXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5J10sIGZyb21FeHBvcnRMYXN0Q2hlY2twb2ludE9ubHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGRpc2NyaW1pbmF0b3JFeHBvcnRMYXN0Q2hlY2twb2ludE9ubHkgPT09ICdQUkVGRVJFTkNFX1RVTklORycpIHtcbiAgICAgICAgY29uc3QgZnJvbUV4cG9ydExhc3RDaGVja3BvaW50T25seSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgICAgICdleHBvcnRMYXN0Q2hlY2twb2ludE9ubHknLFxuICAgICAgICBdKTtcbiAgICAgICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FeHBvcnRMYXN0Q2hlY2twb2ludE9ubHkgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3ByZWZlcmVuY2VPcHRpbWl6YXRpb25TcGVjJywgJ2V4cG9ydExhc3RDaGVja3BvaW50T25seSddLCBmcm9tRXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgZGlzY3JpbWluYXRvckFkYXB0ZXJTaXplID0gZ2V0VmFsdWVCeVBhdGgocm9vdE9iamVjdCwgW1xuICAgICAgICAnY29uZmlnJyxcbiAgICAgICAgJ21ldGhvZCcsXG4gICAgXSk7XG4gICAgaWYgKGRpc2NyaW1pbmF0b3JBZGFwdGVyU2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRpc2NyaW1pbmF0b3JBZGFwdGVyU2l6ZSA9ICdTVVBFUlZJU0VEX0ZJTkVfVFVOSU5HJztcbiAgICB9XG4gICAgaWYgKGRpc2NyaW1pbmF0b3JBZGFwdGVyU2l6ZSA9PT0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnKSB7XG4gICAgICAgIGNvbnN0IGZyb21BZGFwdGVyU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYWRhcHRlclNpemUnXSk7XG4gICAgICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQWRhcHRlclNpemUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N1cGVydmlzZWRUdW5pbmdTcGVjJywgJ2h5cGVyUGFyYW1ldGVycycsICdhZGFwdGVyU2l6ZSddLCBmcm9tQWRhcHRlclNpemUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGRpc2NyaW1pbmF0b3JBZGFwdGVyU2l6ZSA9PT0gJ1BSRUZFUkVOQ0VfVFVOSU5HJykge1xuICAgICAgICBjb25zdCBmcm9tQWRhcHRlclNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FkYXB0ZXJTaXplJ10pO1xuICAgICAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUFkYXB0ZXJTaXplICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwcmVmZXJlbmNlT3B0aW1pemF0aW9uU3BlYycsICdoeXBlclBhcmFtZXRlcnMnLCAnYWRhcHRlclNpemUnXSwgZnJvbUFkYXB0ZXJTaXplKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiYXRjaFNpemUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhdGNoU2l6ZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xlYXJuaW5nUmF0ZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbGVhcm5pbmdSYXRlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhYmVscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGFiZWxzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2xhYmVscyddLCBmcm9tTGFiZWxzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJldGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JldGEnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21CZXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3ByZWZlcmVuY2VPcHRpbWl6YXRpb25TcGVjJywgJ2h5cGVyUGFyYW1ldGVycycsICdiZXRhJ10sIGZyb21CZXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlVHVuaW5nSm9iUGFyYW1ldGVyc1ByaXZhdGVUb01sZGV2KGZyb21PYmplY3QsIHJvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21CYXNlTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Jhc2VNb2RlbCddKTtcbiAgICBpZiAoZnJvbUJhc2VNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Jhc2VNb2RlbCddLCBmcm9tQmFzZU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByZVR1bmVkTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVUdW5lZE1vZGVsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByZVR1bmVkTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcmVUdW5lZE1vZGVsJ10sIGZyb21QcmVUdW5lZE1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRyYWluaW5nRGF0YXNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RyYWluaW5nRGF0YXNldCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UcmFpbmluZ0RhdGFzZXQgIT0gbnVsbCkge1xuICAgICAgICB0dW5pbmdEYXRhc2V0VG9NbGRldihmcm9tVHJhaW5pbmdEYXRhc2V0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgY3JlYXRlVHVuaW5nSm9iQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVR1bmluZ0pvYlBhcmFtZXRlcnNQcml2YXRlVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUJhc2VNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmFzZU1vZGVsJ10pO1xuICAgIGlmIChmcm9tQmFzZU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmFzZU1vZGVsJ10sIGZyb21CYXNlTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJlVHVuZWRNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZVR1bmVkTW9kZWwnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlVHVuZWRNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZVR1bmVkTW9kZWwnXSwgZnJvbVByZVR1bmVkTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHJhaW5pbmdEYXRhc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndHJhaW5pbmdEYXRhc2V0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRyYWluaW5nRGF0YXNldCAhPSBudWxsKSB7XG4gICAgICAgIHR1bmluZ0RhdGFzZXRUb1ZlcnRleChmcm9tVHJhaW5pbmdEYXRhc2V0LCB0b09iamVjdCwgcm9vdE9iamVjdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGNyZWF0ZVR1bmluZ0pvYkNvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0LCByb290T2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0VHVuaW5nSm9iUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCwgX3Jvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdldFR1bmluZ0pvYlBhcmFtZXRlcnNUb1ZlcnRleChmcm9tT2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdFR1bmluZ0pvYnNDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCwgX3Jvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVNpemUnXSwgZnJvbVBhZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVRva2VuJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlVG9rZW4nXSwgZnJvbVBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWx0ZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbHRlciddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAnZmlsdGVyJ10sIGZyb21GaWx0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0VHVuaW5nSm9ic0NvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCwgX3Jvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVNpemUnXSwgZnJvbVBhZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVRva2VuJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlVG9rZW4nXSwgZnJvbVBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWx0ZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbHRlciddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAnZmlsdGVyJ10sIGZyb21GaWx0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0VHVuaW5nSm9ic1BhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QsIHJvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGxpc3RUdW5pbmdKb2JzQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RUdW5pbmdKb2JzUGFyYW1ldGVyc1RvVmVydGV4KGZyb21PYmplY3QsIHJvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGxpc3RUdW5pbmdKb2JzQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0VHVuaW5nSm9ic1Jlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QsIHJvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmV4dFBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25leHRQYWdlVG9rZW4nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTmV4dFBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25leHRQYWdlVG9rZW4nXSwgZnJvbU5leHRQYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHVuaW5nSm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHVuZWRNb2RlbHMnXSk7XG4gICAgaWYgKGZyb21UdW5pbmdKb2JzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21UdW5pbmdKb2JzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR1bmluZ0pvYkZyb21NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1bmluZ0pvYnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdFR1bmluZ0pvYnNSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZXh0UGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmV4dFBhZ2VUb2tlbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21OZXh0UGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmV4dFBhZ2VUb2tlbiddLCBmcm9tTmV4dFBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdW5pbmdKb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0dW5pbmdKb2JzJ10pO1xuICAgIGlmIChmcm9tVHVuaW5nSm9icyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tVHVuaW5nSm9icztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0dW5pbmdKb2JGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVuaW5nSm9icyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0dW5lZE1vZGVsRnJvbU1sZGV2KGZyb21PYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsJ10sIGZyb21Nb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRwb2ludCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbUVuZHBvaW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kcG9pbnQnXSwgZnJvbUVuZHBvaW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdHVuaW5nRGF0YXNldFRvTWxkZXYoZnJvbU9iamVjdCwgX3Jvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2NzVXJpIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZlcnRleERhdGFzZXRSZXNvdXJjZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndmVydGV4RGF0YXNldFJlc291cmNlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGFtcGxlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhhbXBsZXMnXSk7XG4gICAgaWYgKGZyb21FeGFtcGxlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRXhhbXBsZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4YW1wbGVzJywgJ2V4YW1wbGVzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHR1bmluZ0RhdGFzZXRUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QsIHJvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGxldCBkaXNjcmltaW5hdG9yR2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgocm9vdE9iamVjdCwgW1xuICAgICAgICAnY29uZmlnJyxcbiAgICAgICAgJ21ldGhvZCcsXG4gICAgXSk7XG4gICAgaWYgKGRpc2NyaW1pbmF0b3JHY3NVcmkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkaXNjcmltaW5hdG9yR2NzVXJpID0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnO1xuICAgIH1cbiAgICBpZiAoZGlzY3JpbWluYXRvckdjc1VyaSA9PT0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnKSB7XG4gICAgICAgIGNvbnN0IGZyb21HY3NVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKTtcbiAgICAgICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21HY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N1cGVydmlzZWRUdW5pbmdTcGVjJywgJ3RyYWluaW5nRGF0YXNldFVyaSddLCBmcm9tR2NzVXJpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChkaXNjcmltaW5hdG9yR2NzVXJpID09PSAnUFJFRkVSRU5DRV9UVU5JTkcnKSB7XG4gICAgICAgIGNvbnN0IGZyb21HY3NVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKTtcbiAgICAgICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21HY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3ByZWZlcmVuY2VPcHRpbWl6YXRpb25TcGVjJywgJ3RyYWluaW5nRGF0YXNldFVyaSddLCBmcm9tR2NzVXJpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgZGlzY3JpbWluYXRvclZlcnRleERhdGFzZXRSZXNvdXJjZSA9IGdldFZhbHVlQnlQYXRoKHJvb3RPYmplY3QsIFtcbiAgICAgICAgJ2NvbmZpZycsXG4gICAgICAgICdtZXRob2QnLFxuICAgIF0pO1xuICAgIGlmIChkaXNjcmltaW5hdG9yVmVydGV4RGF0YXNldFJlc291cmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGlzY3JpbWluYXRvclZlcnRleERhdGFzZXRSZXNvdXJjZSA9ICdTVVBFUlZJU0VEX0ZJTkVfVFVOSU5HJztcbiAgICB9XG4gICAgaWYgKGRpc2NyaW1pbmF0b3JWZXJ0ZXhEYXRhc2V0UmVzb3VyY2UgPT09ICdTVVBFUlZJU0VEX0ZJTkVfVFVOSU5HJykge1xuICAgICAgICBjb25zdCBmcm9tVmVydGV4RGF0YXNldFJlc291cmNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAgICAgJ3ZlcnRleERhdGFzZXRSZXNvdXJjZScsXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVZlcnRleERhdGFzZXRSZXNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3VwZXJ2aXNlZFR1bmluZ1NwZWMnLCAndHJhaW5pbmdEYXRhc2V0VXJpJ10sIGZyb21WZXJ0ZXhEYXRhc2V0UmVzb3VyY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGRpc2NyaW1pbmF0b3JWZXJ0ZXhEYXRhc2V0UmVzb3VyY2UgPT09ICdQUkVGRVJFTkNFX1RVTklORycpIHtcbiAgICAgICAgY29uc3QgZnJvbVZlcnRleERhdGFzZXRSZXNvdXJjZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgICAgICd2ZXJ0ZXhEYXRhc2V0UmVzb3VyY2UnLFxuICAgICAgICBdKTtcbiAgICAgICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21WZXJ0ZXhEYXRhc2V0UmVzb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3ByZWZlcmVuY2VPcHRpbWl6YXRpb25TcGVjJywgJ3RyYWluaW5nRGF0YXNldFVyaSddLCBmcm9tVmVydGV4RGF0YXNldFJlc291cmNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleGFtcGxlcyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhhbXBsZXMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0dW5pbmdKb2JGcm9tTWxkZXYoZnJvbU9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhdGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXRlJ10pO1xuICAgIGlmIChmcm9tU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGF0ZSddLCB0VHVuaW5nSm9iU3RhdHVzKGZyb21TdGF0ZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ3JlYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY3JlYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbUNyZWF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjcmVhdGVUaW1lJ10sIGZyb21DcmVhdGVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXJ0VGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3R1bmluZ1Rhc2snLFxuICAgICAgICAnc3RhcnRUaW1lJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVN0YXJ0VGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXJ0VGltZSddLCBmcm9tU3RhcnRUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZFRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0dW5pbmdUYXNrJyxcbiAgICAgICAgJ2NvbXBsZXRlVGltZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbmRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kVGltZSddLCBmcm9tRW5kVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcGRhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cGRhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tVXBkYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSwgZnJvbVVwZGF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmFzZU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiYXNlTW9kZWwnXSk7XG4gICAgaWYgKGZyb21CYXNlTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiYXNlTW9kZWwnXSwgZnJvbUJhc2VNb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdW5lZE1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydfc2VsZiddKTtcbiAgICBpZiAoZnJvbVR1bmVkTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0dW5lZE1vZGVsJ10sIHR1bmVkTW9kZWxGcm9tTWxkZXYoZnJvbVR1bmVkTW9kZWwpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdHVuaW5nSm9iRnJvbVZlcnRleChmcm9tT2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhdGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXRlJ10pO1xuICAgIGlmIChmcm9tU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGF0ZSddLCB0VHVuaW5nSm9iU3RhdHVzKGZyb21TdGF0ZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ3JlYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY3JlYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbUNyZWF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjcmVhdGVUaW1lJ10sIGZyb21DcmVhdGVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXJ0VGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhcnRUaW1lJ10pO1xuICAgIGlmIChmcm9tU3RhcnRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRUaW1lJ10sIGZyb21TdGFydFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kVGltZSddKTtcbiAgICBpZiAoZnJvbUVuZFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRUaW1lJ10sIGZyb21FbmRUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVwZGF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21VcGRhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXBkYXRlVGltZSddLCBmcm9tVXBkYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZyb21FcnJvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CYXNlTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Jhc2VNb2RlbCddKTtcbiAgICBpZiAoZnJvbUJhc2VNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Jhc2VNb2RlbCddLCBmcm9tQmFzZU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR1bmVkTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R1bmVkTW9kZWwnXSk7XG4gICAgaWYgKGZyb21UdW5lZE1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVuZWRNb2RlbCddLCBmcm9tVHVuZWRNb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QcmVUdW5lZE1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlVHVuZWRNb2RlbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QcmVUdW5lZE1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJlVHVuZWRNb2RlbCddLCBmcm9tUHJlVHVuZWRNb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdXBlcnZpc2VkVHVuaW5nU3BlYyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N1cGVydmlzZWRUdW5pbmdTcGVjJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVN1cGVydmlzZWRUdW5pbmdTcGVjICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3VwZXJ2aXNlZFR1bmluZ1NwZWMnXSwgZnJvbVN1cGVydmlzZWRUdW5pbmdTcGVjKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByZWZlcmVuY2VPcHRpbWl6YXRpb25TcGVjID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlZmVyZW5jZU9wdGltaXphdGlvblNwZWMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlZmVyZW5jZU9wdGltaXphdGlvblNwZWMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcmVmZXJlbmNlT3B0aW1pemF0aW9uU3BlYyddLCBmcm9tUHJlZmVyZW5jZU9wdGltaXphdGlvblNwZWMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHVuaW5nRGF0YVN0YXRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndHVuaW5nRGF0YVN0YXRzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVR1bmluZ0RhdGFTdGF0cyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1bmluZ0RhdGFTdGF0cyddLCBmcm9tVHVuaW5nRGF0YVN0YXRzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuY3J5cHRpb25TcGVjID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW5jcnlwdGlvblNwZWMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRW5jcnlwdGlvblNwZWMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmNyeXB0aW9uU3BlYyddLCBmcm9tRW5jcnlwdGlvblNwZWMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFydG5lck1vZGVsVHVuaW5nU3BlYyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BhcnRuZXJNb2RlbFR1bmluZ1NwZWMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUGFydG5lck1vZGVsVHVuaW5nU3BlYyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcnRuZXJNb2RlbFR1bmluZ1NwZWMnXSwgZnJvbVBhcnRuZXJNb2RlbFR1bmluZ1NwZWMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ3VzdG9tQmFzZU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY3VzdG9tQmFzZU1vZGVsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUN1c3RvbUJhc2VNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2N1c3RvbUJhc2VNb2RlbCddLCBmcm9tQ3VzdG9tQmFzZU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4cGVyaW1lbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4cGVyaW1lbnQnXSk7XG4gICAgaWYgKGZyb21FeHBlcmltZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhwZXJpbWVudCddLCBmcm9tRXhwZXJpbWVudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYWJlbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhYmVscyddKTtcbiAgICBpZiAoZnJvbUxhYmVscyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhYmVscyddLCBmcm9tTGFiZWxzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dFVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0VXJpJ10pO1xuICAgIGlmIChmcm9tT3V0cHV0VXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnb3V0cHV0VXJpJ10sIGZyb21PdXRwdXRVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGlwZWxpbmVKb2IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BpcGVsaW5lSm9iJ10pO1xuICAgIGlmIChmcm9tUGlwZWxpbmVKb2IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwaXBlbGluZUpvYiddLCBmcm9tUGlwZWxpbmVKb2IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VydmljZUFjY291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZXJ2aWNlQWNjb3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZXJ2aWNlQWNjb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NlcnZpY2VBY2NvdW50J10sIGZyb21TZXJ2aWNlQWNjb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0dW5lZE1vZGVsRGlzcGxheU5hbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVHVuZWRNb2RlbERpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVuZWRNb2RlbERpc3BsYXlOYW1lJ10sIGZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmVvVHVuaW5nU3BlYyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Zlb1R1bmluZ1NwZWMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmVvVHVuaW5nU3BlYyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Zlb1R1bmluZ1NwZWMnXSwgZnJvbVZlb1R1bmluZ1NwZWMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0dW5pbmdPcGVyYXRpb25Gcm9tTWxkZXYoZnJvbU9iamVjdCwgX3Jvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWV0YWRhdGEnXSwgZnJvbU1ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvbmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RvbmUnXSk7XG4gICAgaWYgKGZyb21Eb25lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9uZSddLCBmcm9tRG9uZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZyb21FcnJvcik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHR1bmluZ1ZhbGlkYXRpb25EYXRhc2V0VG9WZXJ0ZXgoZnJvbU9iamVjdCwgX3Jvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21HY3NVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKTtcbiAgICBpZiAoZnJvbUdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZhbGlkYXRpb25EYXRhc2V0VXJpJ10sIGZyb21HY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmVydGV4RGF0YXNldFJlc291cmNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmVydGV4RGF0YXNldFJlc291cmNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZlcnRleERhdGFzZXRSZXNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZhbGlkYXRpb25EYXRhc2V0VXJpJ10sIGZyb21WZXJ0ZXhEYXRhc2V0UmVzb3VyY2UpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNsYXNzIFR1bmluZ3MgZXh0ZW5kcyBCYXNlTW9kdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcGlDbGllbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0cyB0dW5pbmcgam9icy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgbGlzdCByZXF1ZXN0LlxuICAgICAgICAgKiBAcmV0dXJuIC0gQSBwYWdlciBvZiB0dW5pbmcgam9icy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgdHVuaW5nSm9icyA9IGF3YWl0IGFpLnR1bmluZ3MubGlzdCh7Y29uZmlnOiB7J3BhZ2VTaXplJzogMn19KTtcbiAgICAgICAgICogZm9yIGF3YWl0IChjb25zdCB0dW5pbmdKb2Igb2YgdHVuaW5nSm9icykge1xuICAgICAgICAgKiAgIGNvbnNvbGUubG9nKHR1bmluZ0pvYik7XG4gICAgICAgICAqIH1cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxpc3QgPSBhc3luYyAocGFyYW1zID0ge30pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGFnZXIoUGFnZWRJdGVtLlBBR0VEX0lURU1fVFVOSU5HX0pPQlMsICh4KSA9PiB0aGlzLmxpc3RJbnRlcm5hbCh4KSwgYXdhaXQgdGhpcy5saXN0SW50ZXJuYWwocGFyYW1zKSwgcGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgYSBUdW5pbmdKb2IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBuYW1lIC0gVGhlIHJlc291cmNlIG5hbWUgb2YgdGhlIHR1bmluZyBqb2IuXG4gICAgICAgICAqIEByZXR1cm4gLSBBIFR1bmluZ0pvYiBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleHBlcmltZW50YWwgLSBUaGUgU0RLJ3MgdHVuaW5nIGltcGxlbWVudGF0aW9uIGlzIGV4cGVyaW1lbnRhbCwgYW5kIG1heVxuICAgICAgICAgKiBjaGFuZ2UgaW4gZnV0dXJlIHZlcnNpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXQgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRJbnRlcm5hbChwYXJhbXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHN1cGVydmlzZWQgZmluZS10dW5pbmcgam9iLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSB0dW5pbmcgam9iLlxuICAgICAgICAgKiBAcmV0dXJuIC0gQSBUdW5pbmdKb2Igb3BlcmF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhwZXJpbWVudGFsIC0gVGhlIFNESydzIHR1bmluZyBpbXBsZW1lbnRhdGlvbiBpcyBleHBlcmltZW50YWwsIGFuZCBtYXlcbiAgICAgICAgICogY2hhbmdlIGluIGZ1dHVyZSB2ZXJzaW9ucy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHVuZSA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmJhc2VNb2RlbC5zdGFydHNXaXRoKCdwcm9qZWN0cy8nKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmVUdW5lZE1vZGVsID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHVuZWRNb2RlbE5hbWU6IHBhcmFtcy5iYXNlTW9kZWwsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmICgoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJlVHVuZWRNb2RlbENoZWNrcG9pbnRJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlVHVuZWRNb2RlbC5jaGVja3BvaW50SWQgPSBwYXJhbXMuY29uZmlnLnByZVR1bmVkTW9kZWxDaGVja3BvaW50SWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zUHJpdmF0ZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zKSwgeyBwcmVUdW5lZE1vZGVsOiBwcmVUdW5lZE1vZGVsIH0pO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXNQcml2YXRlLmJhc2VNb2RlbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHVuZUludGVybmFsKHBhcmFtc1ByaXZhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zUHJpdmF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnR1bmVJbnRlcm5hbChwYXJhbXNQcml2YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXNQcml2YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvcGVyYXRpb24gPSBhd2FpdCB0aGlzLnR1bmVNbGRldkludGVybmFsKHBhcmFtc1ByaXZhdGUpO1xuICAgICAgICAgICAgICAgIGxldCB0dW5lZE1vZGVsTmFtZSA9ICcnO1xuICAgICAgICAgICAgICAgIGlmIChvcGVyYXRpb25bJ21ldGFkYXRhJ10gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25bJ21ldGFkYXRhJ11bJ3R1bmVkTW9kZWwnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHR1bmVkTW9kZWxOYW1lID0gb3BlcmF0aW9uWydtZXRhZGF0YSddWyd0dW5lZE1vZGVsJ107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvblsnbmFtZSddICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uWyduYW1lJ10uaW5jbHVkZXMoJy9vcGVyYXRpb25zLycpKSB7XG4gICAgICAgICAgICAgICAgICAgIHR1bmVkTW9kZWxOYW1lID0gb3BlcmF0aW9uWyduYW1lJ10uc3BsaXQoJy9vcGVyYXRpb25zLycpWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB0dW5pbmdKb2IgPSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHR1bmVkTW9kZWxOYW1lLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogSm9iU3RhdGUuSk9CX1NUQVRFX1FVRVVFRCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiB0dW5pbmdKb2I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIGdldEludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXRUdW5pbmdKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gdHVuaW5nSm9iRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXRUdW5pbmdKb2JQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSB0dW5pbmdKb2JGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbGlzdEludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBsaXN0VHVuaW5nSm9ic1BhcmFtZXRlcnNUb1ZlcnRleChwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgndHVuaW5nSm9icycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gbGlzdFR1bmluZ0pvYnNSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBMaXN0VHVuaW5nSm9ic1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBsaXN0VHVuaW5nSm9ic1BhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd0dW5lZE1vZGVscycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gbGlzdFR1bmluZ0pvYnNSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IExpc3RUdW5pbmdKb2JzUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbmNlbHMgYSB0dW5pbmcgam9iLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgY2FuY2VsIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgZW1wdHkgcmVzcG9uc2UgcmV0dXJuZWQgYnkgdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBhd2FpdCBhaS50dW5pbmdzLmNhbmNlbCh7bmFtZTogJy4uLid9KTsgLy8gVGhlIHNlcnZlci1nZW5lcmF0ZWQgcmVzb3VyY2UgbmFtZS5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBjYW5jZWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNhbmNlbFR1bmluZ0pvYlBhcmFtZXRlcnNUb1ZlcnRleChwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9OmNhbmNlbCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGNhbmNlbFR1bmluZ0pvYlJlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IENhbmNlbFR1bmluZ0pvYlJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjYW5jZWxUdW5pbmdKb2JQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9OmNhbmNlbCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGNhbmNlbFR1bmluZ0pvYlJlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgQ2FuY2VsVHVuaW5nSm9iUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHR1bmVJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNyZWF0ZVR1bmluZ0pvYlBhcmFtZXRlcnNQcml2YXRlVG9WZXJ0ZXgocGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgndHVuaW5nSm9icycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IHR1bmluZ0pvYkZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBWZXJ0ZXggQUkuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdHVuZU1sZGV2SW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNyZWF0ZVR1bmluZ0pvYlBhcmFtZXRlcnNQcml2YXRlVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgndHVuZWRNb2RlbHMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSB0dW5pbmdPcGVyYXRpb25Gcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IE1BWF9DSFVOS19TSVpFID0gMTAyNCAqIDEwMjQgKiA4OyAvLyBieXRlc1xuY29uc3QgTUFYX1JFVFJZX0NPVU5UID0gMztcbmNvbnN0IElOSVRJQUxfUkVUUllfREVMQVlfTVMgPSAxMDAwO1xuY29uc3QgREVMQVlfTVVMVElQTElFUiA9IDI7XG5jb25zdCBYX0dPT0dfVVBMT0FEX1NUQVRVU19IRUFERVJfRklFTEQgPSAneC1nb29nLXVwbG9hZC1zdGF0dXMnO1xuYXN5bmMgZnVuY3Rpb24gdXBsb2FkQmxvYihmaWxlLCB1cGxvYWRVcmwsIGFwaUNsaWVudCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHVwbG9hZEJsb2JJbnRlcm5hbChmaWxlLCB1cGxvYWRVcmwsIGFwaUNsaWVudCk7XG4gICAgY29uc3QgcmVzcG9uc2VKc29uID0gKGF3YWl0IChyZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuanNvbigpKSk7XG4gICAgaWYgKCgoX2EgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuaGVhZGVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW1hfR09PR19VUExPQURfU1RBVFVTX0hFQURFUl9GSUVMRF0pICE9PSAnZmluYWwnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHVwbG9hZCBmaWxlOiBVcGxvYWQgc3RhdHVzIGlzIG5vdCBmaW5hbGl6ZWQuJyk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZUpzb25bJ2ZpbGUnXTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHVwbG9hZEJsb2JUb0ZpbGVTZWFyY2hTdG9yZShmaWxlLCB1cGxvYWRVcmwsIGFwaUNsaWVudCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHVwbG9hZEJsb2JJbnRlcm5hbChmaWxlLCB1cGxvYWRVcmwsIGFwaUNsaWVudCk7XG4gICAgY29uc3QgcmVzcG9uc2VKc29uID0gKGF3YWl0IChyZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuanNvbigpKSk7XG4gICAgaWYgKCgoX2EgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuaGVhZGVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW1hfR09PR19VUExPQURfU1RBVFVTX0hFQURFUl9GSUVMRF0pICE9PSAnZmluYWwnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHVwbG9hZCBmaWxlOiBVcGxvYWQgc3RhdHVzIGlzIG5vdCBmaW5hbGl6ZWQuJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3AgPSB1cGxvYWRUb0ZpbGVTZWFyY2hTdG9yZU9wZXJhdGlvbkZyb21NbGRldihyZXNwb25zZUpzb24pO1xuICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBVcGxvYWRUb0ZpbGVTZWFyY2hTdG9yZU9wZXJhdGlvbigpO1xuICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICByZXR1cm4gdHlwZWRSZXNwO1xufVxuYXN5bmMgZnVuY3Rpb24gdXBsb2FkQmxvYkludGVybmFsKGZpbGUsIHVwbG9hZFVybCwgYXBpQ2xpZW50KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBsZXQgZmlsZVNpemUgPSAwO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGxldCByZXNwb25zZSA9IG5ldyBIdHRwUmVzcG9uc2UobmV3IFJlc3BvbnNlKCkpO1xuICAgIGxldCB1cGxvYWRDb21tYW5kID0gJ3VwbG9hZCc7XG4gICAgZmlsZVNpemUgPSBmaWxlLnNpemU7XG4gICAgd2hpbGUgKG9mZnNldCA8IGZpbGVTaXplKSB7XG4gICAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IE1hdGgubWluKE1BWF9DSFVOS19TSVpFLCBmaWxlU2l6ZSAtIG9mZnNldCk7XG4gICAgICAgIGNvbnN0IGNodW5rID0gZmlsZS5zbGljZShvZmZzZXQsIG9mZnNldCArIGNodW5rU2l6ZSk7XG4gICAgICAgIGlmIChvZmZzZXQgKyBjaHVua1NpemUgPj0gZmlsZVNpemUpIHtcbiAgICAgICAgICAgIHVwbG9hZENvbW1hbmQgKz0gJywgZmluYWxpemUnO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXRyeUNvdW50ID0gMDtcbiAgICAgICAgbGV0IGN1cnJlbnREZWxheU1zID0gSU5JVElBTF9SRVRSWV9ERUxBWV9NUztcbiAgICAgICAgd2hpbGUgKHJldHJ5Q291bnQgPCBNQVhfUkVUUllfQ09VTlQpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6ICcnLFxuICAgICAgICAgICAgICAgIGJvZHk6IGNodW5rLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICBhcGlWZXJzaW9uOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgYmFzZVVybDogdXBsb2FkVXJsLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnWC1Hb29nLVVwbG9hZC1Db21tYW5kJzogdXBsb2FkQ29tbWFuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdYLUdvb2ctVXBsb2FkLU9mZnNldCc6IFN0cmluZyhvZmZzZXQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtTGVuZ3RoJzogU3RyaW5nKGNodW5rU2l6ZSksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKChfYSA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbWF9HT09HX1VQTE9BRF9TVEFUVVNfSEVBREVSX0ZJRUxEXSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0cnlDb3VudCsrO1xuICAgICAgICAgICAgYXdhaXQgc2xlZXAoY3VycmVudERlbGF5TXMpO1xuICAgICAgICAgICAgY3VycmVudERlbGF5TXMgPSBjdXJyZW50RGVsYXlNcyAqIERFTEFZX01VTFRJUExJRVI7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ICs9IGNodW5rU2l6ZTtcbiAgICAgICAgLy8gVGhlIGB4LWdvb2ctdXBsb2FkLXN0YXR1c2AgaGVhZGVyIGZpZWxkIGNhbiBiZSBgYWN0aXZlYCwgYGZpbmFsYCBhbmRcbiAgICAgICAgLy9gY2FuY2VsbGVkYCBpbiByZXNwb3NuZS5cbiAgICAgICAgaWYgKCgoX2IgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuaGVhZGVycykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW1hfR09PR19VUExPQURfU1RBVFVTX0hFQURFUl9GSUVMRF0pICE9PSAnYWN0aXZlJykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyhiLzQwMTM5MTQzMCkgSW52ZXN0aWdhdGUgd2h5IHRoZSB1cGxvYWQgc3RhdHVzIGlzIG5vdCBmaW5hbGl6ZWRcbiAgICAgICAgLy8gZXZlbiB0aG91Z2ggYWxsIGNvbnRlbnQgaGFzIGJlZW4gdXBsb2FkZWQuXG4gICAgICAgIGlmIChmaWxlU2l6ZSA8PSBvZmZzZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQWxsIGNvbnRlbnQgaGFzIGJlZW4gdXBsb2FkZWQsIGJ1dCB0aGUgdXBsb2FkIHN0YXR1cyBpcyBub3QgZmluYWxpemVkLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEJsb2JTdGF0KGZpbGUpIHtcbiAgICBjb25zdCBmaWxlU3RhdCA9IHsgc2l6ZTogZmlsZS5zaXplLCB0eXBlOiBmaWxlLnR5cGUgfTtcbiAgICByZXR1cm4gZmlsZVN0YXQ7XG59XG5mdW5jdGlvbiBzbGVlcChtcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZVByb21pc2UpID0+IHNldFRpbWVvdXQocmVzb2x2ZVByb21pc2UsIG1zKSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNsYXNzIE5vZGVVcGxvYWRlciB7XG4gICAgYXN5bmMgc3RhdChmaWxlKSB7XG4gICAgICAgIGNvbnN0IGZpbGVTdGF0ID0geyBzaXplOiAwLCB0eXBlOiB1bmRlZmluZWQgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWxlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxTdGF0ID0gYXdhaXQgZnMuc3RhdChmaWxlKTtcbiAgICAgICAgICAgIGZpbGVTdGF0LnNpemUgPSBvcmlnaW5hbFN0YXQuc2l6ZTtcbiAgICAgICAgICAgIGZpbGVTdGF0LnR5cGUgPSB0aGlzLmluZmVyTWltZVR5cGUoZmlsZSk7XG4gICAgICAgICAgICByZXR1cm4gZmlsZVN0YXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgZ2V0QmxvYlN0YXQoZmlsZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdXBsb2FkKGZpbGUsIHVwbG9hZFVybCwgYXBpQ2xpZW50KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnVwbG9hZEZpbGVGcm9tUGF0aChmaWxlLCB1cGxvYWRVcmwsIGFwaUNsaWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdXBsb2FkQmxvYihmaWxlLCB1cGxvYWRVcmwsIGFwaUNsaWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdXBsb2FkVG9GaWxlU2VhcmNoU3RvcmUoZmlsZSwgdXBsb2FkVXJsLCBhcGlDbGllbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWxlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudXBsb2FkRmlsZVRvRmlsZVNlYXJjaFN0b3JlRnJvbVBhdGgoZmlsZSwgdXBsb2FkVXJsLCBhcGlDbGllbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHVwbG9hZEJsb2JUb0ZpbGVTZWFyY2hTdG9yZShmaWxlLCB1cGxvYWRVcmwsIGFwaUNsaWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5mZXJzIHRoZSBNSU1FIHR5cGUgb2YgYSBmaWxlIGJhc2VkIG9uIGl0cyBleHRlbnNpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlsZVBhdGggVGhlIHBhdGggdG8gdGhlIGZpbGUuXG4gICAgICogQHJldHVybnMgVGhlIE1JTUUgdHlwZSBvZiB0aGUgZmlsZSwgb3IgdW5kZWZpbmVkIGlmIGl0IGNhbm5vdCBiZSBpbmZlcnJlZC5cbiAgICAgKi9cbiAgICBpbmZlck1pbWVUeXBlKGZpbGVQYXRoKSB7XG4gICAgICAgIC8vIEdldCB0aGUgZmlsZSBleHRlbnNpb24uXG4gICAgICAgIGNvbnN0IGZpbGVFeHRlbnNpb24gPSBmaWxlUGF0aC5zbGljZShmaWxlUGF0aC5sYXN0SW5kZXhPZignLicpICsgMSk7XG4gICAgICAgIC8vIENyZWF0ZSBhIG1hcCBvZiBmaWxlIGV4dGVuc2lvbnMgdG8gTUlNRSB0eXBlcy5cbiAgICAgICAgY29uc3QgbWltZVR5cGVzID0ge1xuICAgICAgICAgICAgJ2FhYyc6ICdhdWRpby9hYWMnLFxuICAgICAgICAgICAgJ2Fidyc6ICdhcHBsaWNhdGlvbi94LWFiaXdvcmQnLFxuICAgICAgICAgICAgJ2FyYyc6ICdhcHBsaWNhdGlvbi94LWZyZWVhcmMnLFxuICAgICAgICAgICAgJ2F2aSc6ICd2aWRlby94LW1zdmlkZW8nLFxuICAgICAgICAgICAgJ2F6dyc6ICdhcHBsaWNhdGlvbi92bmQuYW1hem9uLmVib29rJyxcbiAgICAgICAgICAgICdiaW4nOiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyxcbiAgICAgICAgICAgICdibXAnOiAnaW1hZ2UvYm1wJyxcbiAgICAgICAgICAgICdieic6ICdhcHBsaWNhdGlvbi94LWJ6aXAnLFxuICAgICAgICAgICAgJ2J6Mic6ICdhcHBsaWNhdGlvbi94LWJ6aXAyJyxcbiAgICAgICAgICAgICdjc2gnOiAnYXBwbGljYXRpb24veC1jc2gnLFxuICAgICAgICAgICAgJ2Nzcyc6ICd0ZXh0L2NzcycsXG4gICAgICAgICAgICAnY3N2JzogJ3RleHQvY3N2JyxcbiAgICAgICAgICAgICdkb2MnOiAnYXBwbGljYXRpb24vbXN3b3JkJyxcbiAgICAgICAgICAgICdkb2N4JzogJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLmRvY3VtZW50JyxcbiAgICAgICAgICAgICdlb3QnOiAnYXBwbGljYXRpb24vdm5kLm1zLWZvbnRvYmplY3QnLFxuICAgICAgICAgICAgJ2VwdWInOiAnYXBwbGljYXRpb24vZXB1Yit6aXAnLFxuICAgICAgICAgICAgJ2d6JzogJ2FwcGxpY2F0aW9uL2d6aXAnLFxuICAgICAgICAgICAgJ2dpZic6ICdpbWFnZS9naWYnLFxuICAgICAgICAgICAgJ2h0bSc6ICd0ZXh0L2h0bWwnLFxuICAgICAgICAgICAgJ2h0bWwnOiAndGV4dC9odG1sJyxcbiAgICAgICAgICAgICdpY28nOiAnaW1hZ2Uvdm5kLm1pY3Jvc29mdC5pY29uJyxcbiAgICAgICAgICAgICdpY3MnOiAndGV4dC9jYWxlbmRhcicsXG4gICAgICAgICAgICAnamFyJzogJ2FwcGxpY2F0aW9uL2phdmEtYXJjaGl2ZScsXG4gICAgICAgICAgICAnanBlZyc6ICdpbWFnZS9qcGVnJyxcbiAgICAgICAgICAgICdqcGcnOiAnaW1hZ2UvanBlZycsXG4gICAgICAgICAgICAnanMnOiAndGV4dC9qYXZhc2NyaXB0JyxcbiAgICAgICAgICAgICdqc29uJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgJ2pzb25sZCc6ICdhcHBsaWNhdGlvbi9sZCtqc29uJyxcbiAgICAgICAgICAgICdrbWwnOiAnYXBwbGljYXRpb24vdm5kLmdvb2dsZS1lYXJ0aC5rbWwreG1sJyxcbiAgICAgICAgICAgICdrbXonOiAnYXBwbGljYXRpb24vdm5kLmdvb2dsZS1lYXJ0aC5rbXoreG1sJyxcbiAgICAgICAgICAgICdtanMnOiAndGV4dC9qYXZhc2NyaXB0JyxcbiAgICAgICAgICAgICdtcDMnOiAnYXVkaW8vbXBlZycsXG4gICAgICAgICAgICAnbXA0JzogJ3ZpZGVvL21wNCcsXG4gICAgICAgICAgICAnbXBlZyc6ICd2aWRlby9tcGVnJyxcbiAgICAgICAgICAgICdtcGtnJzogJ2FwcGxpY2F0aW9uL3ZuZC5hcHBsZS5pbnN0YWxsZXIreG1sJyxcbiAgICAgICAgICAgICdvZHQnOiAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC50ZXh0JyxcbiAgICAgICAgICAgICdvZ2EnOiAnYXVkaW8vb2dnJyxcbiAgICAgICAgICAgICdvZ3YnOiAndmlkZW8vb2dnJyxcbiAgICAgICAgICAgICdvZ3gnOiAnYXBwbGljYXRpb24vb2dnJyxcbiAgICAgICAgICAgICdvcHVzJzogJ2F1ZGlvL29wdXMnLFxuICAgICAgICAgICAgJ290Zic6ICdmb250L290ZicsXG4gICAgICAgICAgICAncG5nJzogJ2ltYWdlL3BuZycsXG4gICAgICAgICAgICAncGRmJzogJ2FwcGxpY2F0aW9uL3BkZicsXG4gICAgICAgICAgICAncGhwJzogJ2FwcGxpY2F0aW9uL3gtaHR0cGQtcGhwJyxcbiAgICAgICAgICAgICdwcHQnOiAnYXBwbGljYXRpb24vdm5kLm1zLXBvd2VycG9pbnQnLFxuICAgICAgICAgICAgJ3BwdHgnOiAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnByZXNlbnRhdGlvbm1sLnByZXNlbnRhdGlvbicsXG4gICAgICAgICAgICAncmFyJzogJ2FwcGxpY2F0aW9uL3ZuZC5yYXInLFxuICAgICAgICAgICAgJ3J0Zic6ICdhcHBsaWNhdGlvbi9ydGYnLFxuICAgICAgICAgICAgJ3NoJzogJ2FwcGxpY2F0aW9uL3gtc2gnLFxuICAgICAgICAgICAgJ3N2Zyc6ICdpbWFnZS9zdmcreG1sJyxcbiAgICAgICAgICAgICdzd2YnOiAnYXBwbGljYXRpb24veC1zaG9ja3dhdmUtZmxhc2gnLFxuICAgICAgICAgICAgJ3Rhcic6ICdhcHBsaWNhdGlvbi94LXRhcicsXG4gICAgICAgICAgICAndGlmJzogJ2ltYWdlL3RpZmYnLFxuICAgICAgICAgICAgJ3RpZmYnOiAnaW1hZ2UvdGlmZicsXG4gICAgICAgICAgICAndHMnOiAndmlkZW8vbXAydCcsXG4gICAgICAgICAgICAndHRmJzogJ2ZvbnQvdHRmJyxcbiAgICAgICAgICAgICd0eHQnOiAndGV4dC9wbGFpbicsXG4gICAgICAgICAgICAndnNkJzogJ2FwcGxpY2F0aW9uL3ZuZC52aXNpbycsXG4gICAgICAgICAgICAnd2F2JzogJ2F1ZGlvL3dhdicsXG4gICAgICAgICAgICAnd2ViYSc6ICdhdWRpby93ZWJtJyxcbiAgICAgICAgICAgICd3ZWJtJzogJ3ZpZGVvL3dlYm0nLFxuICAgICAgICAgICAgJ3dlYnAnOiAnaW1hZ2Uvd2VicCcsXG4gICAgICAgICAgICAnd29mZic6ICdmb250L3dvZmYnLFxuICAgICAgICAgICAgJ3dvZmYyJzogJ2ZvbnQvd29mZjInLFxuICAgICAgICAgICAgJ3hodG1sJzogJ2FwcGxpY2F0aW9uL3hodG1sK3htbCcsXG4gICAgICAgICAgICAneGxzJzogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbCcsXG4gICAgICAgICAgICAneGxzeCc6ICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC5zaGVldCcsXG4gICAgICAgICAgICAneG1sJzogJ2FwcGxpY2F0aW9uL3htbCcsXG4gICAgICAgICAgICAneHVsJzogJ2FwcGxpY2F0aW9uL3ZuZC5tb3ppbGxhLnh1bCt4bWwnLFxuICAgICAgICAgICAgJ3ppcCc6ICdhcHBsaWNhdGlvbi96aXAnLFxuICAgICAgICAgICAgJzNncCc6ICd2aWRlby8zZ3BwJyxcbiAgICAgICAgICAgICczZzInOiAndmlkZW8vM2dwcDInLFxuICAgICAgICAgICAgJzd6JzogJ2FwcGxpY2F0aW9uL3gtN3otY29tcHJlc3NlZCcsXG4gICAgICAgIH07XG4gICAgICAgIC8vIExvb2sgdXAgdGhlIE1JTUUgdHlwZSBiYXNlZCBvbiB0aGUgZmlsZSBleHRlbnNpb24uXG4gICAgICAgIGNvbnN0IG1pbWVUeXBlID0gbWltZVR5cGVzW2ZpbGVFeHRlbnNpb24udG9Mb3dlckNhc2UoKV07XG4gICAgICAgIC8vIFJldHVybiB0aGUgTUlNRSB0eXBlLlxuICAgICAgICByZXR1cm4gbWltZVR5cGU7XG4gICAgfVxuICAgIGFzeW5jIHVwbG9hZEZpbGVGcm9tUGF0aChmaWxlLCB1cGxvYWRVcmwsIGFwaUNsaWVudCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy51cGxvYWRGaWxlRnJvbVBhdGhJbnRlcm5hbChmaWxlLCB1cGxvYWRVcmwsIGFwaUNsaWVudCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlSnNvbiA9IChhd2FpdCAocmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLmpzb24oKSkpO1xuICAgICAgICBpZiAoKChfYSA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbWF9HT09HX1VQTE9BRF9TVEFUVVNfSEVBREVSX0ZJRUxEXSkgIT09ICdmaW5hbCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHVwbG9hZCBmaWxlOiBVcGxvYWQgc3RhdHVzIGlzIG5vdCBmaW5hbGl6ZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlSnNvblsnZmlsZSddO1xuICAgIH1cbiAgICBhc3luYyB1cGxvYWRGaWxlVG9GaWxlU2VhcmNoU3RvcmVGcm9tUGF0aChmaWxlLCB1cGxvYWRVcmwsIGFwaUNsaWVudCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy51cGxvYWRGaWxlRnJvbVBhdGhJbnRlcm5hbChmaWxlLCB1cGxvYWRVcmwsIGFwaUNsaWVudCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlSnNvbiA9IChhd2FpdCAocmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLmpzb24oKSkpO1xuICAgICAgICBpZiAoKChfYSA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbWF9HT09HX1VQTE9BRF9TVEFUVVNfSEVBREVSX0ZJRUxEXSkgIT09ICdmaW5hbCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHVwbG9hZCBmaWxlOiBVcGxvYWQgc3RhdHVzIGlzIG5vdCBmaW5hbGl6ZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcCA9IHVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlT3BlcmF0aW9uRnJvbU1sZGV2KHJlc3BvbnNlSnNvbik7XG4gICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBVcGxvYWRUb0ZpbGVTZWFyY2hTdG9yZU9wZXJhdGlvbigpO1xuICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgfVxuICAgIGFzeW5jIHVwbG9hZEZpbGVGcm9tUGF0aEludGVybmFsKGZpbGUsIHVwbG9hZFVybCwgYXBpQ2xpZW50KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCBmaWxlU2l6ZSA9IDA7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBuZXcgSHR0cFJlc3BvbnNlKG5ldyBSZXNwb25zZSgpKTtcbiAgICAgICAgbGV0IHVwbG9hZENvbW1hbmQgPSAndXBsb2FkJztcbiAgICAgICAgbGV0IGZpbGVIYW5kbGU7XG4gICAgICAgIGNvbnN0IGZpbGVOYW1lID0gcGF0aC5iYXNlbmFtZShmaWxlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZpbGVIYW5kbGUgPSBhd2FpdCBmcy5vcGVuKGZpbGUsICdyJyk7XG4gICAgICAgICAgICBpZiAoIWZpbGVIYW5kbGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBvcGVuIGZpbGVgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbGVTaXplID0gKGF3YWl0IGZpbGVIYW5kbGUuc3RhdCgpKS5zaXplO1xuICAgICAgICAgICAgd2hpbGUgKG9mZnNldCA8IGZpbGVTaXplKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmtTaXplID0gTWF0aC5taW4oTUFYX0NIVU5LX1NJWkUsIGZpbGVTaXplIC0gb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0ICsgY2h1bmtTaXplID49IGZpbGVTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwbG9hZENvbW1hbmQgKz0gJywgZmluYWxpemUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShjaHVua1NpemUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgYnl0ZXNSZWFkOiBieXRlc1JlYWQgfSA9IGF3YWl0IGZpbGVIYW5kbGUucmVhZChidWZmZXIsIDAsIGNodW5rU2l6ZSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoYnl0ZXNSZWFkICE9PSBjaHVua1NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcmVhZCAke2NodW5rU2l6ZX0gYnl0ZXMgZnJvbSBmaWxlIGF0IG9mZnNldCAke29mZnNldH0uIGJ5dGVzIGFjdHVhbGx5IHJlYWQ6ICR7Ynl0ZXNSZWFkfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IG5ldyBCbG9iKFtidWZmZXJdKTtcbiAgICAgICAgICAgICAgICBsZXQgcmV0cnlDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnREZWxheU1zID0gSU5JVElBTF9SRVRSWV9ERUxBWV9NUztcbiAgICAgICAgICAgICAgICB3aGlsZSAocmV0cnlDb3VudCA8IE1BWF9SRVRSWV9DT1VOVCkge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogY2h1bmssXG4gICAgICAgICAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBodHRwT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaVZlcnNpb246ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VVcmw6IHVwbG9hZFVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdYLUdvb2ctVXBsb2FkLUNvbW1hbmQnOiB1cGxvYWRDb21tYW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnWC1Hb29nLVVwbG9hZC1PZmZzZXQnOiBTdHJpbmcob2Zmc2V0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtTGVuZ3RoJzogU3RyaW5nKGJ5dGVzUmVhZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdYLUdvb2ctVXBsb2FkLUZpbGUtTmFtZSc6IGZpbGVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChfYSA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbWF9HT09HX1VQTE9BRF9TVEFUVVNfSEVBREVSX0ZJRUxEXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0cnlDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBzbGVlcChjdXJyZW50RGVsYXlNcyk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnREZWxheU1zID0gY3VycmVudERlbGF5TXMgKiBERUxBWV9NVUxUSVBMSUVSO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gYnl0ZXNSZWFkO1xuICAgICAgICAgICAgICAgIC8vIFRoZSBgeC1nb29nLXVwbG9hZC1zdGF0dXNgIGhlYWRlciBmaWVsZCBjYW4gYmUgYGFjdGl2ZWAsIGBmaW5hbGAgYW5kXG4gICAgICAgICAgICAgICAgLy9gY2FuY2VsbGVkYCBpbiByZXNwb3NuZS5cbiAgICAgICAgICAgICAgICBpZiAoKChfYiA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbWF9HT09HX1VQTE9BRF9TVEFUVVNfSEVBREVSX0ZJRUxEXSkgIT09ICdhY3RpdmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmlsZVNpemUgPD0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQWxsIGNvbnRlbnQgaGFzIGJlZW4gdXBsb2FkZWQsIGJ1dCB0aGUgdXBsb2FkIHN0YXR1cyBpcyBub3QgZmluYWxpemVkLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgZmlsZSBoYW5kbGUgaXMgYWx3YXlzIGNsb3NlZFxuICAgICAgICAgICAgaWYgKGZpbGVIYW5kbGUpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBmaWxlSGFuZGxlLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNvbnN0IExBTkdVQUdFX0xBQkVMX1BSRUZJWCA9ICdnbC1ub2RlLyc7XG4vKipcbiAqIFRoZSBHb29nbGUgR2VuQUkgU0RLLlxuICpcbiAqIEByZW1hcmtzXG4gKiBQcm92aWRlcyBhY2Nlc3MgdG8gdGhlIEdlbkFJIGZlYXR1cmVzIHRocm91Z2ggZWl0aGVyIHRoZSB7QGxpbmtcbiAqIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS92ZXJ0ZXgtYWkvZG9jcy9yZWZlcmVuY2UvcmVzdCB8IEdlbWluaSBBUEl9IG9yXG4gKiB0aGUge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS92ZXJ0ZXgtYWkvZG9jcy9yZWZlcmVuY2UvcmVzdCB8IFZlcnRleCBBSVxuICogQVBJfS5cbiAqXG4gKiBUaGUge0BsaW5rIEdvb2dsZUdlbkFJT3B0aW9ucy52ZXJ0ZXhhaX0gdmFsdWUgZGV0ZXJtaW5lcyB3aGljaCBvZiB0aGUgQVBJXG4gKiBzZXJ2aWNlcyB0byB1c2UuXG4gKlxuICogV2hlbiB1c2luZyB0aGUgR2VtaW5pIEFQSSwgYSB7QGxpbmsgR29vZ2xlR2VuQUlPcHRpb25zLmFwaUtleX0gbXVzdCBhbHNvIGJlXG4gKiBzZXQuIFdoZW4gdXNpbmcgVmVydGV4IEFJLCBib3RoIHtAbGluayBHb29nbGVHZW5BSU9wdGlvbnMucHJvamVjdH0gYW5kIHtAbGlua1xuICogR29vZ2xlR2VuQUlPcHRpb25zLmxvY2F0aW9ufSBtdXN0IGJlIHNldCwgb3IgYSB7QGxpbmtcbiAqIEdvb2dsZUdlbkFJT3B0aW9ucy5hcGlLZXl9IG11c3QgYmUgc2V0IHdoZW4gdXNpbmcgRXhwcmVzcyBNb2RlLlxuICpcbiAqIEV4cGxpY2l0bHkgcGFzc2VkIGluIHZhbHVlcyBpbiB7QGxpbmsgR29vZ2xlR2VuQUlPcHRpb25zfSB3aWxsIGFsd2F5cyB0YWtlXG4gKiBwcmVjZWRlbmNlIG92ZXIgZW52aXJvbm1lbnQgdmFyaWFibGVzLiBJZiBib3RoIHByb2plY3QvbG9jYXRpb24gYW5kIGFwaV9rZXlcbiAqIGV4aXN0IGluIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMsIHRoZSBwcm9qZWN0L2xvY2F0aW9uIHdpbGwgYmUgdXNlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogSW5pdGlhbGl6aW5nIHRoZSBTREsgZm9yIHVzaW5nIHRoZSBHZW1pbmkgQVBJOlxuICogYGBgdHNcbiAqIGltcG9ydCB7R29vZ2xlR2VuQUl9IGZyb20gJ0Bnb29nbGUvZ2VuYWknO1xuICogY29uc3QgYWkgPSBuZXcgR29vZ2xlR2VuQUkoe2FwaUtleTogJ0dFTUlOSV9BUElfS0VZJ30pO1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIEluaXRpYWxpemluZyB0aGUgU0RLIGZvciB1c2luZyB0aGUgVmVydGV4IEFJIEFQSTpcbiAqIGBgYHRzXG4gKiBpbXBvcnQge0dvb2dsZUdlbkFJfSBmcm9tICdAZ29vZ2xlL2dlbmFpJztcbiAqIGNvbnN0IGFpID0gbmV3IEdvb2dsZUdlbkFJKHtcbiAqICAgdmVydGV4YWk6IHRydWUsXG4gKiAgIHByb2plY3Q6ICdQUk9KRUNUX0lEJyxcbiAqICAgbG9jYXRpb246ICdQUk9KRUNUX0xPQ0FUSU9OJ1xuICogfSk7XG4gKiBgYGBcbiAqXG4gKi9cbmNsYXNzIEdvb2dsZUdlbkFJIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICAvLyBWYWxpZGF0ZSBleHBsaWNpdGx5IHNldCBpbml0aWFsaXplciB2YWx1ZXMuXG4gICAgICAgIGlmICgob3B0aW9ucy5wcm9qZWN0IHx8IG9wdGlvbnMubG9jYXRpb24pICYmIG9wdGlvbnMuYXBpS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3QvbG9jYXRpb24gYW5kIEFQSSBrZXkgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZSBpbiB0aGUgY2xpZW50IGluaXRpYWxpemVyLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmVydGV4YWkgPVxuICAgICAgICAgICAgKF9iID0gKF9hID0gb3B0aW9ucy52ZXJ0ZXhhaSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZ2V0Qm9vbGVhbkVudignR09PR0xFX0dFTkFJX1VTRV9WRVJURVhBSScpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZTtcbiAgICAgICAgY29uc3QgZW52QXBpS2V5ID0gZ2V0QXBpS2V5RnJvbUVudigpO1xuICAgICAgICBjb25zdCBlbnZQcm9qZWN0ID0gZ2V0RW52KCdHT09HTEVfQ0xPVURfUFJPSkVDVCcpO1xuICAgICAgICBjb25zdCBlbnZMb2NhdGlvbiA9IGdldEVudignR09PR0xFX0NMT1VEX0xPQ0FUSU9OJyk7XG4gICAgICAgIHRoaXMuYXBpS2V5ID0gKF9jID0gb3B0aW9ucy5hcGlLZXkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGVudkFwaUtleTtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gKF9kID0gb3B0aW9ucy5wcm9qZWN0KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBlbnZQcm9qZWN0O1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gKF9lID0gb3B0aW9ucy5sb2NhdGlvbikgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogZW52TG9jYXRpb247XG4gICAgICAgIC8vIEhhbmRsZSB3aGVuIHRvIHVzZSBWZXJ0ZXggQUkgaW4gZXhwcmVzcyBtb2RlIChhcGkga2V5KVxuICAgICAgICBpZiAob3B0aW9ucy52ZXJ0ZXhhaSkge1xuICAgICAgICAgICAgaWYgKChfZiA9IG9wdGlvbnMuZ29vZ2xlQXV0aE9wdGlvbnMpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0IGNyZWRlbnRpYWxzIHRha2UgcHJlY2VkZW5jZSBvdmVyIGltcGxpY2l0IGFwaV9rZXkuXG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnVGhlIHVzZXIgcHJvdmlkZWQgR29vZ2xlIENsb3VkIGNyZWRlbnRpYWxzIHdpbGwgdGFrZSBwcmVjZWRlbmNlJyArXG4gICAgICAgICAgICAgICAgICAgICcgb3ZlciB0aGUgQVBJIGtleSBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZS4nKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFwaUtleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEV4cGxpY2l0IGFwaV9rZXkgYW5kIGV4cGxpY2l0IHByb2plY3QvbG9jYXRpb24gYWxyZWFkeSBoYW5kbGVkIGFib3ZlLlxuICAgICAgICAgICAgaWYgKChlbnZQcm9qZWN0IHx8IGVudkxvY2F0aW9uKSAmJiBvcHRpb25zLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0IGFwaV9rZXkgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGltcGxpY2l0IHByb2plY3QvbG9jYXRpb24uXG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnVGhlIHVzZXIgcHJvdmlkZWQgVmVydGV4IEFJIEFQSSBrZXkgd2lsbCB0YWtlIHByZWNlZGVuY2Ugb3ZlcicgK1xuICAgICAgICAgICAgICAgICAgICAnIHRoZSBwcm9qZWN0L2xvY2F0aW9uIGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlcy4nKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2plY3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChvcHRpb25zLnByb2plY3QgfHwgb3B0aW9ucy5sb2NhdGlvbikgJiYgZW52QXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgLy8gRXhwbGljaXQgcHJvamVjdC9sb2NhdGlvbiB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgaW1wbGljaXQgYXBpX2tleS5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdUaGUgdXNlciBwcm92aWRlZCBwcm9qZWN0L2xvY2F0aW9uIHdpbGwgdGFrZSBwcmVjZWRlbmNlIG92ZXInICtcbiAgICAgICAgICAgICAgICAgICAgJyB0aGUgQVBJIGtleSBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMuJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5hcGlLZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoZW52UHJvamVjdCB8fCBlbnZMb2NhdGlvbikgJiYgZW52QXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgLy8gSW1wbGljaXQgcHJvamVjdC9sb2NhdGlvbiB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgaW1wbGljaXQgYXBpX2tleS5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdUaGUgcHJvamVjdC9sb2NhdGlvbiBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgd2lsbCB0YWtlJyArXG4gICAgICAgICAgICAgICAgICAgICcgcHJlY2VkZW5jZSBvdmVyIHRoZSBBUEkga2V5IGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlcy4nKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFwaUtleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5sb2NhdGlvbiAmJiAhdGhpcy5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2F0aW9uID0gJ2dsb2JhbCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmFzZVVybCA9IGdldEJhc2VVcmwob3B0aW9ucy5odHRwT3B0aW9ucywgb3B0aW9ucy52ZXJ0ZXhhaSwgZ2V0RW52KCdHT09HTEVfVkVSVEVYX0JBU0VfVVJMJyksIGdldEVudignR09PR0xFX0dFTUlOSV9CQVNFX1VSTCcpKTtcbiAgICAgICAgaWYgKGJhc2VVcmwpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmh0dHBPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5odHRwT3B0aW9ucy5iYXNlVXJsID0gYmFzZVVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuaHR0cE9wdGlvbnMgPSB7IGJhc2VVcmw6IGJhc2VVcmwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwaVZlcnNpb24gPSBvcHRpb25zLmFwaVZlcnNpb247XG4gICAgICAgIHRoaXMuaHR0cE9wdGlvbnMgPSBvcHRpb25zLmh0dHBPcHRpb25zO1xuICAgICAgICBjb25zdCBhdXRoID0gbmV3IE5vZGVBdXRoKHtcbiAgICAgICAgICAgIGFwaUtleTogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICBnb29nbGVBdXRoT3B0aW9uczogb3B0aW9ucy5nb29nbGVBdXRoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gbmV3IEFwaUNsaWVudCh7XG4gICAgICAgICAgICBhdXRoOiBhdXRoLFxuICAgICAgICAgICAgcHJvamVjdDogdGhpcy5wcm9qZWN0LFxuICAgICAgICAgICAgbG9jYXRpb246IHRoaXMubG9jYXRpb24sXG4gICAgICAgICAgICBhcGlWZXJzaW9uOiB0aGlzLmFwaVZlcnNpb24sXG4gICAgICAgICAgICBhcGlLZXk6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgdmVydGV4YWk6IHRoaXMudmVydGV4YWksXG4gICAgICAgICAgICBodHRwT3B0aW9uczogdGhpcy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgIHVzZXJBZ2VudEV4dHJhOiBMQU5HVUFHRV9MQUJFTF9QUkVGSVggKyBwcm9jZXNzLnZlcnNpb24sXG4gICAgICAgICAgICB1cGxvYWRlcjogbmV3IE5vZGVVcGxvYWRlcigpLFxuICAgICAgICAgICAgZG93bmxvYWRlcjogbmV3IE5vZGVEb3dubG9hZGVyKCksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1vZGVscyA9IG5ldyBNb2RlbHModGhpcy5hcGlDbGllbnQpO1xuICAgICAgICB0aGlzLmxpdmUgPSBuZXcgTGl2ZSh0aGlzLmFwaUNsaWVudCwgYXV0aCwgbmV3IE5vZGVXZWJTb2NrZXRGYWN0b3J5KCkpO1xuICAgICAgICB0aGlzLmJhdGNoZXMgPSBuZXcgQmF0Y2hlcyh0aGlzLmFwaUNsaWVudCk7XG4gICAgICAgIHRoaXMuY2hhdHMgPSBuZXcgQ2hhdHModGhpcy5tb2RlbHMsIHRoaXMuYXBpQ2xpZW50KTtcbiAgICAgICAgdGhpcy5jYWNoZXMgPSBuZXcgQ2FjaGVzKHRoaXMuYXBpQ2xpZW50KTtcbiAgICAgICAgdGhpcy5maWxlcyA9IG5ldyBGaWxlcyh0aGlzLmFwaUNsaWVudCk7XG4gICAgICAgIHRoaXMub3BlcmF0aW9ucyA9IG5ldyBPcGVyYXRpb25zKHRoaXMuYXBpQ2xpZW50KTtcbiAgICAgICAgdGhpcy5hdXRoVG9rZW5zID0gbmV3IFRva2Vucyh0aGlzLmFwaUNsaWVudCk7XG4gICAgICAgIHRoaXMudHVuaW5ncyA9IG5ldyBUdW5pbmdzKHRoaXMuYXBpQ2xpZW50KTtcbiAgICAgICAgdGhpcy5maWxlU2VhcmNoU3RvcmVzID0gbmV3IEZpbGVTZWFyY2hTdG9yZXModGhpcy5hcGlDbGllbnQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEVudihlbnYpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICByZXR1cm4gKF9jID0gKF9iID0gKF9hID0gcHJvY2VzcyA9PT0gbnVsbCB8fCBwcm9jZXNzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9jZXNzLmVudikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2Vudl0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50cmltKCkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGdldEJvb2xlYW5FbnYoZW52KSB7XG4gICAgcmV0dXJuIHN0cmluZ1RvQm9vbGVhbihnZXRFbnYoZW52KSk7XG59XG5mdW5jdGlvbiBzdHJpbmdUb0Jvb2xlYW4oc3RyKSB7XG4gICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHN0ci50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG59XG5mdW5jdGlvbiBnZXRBcGlLZXlGcm9tRW52KCkge1xuICAgIGNvbnN0IGVudkdvb2dsZUFwaUtleSA9IGdldEVudignR09PR0xFX0FQSV9LRVknKTtcbiAgICBjb25zdCBlbnZHZW1pbmlBcGlLZXkgPSBnZXRFbnYoJ0dFTUlOSV9BUElfS0VZJyk7XG4gICAgaWYgKGVudkdvb2dsZUFwaUtleSAmJiBlbnZHZW1pbmlBcGlLZXkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdCb3RoIEdPT0dMRV9BUElfS0VZIGFuZCBHRU1JTklfQVBJX0tFWSBhcmUgc2V0LiBVc2luZyBHT09HTEVfQVBJX0tFWS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGVudkdvb2dsZUFwaUtleSB8fCBlbnZHZW1pbmlBcGlLZXkgfHwgdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgeyBBY3Rpdml0eUhhbmRsaW5nLCBBZGFwdGVyU2l6ZSwgQXBpRXJyb3IsIEFwaVNwZWMsIEF1dGhUeXBlLCBCYXRjaGVzLCBCZWhhdmlvciwgQmxvY2tlZFJlYXNvbiwgQ2FjaGVzLCBDYW5jZWxUdW5pbmdKb2JSZXNwb25zZSwgQ2hhdCwgQ2hhdHMsIENvbXB1dGVUb2tlbnNSZXNwb25zZSwgQ29udGVudFJlZmVyZW5jZUltYWdlLCBDb250cm9sUmVmZXJlbmNlSW1hZ2UsIENvbnRyb2xSZWZlcmVuY2VUeXBlLCBDb3VudFRva2Vuc1Jlc3BvbnNlLCBDcmVhdGVGaWxlUmVzcG9uc2UsIERlbGV0ZUNhY2hlZENvbnRlbnRSZXNwb25zZSwgRGVsZXRlRmlsZVJlc3BvbnNlLCBEZWxldGVNb2RlbFJlc3BvbnNlLCBEb2N1bWVudFN0YXRlLCBEeW5hbWljUmV0cmlldmFsQ29uZmlnTW9kZSwgRWRpdEltYWdlUmVzcG9uc2UsIEVkaXRNb2RlLCBFbWJlZENvbnRlbnRSZXNwb25zZSwgRW5kU2Vuc2l0aXZpdHksIEVudmlyb25tZW50LCBGZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZSwgRmlsZVNvdXJjZSwgRmlsZVN0YXRlLCBGaWxlcywgRmluaXNoUmVhc29uLCBGdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlLCBGdW5jdGlvblJlc3BvbnNlLCBGdW5jdGlvblJlc3BvbnNlQmxvYiwgRnVuY3Rpb25SZXNwb25zZUZpbGVEYXRhLCBGdW5jdGlvblJlc3BvbnNlUGFydCwgRnVuY3Rpb25SZXNwb25zZVNjaGVkdWxpbmcsIEdlbmVyYXRlQ29udGVudFJlc3BvbnNlLCBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZVByb21wdEZlZWRiYWNrLCBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZVVzYWdlTWV0YWRhdGEsIEdlbmVyYXRlSW1hZ2VzUmVzcG9uc2UsIEdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uLCBHZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlLCBHb29nbGVHZW5BSSwgSGFybUJsb2NrTWV0aG9kLCBIYXJtQmxvY2tUaHJlc2hvbGQsIEhhcm1DYXRlZ29yeSwgSGFybVByb2JhYmlsaXR5LCBIYXJtU2V2ZXJpdHksIEh0dHBFbGVtZW50TG9jYXRpb24sIEh0dHBSZXNwb25zZSwgSW1hZ2VQcm9tcHRMYW5ndWFnZSwgSW1wb3J0RmlsZU9wZXJhdGlvbiwgSW1wb3J0RmlsZVJlc3BvbnNlLCBJbmxpbmVkRW1iZWRDb250ZW50UmVzcG9uc2UsIElubGluZWRSZXNwb25zZSwgSm9iU3RhdGUsIExhbmd1YWdlLCBMaXN0QmF0Y2hKb2JzUmVzcG9uc2UsIExpc3RDYWNoZWRDb250ZW50c1Jlc3BvbnNlLCBMaXN0RG9jdW1lbnRzUmVzcG9uc2UsIExpc3RGaWxlU2VhcmNoU3RvcmVzUmVzcG9uc2UsIExpc3RGaWxlc1Jlc3BvbnNlLCBMaXN0TW9kZWxzUmVzcG9uc2UsIExpc3RUdW5pbmdKb2JzUmVzcG9uc2UsIExpdmUsIExpdmVDbGllbnRUb29sUmVzcG9uc2UsIExpdmVNdXNpY1BsYXliYWNrQ29udHJvbCwgTGl2ZU11c2ljU2VydmVyTWVzc2FnZSwgTGl2ZVNlbmRUb29sUmVzcG9uc2VQYXJhbWV0ZXJzLCBMaXZlU2VydmVyTWVzc2FnZSwgTWFza1JlZmVyZW5jZUltYWdlLCBNYXNrUmVmZXJlbmNlTW9kZSwgTWVkaWFNb2RhbGl0eSwgTWVkaWFSZXNvbHV0aW9uLCBNb2RhbGl0eSwgTW9kZSwgTW9kZWxzLCBNdXNpY0dlbmVyYXRpb25Nb2RlLCBPcGVyYXRpb25zLCBPdXRjb21lLCBQYWdlZEl0ZW0sIFBhZ2VyLCBQYXJ0TWVkaWFSZXNvbHV0aW9uTGV2ZWwsIFBlcnNvbkdlbmVyYXRpb24sIFBoaXNoQmxvY2tUaHJlc2hvbGQsIFJhd1JlZmVyZW5jZUltYWdlLCBSZWNvbnRleHRJbWFnZVJlc3BvbnNlLCBSZXBsYXlSZXNwb25zZSwgU2FmZXR5RmlsdGVyTGV2ZWwsIFNjYWxlLCBTZWdtZW50SW1hZ2VSZXNwb25zZSwgU2VnbWVudE1vZGUsIFNlc3Npb24sIFNpbmdsZUVtYmVkQ29udGVudFJlc3BvbnNlLCBTdGFydFNlbnNpdGl2aXR5LCBTdHlsZVJlZmVyZW5jZUltYWdlLCBTdWJqZWN0UmVmZXJlbmNlSW1hZ2UsIFN1YmplY3RSZWZlcmVuY2VUeXBlLCBUaGlua2luZ0xldmVsLCBUb2tlbnMsIFRyYWZmaWNUeXBlLCBUdW5pbmdNZXRob2QsIFR1bmluZ01vZGUsIFR1bmluZ1Rhc2ssIFR1cm5Db21wbGV0ZVJlYXNvbiwgVHVybkNvdmVyYWdlLCBUeXBlLCBVcGxvYWRUb0ZpbGVTZWFyY2hTdG9yZU9wZXJhdGlvbiwgVXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVSZXNwb25zZSwgVXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVSZXN1bWFibGVSZXNwb25zZSwgVXBzY2FsZUltYWdlUmVzcG9uc2UsIFVybFJldHJpZXZhbFN0YXR1cywgVmlkZW9Db21wcmVzc2lvblF1YWxpdHksIFZpZGVvR2VuZXJhdGlvbk1hc2tNb2RlLCBWaWRlb0dlbmVyYXRpb25SZWZlcmVuY2VUeXBlLCBjcmVhdGVGdW5jdGlvblJlc3BvbnNlUGFydEZyb21CYXNlNjQsIGNyZWF0ZUZ1bmN0aW9uUmVzcG9uc2VQYXJ0RnJvbVVyaSwgY3JlYXRlTW9kZWxDb250ZW50LCBjcmVhdGVQYXJ0RnJvbUJhc2U2NCwgY3JlYXRlUGFydEZyb21Db2RlRXhlY3V0aW9uUmVzdWx0LCBjcmVhdGVQYXJ0RnJvbUV4ZWN1dGFibGVDb2RlLCBjcmVhdGVQYXJ0RnJvbUZ1bmN0aW9uQ2FsbCwgY3JlYXRlUGFydEZyb21GdW5jdGlvblJlc3BvbnNlLCBjcmVhdGVQYXJ0RnJvbVRleHQsIGNyZWF0ZVBhcnRGcm9tVXJpLCBjcmVhdGVVc2VyQ29udGVudCwgbWNwVG9Ub29sLCBzZXREZWZhdWx0QmFzZVVybHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6WyJHb29nbGVBdXRoIiwiY3JlYXRlV3JpdGVTdHJlYW0iLCJmcyIsIndyaXRlRmlsZSIsIlJlYWRhYmxlIiwiZmluaXNoZWQiLCJOb2RlV3MiLCJwYXRoIiwiX2RlZmF1bHRCYXNlR2VtaW5pVXJsIiwidW5kZWZpbmVkIiwiX2RlZmF1bHRCYXNlVmVydGV4VXJsIiwic2V0RGVmYXVsdEJhc2VVcmxzIiwiYmFzZVVybFBhcmFtcyIsImdlbWluaVVybCIsInZlcnRleFVybCIsImdldERlZmF1bHRCYXNlVXJscyIsImdldEJhc2VVcmwiLCJodHRwT3B0aW9ucyIsInZlcnRleGFpIiwidmVydGV4QmFzZVVybEZyb21FbnYiLCJnZW1pbmlCYXNlVXJsRnJvbUVudiIsIl9hIiwiX2IiLCJiYXNlVXJsIiwiZGVmYXVsdEJhc2VVcmxzIiwiQmFzZU1vZHVsZSIsImZvcm1hdE1hcCIsInRlbXBsYXRlU3RyaW5nIiwidmFsdWVNYXAiLCJyZWdleCIsInJlcGxhY2UiLCJtYXRjaCIsImtleSIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInZhbHVlIiwiU3RyaW5nIiwiRXJyb3IiLCJzZXRWYWx1ZUJ5UGF0aCIsImRhdGEiLCJrZXlzIiwiaSIsImxlbmd0aCIsImVuZHNXaXRoIiwia2V5TmFtZSIsInNsaWNlIiwiQXJyYXkiLCJpc0FycmF5IiwiZnJvbSIsImFycmF5RGF0YSIsImoiLCJlbnRyeSIsImQiLCJrZXlUb1NldCIsImV4aXN0aW5nRGF0YSIsImFzc2lnbiIsInZhbHVlQXNSZWNvcmQiLCJnZXRWYWx1ZUJ5UGF0aCIsImRlZmF1bHRWYWx1ZSIsIm1hcCIsImVycm9yIiwiVHlwZUVycm9yIiwibW92ZVZhbHVlQnlQYXRoIiwicGF0aHMiLCJzb3VyY2VQYXRoIiwiZGVzdFBhdGgiLCJlbnRyaWVzIiwic291cmNlS2V5cyIsInNwbGl0IiwiZGVzdEtleXMiLCJleGNsdWRlS2V5cyIsIlNldCIsIndpbGRjYXJkSWR4IiwiYWRkIiwiX21vdmVWYWx1ZVJlY3Vyc2l2ZSIsImtleUlkeCIsImRhdGFSZWNvcmQiLCJpdGVtIiwia2V5c1RvTW92ZSIsImZpbHRlciIsImsiLCJzdGFydHNXaXRoIiwiaGFzIiwidmFsdWVzVG9Nb3ZlIiwidiIsIm5ld0Rlc3RLZXlzIiwiZGsiLCJwdXNoIiwidEJ5dGVzJDEiLCJmcm9tQnl0ZXMiLCJmZXRjaFByZWRpY3RPcGVyYXRpb25QYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJmcm9tT2JqZWN0IiwidG9PYmplY3QiLCJmcm9tT3BlcmF0aW9uTmFtZSIsImZyb21SZXNvdXJjZU5hbWUiLCJnZW5lcmF0ZVZpZGVvc09wZXJhdGlvbkZyb21NbGRldiQxIiwiZnJvbU5hbWUiLCJmcm9tTWV0YWRhdGEiLCJmcm9tRG9uZSIsImZyb21FcnJvciIsImZyb21SZXNwb25zZSIsImdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tTWxkZXYkMSIsImdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uRnJvbVZlcnRleCQxIiwiZ2VuZXJhdGVWaWRlb3NSZXNwb25zZUZyb21WZXJ0ZXgkMSIsImZyb21HZW5lcmF0ZWRWaWRlb3MiLCJ0cmFuc2Zvcm1lZExpc3QiLCJnZW5lcmF0ZWRWaWRlb0Zyb21NbGRldiQxIiwiZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCIsImZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyIsImdlbmVyYXRlZFZpZGVvRnJvbVZlcnRleCQxIiwiZnJvbVZpZGVvIiwidmlkZW9Gcm9tTWxkZXYkMSIsInZpZGVvRnJvbVZlcnRleCQxIiwiZ2V0T3BlcmF0aW9uUGFyYW1ldGVyc1RvTWxkZXYiLCJnZXRPcGVyYXRpb25QYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJpbXBvcnRGaWxlT3BlcmF0aW9uRnJvbU1sZGV2JDEiLCJpbXBvcnRGaWxlUmVzcG9uc2VGcm9tTWxkZXYkMSIsImZyb21TZGtIdHRwUmVzcG9uc2UiLCJmcm9tUGFyZW50IiwiZnJvbURvY3VtZW50TmFtZSIsInVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlT3BlcmF0aW9uRnJvbU1sZGV2IiwidXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVSZXNwb25zZUZyb21NbGRldiIsImZyb21VcmkiLCJmcm9tVmlkZW9CeXRlcyIsImZyb21NaW1lVHlwZSIsIk91dGNvbWUiLCJMYW5ndWFnZSIsIkZ1bmN0aW9uUmVzcG9uc2VTY2hlZHVsaW5nIiwiVHlwZSIsIk1vZGUiLCJBcGlTcGVjIiwiQXV0aFR5cGUiLCJIdHRwRWxlbWVudExvY2F0aW9uIiwiUGhpc2hCbG9ja1RocmVzaG9sZCIsIlRoaW5raW5nTGV2ZWwiLCJIYXJtQ2F0ZWdvcnkiLCJIYXJtQmxvY2tNZXRob2QiLCJIYXJtQmxvY2tUaHJlc2hvbGQiLCJGaW5pc2hSZWFzb24iLCJIYXJtUHJvYmFiaWxpdHkiLCJIYXJtU2V2ZXJpdHkiLCJVcmxSZXRyaWV2YWxTdGF0dXMiLCJCbG9ja2VkUmVhc29uIiwiVHJhZmZpY1R5cGUiLCJNb2RhbGl0eSIsIk1lZGlhUmVzb2x1dGlvbiIsIlR1bmluZ01vZGUiLCJBZGFwdGVyU2l6ZSIsIkpvYlN0YXRlIiwiVHVuaW5nVGFzayIsIlBhcnRNZWRpYVJlc29sdXRpb25MZXZlbCIsIkZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlIiwiQmVoYXZpb3IiLCJEeW5hbWljUmV0cmlldmFsQ29uZmlnTW9kZSIsIkVudmlyb25tZW50IiwiRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZSIsIlNhZmV0eUZpbHRlckxldmVsIiwiUGVyc29uR2VuZXJhdGlvbiIsIkltYWdlUHJvbXB0TGFuZ3VhZ2UiLCJNYXNrUmVmZXJlbmNlTW9kZSIsIkNvbnRyb2xSZWZlcmVuY2VUeXBlIiwiU3ViamVjdFJlZmVyZW5jZVR5cGUiLCJFZGl0TW9kZSIsIlNlZ21lbnRNb2RlIiwiVmlkZW9HZW5lcmF0aW9uUmVmZXJlbmNlVHlwZSIsIlZpZGVvR2VuZXJhdGlvbk1hc2tNb2RlIiwiVmlkZW9Db21wcmVzc2lvblF1YWxpdHkiLCJUdW5pbmdNZXRob2QiLCJEb2N1bWVudFN0YXRlIiwiRmlsZVN0YXRlIiwiRmlsZVNvdXJjZSIsIlR1cm5Db21wbGV0ZVJlYXNvbiIsIk1lZGlhTW9kYWxpdHkiLCJTdGFydFNlbnNpdGl2aXR5IiwiRW5kU2Vuc2l0aXZpdHkiLCJBY3Rpdml0eUhhbmRsaW5nIiwiVHVybkNvdmVyYWdlIiwiU2NhbGUiLCJNdXNpY0dlbmVyYXRpb25Nb2RlIiwiTGl2ZU11c2ljUGxheWJhY2tDb250cm9sIiwiRnVuY3Rpb25SZXNwb25zZUJsb2IiLCJGdW5jdGlvblJlc3BvbnNlRmlsZURhdGEiLCJGdW5jdGlvblJlc3BvbnNlUGFydCIsImNyZWF0ZUZ1bmN0aW9uUmVzcG9uc2VQYXJ0RnJvbUJhc2U2NCIsIm1pbWVUeXBlIiwiaW5saW5lRGF0YSIsImNyZWF0ZUZ1bmN0aW9uUmVzcG9uc2VQYXJ0RnJvbVVyaSIsInVyaSIsImZpbGVEYXRhIiwiZmlsZVVyaSIsIkZ1bmN0aW9uUmVzcG9uc2UiLCJjcmVhdGVQYXJ0RnJvbVVyaSIsIm1lZGlhUmVzb2x1dGlvbiIsImxldmVsIiwiY3JlYXRlUGFydEZyb21UZXh0IiwidGV4dCIsImNyZWF0ZVBhcnRGcm9tRnVuY3Rpb25DYWxsIiwibmFtZSIsImFyZ3MiLCJmdW5jdGlvbkNhbGwiLCJjcmVhdGVQYXJ0RnJvbUZ1bmN0aW9uUmVzcG9uc2UiLCJpZCIsInJlc3BvbnNlIiwicGFydHMiLCJmdW5jdGlvblJlc3BvbnNlIiwiY3JlYXRlUGFydEZyb21CYXNlNjQiLCJjcmVhdGVQYXJ0RnJvbUNvZGVFeGVjdXRpb25SZXN1bHQiLCJvdXRjb21lIiwib3V0cHV0IiwiY29kZUV4ZWN1dGlvblJlc3VsdCIsImNyZWF0ZVBhcnRGcm9tRXhlY3V0YWJsZUNvZGUiLCJjb2RlIiwibGFuZ3VhZ2UiLCJleGVjdXRhYmxlQ29kZSIsIl9pc1BhcnQiLCJvYmoiLCJfdG9QYXJ0cyIsInBhcnRPclN0cmluZyIsInBhcnQiLCJjcmVhdGVVc2VyQ29udGVudCIsInJvbGUiLCJjcmVhdGVNb2RlbENvbnRlbnQiLCJIdHRwUmVzcG9uc2UiLCJjb25zdHJ1Y3RvciIsImhlYWRlcnMiLCJwYWlyIiwicmVzcG9uc2VJbnRlcm5hbCIsImpzb24iLCJHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZVByb21wdEZlZWRiYWNrIiwiR2VuZXJhdGVDb250ZW50UmVzcG9uc2VVc2FnZU1ldGFkYXRhIiwiR2VuZXJhdGVDb250ZW50UmVzcG9uc2UiLCJfYyIsIl9kIiwiX2UiLCJfZiIsIl9nIiwiX2giLCJjYW5kaWRhdGVzIiwiY29udGVudCIsImNvbnNvbGUiLCJ3YXJuIiwiYW55VGV4dFBhcnRUZXh0Iiwibm9uVGV4dFBhcnRzIiwiZmllbGROYW1lIiwiZmllbGRWYWx1ZSIsInRob3VnaHQiLCJub25EYXRhUGFydHMiLCJhdG9iIiwiYnRvYSIsImZ1bmN0aW9uQ2FsbHMiLCJfaiIsIkVtYmVkQ29udGVudFJlc3BvbnNlIiwiR2VuZXJhdGVJbWFnZXNSZXNwb25zZSIsIkVkaXRJbWFnZVJlc3BvbnNlIiwiVXBzY2FsZUltYWdlUmVzcG9uc2UiLCJSZWNvbnRleHRJbWFnZVJlc3BvbnNlIiwiU2VnbWVudEltYWdlUmVzcG9uc2UiLCJMaXN0TW9kZWxzUmVzcG9uc2UiLCJEZWxldGVNb2RlbFJlc3BvbnNlIiwiQ291bnRUb2tlbnNSZXNwb25zZSIsIkNvbXB1dGVUb2tlbnNSZXNwb25zZSIsIkdlbmVyYXRlVmlkZW9zUmVzcG9uc2UiLCJHZW5lcmF0ZVZpZGVvc09wZXJhdGlvbiIsIl9mcm9tQVBJUmVzcG9uc2UiLCJhcGlSZXNwb25zZSIsIl9pc1ZlcnRleEFJIiwib3BlcmF0aW9uIiwib3AiLCJMaXN0VHVuaW5nSm9ic1Jlc3BvbnNlIiwiQ2FuY2VsVHVuaW5nSm9iUmVzcG9uc2UiLCJEZWxldGVDYWNoZWRDb250ZW50UmVzcG9uc2UiLCJMaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZSIsIkxpc3REb2N1bWVudHNSZXNwb25zZSIsIkxpc3RGaWxlU2VhcmNoU3RvcmVzUmVzcG9uc2UiLCJVcGxvYWRUb0ZpbGVTZWFyY2hTdG9yZVJlc3VtYWJsZVJlc3BvbnNlIiwiSW1wb3J0RmlsZVJlc3BvbnNlIiwiSW1wb3J0RmlsZU9wZXJhdGlvbiIsIkxpc3RGaWxlc1Jlc3BvbnNlIiwiQ3JlYXRlRmlsZVJlc3BvbnNlIiwiRGVsZXRlRmlsZVJlc3BvbnNlIiwiSW5saW5lZFJlc3BvbnNlIiwiU2luZ2xlRW1iZWRDb250ZW50UmVzcG9uc2UiLCJJbmxpbmVkRW1iZWRDb250ZW50UmVzcG9uc2UiLCJMaXN0QmF0Y2hKb2JzUmVzcG9uc2UiLCJSZXBsYXlSZXNwb25zZSIsIlJhd1JlZmVyZW5jZUltYWdlIiwidG9SZWZlcmVuY2VJbWFnZUFQSSIsInJlZmVyZW5jZUltYWdlQVBJIiwicmVmZXJlbmNlVHlwZSIsInJlZmVyZW5jZUltYWdlIiwicmVmZXJlbmNlSWQiLCJNYXNrUmVmZXJlbmNlSW1hZ2UiLCJtYXNrSW1hZ2VDb25maWciLCJjb25maWciLCJDb250cm9sUmVmZXJlbmNlSW1hZ2UiLCJjb250cm9sSW1hZ2VDb25maWciLCJTdHlsZVJlZmVyZW5jZUltYWdlIiwic3R5bGVJbWFnZUNvbmZpZyIsIlN1YmplY3RSZWZlcmVuY2VJbWFnZSIsInN1YmplY3RJbWFnZUNvbmZpZyIsIkNvbnRlbnRSZWZlcmVuY2VJbWFnZSIsIkxpdmVTZXJ2ZXJNZXNzYWdlIiwiYW55VGV4dFBhcnRGb3VuZCIsInNlcnZlckNvbnRlbnQiLCJtb2RlbFR1cm4iLCJMaXZlQ2xpZW50VG9vbFJlc3BvbnNlIiwiTGl2ZVNlbmRUb29sUmVzcG9uc2VQYXJhbWV0ZXJzIiwiZnVuY3Rpb25SZXNwb25zZXMiLCJMaXZlTXVzaWNTZXJ2ZXJNZXNzYWdlIiwiYXVkaW9DaHVuayIsImF1ZGlvQ2h1bmtzIiwiVXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVSZXNwb25zZSIsIlVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlT3BlcmF0aW9uIiwidE1vZGVsIiwiYXBpQ2xpZW50IiwibW9kZWwiLCJpbmNsdWRlcyIsImlzVmVydGV4QUkiLCJpbmRleE9mIiwidENhY2hlc01vZGVsIiwidHJhbnNmb3JtZWRNb2RlbCIsImdldFByb2plY3QiLCJnZXRMb2NhdGlvbiIsInRCbG9icyIsImJsb2JzIiwiYmxvYiIsInRCbG9iIiwidEltYWdlQmxvYiIsInRyYW5zZm9ybWVkQmxvYiIsInRBdWRpb0Jsb2IiLCJ0UGFydCIsIm9yaWdpbiIsInRQYXJ0cyIsIl9pc0NvbnRlbnQiLCJfaXNGdW5jdGlvbkNhbGxQYXJ0IiwiX2lzRnVuY3Rpb25SZXNwb25zZVBhcnQiLCJ0Q29udGVudCIsInRDb250ZW50c0ZvckVtYmVkIiwiZmxhdE1hcCIsInRDb250ZW50cyIsInJlc3VsdCIsImFjY3VtdWxhdGVkUGFydHMiLCJpc0NvbnRlbnRBcnJheSIsImlzQ29udGVudCIsImZsYXR0ZW5UeXBlQXJyYXlUb0FueU9mIiwidHlwZUxpc3QiLCJyZXN1bHRpbmdTY2hlbWEiLCJsaXN0V2l0aG91dE51bGwiLCJ0eXBlIiwidmFsdWVzIiwidG9VcHBlckNhc2UiLCJUWVBFX1VOU1BFQ0lGSUVEIiwicHJvY2Vzc0pzb25TY2hlbWEiLCJfanNvblNjaGVtYSIsImdlbkFJU2NoZW1hIiwic2NoZW1hRmllbGROYW1lcyIsImxpc3RTY2hlbWFGaWVsZE5hbWVzIiwiZGljdFNjaGVtYUZpZWxkTmFtZXMiLCJpbmNvbWluZ0FueU9mIiwibGlzdFNjaGVtYUZpZWxkVmFsdWUiLCJkaWN0U2NoZW1hRmllbGRWYWx1ZSIsInRTY2hlbWEiLCJzY2hlbWEiLCJ0U3BlZWNoQ29uZmlnIiwic3BlZWNoQ29uZmlnIiwidm9pY2VDb25maWciLCJwcmVidWlsdFZvaWNlQ29uZmlnIiwidm9pY2VOYW1lIiwidExpdmVTcGVlY2hDb25maWciLCJ0VG9vbCIsInRvb2wiLCJmdW5jdGlvbkRlY2xhcmF0aW9ucyIsImZ1bmN0aW9uRGVjbGFyYXRpb24iLCJwYXJhbWV0ZXJzIiwicGFyYW1ldGVyc0pzb25TY2hlbWEiLCJyZXNwb25zZUpzb25TY2hlbWEiLCJ0VG9vbHMiLCJ0b29scyIsInJlc291cmNlTmFtZSIsImNsaWVudCIsInJlc291cmNlUHJlZml4Iiwic3BsaXRzQWZ0ZXJQcmVmaXgiLCJzaG91bGRBcHBlbmRQcmVmaXgiLCJ0Q2FjaGVkQ29udGVudE5hbWUiLCJ0VHVuaW5nSm9iU3RhdHVzIiwic3RhdHVzIiwidEJ5dGVzIiwiZnJvbUltYWdlQnl0ZXMiLCJfaXNGaWxlIiwiaXNHZW5lcmF0ZWRWaWRlbyIsImlzVmlkZW8iLCJ0RmlsZU5hbWUiLCJ2aWRlbyIsInN1ZmZpeCIsInRNb2RlbHNVcmwiLCJiYXNlTW9kZWxzIiwicmVzIiwidEV4dHJhY3RNb2RlbHMiLCJoYXNGaWVsZCIsIm1jcFRvR2VtaW5pVG9vbCIsIm1jcFRvb2wiLCJtY3BUb29sU2NoZW1hIiwiZGVzY3JpcHRpb24iLCJiZWhhdmlvciIsImdlbWluaVRvb2wiLCJtY3BUb29sc1RvR2VtaW5pVG9vbCIsIm1jcFRvb2xzIiwidG9vbE5hbWVzIiwibWNwVG9vbE5hbWUiLCJ0QmF0Y2hKb2JTb3VyY2UiLCJzcmMiLCJzb3VyY2VPYmoiLCJmb3JtYXQiLCJnY3NVcmkiLCJiaWdxdWVyeVVyaSIsImZpbGVOYW1lIiwiaW5saW5lZFJlcXVlc3RzIiwidmVydGV4U291cmNlc0NvdW50IiwiQm9vbGVhbiIsIm1sZGV2U291cmNlc0NvdW50IiwidEJhdGNoSm9iRGVzdGluYXRpb24iLCJkZXN0IiwiZGVzdFN0cmluZyIsInRSZWN2QmF0Y2hKb2JEZXN0aW5hdGlvbiIsImlubGluZVJlc3BvbnNlc1ZhbCIsImlubGluZVJlc3BvbnNlc09iaiIsInJlc3BvbnNlc0FycmF5IiwiaGFzRW1iZWRkaW5nIiwicmVzcG9uc2VJdGVtIiwicmVzcG9uc2VJdGVtT2JqIiwicmVzcG9uc2VWYWwiLCJyZXNwb25zZU9iaiIsInRCYXRjaEpvYk5hbWUiLCJuYW1lU3RyaW5nIiwibWxkZXZQYXR0ZXJuIiwidGVzdCIsInBvcCIsInZlcnRleFBhdHRlcm4iLCJ0Sm9iU3RhdGUiLCJzdGF0ZSIsInN0YXRlU3RyaW5nIiwiYmF0Y2hKb2JEZXN0aW5hdGlvbkZyb21NbGRldiIsImZyb21GaWxlTmFtZSIsImZyb21JbmxpbmVkUmVzcG9uc2VzIiwiaW5saW5lZFJlc3BvbnNlRnJvbU1sZGV2IiwiZnJvbUlubGluZWRFbWJlZENvbnRlbnRSZXNwb25zZXMiLCJiYXRjaEpvYkRlc3RpbmF0aW9uRnJvbVZlcnRleCIsImZyb21Gb3JtYXQiLCJmcm9tR2NzVXJpIiwiZnJvbUJpZ3F1ZXJ5VXJpIiwiYmF0Y2hKb2JEZXN0aW5hdGlvblRvVmVydGV4IiwiYmF0Y2hKb2JGcm9tTWxkZXYiLCJmcm9tRGlzcGxheU5hbWUiLCJmcm9tU3RhdGUiLCJmcm9tQ3JlYXRlVGltZSIsImZyb21FbmRUaW1lIiwiZnJvbVVwZGF0ZVRpbWUiLCJmcm9tTW9kZWwiLCJmcm9tRGVzdCIsImJhdGNoSm9iRnJvbVZlcnRleCIsImZyb21TdGFydFRpbWUiLCJmcm9tU3JjIiwiYmF0Y2hKb2JTb3VyY2VGcm9tVmVydGV4IiwiZnJvbUNvbXBsZXRpb25TdGF0cyIsImJhdGNoSm9iU291cmNlVG9NbGRldiIsImZyb21JbmxpbmVkUmVxdWVzdHMiLCJpbmxpbmVkUmVxdWVzdFRvTWxkZXYiLCJiYXRjaEpvYlNvdXJjZVRvVmVydGV4IiwiYmxvYlRvTWxkZXYkNCIsImZyb21EYXRhIiwiY2FuY2VsQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldiIsImNhbmNlbEJhdGNoSm9iUGFyYW1ldGVyc1RvVmVydGV4IiwiY2FuZGlkYXRlRnJvbU1sZGV2JDEiLCJmcm9tQ29udGVudCIsImZyb21DaXRhdGlvbk1ldGFkYXRhIiwiY2l0YXRpb25NZXRhZGF0YUZyb21NbGRldiQxIiwiZnJvbVRva2VuQ291bnQiLCJmcm9tRmluaXNoUmVhc29uIiwiZnJvbUF2Z0xvZ3Byb2JzIiwiZnJvbUdyb3VuZGluZ01ldGFkYXRhIiwiZnJvbUluZGV4IiwiZnJvbUxvZ3Byb2JzUmVzdWx0IiwiZnJvbVNhZmV0eVJhdGluZ3MiLCJmcm9tVXJsQ29udGV4dE1ldGFkYXRhIiwiZnJvbUNpdGF0aW9ucyIsImNvbnRlbnRUb01sZGV2JDQiLCJmcm9tUGFydHMiLCJwYXJ0VG9NbGRldiQ0IiwiZnJvbVJvbGUiLCJjcmVhdGVCYXRjaEpvYkNvbmZpZ1RvTWxkZXYiLCJwYXJlbnRPYmplY3QiLCJjcmVhdGVCYXRjaEpvYkNvbmZpZ1RvVmVydGV4IiwiY3JlYXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldiIsImZyb21Db25maWciLCJjcmVhdGVCYXRjaEpvYlBhcmFtZXRlcnNUb1ZlcnRleCIsImNyZWF0ZUVtYmVkZGluZ3NCYXRjaEpvYkNvbmZpZ1RvTWxkZXYiLCJjcmVhdGVFbWJlZGRpbmdzQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldiIsImVtYmVkZGluZ3NCYXRjaEpvYlNvdXJjZVRvTWxkZXYiLCJkZWxldGVCYXRjaEpvYlBhcmFtZXRlcnNUb01sZGV2IiwiZGVsZXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJkZWxldGVSZXNvdXJjZUpvYkZyb21NbGRldiIsImRlbGV0ZVJlc291cmNlSm9iRnJvbVZlcnRleCIsImVtYmVkQ29udGVudEJhdGNoVG9NbGRldiIsImZyb21Db250ZW50cyIsImVtYmVkQ29udGVudENvbmZpZ1RvTWxkZXYkMSIsImZyb21UYXNrVHlwZSIsImZyb21UaXRsZSIsImZyb21PdXRwdXREaW1lbnNpb25hbGl0eSIsImZpbGVEYXRhVG9NbGRldiQ0IiwiZnJvbUZpbGVVcmkiLCJmdW5jdGlvbkNhbGxUb01sZGV2JDQiLCJmcm9tSWQiLCJmcm9tQXJncyIsImZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ1RvTWxkZXYkMiIsImZyb21Nb2RlIiwiZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzIiwiZ2VuZXJhdGVDb250ZW50Q29uZmlnVG9NbGRldiQxIiwiZnJvbVN5c3RlbUluc3RydWN0aW9uIiwiZnJvbVRlbXBlcmF0dXJlIiwiZnJvbVRvcFAiLCJmcm9tVG9wSyIsImZyb21DYW5kaWRhdGVDb3VudCIsImZyb21NYXhPdXRwdXRUb2tlbnMiLCJmcm9tU3RvcFNlcXVlbmNlcyIsImZyb21SZXNwb25zZUxvZ3Byb2JzIiwiZnJvbUxvZ3Byb2JzIiwiZnJvbVByZXNlbmNlUGVuYWx0eSIsImZyb21GcmVxdWVuY3lQZW5hbHR5IiwiZnJvbVNlZWQiLCJmcm9tUmVzcG9uc2VNaW1lVHlwZSIsImZyb21SZXNwb25zZVNjaGVtYSIsImZyb21SZXNwb25zZUpzb25TY2hlbWEiLCJmcm9tU2FmZXR5U2V0dGluZ3MiLCJzYWZldHlTZXR0aW5nVG9NbGRldiQxIiwiZnJvbVRvb2xzIiwidG9vbFRvTWxkZXYkNCIsImZyb21Ub29sQ29uZmlnIiwidG9vbENvbmZpZ1RvTWxkZXYkMiIsImZyb21DYWNoZWRDb250ZW50IiwiZnJvbVJlc3BvbnNlTW9kYWxpdGllcyIsImZyb21NZWRpYVJlc29sdXRpb24iLCJmcm9tU3BlZWNoQ29uZmlnIiwiZnJvbVRoaW5raW5nQ29uZmlnIiwiZnJvbUltYWdlQ29uZmlnIiwiaW1hZ2VDb25maWdUb01sZGV2JDEiLCJnZW5lcmF0ZUNvbnRlbnRSZXNwb25zZUZyb21NbGRldiQxIiwiZnJvbUNhbmRpZGF0ZXMiLCJmcm9tTW9kZWxWZXJzaW9uIiwiZnJvbVByb21wdEZlZWRiYWNrIiwiZnJvbVJlc3BvbnNlSWQiLCJmcm9tVXNhZ2VNZXRhZGF0YSIsImdldEJhdGNoSm9iUGFyYW1ldGVyc1RvTWxkZXYiLCJnZXRCYXRjaEpvYlBhcmFtZXRlcnNUb1ZlcnRleCIsImdvb2dsZU1hcHNUb01sZGV2JDQiLCJmcm9tRW5hYmxlV2lkZ2V0IiwiZ29vZ2xlU2VhcmNoVG9NbGRldiQ0IiwiZnJvbVRpbWVSYW5nZUZpbHRlciIsImZyb21Bc3BlY3RSYXRpbyIsImZyb21JbWFnZVNpemUiLCJsaXN0QmF0Y2hKb2JzQ29uZmlnVG9NbGRldiIsImZyb21QYWdlU2l6ZSIsImZyb21QYWdlVG9rZW4iLCJsaXN0QmF0Y2hKb2JzQ29uZmlnVG9WZXJ0ZXgiLCJmcm9tRmlsdGVyIiwibGlzdEJhdGNoSm9ic1BhcmFtZXRlcnNUb01sZGV2IiwibGlzdEJhdGNoSm9ic1BhcmFtZXRlcnNUb1ZlcnRleCIsImxpc3RCYXRjaEpvYnNSZXNwb25zZUZyb21NbGRldiIsImZyb21OZXh0UGFnZVRva2VuIiwiZnJvbUJhdGNoSm9icyIsImxpc3RCYXRjaEpvYnNSZXNwb25zZUZyb21WZXJ0ZXgiLCJmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCIsImZyb21FeGVjdXRhYmxlQ29kZSIsImZyb21GaWxlRGF0YSIsImZyb21GdW5jdGlvbkNhbGwiLCJmcm9tRnVuY3Rpb25SZXNwb25zZSIsImZyb21JbmxpbmVEYXRhIiwiZnJvbVRleHQiLCJmcm9tVGhvdWdodCIsImZyb21UaG91Z2h0U2lnbmF0dXJlIiwiZnJvbVZpZGVvTWV0YWRhdGEiLCJmcm9tQ2F0ZWdvcnkiLCJmcm9tVGhyZXNob2xkIiwiZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZyIsImZyb21SZXRyaWV2YWxDb25maWciLCJmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMiLCJmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsIiwiZnJvbUNvbXB1dGVyVXNlIiwiZnJvbUZpbGVTZWFyY2giLCJmcm9tQ29kZUV4ZWN1dGlvbiIsImZyb21Hb29nbGVNYXBzIiwiZnJvbUdvb2dsZVNlYXJjaCIsImZyb21VcmxDb250ZXh0IiwiUGFnZWRJdGVtIiwiUGFnZXIiLCJyZXF1ZXN0IiwicGFyYW1zIiwicGFnZUludGVybmFsIiwicGFyYW1zSW50ZXJuYWwiLCJyZXF1ZXN0SW50ZXJuYWwiLCJpbml0IiwibmFtZUludGVybmFsIiwic2RrSHR0cFJlc3BvbnNlSW50ZXJuYWwiLCJzZGtIdHRwUmVzcG9uc2UiLCJpZHhJbnRlcm5hbCIsInJlcXVlc3RQYXJhbXMiLCJwYWdlSW50ZXJuYWxTaXplIiwiaW5pdE5leHRQYWdlIiwicGFnZSIsInBhZ2VTaXplIiwicGFnZUxlbmd0aCIsImdldEl0ZW0iLCJpbmRleCIsIlN5bWJvbCIsImFzeW5jSXRlcmF0b3IiLCJuZXh0IiwiaGFzTmV4dFBhZ2UiLCJuZXh0UGFnZSIsImRvbmUiLCJyZXR1cm4iLCJCYXRjaGVzIiwibGlzdCIsIlBBR0VEX0lURU1fQkFUQ0hfSk9CUyIsIngiLCJsaXN0SW50ZXJuYWwiLCJjcmVhdGUiLCJmb3JtYXREZXN0aW5hdGlvbiIsImNyZWF0ZUludGVybmFsIiwiY3JlYXRlRW1iZWRkaW5ncyIsImNyZWF0ZUVtYmVkZGluZ3NJbnRlcm5hbCIsImNyZWF0ZUlubGluZWRHZW5lcmF0ZUNvbnRlbnRSZXF1ZXN0IiwiYm9keSIsInVybFBhcmFtcyIsImJhdGNoIiwiaW5wdXRDb25maWciLCJyZXF1ZXN0c1dyYXBwZXIiLCJyZXF1ZXN0cyIsIm5ld1JlcXVlc3RzIiwicmVxdWVzdERpY3QiLCJzeXN0ZW1JbnN0cnVjdGlvblZhbHVlIiwicmVxdWVzdENvbnRlbnQiLCJnZXRHY3NVcmkiLCJnZXRCaWdxdWVyeVVyaSIsIm5ld0NvbmZpZyIsInRpbWVzdGFtcFN0ciIsIkRhdGUiLCJub3ciLCJ0b1N0cmluZyIsImRpc3BsYXlOYW1lIiwicXVlcnlQYXJhbXMiLCJKU09OIiwic3RyaW5naWZ5IiwiaHR0cE1ldGhvZCIsImFib3J0U2lnbmFsIiwidGhlbiIsImh0dHBSZXNwb25zZSIsInJlc3AiLCJnZXQiLCJjYW5jZWwiLCJqc29uUmVzcG9uc2UiLCJ0eXBlZFJlc3AiLCJkZWxldGUiLCJibG9iVG9NbGRldiQzIiwiY29udGVudFRvTWxkZXYkMyIsInBhcnRUb01sZGV2JDMiLCJjcmVhdGVDYWNoZWRDb250ZW50Q29uZmlnVG9NbGRldiIsImZyb21UdGwiLCJmcm9tRXhwaXJlVGltZSIsInRvb2xUb01sZGV2JDMiLCJ0b29sQ29uZmlnVG9NbGRldiQxIiwiY3JlYXRlQ2FjaGVkQ29udGVudENvbmZpZ1RvVmVydGV4IiwidG9vbFRvVmVydGV4JDIiLCJmcm9tS21zS2V5TmFtZSIsImNyZWF0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldiIsImNyZWF0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJkZWxldGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYiLCJkZWxldGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4IiwiZGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2IiwiZGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlRnJvbVZlcnRleCIsImZpbGVEYXRhVG9NbGRldiQzIiwiZnVuY3Rpb25DYWxsVG9NbGRldiQzIiwiZnVuY3Rpb25DYWxsaW5nQ29uZmlnVG9NbGRldiQxIiwiZnVuY3Rpb25EZWNsYXJhdGlvblRvVmVydGV4JDIiLCJmcm9tRGVzY3JpcHRpb24iLCJmcm9tUGFyYW1ldGVycyIsImZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSIsImdldENhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldiIsImdldENhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJnb29nbGVNYXBzVG9NbGRldiQzIiwiZ29vZ2xlU2VhcmNoVG9NbGRldiQzIiwibGlzdENhY2hlZENvbnRlbnRzQ29uZmlnVG9NbGRldiIsImxpc3RDYWNoZWRDb250ZW50c0NvbmZpZ1RvVmVydGV4IiwibGlzdENhY2hlZENvbnRlbnRzUGFyYW1ldGVyc1RvTWxkZXYiLCJsaXN0Q2FjaGVkQ29udGVudHNQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJsaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZUZyb21NbGRldiIsImZyb21DYWNoZWRDb250ZW50cyIsImxpc3RDYWNoZWRDb250ZW50c1Jlc3BvbnNlRnJvbVZlcnRleCIsImZyb21SZXRyaWV2YWwiLCJmcm9tRW50ZXJwcmlzZVdlYlNlYXJjaCIsInVwZGF0ZUNhY2hlZENvbnRlbnRDb25maWdUb01sZGV2IiwidXBkYXRlQ2FjaGVkQ29udGVudENvbmZpZ1RvVmVydGV4IiwidXBkYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2IiwidXBkYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCIsIkNhY2hlcyIsIlBBR0VEX0lURU1fQ0FDSEVEX0NPTlRFTlRTIiwidXBkYXRlIiwiX192YWx1ZXMiLCJvIiwicyIsIml0ZXJhdG9yIiwibSIsIl9fYXdhaXQiLCJfX2FzeW5jR2VuZXJhdG9yIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJnZW5lcmF0b3IiLCJnIiwiYXBwbHkiLCJxIiwiQXN5bmNJdGVyYXRvciIsInZlcmIiLCJhd2FpdFJldHVybiIsImYiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIm4iLCJhIiwiYiIsInJlc3VtZSIsInN0ZXAiLCJlIiwic2V0dGxlIiwiciIsImZ1bGZpbGwiLCJzaGlmdCIsIl9fYXN5bmNWYWx1ZXMiLCJTdXBwcmVzc2VkRXJyb3IiLCJzdXBwcmVzc2VkIiwibWVzc2FnZSIsImlzVmFsaWRSZXNwb25zZSIsImlzVmFsaWRDb250ZW50IiwidmFsaWRhdGVIaXN0b3J5IiwiaGlzdG9yeSIsImV4dHJhY3RDdXJhdGVkSGlzdG9yeSIsImNvbXByZWhlbnNpdmVIaXN0b3J5IiwiY3VyYXRlZEhpc3RvcnkiLCJtb2RlbE91dHB1dCIsImlzVmFsaWQiLCJDaGF0cyIsIm1vZGVsc01vZHVsZSIsIkNoYXQiLCJzdHJ1Y3R1cmVkQ2xvbmUiLCJzZW5kUHJvbWlzZSIsInNlbmRNZXNzYWdlIiwiaW5wdXRDb250ZW50IiwicmVzcG9uc2VQcm9taXNlIiwiZ2VuZXJhdGVDb250ZW50IiwiY29udGVudHMiLCJnZXRIaXN0b3J5IiwiY29uY2F0Iiwib3V0cHV0Q29udGVudCIsImZ1bGxBdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5IiwiYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSIsInJlY29yZEhpc3RvcnkiLCJjYXRjaCIsInNlbmRNZXNzYWdlU3RyZWFtIiwic3RyZWFtUmVzcG9uc2UiLCJnZW5lcmF0ZUNvbnRlbnRTdHJlYW0iLCJwcm9jZXNzU3RyZWFtUmVzcG9uc2UiLCJjdXJhdGVkIiwiYXJndW1lbnRzIiwicHJvY2Vzc1N0cmVhbVJlc3BvbnNlXzEiLCJlXzEiLCJzdHJlYW1SZXNwb25zZV8xIiwic3RyZWFtUmVzcG9uc2VfMV8xIiwiY2h1bmsiLCJlXzFfMSIsInVzZXJJbnB1dCIsIm91dHB1dENvbnRlbnRzIiwiZXZlcnkiLCJBcGlFcnJvciIsIm9wdGlvbnMiLCJzZXRQcm90b3R5cGVPZiIsImNyZWF0ZUZpbGVQYXJhbWV0ZXJzVG9NbGRldiIsImZyb21GaWxlIiwiY3JlYXRlRmlsZVJlc3BvbnNlRnJvbU1sZGV2IiwiZGVsZXRlRmlsZVBhcmFtZXRlcnNUb01sZGV2IiwiZGVsZXRlRmlsZVJlc3BvbnNlRnJvbU1sZGV2IiwiZ2V0RmlsZVBhcmFtZXRlcnNUb01sZGV2IiwibGlzdEZpbGVzQ29uZmlnVG9NbGRldiIsImxpc3RGaWxlc1BhcmFtZXRlcnNUb01sZGV2IiwibGlzdEZpbGVzUmVzcG9uc2VGcm9tTWxkZXYiLCJmcm9tRmlsZXMiLCJGaWxlcyIsIlBBR0VEX0lURU1fRklMRVMiLCJ1cGxvYWQiLCJ1cGxvYWRGaWxlIiwiZmlsZSIsImRvd25sb2FkIiwiZG93bmxvYWRGaWxlIiwiYmxvYlRvTWxkZXYkMiIsImNvbnRlbnRUb01sZGV2JDIiLCJwYXJ0VG9NbGRldiQyIiwiZmlsZURhdGFUb01sZGV2JDIiLCJmdW5jdGlvbkNhbGxUb01sZGV2JDIiLCJmdW5jdGlvbkRlY2xhcmF0aW9uVG9WZXJ0ZXgkMSIsImdlbmVyYXRpb25Db25maWdUb1ZlcnRleCQxIiwiZnJvbU1vZGVsU2VsZWN0aW9uQ29uZmlnIiwiZnJvbUF1ZGlvVGltZXN0YW1wIiwiZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyIsImZyb21Sb3V0aW5nQ29uZmlnIiwic3BlZWNoQ29uZmlnVG9WZXJ0ZXgkMSIsImdvb2dsZU1hcHNUb01sZGV2JDIiLCJnb29nbGVTZWFyY2hUb01sZGV2JDIiLCJsaXZlQ29ubmVjdENvbmZpZ1RvTWxkZXYkMSIsImZyb21HZW5lcmF0aW9uQ29uZmlnIiwidG9vbFRvTWxkZXYkMiIsImZyb21TZXNzaW9uUmVzdW1wdGlvbiIsInNlc3Npb25SZXN1bXB0aW9uQ29uZmlnVG9NbGRldiQxIiwiZnJvbUlucHV0QXVkaW9UcmFuc2NyaXB0aW9uIiwiZnJvbU91dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbiIsImZyb21SZWFsdGltZUlucHV0Q29uZmlnIiwiZnJvbUNvbnRleHRXaW5kb3dDb21wcmVzc2lvbiIsImZyb21Qcm9hY3Rpdml0eSIsImxpdmVDb25uZWN0Q29uZmlnVG9WZXJ0ZXgiLCJ0b29sVG9WZXJ0ZXgkMSIsImxpdmVDb25uZWN0UGFyYW1ldGVyc1RvTWxkZXYiLCJsaXZlQ29ubmVjdFBhcmFtZXRlcnNUb1ZlcnRleCIsImxpdmVNdXNpY1NldENvbmZpZ1BhcmFtZXRlcnNUb01sZGV2IiwiZnJvbU11c2ljR2VuZXJhdGlvbkNvbmZpZyIsImxpdmVNdXNpY1NldFdlaWdodGVkUHJvbXB0c1BhcmFtZXRlcnNUb01sZGV2IiwiZnJvbVdlaWdodGVkUHJvbXB0cyIsImxpdmVTZW5kUmVhbHRpbWVJbnB1dFBhcmFtZXRlcnNUb01sZGV2IiwiZnJvbU1lZGlhIiwiZnJvbUF1ZGlvIiwiZnJvbUF1ZGlvU3RyZWFtRW5kIiwiZnJvbUFjdGl2aXR5U3RhcnQiLCJmcm9tQWN0aXZpdHlFbmQiLCJsaXZlU2VuZFJlYWx0aW1lSW5wdXRQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJsaXZlU2VydmVyTWVzc2FnZUZyb21WZXJ0ZXgiLCJmcm9tU2V0dXBDb21wbGV0ZSIsImZyb21TZXJ2ZXJDb250ZW50IiwiZnJvbVRvb2xDYWxsIiwiZnJvbVRvb2xDYWxsQ2FuY2VsbGF0aW9uIiwidXNhZ2VNZXRhZGF0YUZyb21WZXJ0ZXgiLCJmcm9tR29Bd2F5IiwiZnJvbVNlc3Npb25SZXN1bXB0aW9uVXBkYXRlIiwiZnJvbUhhbmRsZSIsImZyb21MYW5ndWFnZUNvZGUiLCJmcm9tVm9pY2VDb25maWciLCJmcm9tUHJvbXB0VG9rZW5Db3VudCIsImZyb21DYWNoZWRDb250ZW50VG9rZW5Db3VudCIsImZyb21SZXNwb25zZVRva2VuQ291bnQiLCJmcm9tVG9vbFVzZVByb21wdFRva2VuQ291bnQiLCJmcm9tVGhvdWdodHNUb2tlbkNvdW50IiwiZnJvbVRvdGFsVG9rZW5Db3VudCIsImZyb21Qcm9tcHRUb2tlbnNEZXRhaWxzIiwiZnJvbUNhY2hlVG9rZW5zRGV0YWlscyIsImZyb21SZXNwb25zZVRva2Vuc0RldGFpbHMiLCJmcm9tVG9vbFVzZVByb21wdFRva2Vuc0RldGFpbHMiLCJmcm9tVHJhZmZpY1R5cGUiLCJibG9iVG9NbGRldiQxIiwiY2FuZGlkYXRlRnJvbU1sZGV2IiwiY2l0YXRpb25NZXRhZGF0YUZyb21NbGRldiIsImNvbXB1dGVUb2tlbnNQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJjb21wdXRlVG9rZW5zUmVzcG9uc2VGcm9tVmVydGV4IiwiZnJvbVRva2Vuc0luZm8iLCJjb250ZW50RW1iZWRkaW5nRnJvbVZlcnRleCIsImZyb21WYWx1ZXMiLCJmcm9tU3RhdGlzdGljcyIsImNvbnRlbnRFbWJlZGRpbmdTdGF0aXN0aWNzRnJvbVZlcnRleCIsImZyb21UcnVuY2F0ZWQiLCJjb250ZW50VG9NbGRldiQxIiwicGFydFRvTWxkZXYkMSIsImNvbnRyb2xSZWZlcmVuY2VDb25maWdUb1ZlcnRleCIsImZyb21Db250cm9sVHlwZSIsImZyb21FbmFibGVDb250cm9sSW1hZ2VDb21wdXRhdGlvbiIsImNvdW50VG9rZW5zQ29uZmlnVG9NbGRldiIsImNvdW50VG9rZW5zQ29uZmlnVG9WZXJ0ZXgiLCJ0b29sVG9WZXJ0ZXgiLCJnZW5lcmF0aW9uQ29uZmlnVG9WZXJ0ZXgiLCJjb3VudFRva2Vuc1BhcmFtZXRlcnNUb01sZGV2IiwiY291bnRUb2tlbnNQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJjb3VudFRva2Vuc1Jlc3BvbnNlRnJvbU1sZGV2IiwiZnJvbVRvdGFsVG9rZW5zIiwiY291bnRUb2tlbnNSZXNwb25zZUZyb21WZXJ0ZXgiLCJkZWxldGVNb2RlbFBhcmFtZXRlcnNUb01sZGV2IiwiZGVsZXRlTW9kZWxQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJkZWxldGVNb2RlbFJlc3BvbnNlRnJvbU1sZGV2IiwiZGVsZXRlTW9kZWxSZXNwb25zZUZyb21WZXJ0ZXgiLCJlZGl0SW1hZ2VDb25maWdUb1ZlcnRleCIsImZyb21PdXRwdXRHY3NVcmkiLCJmcm9tTmVnYXRpdmVQcm9tcHQiLCJmcm9tTnVtYmVyT2ZJbWFnZXMiLCJmcm9tR3VpZGFuY2VTY2FsZSIsImZyb21TYWZldHlGaWx0ZXJMZXZlbCIsImZyb21QZXJzb25HZW5lcmF0aW9uIiwiZnJvbUluY2x1ZGVTYWZldHlBdHRyaWJ1dGVzIiwiZnJvbUluY2x1ZGVSYWlSZWFzb24iLCJmcm9tTGFuZ3VhZ2UiLCJmcm9tT3V0cHV0TWltZVR5cGUiLCJmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5IiwiZnJvbUFkZFdhdGVybWFyayIsImZyb21MYWJlbHMiLCJmcm9tRWRpdE1vZGUiLCJmcm9tQmFzZVN0ZXBzIiwiZWRpdEltYWdlUGFyYW1ldGVyc0ludGVybmFsVG9WZXJ0ZXgiLCJmcm9tUHJvbXB0IiwiZnJvbVJlZmVyZW5jZUltYWdlcyIsInJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWxUb1ZlcnRleCIsImVkaXRJbWFnZVJlc3BvbnNlRnJvbVZlcnRleCIsImZyb21HZW5lcmF0ZWRJbWFnZXMiLCJnZW5lcmF0ZWRJbWFnZUZyb21WZXJ0ZXgiLCJlbWJlZENvbnRlbnRDb25maWdUb01sZGV2IiwiZW1iZWRDb250ZW50Q29uZmlnVG9WZXJ0ZXgiLCJmcm9tQXV0b1RydW5jYXRlIiwiZW1iZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYiLCJmcm9tTW9kZWxGb3JFbWJlZENvbnRlbnQiLCJlbWJlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJlbWJlZENvbnRlbnRSZXNwb25zZUZyb21NbGRldiIsImZyb21FbWJlZGRpbmdzIiwiZW1iZWRDb250ZW50UmVzcG9uc2VGcm9tVmVydGV4IiwiZW5kcG9pbnRGcm9tVmVydGV4IiwiZnJvbURlcGxveWVkTW9kZWxJZCIsImZpbGVEYXRhVG9NbGRldiQxIiwiZnVuY3Rpb25DYWxsVG9NbGRldiQxIiwiZnVuY3Rpb25DYWxsaW5nQ29uZmlnVG9NbGRldiIsImZ1bmN0aW9uRGVjbGFyYXRpb25Ub1ZlcnRleCIsImdlbmVyYXRlQ29udGVudENvbmZpZ1RvTWxkZXYiLCJzYWZldHlTZXR0aW5nVG9NbGRldiIsInRvb2xUb01sZGV2JDEiLCJ0b29sQ29uZmlnVG9NbGRldiIsImltYWdlQ29uZmlnVG9NbGRldiIsImdlbmVyYXRlQ29udGVudENvbmZpZ1RvVmVydGV4Iiwic3BlZWNoQ29uZmlnVG9WZXJ0ZXgiLCJpbWFnZUNvbmZpZ1RvVmVydGV4IiwiZ2VuZXJhdGVDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYiLCJnZW5lcmF0ZUNvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJnZW5lcmF0ZUNvbnRlbnRSZXNwb25zZUZyb21NbGRldiIsImdlbmVyYXRlQ29udGVudFJlc3BvbnNlRnJvbVZlcnRleCIsImdlbmVyYXRlSW1hZ2VzQ29uZmlnVG9NbGRldiIsImdlbmVyYXRlSW1hZ2VzQ29uZmlnVG9WZXJ0ZXgiLCJmcm9tRW5oYW5jZVByb21wdCIsImdlbmVyYXRlSW1hZ2VzUGFyYW1ldGVyc1RvTWxkZXYiLCJnZW5lcmF0ZUltYWdlc1BhcmFtZXRlcnNUb1ZlcnRleCIsImdlbmVyYXRlSW1hZ2VzUmVzcG9uc2VGcm9tTWxkZXYiLCJnZW5lcmF0ZWRJbWFnZUZyb21NbGRldiIsImZyb21Qb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMiLCJzYWZldHlBdHRyaWJ1dGVzRnJvbU1sZGV2IiwiZ2VuZXJhdGVJbWFnZXNSZXNwb25zZUZyb21WZXJ0ZXgiLCJzYWZldHlBdHRyaWJ1dGVzRnJvbVZlcnRleCIsImdlbmVyYXRlVmlkZW9zQ29uZmlnVG9NbGRldiIsImZyb21OdW1iZXJPZlZpZGVvcyIsImZyb21EdXJhdGlvblNlY29uZHMiLCJmcm9tUmVzb2x1dGlvbiIsImZyb21MYXN0RnJhbWUiLCJpbWFnZVRvTWxkZXYiLCJ2aWRlb0dlbmVyYXRpb25SZWZlcmVuY2VJbWFnZVRvTWxkZXYiLCJnZW5lcmF0ZVZpZGVvc0NvbmZpZ1RvVmVydGV4IiwiZnJvbUZwcyIsImZyb21QdWJzdWJUb3BpYyIsImZyb21HZW5lcmF0ZUF1ZGlvIiwiaW1hZ2VUb1ZlcnRleCIsInZpZGVvR2VuZXJhdGlvblJlZmVyZW5jZUltYWdlVG9WZXJ0ZXgiLCJmcm9tTWFzayIsInZpZGVvR2VuZXJhdGlvbk1hc2tUb1ZlcnRleCIsImZyb21Db21wcmVzc2lvblF1YWxpdHkiLCJnZW5lcmF0ZVZpZGVvc09wZXJhdGlvbkZyb21NbGRldiIsImdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tTWxkZXYiLCJnZW5lcmF0ZVZpZGVvc09wZXJhdGlvbkZyb21WZXJ0ZXgiLCJnZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlRnJvbVZlcnRleCIsImdlbmVyYXRlVmlkZW9zUGFyYW1ldGVyc1RvTWxkZXYiLCJmcm9tSW1hZ2UiLCJ2aWRlb1RvTWxkZXYiLCJmcm9tU291cmNlIiwiZ2VuZXJhdGVWaWRlb3NTb3VyY2VUb01sZGV2IiwiZ2VuZXJhdGVWaWRlb3NQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJ2aWRlb1RvVmVydGV4IiwiZ2VuZXJhdGVWaWRlb3NTb3VyY2VUb1ZlcnRleCIsImdlbmVyYXRlZFZpZGVvRnJvbU1sZGV2IiwiZ2VuZXJhdGVkVmlkZW9Gcm9tVmVydGV4IiwiaW1hZ2VGcm9tTWxkZXYiLCJmcm9tUmFpRmlsdGVyZWRSZWFzb24iLCJmcm9tU2FmZXR5QXR0cmlidXRlcyIsImltYWdlRnJvbVZlcnRleCIsImZyb21FbmhhbmNlZFByb21wdCIsImdlbmVyYXRlZEltYWdlTWFza0Zyb21WZXJ0ZXgiLCJ2aWRlb0Zyb21NbGRldiIsInZpZGVvRnJvbVZlcnRleCIsImdldE1vZGVsUGFyYW1ldGVyc1RvTWxkZXYiLCJnZXRNb2RlbFBhcmFtZXRlcnNUb1ZlcnRleCIsImdvb2dsZU1hcHNUb01sZGV2JDEiLCJnb29nbGVTZWFyY2hUb01sZGV2JDEiLCJsaXN0TW9kZWxzQ29uZmlnVG9NbGRldiIsImZyb21RdWVyeUJhc2UiLCJsaXN0TW9kZWxzQ29uZmlnVG9WZXJ0ZXgiLCJsaXN0TW9kZWxzUGFyYW1ldGVyc1RvTWxkZXYiLCJsaXN0TW9kZWxzUGFyYW1ldGVyc1RvVmVydGV4IiwibGlzdE1vZGVsc1Jlc3BvbnNlRnJvbU1sZGV2IiwiZnJvbU1vZGVscyIsIm1vZGVsRnJvbU1sZGV2IiwibGlzdE1vZGVsc1Jlc3BvbnNlRnJvbVZlcnRleCIsIm1vZGVsRnJvbVZlcnRleCIsIm1hc2tSZWZlcmVuY2VDb25maWdUb1ZlcnRleCIsImZyb21NYXNrTW9kZSIsImZyb21TZWdtZW50YXRpb25DbGFzc2VzIiwiZnJvbU1hc2tEaWxhdGlvbiIsImZyb21WZXJzaW9uIiwiZnJvbVR1bmVkTW9kZWxJbmZvIiwidHVuZWRNb2RlbEluZm9Gcm9tTWxkZXYiLCJmcm9tSW5wdXRUb2tlbkxpbWl0IiwiZnJvbU91dHB1dFRva2VuTGltaXQiLCJmcm9tU3VwcG9ydGVkQWN0aW9ucyIsImZyb21NYXhUZW1wZXJhdHVyZSIsImZyb21UaGlua2luZyIsImZyb21FbmRwb2ludHMiLCJ0dW5lZE1vZGVsSW5mb0Zyb21WZXJ0ZXgiLCJmcm9tRGVmYXVsdENoZWNrcG9pbnRJZCIsImZyb21DaGVja3BvaW50cyIsInByb2R1Y3RJbWFnZVRvVmVydGV4IiwiZnJvbVByb2R1Y3RJbWFnZSIsInJlY29udGV4dEltYWdlQ29uZmlnVG9WZXJ0ZXgiLCJyZWNvbnRleHRJbWFnZVBhcmFtZXRlcnNUb1ZlcnRleCIsInJlY29udGV4dEltYWdlU291cmNlVG9WZXJ0ZXgiLCJyZWNvbnRleHRJbWFnZVJlc3BvbnNlRnJvbVZlcnRleCIsImZyb21QZXJzb25JbWFnZSIsImZyb21Qcm9kdWN0SW1hZ2VzIiwiZnJvbVJlZmVyZW5jZUltYWdlIiwiZnJvbVJlZmVyZW5jZUlkIiwiZnJvbVJlZmVyZW5jZVR5cGUiLCJmcm9tTWFza0ltYWdlQ29uZmlnIiwiZnJvbUNvbnRyb2xJbWFnZUNvbmZpZyIsImZyb21TdHlsZUltYWdlQ29uZmlnIiwiZnJvbVN1YmplY3RJbWFnZUNvbmZpZyIsImZyb21DYXRlZ29yaWVzIiwiZnJvbVNjb3JlcyIsImZyb21Db250ZW50VHlwZSIsInNjcmliYmxlSW1hZ2VUb1ZlcnRleCIsInNlZ21lbnRJbWFnZUNvbmZpZ1RvVmVydGV4IiwiZnJvbU1heFByZWRpY3Rpb25zIiwiZnJvbUNvbmZpZGVuY2VUaHJlc2hvbGQiLCJmcm9tQmluYXJ5Q29sb3JUaHJlc2hvbGQiLCJzZWdtZW50SW1hZ2VQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJzZWdtZW50SW1hZ2VTb3VyY2VUb1ZlcnRleCIsInNlZ21lbnRJbWFnZVJlc3BvbnNlRnJvbVZlcnRleCIsImZyb21HZW5lcmF0ZWRNYXNrcyIsImZyb21TY3JpYmJsZUltYWdlIiwiZnJvbUJhc2VNb2RlbCIsInVwZGF0ZU1vZGVsQ29uZmlnVG9NbGRldiIsInVwZGF0ZU1vZGVsQ29uZmlnVG9WZXJ0ZXgiLCJ1cGRhdGVNb2RlbFBhcmFtZXRlcnNUb01sZGV2IiwidXBkYXRlTW9kZWxQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJ1cHNjYWxlSW1hZ2VBUElDb25maWdJbnRlcm5hbFRvVmVydGV4IiwiZnJvbUVuaGFuY2VJbnB1dEltYWdlIiwiZnJvbUltYWdlUHJlc2VydmF0aW9uRmFjdG9yIiwidXBzY2FsZUltYWdlQVBJUGFyYW1ldGVyc0ludGVybmFsVG9WZXJ0ZXgiLCJmcm9tVXBzY2FsZUZhY3RvciIsInVwc2NhbGVJbWFnZVJlc3BvbnNlRnJvbVZlcnRleCIsImNyZWF0ZUZpbGVTZWFyY2hTdG9yZUNvbmZpZ1RvTWxkZXYiLCJjcmVhdGVGaWxlU2VhcmNoU3RvcmVQYXJhbWV0ZXJzVG9NbGRldiIsImRlbGV0ZUZpbGVTZWFyY2hTdG9yZUNvbmZpZ1RvTWxkZXYiLCJmcm9tRm9yY2UiLCJkZWxldGVGaWxlU2VhcmNoU3RvcmVQYXJhbWV0ZXJzVG9NbGRldiIsImdldEZpbGVTZWFyY2hTdG9yZVBhcmFtZXRlcnNUb01sZGV2IiwiaW1wb3J0RmlsZUNvbmZpZ1RvTWxkZXYiLCJmcm9tQ3VzdG9tTWV0YWRhdGEiLCJmcm9tQ2h1bmtpbmdDb25maWciLCJpbXBvcnRGaWxlT3BlcmF0aW9uRnJvbU1sZGV2IiwiaW1wb3J0RmlsZVJlc3BvbnNlRnJvbU1sZGV2IiwiaW1wb3J0RmlsZVBhcmFtZXRlcnNUb01sZGV2IiwiZnJvbUZpbGVTZWFyY2hTdG9yZU5hbWUiLCJsaXN0RmlsZVNlYXJjaFN0b3Jlc0NvbmZpZ1RvTWxkZXYiLCJsaXN0RmlsZVNlYXJjaFN0b3Jlc1BhcmFtZXRlcnNUb01sZGV2IiwibGlzdEZpbGVTZWFyY2hTdG9yZXNSZXNwb25zZUZyb21NbGRldiIsImZyb21GaWxlU2VhcmNoU3RvcmVzIiwidXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVDb25maWdUb01sZGV2IiwidXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVQYXJhbWV0ZXJzVG9NbGRldiIsInVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlUmVzdW1hYmxlUmVzcG9uc2VGcm9tTWxkZXYiLCJDT05URU5UX1RZUEVfSEVBREVSIiwiU0VSVkVSX1RJTUVPVVRfSEVBREVSIiwiVVNFUl9BR0VOVF9IRUFERVIiLCJHT09HTEVfQVBJX0NMSUVOVF9IRUFERVIiLCJTREtfVkVSU0lPTiIsIkxJQlJBUllfTEFCRUwiLCJWRVJURVhfQUlfQVBJX0RFRkFVTFRfVkVSU0lPTiIsIkdPT0dMRV9BSV9BUElfREVGQVVMVF9WRVJTSU9OIiwicmVzcG9uc2VMaW5lUkUiLCJBcGlDbGllbnQiLCJvcHRzIiwiY2xpZW50T3B0aW9ucyIsInByb2plY3QiLCJsb2NhdGlvbiIsImFwaUtleSIsImluaXRIdHRwT3B0aW9ucyIsImFwaVZlcnNpb24iLCJiYXNlVXJsRnJvbVByb2plY3RMb2NhdGlvbiIsIm5vcm1hbGl6ZUF1dGhQYXJhbWV0ZXJzIiwiZ2V0RGVmYXVsdEhlYWRlcnMiLCJwYXRjaEh0dHBPcHRpb25zIiwiZ2V0QXBpVmVyc2lvbiIsImdldFJlcXVlc3RVcmwiLCJnZXRSZXF1ZXN0VXJsSW50ZXJuYWwiLCJnZXRIZWFkZXJzIiwidXJsRWxlbWVudCIsImpvaW4iLCJnZXRCYXNlUmVzb3VyY2VQYXRoIiwiZ2V0QXBpS2V5IiwiZ2V0V2Vic29ja2V0QmFzZVVybCIsInVybFBhcnRzIiwiVVJMIiwicHJvdG9jb2wiLCJzZXRCYXNlVXJsIiwidXJsIiwiY29uc3RydWN0VXJsIiwicHJlcGVuZFByb2plY3RMb2NhdGlvbiIsInNob3VsZFByZXBlbmRWZXJ0ZXhQcm9qZWN0UGF0aCIsInBhdGNoZWRIdHRwT3B0aW9ucyIsInNlYXJjaFBhcmFtcyIsImFwcGVuZCIsInJlcXVlc3RJbml0IiwiaW5jbHVkZUV4dHJhSHR0cE9wdGlvbnNUb1JlcXVlc3RJbml0IiwidW5hcnlBcGlDYWxsIiwiYmFzZUh0dHBPcHRpb25zIiwicmVxdWVzdEh0dHBPcHRpb25zIiwicGFyc2UiLCJyZXF1ZXN0U3RyZWFtIiwic2V0Iiwic3RyZWFtQXBpQ2FsbCIsInRpbWVvdXQiLCJhYm9ydENvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJzaWduYWwiLCJ0aW1lb3V0SGFuZGxlIiwic2V0VGltZW91dCIsImFib3J0IiwidW5yZWYiLCJhZGRFdmVudExpc3RlbmVyIiwiZXh0cmFCb2R5IiwiaW5jbHVkZUV4dHJhQm9keVRvUmVxdWVzdEluaXQiLCJnZXRIZWFkZXJzSW50ZXJuYWwiLCJhcGlDYWxsIiwibWV0aG9kIiwidGhyb3dFcnJvcklmTm90T0siLCJyZWFkZXIiLCJnZXRSZWFkZXIiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJidWZmZXIiLCJyZWFkIiwidHJpbSIsImNodW5rU3RyaW5nIiwiZGVjb2RlIiwic3RyZWFtIiwiY2h1bmtKc29uIiwiZXJyb3JKc29uIiwiZXJyb3JNZXNzYWdlIiwiYXBpRXJyb3IiLCJwcm9jZXNzZWRDaHVua1N0cmluZyIsInBhcnRpYWxSZXNwb25zZSIsIlJlc3BvbnNlIiwic3RhdHVzVGV4dCIsInJlbGVhc2VMb2NrIiwiZmV0Y2giLCJ2ZXJzaW9uSGVhZGVyVmFsdWUiLCJ1c2VyQWdlbnRFeHRyYSIsIkhlYWRlcnMiLCJNYXRoIiwiY2VpbCIsImF1dGgiLCJhZGRBdXRoSGVhZGVycyIsImdldEZpbGVOYW1lIiwiZmlsZVRvVXBsb2FkIiwidXBsb2FkZXIiLCJmaWxlU3RhdCIsInN0YXQiLCJzaXplQnl0ZXMiLCJzaXplIiwidXBsb2FkVXJsIiwiZmV0Y2hVcGxvYWRVcmwiLCJ1cGxvYWRGaWxlVG9GaWxlU2VhcmNoU3RvcmUiLCJmaWxlU2VhcmNoU3RvcmVOYW1lIiwidXBsb2FkVG9GaWxlU2VhcmNoU3RvcmUiLCJkb3dubG9hZGVyIiwiY29uZmlnSHR0cE9wdGlvbnMiLCJvayIsImVycm9yQm9keSIsIkJsb2IiLCJjdXJyZW50Qm9keU9iamVjdCIsInBhcnNlZEJvZHkiLCJkZWVwTWVyZ2UiLCJ0YXJnZXQiLCJzb3VyY2UiLCJzb3VyY2VWYWx1ZSIsInRhcmdldFZhbHVlIiwibWVyZ2VkQm9keSIsIk1DUF9MQUJFTCIsImhhc01jcFRvb2xVc2FnZUZyb21NY3BUb1Rvb2wiLCJoYXNNY3BUb29sVXNhZ2UiLCJpc01jcENhbGxhYmxlVG9vbCIsInNldE1jcFVzYWdlSGVhZGVyIiwiZXhpc3RpbmdIZWFkZXIiLCJ0cmltU3RhcnQiLCJvYmplY3QiLCJNY3BDYWxsYWJsZVRvb2wiLCJsaXN0QWxsVG9vbHMiLCJtY3BDbGllbnQiLCJtYXhUb29scyIsImxpc3RBbGxUb29sc18xIiwiY3Vyc29yIiwibnVtVG9vbHMiLCJ0IiwibGlzdFRvb2xzIiwibmV4dEN1cnNvciIsIm1jcENsaWVudHMiLCJmdW5jdGlvbk5hbWVUb01jcENsaWVudCIsImluaXRpYWxpemUiLCJmdW5jdGlvbk1hcCIsImNhbGxUb29sIiwiZnVuY3Rpb25DYWxsUmVzcG9uc2VQYXJ0cyIsInJlcXVlc3RPcHRpb25zIiwiY2FsbFRvb2xSZXNwb25zZSIsImlzRXJyb3IiLCJpc01jcENsaWVudCIsIm1jcFRvVG9vbCIsIm1heWJlQ29uZmlnIiwiaGFuZGxlV2ViU29ja2V0TWVzc2FnZSQxIiwib25tZXNzYWdlIiwiZXZlbnQiLCJzZXJ2ZXJNZXNzYWdlIiwiTGl2ZU11c2ljIiwid2ViU29ja2V0RmFjdG9yeSIsImNvbm5lY3QiLCJ3ZWJzb2NrZXRCYXNlVXJsIiwibWFwVG9IZWFkZXJzJDEiLCJvbm9wZW5SZXNvbHZlIiwib25vcGVuUHJvbWlzZSIsImNhbGxiYWNrcyIsIm9ub3BlbkF3YWl0ZWRDYWxsYmFjayIsIndlYnNvY2tldENhbGxiYWNrcyIsIm9ub3BlbiIsIm9uZXJyb3IiLCJvbmNsb3NlIiwiY29ubiIsImhlYWRlcnNUb01hcCQxIiwic2V0dXAiLCJjbGllbnRNZXNzYWdlIiwic2VuZCIsIkxpdmVNdXNpY1Nlc3Npb24iLCJzZXRXZWlnaHRlZFByb21wdHMiLCJ3ZWlnaHRlZFByb21wdHMiLCJjbGllbnRDb250ZW50Iiwic2V0TXVzaWNHZW5lcmF0aW9uQ29uZmlnIiwibXVzaWNHZW5lcmF0aW9uQ29uZmlnIiwic2V0Q29uZmlnUGFyYW1ldGVycyIsInNlbmRQbGF5YmFja0NvbnRyb2wiLCJwbGF5YmFja0NvbnRyb2wiLCJwbGF5IiwiUExBWSIsInBhdXNlIiwiUEFVU0UiLCJzdG9wIiwiU1RPUCIsInJlc2V0Q29udGV4dCIsIlJFU0VUX0NPTlRFWFQiLCJjbG9zZSIsImhlYWRlck1hcCIsImZvckVhY2giLCJGVU5DVElPTl9SRVNQT05TRV9SRVFVSVJFU19JRCIsImhhbmRsZVdlYlNvY2tldE1lc3NhZ2UiLCJqc29uRGF0YSIsIkFycmF5QnVmZmVyIiwiTGl2ZSIsIm11c2ljIiwiY2xpZW50SGVhZGVycyIsIm1hcFRvSGVhZGVycyIsImhlYWRlcnNUb01hcCIsInJlc3BvbnNlTW9kYWxpdGllcyIsIkFVRElPIiwiZ2VuZXJhdGlvbkNvbmZpZyIsImlucHV0VG9vbHMiLCJjb252ZXJ0ZWRUb29scyIsImlzQ2FsbGFibGVUb29sIiwiY2FsbGFibGVUb29sIiwibGl2ZUNvbm5lY3RQYXJhbWV0ZXJzIiwiU2Vzc2lvbiIsImRlZmF1bHRMaXZlU2VuZENsaWVudENvbnRlbnRQYXJhbWVydGVycyIsInR1cm5Db21wbGV0ZSIsInRMaXZlQ2xpZW50Q29udGVudCIsInR1cm5zIiwidExpdmVDbGllbnR0VG9vbFJlc3BvbnNlIiwidG9vbFJlc3BvbnNlIiwic2VuZENsaWVudENvbnRlbnQiLCJzZW5kUmVhbHRpbWVJbnB1dCIsInNlbmRUb29sUmVzcG9uc2UiLCJERUZBVUxUX01BWF9SRU1PVEVfQ0FMTFMiLCJzaG91bGREaXNhYmxlQWZjIiwiYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nIiwiZGlzYWJsZSIsImNhbGxhYmxlVG9vbHNQcmVzZW50IiwibWF4Q2FsbHMiLCJtYXhpbXVtUmVtb3RlQ2FsbHMiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJoYXNDYWxsYWJsZVRvb2xzIiwic29tZSIsImZpbmRBZmNJbmNvbXBhdGlibGVUb29sSW5kZXhlcyIsImFmY0luY29tcGF0aWJsZVRvb2xJbmRleGVzIiwic2hvdWxkQXBwZW5kQWZjSGlzdG9yeSIsImlnbm9yZUNhbGxIaXN0b3J5IiwiTW9kZWxzIiwidHJhbnNmb3JtZWRQYXJhbXMiLCJwcm9jZXNzUGFyYW1zTWF5YmVBZGRNY3BVc2FnZSIsIm1heWJlTW92ZVRvUmVzcG9uc2VKc29uU2NoZW0iLCJnZW5lcmF0ZUNvbnRlbnRJbnRlcm5hbCIsImluY29tcGF0aWJsZVRvb2xJbmRleGVzIiwiZm9ybWF0dGVkSW5kZXhlcyIsImZ1bmN0aW9uUmVzcG9uc2VDb250ZW50IiwibWF4UmVtb3RlQ2FsbHMiLCJyZW1vdGVDYWxscyIsInJlc3BvbnNlQ29udGVudCIsImZ1bmN0aW9uUmVzcG9uc2VQYXJ0cyIsImdlbmVyYXRlQ29udGVudFN0cmVhbUludGVybmFsIiwic3RyZWFtRnVuY3Rpb25DYWxsIiwidG9vbENvbmZpZyIsImZ1bmN0aW9uQ2FsbGluZ0NvbmZpZyIsInN0cmVhbUZ1bmN0aW9uQ2FsbEFyZ3VtZW50cyIsImRpc2FibGVBZmMiLCJwcm9jZXNzQWZjU3RyZWFtIiwiZ2VuZXJhdGVJbWFnZXMiLCJnZW5lcmF0ZUltYWdlc0ludGVybmFsIiwicG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzIiwiZ2VuZXJhdGVkSW1hZ2VzIiwiZ2VuZXJhdGVkSW1hZ2UiLCJzYWZldHlBdHRyaWJ1dGVzIiwiY29udGVudFR5cGUiLCJkZWZhdWx0Q29uZmlnIiwicXVlcnlCYXNlIiwiYWN0dWFsQ29uZmlnIiwiYWN0dWFsUGFyYW1zIiwiUEFHRURfSVRFTV9NT0RFTFMiLCJlZGl0SW1hZ2UiLCJwcm9tcHQiLCJyZWZlcmVuY2VJbWFnZXMiLCJpbWciLCJlZGl0SW1hZ2VJbnRlcm5hbCIsInVwc2NhbGVJbWFnZSIsImFwaUNvbmZpZyIsIm51bWJlck9mSW1hZ2VzIiwibW9kZSIsImFwaVBhcmFtcyIsImltYWdlIiwidXBzY2FsZUZhY3RvciIsInVwc2NhbGVJbWFnZUludGVybmFsIiwiZ2VuZXJhdGVWaWRlb3MiLCJ2aWRlb0J5dGVzIiwiZ2VuZXJhdGVWaWRlb3NJbnRlcm5hbCIsInJlc3BvbnNlU2NoZW1hIiwidHJhbnNmb3JtZWRUb29scyIsImFsbCIsIm5ld1BhcmFtcyIsIm5ld0hlYWRlcnMiLCJpbml0QWZjVG9vbHNNYXAiLCJhZmNUb29scyIsIk1hcCIsInRvb2xEZWNsYXJhdGlvbiIsImRlY2xhcmF0aW9uIiwid2VyZUZ1bmN0aW9uc0NhbGxlZCIsInJlbW90ZUNhbGxDb3VudCIsImFmY1Rvb2xzTWFwIiwibW9kZWxzIiwicmVzcG9uc2VDb250ZW50cyIsInJlc3BvbnNlXzEiLCJyZXNwb25zZV8xXzEiLCJyZXNwb25zZVBhcnRzIiwidHlwZWRSZXNwb25zZUNodW5rIiwibmV3Q29udGVudHMiLCJ1cGRhdGVkQ29udGVudHMiLCJlXzIiLCJhcGlSZXNwb25zZV8xIiwiYXBpUmVzcG9uc2VfMV8xIiwiZV8yXzEiLCJlXzMiLCJhcGlSZXNwb25zZV8yIiwiYXBpUmVzcG9uc2VfMl8xIiwiZV8zXzEiLCJlbWJlZENvbnRlbnQiLCJyZWNvbnRleHRJbWFnZSIsInNlZ21lbnRJbWFnZSIsImNvdW50VG9rZW5zIiwiY29tcHV0ZVRva2VucyIsIk9wZXJhdGlvbnMiLCJnZXRWaWRlb3NPcGVyYXRpb24iLCJyYXdPcGVyYXRpb24iLCJmZXRjaFByZWRpY3RWaWRlb3NPcGVyYXRpb25JbnRlcm5hbCIsIm9wZXJhdGlvbk5hbWUiLCJnZXRWaWRlb3NPcGVyYXRpb25JbnRlcm5hbCIsImJsb2JUb01sZGV2IiwiY29udGVudFRvTWxkZXYiLCJwYXJ0VG9NbGRldiIsImNyZWF0ZUF1dGhUb2tlbkNvbmZpZ1RvTWxkZXYiLCJmcm9tTmV3U2Vzc2lvbkV4cGlyZVRpbWUiLCJmcm9tVXNlcyIsImZyb21MaXZlQ29ubmVjdENvbnN0cmFpbnRzIiwibGl2ZUNvbm5lY3RDb25zdHJhaW50c1RvTWxkZXYiLCJmcm9tTG9ja0FkZGl0aW9uYWxGaWVsZHMiLCJjcmVhdGVBdXRoVG9rZW5QYXJhbWV0ZXJzVG9NbGRldiIsImZpbGVEYXRhVG9NbGRldiIsImZ1bmN0aW9uQ2FsbFRvTWxkZXYiLCJnb29nbGVNYXBzVG9NbGRldiIsImdvb2dsZVNlYXJjaFRvTWxkZXYiLCJsaXZlQ29ubmVjdENvbmZpZ1RvTWxkZXYiLCJ0b29sVG9NbGRldiIsInNlc3Npb25SZXN1bXB0aW9uQ29uZmlnVG9NbGRldiIsImdldEZpZWxkTWFza3MiLCJmaWVsZHMiLCJmaWVsZCIsImtrIiwiY29udmVydEJpZGlTZXR1cFRvVG9rZW5TZXR1cCIsInNldHVwRm9yTWFza0dlbmVyYXRpb24iLCJiaWRpR2VuZXJhdGVDb250ZW50U2V0dXBWYWx1ZSIsImlubmVyU2V0dXAiLCJwcmVFeGlzdGluZ0ZpZWxkTWFzayIsImdlbmVyYXRlZE1hc2tGcm9tQmlkaSIsImxvY2tBZGRpdGlvbmFsRmllbGRzIiwiZ2VuZXJhdGlvbkNvbmZpZ0ZpZWxkcyIsIm1hcHBlZEZpZWxkc0Zyb21QcmVFeGlzdGluZyIsImZpbmFsTWFza1BhcnRzIiwiVG9rZW5zIiwidHJhbnNmb3JtZWRCb2R5IiwiZGVsZXRlRG9jdW1lbnRDb25maWdUb01sZGV2IiwiZGVsZXRlRG9jdW1lbnRQYXJhbWV0ZXJzVG9NbGRldiIsImdldERvY3VtZW50UGFyYW1ldGVyc1RvTWxkZXYiLCJsaXN0RG9jdW1lbnRzQ29uZmlnVG9NbGRldiIsImxpc3REb2N1bWVudHNQYXJhbWV0ZXJzVG9NbGRldiIsImxpc3REb2N1bWVudHNSZXNwb25zZUZyb21NbGRldiIsImZyb21Eb2N1bWVudHMiLCJEb2N1bWVudHMiLCJQQUdFRF9JVEVNX0RPQ1VNRU5UUyIsInBhcmVudCIsIkZpbGVTZWFyY2hTdG9yZXMiLCJkb2N1bWVudHMiLCJQQUdFRF9JVEVNX0ZJTEVfU0VBUkNIX1NUT1JFUyIsInVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlSW50ZXJuYWwiLCJpbXBvcnRGaWxlIiwiR09PR0xFX0FQSV9LRVlfSEVBREVSIiwiUkVRVUlSRURfVkVSVEVYX0FJX1NDT1BFIiwiTm9kZUF1dGgiLCJ2ZXJ0ZXhBdXRoT3B0aW9ucyIsImJ1aWxkR29vZ2xlQXV0aE9wdGlvbnMiLCJnb29nbGVBdXRoT3B0aW9ucyIsImdvb2dsZUF1dGgiLCJhZGRLZXlIZWFkZXIiLCJhZGRHb29nbGVBdXRoSGVhZGVycyIsImF1dGhIZWFkZXJzIiwiZ2V0UmVxdWVzdEhlYWRlcnMiLCJhdXRoT3B0aW9ucyIsInNjb3BlcyIsIk5vZGVEb3dubG9hZGVyIiwiZG93bmxvYWRQYXRoIiwid3JpdGVyIiwiZnJvbVdlYiIsInBpcGUiLCJlbmNvZGluZyIsIk5vZGVXZWJTb2NrZXRGYWN0b3J5IiwiTm9kZVdlYlNvY2tldCIsIndzIiwiV2ViU29ja2V0IiwiY2FuY2VsVHVuaW5nSm9iUGFyYW1ldGVyc1RvTWxkZXYiLCJfcm9vdE9iamVjdCIsImNhbmNlbFR1bmluZ0pvYlBhcmFtZXRlcnNUb1ZlcnRleCIsImNhbmNlbFR1bmluZ0pvYlJlc3BvbnNlRnJvbU1sZGV2IiwiY2FuY2VsVHVuaW5nSm9iUmVzcG9uc2VGcm9tVmVydGV4IiwiY3JlYXRlVHVuaW5nSm9iQ29uZmlnVG9NbGRldiIsImZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUiLCJmcm9tRXBvY2hDb3VudCIsImZyb21MZWFybmluZ1JhdGVNdWx0aXBsaWVyIiwiZnJvbUJhdGNoU2l6ZSIsImZyb21MZWFybmluZ1JhdGUiLCJjcmVhdGVUdW5pbmdKb2JDb25maWdUb1ZlcnRleCIsInJvb3RPYmplY3QiLCJkaXNjcmltaW5hdG9yVmFsaWRhdGlvbkRhdGFzZXQiLCJmcm9tVmFsaWRhdGlvbkRhdGFzZXQiLCJ0dW5pbmdWYWxpZGF0aW9uRGF0YXNldFRvVmVydGV4IiwiZGlzY3JpbWluYXRvckVwb2NoQ291bnQiLCJkaXNjcmltaW5hdG9yTGVhcm5pbmdSYXRlTXVsdGlwbGllciIsImRpc2NyaW1pbmF0b3JFeHBvcnRMYXN0Q2hlY2twb2ludE9ubHkiLCJmcm9tRXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5IiwiZGlzY3JpbWluYXRvckFkYXB0ZXJTaXplIiwiZnJvbUFkYXB0ZXJTaXplIiwiZnJvbUJldGEiLCJjcmVhdGVUdW5pbmdKb2JQYXJhbWV0ZXJzUHJpdmF0ZVRvTWxkZXYiLCJmcm9tUHJlVHVuZWRNb2RlbCIsImZyb21UcmFpbmluZ0RhdGFzZXQiLCJ0dW5pbmdEYXRhc2V0VG9NbGRldiIsImNyZWF0ZVR1bmluZ0pvYlBhcmFtZXRlcnNQcml2YXRlVG9WZXJ0ZXgiLCJ0dW5pbmdEYXRhc2V0VG9WZXJ0ZXgiLCJnZXRUdW5pbmdKb2JQYXJhbWV0ZXJzVG9NbGRldiIsImdldFR1bmluZ0pvYlBhcmFtZXRlcnNUb1ZlcnRleCIsImxpc3RUdW5pbmdKb2JzQ29uZmlnVG9NbGRldiIsImxpc3RUdW5pbmdKb2JzQ29uZmlnVG9WZXJ0ZXgiLCJsaXN0VHVuaW5nSm9ic1BhcmFtZXRlcnNUb01sZGV2IiwibGlzdFR1bmluZ0pvYnNQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJsaXN0VHVuaW5nSm9ic1Jlc3BvbnNlRnJvbU1sZGV2IiwiZnJvbVR1bmluZ0pvYnMiLCJ0dW5pbmdKb2JGcm9tTWxkZXYiLCJsaXN0VHVuaW5nSm9ic1Jlc3BvbnNlRnJvbVZlcnRleCIsInR1bmluZ0pvYkZyb21WZXJ0ZXgiLCJ0dW5lZE1vZGVsRnJvbU1sZGV2IiwiZnJvbUVuZHBvaW50IiwiZnJvbUV4YW1wbGVzIiwiZGlzY3JpbWluYXRvckdjc1VyaSIsImRpc2NyaW1pbmF0b3JWZXJ0ZXhEYXRhc2V0UmVzb3VyY2UiLCJmcm9tVmVydGV4RGF0YXNldFJlc291cmNlIiwiZnJvbVR1bmVkTW9kZWwiLCJmcm9tU3VwZXJ2aXNlZFR1bmluZ1NwZWMiLCJmcm9tUHJlZmVyZW5jZU9wdGltaXphdGlvblNwZWMiLCJmcm9tVHVuaW5nRGF0YVN0YXRzIiwiZnJvbUVuY3J5cHRpb25TcGVjIiwiZnJvbVBhcnRuZXJNb2RlbFR1bmluZ1NwZWMiLCJmcm9tQ3VzdG9tQmFzZU1vZGVsIiwiZnJvbUV4cGVyaW1lbnQiLCJmcm9tT3V0cHV0VXJpIiwiZnJvbVBpcGVsaW5lSm9iIiwiZnJvbVNlcnZpY2VBY2NvdW50IiwiZnJvbVZlb1R1bmluZ1NwZWMiLCJ0dW5pbmdPcGVyYXRpb25Gcm9tTWxkZXYiLCJUdW5pbmdzIiwiUEFHRURfSVRFTV9UVU5JTkdfSk9CUyIsImdldEludGVybmFsIiwidHVuZSIsImJhc2VNb2RlbCIsInByZVR1bmVkTW9kZWwiLCJ0dW5lZE1vZGVsTmFtZSIsInByZVR1bmVkTW9kZWxDaGVja3BvaW50SWQiLCJjaGVja3BvaW50SWQiLCJwYXJhbXNQcml2YXRlIiwidHVuZUludGVybmFsIiwidHVuZU1sZGV2SW50ZXJuYWwiLCJ0dW5pbmdKb2IiLCJKT0JfU1RBVEVfUVVFVUVEIiwiTUFYX0NIVU5LX1NJWkUiLCJNQVhfUkVUUllfQ09VTlQiLCJJTklUSUFMX1JFVFJZX0RFTEFZX01TIiwiREVMQVlfTVVMVElQTElFUiIsIlhfR09PR19VUExPQURfU1RBVFVTX0hFQURFUl9GSUVMRCIsInVwbG9hZEJsb2IiLCJ1cGxvYWRCbG9iSW50ZXJuYWwiLCJyZXNwb25zZUpzb24iLCJ1cGxvYWRCbG9iVG9GaWxlU2VhcmNoU3RvcmUiLCJmaWxlU2l6ZSIsIm9mZnNldCIsInVwbG9hZENvbW1hbmQiLCJjaHVua1NpemUiLCJtaW4iLCJyZXRyeUNvdW50IiwiY3VycmVudERlbGF5TXMiLCJzbGVlcCIsImdldEJsb2JTdGF0IiwibXMiLCJyZXNvbHZlUHJvbWlzZSIsIk5vZGVVcGxvYWRlciIsIm9yaWdpbmFsU3RhdCIsImluZmVyTWltZVR5cGUiLCJ1cGxvYWRGaWxlRnJvbVBhdGgiLCJ1cGxvYWRGaWxlVG9GaWxlU2VhcmNoU3RvcmVGcm9tUGF0aCIsImZpbGVQYXRoIiwiZmlsZUV4dGVuc2lvbiIsImxhc3RJbmRleE9mIiwibWltZVR5cGVzIiwidG9Mb3dlckNhc2UiLCJ1cGxvYWRGaWxlRnJvbVBhdGhJbnRlcm5hbCIsImZpbGVIYW5kbGUiLCJiYXNlbmFtZSIsIm9wZW4iLCJVaW50OEFycmF5IiwiYnl0ZXNSZWFkIiwiTEFOR1VBR0VfTEFCRUxfUFJFRklYIiwiR29vZ2xlR2VuQUkiLCJnZXRCb29sZWFuRW52IiwiZW52QXBpS2V5IiwiZ2V0QXBpS2V5RnJvbUVudiIsImVudlByb2plY3QiLCJnZXRFbnYiLCJlbnZMb2NhdGlvbiIsImNyZWRlbnRpYWxzIiwiZGVidWciLCJwcm9jZXNzIiwidmVyc2lvbiIsImxpdmUiLCJiYXRjaGVzIiwiY2hhdHMiLCJjYWNoZXMiLCJmaWxlcyIsIm9wZXJhdGlvbnMiLCJhdXRoVG9rZW5zIiwidHVuaW5ncyIsImZpbGVTZWFyY2hTdG9yZXMiLCJlbnYiLCJzdHJpbmdUb0Jvb2xlYW4iLCJzdHIiLCJlbnZHb29nbGVBcGlLZXkiLCJlbnZHZW1pbmlBcGlLZXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@google/genai/dist/node/index.mjs\n");

/***/ })

};
;